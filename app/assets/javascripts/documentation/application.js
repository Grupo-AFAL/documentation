(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from3, except, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: self.console,
        WebSocket: self.WebSocket
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, protocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error3) {
              logger_default.log("Failed to reopen WebSocket", error3);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              return this.subscriptions.notify(identifier, "connected");
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s) => s !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s) => s.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command2) {
          const { identifier } = subscription;
          return this.consumer.send({ command: command2, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a = document.createElement("a");
      a.href = url;
      a.href = a.href;
      a.protocol = a.protocol.replace("http", "ws");
      return a.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // node_modules/@popperjs/core/lib/enums.js
  var top, bottom, right, left, auto, basePlacements, start2, end, clippingParents, viewport, popper, reference, variationPlacements, placements, beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite, modifierPhases;
  var init_enums = __esm({
    "node_modules/@popperjs/core/lib/enums.js"() {
      top = "top";
      bottom = "bottom";
      right = "right";
      left = "left";
      auto = "auto";
      basePlacements = [top, bottom, right, left];
      start2 = "start";
      end = "end";
      clippingParents = "clippingParents";
      viewport = "viewport";
      popper = "popper";
      reference = "reference";
      variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
        return acc.concat([placement + "-" + start2, placement + "-" + end]);
      }, []);
      placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
        return acc.concat([placement, placement + "-" + start2, placement + "-" + end]);
      }, []);
      beforeRead = "beforeRead";
      read = "read";
      afterRead = "afterRead";
      beforeMain = "beforeMain";
      main = "main";
      afterMain = "afterMain";
      beforeWrite = "beforeWrite";
      write = "write";
      afterWrite = "afterWrite";
      modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  var init_getNodeName = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getNodeName.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  var init_getWindow = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getWindow.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  var init_instanceOf = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/instanceOf.js"() {
      init_getWindow();
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style2 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style2 = styleProperties.reduce(function(style3, property) {
          style3[property] = "";
          return style3;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default;
  var init_applyStyles = __esm({
    "node_modules/@popperjs/core/lib/modifiers/applyStyles.js"() {
      init_getNodeName();
      init_instanceOf();
      applyStyles_default = {
        name: "applyStyles",
        enabled: true,
        phase: "write",
        fn: applyStyles,
        effect,
        requires: ["computeStyles"]
      };
    }
  });

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  var init_getBasePlacement = __esm({
    "node_modules/@popperjs/core/lib/utils/getBasePlacement.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/utils/math.js
  var max, min, round2;
  var init_math = __esm({
    "node_modules/@popperjs/core/lib/utils/math.js"() {
      max = Math.max;
      min = Math.min;
      round2 = Math.round;
    }
  });

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  var init_userAgent = __esm({
    "node_modules/@popperjs/core/lib/utils/userAgent.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  var init_isLayoutViewport = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js"() {
      init_userAgent();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect2 = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round2(clientRect2.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round2(clientRect2.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect2.width / scaleX;
    var height = clientRect2.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }
  var init_getBoundingClientRect = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js"() {
      init_instanceOf();
      init_math();
      init_getWindow();
      init_isLayoutViewport();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect2 = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect2.width - width) <= 1) {
      width = clientRect2.width;
    }
    if (Math.abs(clientRect2.height - height) <= 1) {
      height = clientRect2.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }
  var init_getLayoutRect = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js"() {
      init_getBoundingClientRect();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }
  var init_contains = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/contains.js"() {
      init_instanceOf();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle3(element) {
    return getWindow(element).getComputedStyle(element);
  }
  var init_getComputedStyle = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js"() {
      init_getWindow();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  var init_isTableElement = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/isTableElement.js"() {
      init_getNodeName();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }
  var init_getDocumentElement = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js"() {
      init_instanceOf();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }
  var init_getParentNode = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getParentNode.js"() {
      init_getNodeName();
      init_getDocumentElement();
      init_instanceOf();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle3(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle3(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css3 = getComputedStyle3(currentNode);
      if (css3.transform !== "none" || css3.perspective !== "none" || css3.contain === "paint" || ["transform", "perspective"].indexOf(css3.willChange) !== -1 || isFirefox && css3.willChange === "filter" || isFirefox && css3.filter && css3.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle3(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle3(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  var init_getOffsetParent = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js"() {
      init_getWindow();
      init_getNodeName();
      init_getComputedStyle();
      init_instanceOf();
      init_isTableElement();
      init_getParentNode();
      init_userAgent();
    }
  });

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  var init_getMainAxisFromPlacement = __esm({
    "node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }
  var init_within = __esm({
    "node_modules/@popperjs/core/lib/utils/within.js"() {
      init_math();
    }
  });

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  var init_getFreshSideObject = __esm({
    "node_modules/@popperjs/core/lib/utils/getFreshSideObject.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  var init_mergePaddingObject = __esm({
    "node_modules/@popperjs/core/lib/utils/mergePaddingObject.js"() {
      init_getFreshSideObject();
    }
  });

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys2) {
    return keys2.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }
  var init_expandToHashMap = __esm({
    "node_modules/@popperjs/core/lib/utils/expandToHashMap.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var toPaddingObject, arrow_default;
  var init_arrow = __esm({
    "node_modules/@popperjs/core/lib/modifiers/arrow.js"() {
      init_getBasePlacement();
      init_getLayoutRect();
      init_contains();
      init_getOffsetParent();
      init_getMainAxisFromPlacement();
      init_within();
      init_mergePaddingObject();
      init_expandToHashMap();
      init_enums();
      toPaddingObject = function toPaddingObject2(padding, state) {
        padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
          placement: state.placement
        })) : padding;
        return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      };
      arrow_default = {
        name: "arrow",
        enabled: true,
        phase: "main",
        fn: arrow,
        effect: effect2,
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
      };
    }
  });

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  var init_getVariation = __esm({
    "node_modules/@popperjs/core/lib/utils/getVariation.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round2(x * dpr) / dpr || 0,
      y: round2(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle3(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var unsetSides, computeStyles_default;
  var init_computeStyles = __esm({
    "node_modules/@popperjs/core/lib/modifiers/computeStyles.js"() {
      init_enums();
      init_getOffsetParent();
      init_getWindow();
      init_getDocumentElement();
      init_getComputedStyle();
      init_getBasePlacement();
      init_getVariation();
      init_math();
      unsetSides = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
      };
      computeStyles_default = {
        name: "computeStyles",
        enabled: true,
        phase: "beforeWrite",
        fn: computeStyles,
        data: {}
      };
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var passive, eventListeners_default;
  var init_eventListeners = __esm({
    "node_modules/@popperjs/core/lib/modifiers/eventListeners.js"() {
      init_getWindow();
      passive = {
        passive: true
      };
      eventListeners_default = {
        name: "eventListeners",
        enabled: true,
        phase: "write",
        fn: function fn() {
        },
        effect: effect3,
        data: {}
      };
    }
  });

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }
  var hash;
  var init_getOppositePlacement = __esm({
    "node_modules/@popperjs/core/lib/utils/getOppositePlacement.js"() {
      hash = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
    }
  });

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }
  var hash2;
  var init_getOppositeVariationPlacement = __esm({
    "node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js"() {
      hash2 = {
        start: "end",
        end: "start"
      };
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  var init_getWindowScroll = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js"() {
      init_getWindow();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  var init_getWindowScrollBarX = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js"() {
      init_getBoundingClientRect();
      init_getDocumentElement();
      init_getWindowScroll();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }
  var init_getViewportRect = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js"() {
      init_getWindow();
      init_getDocumentElement();
      init_getWindowScrollBarX();
      init_isLayoutViewport();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle3(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  var init_getDocumentRect = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js"() {
      init_getDocumentElement();
      init_getComputedStyle();
      init_getWindowScrollBarX();
      init_getWindowScroll();
      init_math();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle3(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  var init_isScrollParent = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js"() {
      init_getComputedStyle();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }
  var init_getScrollParent = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js"() {
      init_getParentNode();
      init_isScrollParent();
      init_getNodeName();
      init_instanceOf();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }
  var init_listScrollParents = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js"() {
      init_getScrollParent();
      init_getParentNode();
      init_getWindow();
      init_isScrollParent();
    }
  });

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  var init_rectToClientRect = __esm({
    "node_modules/@popperjs/core/lib/utils/rectToClientRect.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle3(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  var init_getClippingRect = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js"() {
      init_enums();
      init_getViewportRect();
      init_getDocumentRect();
      init_listScrollParents();
      init_getOffsetParent();
      init_getDocumentElement();
      init_getComputedStyle();
      init_instanceOf();
      init_getBoundingClientRect();
      init_getParentNode();
      init_contains();
      init_getNodeName();
      init_rectToClientRect();
      init_math();
    }
  });

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start2:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }
  var init_computeOffsets = __esm({
    "node_modules/@popperjs/core/lib/utils/computeOffsets.js"() {
      init_getBasePlacement();
      init_getVariation();
      init_getMainAxisFromPlacement();
      init_enums();
    }
  });

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  var init_detectOverflow = __esm({
    "node_modules/@popperjs/core/lib/utils/detectOverflow.js"() {
      init_getClippingRect();
      init_getDocumentElement();
      init_getBoundingClientRect();
      init_computeOffsets();
      init_rectToClientRect();
      init_enums();
      init_instanceOf();
      init_mergePaddingObject();
      init_expandToHashMap();
    }
  });

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }
  var init_computeAutoPlacement = __esm({
    "node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js"() {
      init_getVariation();
      init_enums();
      init_detectOverflow();
      init_getBasePlacement();
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start2;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default;
  var init_flip = __esm({
    "node_modules/@popperjs/core/lib/modifiers/flip.js"() {
      init_getOppositePlacement();
      init_getBasePlacement();
      init_getOppositeVariationPlacement();
      init_detectOverflow();
      init_computeAutoPlacement();
      init_enums();
      init_getVariation();
      flip_default = {
        name: "flip",
        enabled: true,
        phase: "main",
        fn: flip,
        requiresIfExists: ["offset"],
        data: {
          _skip: false
        }
      };
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default;
  var init_hide = __esm({
    "node_modules/@popperjs/core/lib/modifiers/hide.js"() {
      init_enums();
      init_detectOverflow();
      hide_default = {
        name: "hide",
        enabled: true,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: hide
      };
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default;
  var init_offset = __esm({
    "node_modules/@popperjs/core/lib/modifiers/offset.js"() {
      init_getBasePlacement();
      init_enums();
      offset_default = {
        name: "offset",
        enabled: true,
        phase: "main",
        requires: ["popperOffsets"],
        fn: offset
      };
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default;
  var init_popperOffsets = __esm({
    "node_modules/@popperjs/core/lib/modifiers/popperOffsets.js"() {
      init_computeOffsets();
      popperOffsets_default = {
        name: "popperOffsets",
        enabled: true,
        phase: "read",
        fn: popperOffsets,
        data: {}
      };
    }
  });

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  var init_getAltAxis = __esm({
    "node_modules/@popperjs/core/lib/utils/getAltAxis.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default;
  var init_preventOverflow = __esm({
    "node_modules/@popperjs/core/lib/modifiers/preventOverflow.js"() {
      init_enums();
      init_getBasePlacement();
      init_getMainAxisFromPlacement();
      init_getAltAxis();
      init_within();
      init_getLayoutRect();
      init_getOffsetParent();
      init_detectOverflow();
      init_getVariation();
      init_getFreshSideObject();
      init_math();
      preventOverflow_default = {
        name: "preventOverflow",
        enabled: true,
        phase: "main",
        fn: preventOverflow,
        requiresIfExists: ["offset"]
      };
    }
  });

  // node_modules/@popperjs/core/lib/modifiers/index.js
  var init_modifiers = __esm({
    "node_modules/@popperjs/core/lib/modifiers/index.js"() {
      init_applyStyles();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  var init_getHTMLElementScroll = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }
  var init_getNodeScroll = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js"() {
      init_getWindowScroll();
      init_getWindow();
      init_instanceOf();
      init_getHTMLElementScroll();
    }
  });

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round2(rect.width) / element.offsetWidth || 1;
    var scaleY = round2(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  var init_getCompositeRect = __esm({
    "node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js"() {
      init_getBoundingClientRect();
      init_getNodeScroll();
      init_getNodeName();
      init_instanceOf();
      init_getWindowScrollBarX();
      init_getDocumentElement();
      init_isScrollParent();
      init_math();
    }
  });

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers2) {
    var map4 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers2.forEach(function(modifier) {
      map4.set(modifier.name, modifier);
    });
    function sort2(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map4.get(dep);
          if (depModifier) {
            sort2(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers2.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort2(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers2) {
    var orderedModifiers = order(modifiers2);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  var init_orderModifiers = __esm({
    "node_modules/@popperjs/core/lib/utils/orderModifiers.js"() {
      init_enums();
    }
  });

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce2(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve2) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve2(fn2());
          });
        });
      }
      return pending;
    };
  }
  var init_debounce = __esm({
    "node_modules/@popperjs/core/lib/utils/debounce.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers2) {
    var merged = modifiers2.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  var init_mergeByName = __esm({
    "node_modules/@popperjs/core/lib/utils/mergeByName.js"() {
    }
  });

  // node_modules/@popperjs/core/lib/createPopper.js
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions4 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions4;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions4),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions4, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index3 = 0; index3 < state.orderedModifiers.length; index3++) {
            if (state.reset === true) {
              state.reset = false;
              index3 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index3], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce2(function() {
          return new Promise(function(resolve2) {
            instance.forceUpdate();
            resolve2(state);
          });
        }),
        destroy: function destroy3() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
          if (typeof effect5 === "function") {
            var cleanupFn = effect5({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var DEFAULT_OPTIONS;
  var init_createPopper = __esm({
    "node_modules/@popperjs/core/lib/createPopper.js"() {
      init_getCompositeRect();
      init_getLayoutRect();
      init_listScrollParents();
      init_getOffsetParent();
      init_orderModifiers();
      init_debounce();
      init_mergeByName();
      init_instanceOf();
      DEFAULT_OPTIONS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
      };
    }
  });

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers, createPopper;
  var init_popper = __esm({
    "node_modules/@popperjs/core/lib/popper.js"() {
      init_createPopper();
      init_eventListeners();
      init_popperOffsets();
      init_computeStyles();
      init_applyStyles();
      init_offset();
      init_flip();
      init_preventOverflow();
      init_arrow();
      init_hide();
      init_modifiers();
      defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
      createPopper = /* @__PURE__ */ popperGenerator({
        defaultModifiers
      });
    }
  });

  // node_modules/@popperjs/core/lib/index.js
  var init_lib = __esm({
    "node_modules/@popperjs/core/lib/index.js"() {
      init_enums();
      init_modifiers();
      init_popper();
    }
  });

  // node_modules/lodash.throttle/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.throttle/index.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now2 = function() {
        return root.Date.now();
      };
      function debounce5(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function throttle7(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce5(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function isObject2(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = throttle7;
    }
  });

  // node_modules/@rails/request.js/src/fetch_response.js
  var FetchResponse2;
  var init_fetch_response = __esm({
    "node_modules/@rails/request.js/src/fetch_response.js"() {
      FetchResponse2 = class {
        constructor(response) {
          this.response = response;
        }
        get statusCode() {
          return this.response.status;
        }
        get redirected() {
          return this.response.redirected;
        }
        get ok() {
          return this.response.ok;
        }
        get unauthenticated() {
          return this.statusCode === 401;
        }
        get unprocessableEntity() {
          return this.statusCode === 422;
        }
        get authenticationURL() {
          return this.response.headers.get("WWW-Authenticate");
        }
        get contentType() {
          const contentType = this.response.headers.get("Content-Type") || "";
          return contentType.replace(/;.*$/, "");
        }
        get headers() {
          return this.response.headers;
        }
        get html() {
          if (this.contentType.match(/^(application|text)\/(html|xhtml\+xml)$/)) {
            return this.text;
          }
          return Promise.reject(new Error(`Expected an HTML response but got "${this.contentType}" instead`));
        }
        get json() {
          if (this.contentType.match(/^application\/.*json$/)) {
            return this.responseJson || (this.responseJson = this.response.json());
          }
          return Promise.reject(new Error(`Expected a JSON response but got "${this.contentType}" instead`));
        }
        get text() {
          return this.responseText || (this.responseText = this.response.text());
        }
        get isTurboStream() {
          return this.contentType.match(/^text\/vnd\.turbo-stream\.html/);
        }
        async renderTurboStream() {
          if (this.isTurboStream) {
            if (window.Turbo) {
              await window.Turbo.renderStreamMessage(await this.text);
            } else {
              console.warn("You must set `window.Turbo = Turbo` to automatically process Turbo Stream events with request.js");
            }
          } else {
            return Promise.reject(new Error(`Expected a Turbo Stream response but got "${this.contentType}" instead`));
          }
        }
      };
    }
  });

  // node_modules/@rails/request.js/src/request_interceptor.js
  var RequestInterceptor;
  var init_request_interceptor = __esm({
    "node_modules/@rails/request.js/src/request_interceptor.js"() {
      RequestInterceptor = class {
        static register(interceptor) {
          this.interceptor = interceptor;
        }
        static get() {
          return this.interceptor;
        }
        static reset() {
          this.interceptor = void 0;
        }
      };
    }
  });

  // node_modules/@rails/request.js/src/lib/utils.js
  function getCookie(name) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const prefix = `${encodeURIComponent(name)}=`;
    const cookie = cookies.find((cookie2) => cookie2.startsWith(prefix));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      if (value) {
        return decodeURIComponent(value);
      }
    }
  }
  function compact(object) {
    const result = {};
    for (const key in object) {
      const value = object[key];
      if (value !== void 0) {
        result[key] = value;
      }
    }
    return result;
  }
  function metaContent(name) {
    const element = document.head.querySelector(`meta[name="${name}"]`);
    return element && element.content;
  }
  function stringEntriesFromFormData(formData) {
    return [...formData].reduce((entries, [name, value]) => {
      return entries.concat(typeof value === "string" ? [[name, value]] : []);
    }, []);
  }
  function mergeEntries(searchParams, entries) {
    for (const [name, value] of entries) {
      if (value instanceof window.File)
        continue;
      if (searchParams.has(name) && !name.includes("[]")) {
        searchParams.delete(name);
        searchParams.set(name, value);
      } else {
        searchParams.append(name, value);
      }
    }
  }
  var init_utils = __esm({
    "node_modules/@rails/request.js/src/lib/utils.js"() {
    }
  });

  // node_modules/@rails/request.js/src/fetch_request.js
  var FetchRequest2;
  var init_fetch_request = __esm({
    "node_modules/@rails/request.js/src/fetch_request.js"() {
      init_fetch_response();
      init_request_interceptor();
      init_utils();
      FetchRequest2 = class {
        constructor(method, url, options = {}) {
          this.method = method;
          this.options = options;
          this.originalUrl = url.toString();
        }
        async perform() {
          try {
            const requestInterceptor = RequestInterceptor.get();
            if (requestInterceptor) {
              await requestInterceptor(this);
            }
          } catch (error3) {
            console.error(error3);
          }
          const response = new FetchResponse2(await window.fetch(this.url, this.fetchOptions));
          if (response.unauthenticated && response.authenticationURL) {
            return Promise.reject(window.location.href = response.authenticationURL);
          }
          const responseStatusIsTurboStreamable = response.ok || response.unprocessableEntity;
          if (responseStatusIsTurboStreamable && response.isTurboStream) {
            await response.renderTurboStream();
          }
          return response;
        }
        addHeader(key, value) {
          const headers = this.additionalHeaders;
          headers[key] = value;
          this.options.headers = headers;
        }
        sameHostname() {
          if (!this.originalUrl.startsWith("http:")) {
            return true;
          }
          try {
            return new URL(this.originalUrl).hostname === window.location.hostname;
          } catch (_) {
            return true;
          }
        }
        get fetchOptions() {
          return {
            method: this.method.toUpperCase(),
            headers: this.headers,
            body: this.formattedBody,
            signal: this.signal,
            credentials: this.credentials,
            redirect: this.redirect
          };
        }
        get headers() {
          const baseHeaders = {
            "X-Requested-With": "XMLHttpRequest",
            "Content-Type": this.contentType,
            Accept: this.accept
          };
          if (this.sameHostname()) {
            baseHeaders["X-CSRF-Token"] = this.csrfToken;
          }
          return compact(
            Object.assign(baseHeaders, this.additionalHeaders)
          );
        }
        get csrfToken() {
          return getCookie(metaContent("csrf-param")) || metaContent("csrf-token");
        }
        get contentType() {
          if (this.options.contentType) {
            return this.options.contentType;
          } else if (this.body == null || this.body instanceof window.FormData) {
            return void 0;
          } else if (this.body instanceof window.File) {
            return this.body.type;
          }
          return "application/json";
        }
        get accept() {
          switch (this.responseKind) {
            case "html":
              return "text/html, application/xhtml+xml";
            case "turbo-stream":
              return "text/vnd.turbo-stream.html, text/html, application/xhtml+xml";
            case "json":
              return "application/json, application/vnd.api+json";
            default:
              return "*/*";
          }
        }
        get body() {
          return this.options.body;
        }
        get query() {
          const originalQuery = (this.originalUrl.split("?")[1] || "").split("#")[0];
          const params = new URLSearchParams(originalQuery);
          let requestQuery = this.options.query;
          if (requestQuery instanceof window.FormData) {
            requestQuery = stringEntriesFromFormData(requestQuery);
          } else if (requestQuery instanceof window.URLSearchParams) {
            requestQuery = requestQuery.entries();
          } else {
            requestQuery = Object.entries(requestQuery || {});
          }
          mergeEntries(params, requestQuery);
          const query = params.toString();
          return query.length > 0 ? `?${query}` : "";
        }
        get url() {
          return this.originalUrl.split("?")[0].split("#")[0] + this.query;
        }
        get responseKind() {
          return this.options.responseKind || "html";
        }
        get signal() {
          return this.options.signal;
        }
        get redirect() {
          return this.options.redirect || "follow";
        }
        get credentials() {
          return this.options.credentials || "same-origin";
        }
        get additionalHeaders() {
          return this.options.headers || {};
        }
        get formattedBody() {
          const bodyIsAString = Object.prototype.toString.call(this.body) === "[object String]";
          const contentTypeIsJson = this.headers["Content-Type"] === "application/json";
          if (contentTypeIsJson && !bodyIsAString) {
            return JSON.stringify(this.body);
          }
          return this.body;
        }
      };
    }
  });

  // node_modules/@rails/request.js/src/verbs.js
  async function get(url, options) {
    const request = new FetchRequest2("get", url, options);
    return request.perform();
  }
  var init_verbs = __esm({
    "node_modules/@rails/request.js/src/verbs.js"() {
      init_fetch_request();
    }
  });

  // node_modules/@rails/request.js/src/index.js
  var init_src2 = __esm({
    "node_modules/@rails/request.js/src/index.js"() {
      init_fetch_request();
      init_fetch_response();
      init_request_interceptor();
      init_verbs();
    }
  });

  // node_modules/tippy.js/dist/tippy.esm.js
  function hasOwnProperty(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getValueAtIndexOrReturn(value, index3, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index3];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index3] : defaultValue : v;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce3(fn2, ms) {
    if (ms === 0) {
      return fn2;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn2(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys2) {
    var clone4 = Object.assign({}, obj);
    keys2.forEach(function(key) {
      delete clone4[key];
    });
    return clone4;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index3) {
      return arr.indexOf(item) === index3;
    });
  }
  function getBasePlacement2(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
      if (obj[key] !== void 0) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement2(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement2(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement2(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
      box[method](event, listener);
    });
  }
  function actualContains(parent, child) {
    var target = child;
    while (target) {
      var _target$getRootNode;
      if (parent.contains(target)) {
        return true;
      }
      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
  }
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now2 = performance.now();
    if (now2 - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now2;
  }
  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      // title
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      // message
      "line-height: 1.5",
      // footer
      "color: #a6a095;"
    ];
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  function getExtendedPassedProps(passedProps) {
    var plugins3 = passedProps.plugins || [];
    var pluginProps2 = plugins3.reduce(function(acc, plugin) {
      var name = plugin.name, defaultValue = plugin.defaultValue;
      if (name) {
        var _name;
        acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps2);
  }
  function getDataAttributeProps(reference2, plugins3) {
    var propKeys = plugins3 ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins: plugins3
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
      var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference2, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference2])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins3) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins3 === void 0) {
      plugins3 = [];
    }
    var keys2 = Object.keys(partialProps);
    keys2.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins3.filter(function(plugin) {
          return plugin.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow4 = div();
    if (value === true) {
      arrow4.className = ARROW_CLASS;
    } else {
      arrow4.className = SVG_ARROW_CLASS;
      if (isElement2(value)) {
        arrow4.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow4, value);
      }
    }
    return arrow4;
  }
  function setContent(content, props) {
    if (isElement2(props.content)) {
      dangerouslySetInnerHTML(content, "");
      content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper2) {
    var box = popper2.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper2 = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent(content, instance.props);
    popper2.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow4 = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content2, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow4) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow4);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow4) {
        box2.removeChild(arrow4);
      }
    }
    return {
      popper: popper2,
      onUpdate
    };
  }
  function createTippy(reference2, passedProps) {
    var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce3(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id = idCounter++;
    var popperInstance = null;
    var plugins3 = unique(props.plugins);
    var state = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id,
      reference: reference2,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins: plugins3,
      // methods
      clearDelayTimeouts,
      setProps,
      setContent: setContent3,
      show,
      hide: hide2,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy: destroy3
    };
    if (!props.render) {
      if (true) {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper2.setAttribute("data-tippy-root", "");
    popper2.id = "tippy-" + instance.id;
    instance.popper = popper2;
    reference2._tippy = instance;
    popper2._tippy = instance;
    var pluginsHooks = plugins3.map(function(plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper2.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper2.addEventListener("mouseleave", function() {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference2;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper2);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }
      popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
      popper2.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id2 = popper2.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
        } else {
          var nextValue = currentValue && currentValue.replace(id2, "").trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        if (instance.props.interactive) {
          node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
        } else {
          node.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === "mousedown") {
          return;
        }
      }
      var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
      if (instance.props.interactive && actualContains(popper2, actualTarget)) {
        return;
      }
      if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc3 = getDocument();
      doc3.addEventListener("mousedown", onDocumentPress, true);
      doc3.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc3.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc3.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc3 = getDocument();
      doc3.removeEventListener("mousedown", onDocumentPress, true);
      doc3.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc3.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc3.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback2) {
      onTransitionEnd(duration, function() {
        if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
          callback2();
        }
      });
    }
    function onTransitionedIn(duration, callback2) {
      onTransitionEnd(duration, callback2);
    }
    function onTransitionEnd(duration, callback2) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback2();
        }
      }
      if (duration === 0) {
        return callback2();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on2(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node,
          eventType,
          handler,
          options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on2("touchstart", onTrigger2, {
          passive: true
        });
        on2("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on2(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on2("mouseleave", onMouseLeave);
            break;
          case "focus":
            on2(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on2("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger2(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
      if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
      if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
        var _instance$popperInsta;
        var instance2 = popper3._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper3.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow4 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference2;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn2(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers2 = [{
        name: "offset",
        options: {
          offset: offset2
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow4) {
        modifiers2.push({
          name: "arrow",
          options: {
            element: arrow4,
            padding: 3
          }
        });
      }
      modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers: modifiers2
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount2() {
      var appendTo = instance.props.appendTo;
      var parentNode2;
      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
        parentNode2 = node.parentNode;
      } else {
        parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
      }
      if (!parentNode2.contains(popper2)) {
        parentNode2.appendChild(popper2);
      }
      instance.state.isMounted = true;
      createPopperInstance();
      if (true) {
        warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook("onTrigger", [instance, event]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce3(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
          node.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference2.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent3(content) {
      instance.setProps({
        content
      });
    }
    function show() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper2.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper2.offsetHeight;
        popper2.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount2();
    }
    function hide2() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper2.parentNode) {
        popper2.parentNode.removeChild(popper2);
      }
      mountedInstances = mountedInstances.filter(function(i) {
        return i !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy3() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference2._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins3 = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (true) {
      validateTargets(targets);
      validateProps(optionalProps, plugins3);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins: plugins3
    });
    var elements2 = getArrayOfElements(targets);
    if (true) {
      var isSingleContentElement = isElement2(passedProps.content);
      var isMoreThanOneReferenceElement = elements2.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances2 = elements2.reduce(function(acc, reference2) {
      var instance = reference2 && createTippy(reference2, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement2(targets) ? instances2[0] : instances2;
  }
  var BOX_CLASS, CONTENT_CLASS, BACKDROP_CLASS, ARROW_CLASS, SVG_ARROW_CLASS, TOUCH_OPTIONS, TIPPY_DEFAULT_APPEND_TO, currentInput, lastMouseMoveTime, isBrowser, isIE11, visitedMessages, pluginProps, renderProps, defaultProps, defaultKeys, setDefaultProps, innerHTML, idCounter, mouseMoveListeners, mountedInstances, applyStylesModifier, tippy_esm_default;
  var init_tippy_esm = __esm({
    "node_modules/tippy.js/dist/tippy.esm.js"() {
      init_lib();
      BOX_CLASS = "tippy-box";
      CONTENT_CLASS = "tippy-content";
      BACKDROP_CLASS = "tippy-backdrop";
      ARROW_CLASS = "tippy-arrow";
      SVG_ARROW_CLASS = "tippy-svg-arrow";
      TOUCH_OPTIONS = {
        passive: true,
        capture: true
      };
      TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
        return document.body;
      };
      currentInput = {
        isTouch: false
      };
      lastMouseMoveTime = 0;
      isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      isIE11 = isBrowser ? (
        // @ts-ignore
        !!window.msCrypto
      ) : false;
      if (true) {
        resetVisitedMessages();
      }
      pluginProps = {
        animateFill: false,
        followCursor: false,
        inlinePositioning: false,
        sticky: false
      };
      renderProps = {
        allowHTML: false,
        animation: "fade",
        arrow: true,
        content: "",
        inertia: false,
        maxWidth: 350,
        role: "tooltip",
        theme: "",
        zIndex: 9999
      };
      defaultProps = Object.assign({
        appendTo: TIPPY_DEFAULT_APPEND_TO,
        aria: {
          content: "auto",
          expanded: "auto"
        },
        delay: 0,
        duration: [300, 250],
        getReferenceClientRect: null,
        hideOnClick: true,
        ignoreAttributes: false,
        interactive: false,
        interactiveBorder: 2,
        interactiveDebounce: 0,
        moveTransition: "",
        offset: [0, 10],
        onAfterUpdate: function onAfterUpdate() {
        },
        onBeforeUpdate: function onBeforeUpdate() {
        },
        onCreate: function onCreate() {
        },
        onDestroy: function onDestroy() {
        },
        onHidden: function onHidden() {
        },
        onHide: function onHide() {
        },
        onMount: function onMount() {
        },
        onShow: function onShow() {
        },
        onShown: function onShown() {
        },
        onTrigger: function onTrigger() {
        },
        onUntrigger: function onUntrigger() {
        },
        onClickOutside: function onClickOutside() {
        },
        placement: "top",
        plugins: [],
        popperOptions: {},
        render: null,
        showOnCreate: false,
        touch: true,
        trigger: "mouseenter focus",
        triggerTarget: null
      }, pluginProps, renderProps);
      defaultKeys = Object.keys(defaultProps);
      setDefaultProps = function setDefaultProps2(partialProps) {
        if (true) {
          validateProps(partialProps, []);
        }
        var keys2 = Object.keys(partialProps);
        keys2.forEach(function(key) {
          defaultProps[key] = partialProps[key];
        });
      };
      innerHTML = function innerHTML2() {
        return "innerHTML";
      };
      render.$$tippy = true;
      idCounter = 1;
      mouseMoveListeners = [];
      mountedInstances = [];
      tippy.defaultProps = defaultProps;
      tippy.setDefaultProps = setDefaultProps;
      tippy.currentInput = currentInput;
      applyStylesModifier = Object.assign({}, applyStyles_default, {
        effect: function effect4(_ref) {
          var state = _ref.state;
          var initialStyles = {
            popper: {
              position: state.options.strategy,
              left: "0",
              top: "0",
              margin: "0"
            },
            arrow: {
              position: "absolute"
            },
            reference: {}
          };
          Object.assign(state.elements.popper.style, initialStyles.popper);
          state.styles = initialStyles;
          if (state.elements.arrow) {
            Object.assign(state.elements.arrow.style, initialStyles.arrow);
          }
        }
      });
      tippy.setDefaultProps({
        render
      });
      tippy_esm_default = tippy;
    }
  });

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      module.exports = function equal2(a, b) {
        if (a === b)
          return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor)
            return false;
          var length, i, keys2;
          if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length)
              return false;
            for (i = length; i-- !== 0; )
              if (!equal2(a[i], b[i]))
                return false;
            return true;
          }
          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString();
          keys2 = Object.keys(a);
          length = keys2.length;
          if (length !== Object.keys(b).length)
            return false;
          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys2[i]))
              return false;
          for (i = length; i-- !== 0; ) {
            var key = keys2[i];
            if (!equal2(a[key], b[key]))
              return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
    }
  });

  // node_modules/orderedmap/dist/index.js
  function OrderedMap(content) {
    this.content = content;
  }
  var dist_default;
  var init_dist = __esm({
    "node_modules/orderedmap/dist/index.js"() {
      OrderedMap.prototype = {
        constructor: OrderedMap,
        find: function(key) {
          for (var i = 0; i < this.content.length; i += 2)
            if (this.content[i] === key)
              return i;
          return -1;
        },
        // :: (string)  ?any
        // Retrieve the value stored under `key`, or return undefined when
        // no such key exists.
        get: function(key) {
          var found2 = this.find(key);
          return found2 == -1 ? void 0 : this.content[found2 + 1];
        },
        // :: (string, any, ?string)  OrderedMap
        // Create a new map by replacing the value of `key` with a new
        // value, or adding a binding to the end of the map. If `newKey` is
        // given, the key of the binding will be replaced with that key.
        update: function(key, value, newKey) {
          var self2 = newKey && newKey != key ? this.remove(newKey) : this;
          var found2 = self2.find(key), content = self2.content.slice();
          if (found2 == -1) {
            content.push(newKey || key, value);
          } else {
            content[found2 + 1] = value;
            if (newKey)
              content[found2] = newKey;
          }
          return new OrderedMap(content);
        },
        // :: (string)  OrderedMap
        // Return a map with the given key removed, if it existed.
        remove: function(key) {
          var found2 = this.find(key);
          if (found2 == -1)
            return this;
          var content = this.content.slice();
          content.splice(found2, 2);
          return new OrderedMap(content);
        },
        // :: (string, any)  OrderedMap
        // Add a new key to the start of the map.
        addToStart: function(key, value) {
          return new OrderedMap([key, value].concat(this.remove(key).content));
        },
        // :: (string, any)  OrderedMap
        // Add a new key to the end of the map.
        addToEnd: function(key, value) {
          var content = this.remove(key).content.slice();
          content.push(key, value);
          return new OrderedMap(content);
        },
        // :: (string, string, any)  OrderedMap
        // Add a key after the given key. If `place` is not found, the new
        // key is added to the end.
        addBefore: function(place, key, value) {
          var without = this.remove(key), content = without.content.slice();
          var found2 = without.find(place);
          content.splice(found2 == -1 ? content.length : found2, 0, key, value);
          return new OrderedMap(content);
        },
        // :: ((key: string, value: any))
        // Call the given function for each key/value pair in the map, in
        // order.
        forEach: function(f) {
          for (var i = 0; i < this.content.length; i += 2)
            f(this.content[i], this.content[i + 1]);
        },
        // :: (union<Object, OrderedMap>)  OrderedMap
        // Create a new map by prepending the keys in this map that don't
        // appear in `map` before the keys in `map`.
        prepend: function(map4) {
          map4 = OrderedMap.from(map4);
          if (!map4.size)
            return this;
          return new OrderedMap(map4.content.concat(this.subtract(map4).content));
        },
        // :: (union<Object, OrderedMap>)  OrderedMap
        // Create a new map by appending the keys in this map that don't
        // appear in `map` after the keys in `map`.
        append: function(map4) {
          map4 = OrderedMap.from(map4);
          if (!map4.size)
            return this;
          return new OrderedMap(this.subtract(map4).content.concat(map4.content));
        },
        // :: (union<Object, OrderedMap>)  OrderedMap
        // Create a map containing all the keys in this map that don't
        // appear in `map`.
        subtract: function(map4) {
          var result = this;
          map4 = OrderedMap.from(map4);
          for (var i = 0; i < map4.content.length; i += 2)
            result = result.remove(map4.content[i]);
          return result;
        },
        // :: ()  Object
        // Turn ordered map into a plain object.
        toObject: function() {
          var result = {};
          this.forEach(function(key, value) {
            result[key] = value;
          });
          return result;
        },
        // :: number
        // The amount of keys in this map.
        get size() {
          return this.content.length >> 1;
        }
      };
      OrderedMap.from = function(value) {
        if (value instanceof OrderedMap)
          return value;
        var content = [];
        if (value)
          for (var prop in value)
            content.push(prop, value[prop]);
        return new OrderedMap(content);
      };
      dist_default = OrderedMap;
    }
  });

  // node_modules/prosemirror-model/dist/index.js
  function findDiffStart(a, b, pos) {
    for (let i = 0; ; i++) {
      if (i == a.childCount || i == b.childCount)
        return a.childCount == b.childCount ? null : pos;
      let childA = a.child(i), childB = b.child(i);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return pos;
      if (childA.isText && childA.text != childB.text) {
        for (let j = 0; childA.text[j] == childB.text[j]; j++)
          pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null)
          return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a, b, posA, posB) {
    for (let iA = a.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0)
        return iA == iB ? null : { a: posA, b: posB };
      let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return { a: posA, b: posB };
      if (childA.isText && childA.text != childB.text) {
        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner)
          return inner;
      }
      posA -= size;
      posB -= size;
    }
  }
  function retIndex(index3, offset2) {
    found.index = index3;
    found.offset = offset2;
    return found;
  }
  function compareDeep(a, b) {
    if (a === b)
      return true;
    if (!(a && typeof a == "object") || !(b && typeof b == "object"))
      return false;
    let array = Array.isArray(a);
    if (Array.isArray(b) != array)
      return false;
    if (array) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!compareDeep(a[i], b[i]))
          return false;
    } else {
      for (let p in a)
        if (!(p in b) || !compareDeep(a[p], b[p]))
          return false;
      for (let p in b)
        if (!(p in a))
          return false;
    }
    return true;
  }
  function removeRange(content, from3, to2) {
    let { index: index3, offset: offset2 } = content.findIndex(from3), child = content.maybeChild(index3);
    let { index: indexTo, offset: offsetTo } = content.findIndex(to2);
    if (offset2 == from3 || child.isText) {
      if (offsetTo != to2 && !content.child(indexTo).isText)
        throw new RangeError("Removing non-flat range");
      return content.cut(0, from3).append(content.cut(to2));
    }
    if (index3 != indexTo)
      throw new RangeError("Removing non-flat range");
    return content.replaceChild(index3, child.copy(removeRange(child.content, from3 - offset2 - 1, to2 - offset2 - 1)));
  }
  function insertInto(content, dist, insert, parent) {
    let { index: index3, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index3);
    if (offset2 == dist || child.isText) {
      if (parent && !parent.canReplace(index3, index3, insert))
        return null;
      return content.cut(0, dist).append(insert).append(content.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset2 - 1, insert);
    return inner && content.replaceChild(index3, child.copy(inner));
  }
  function replace($from, $to, slice2) {
    if (slice2.openStart > $from.depth)
      throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
      throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice2, 0);
  }
  function replaceOuter($from, $to, slice2, depth) {
    let index3 = $from.index(depth), node = $from.node(depth);
    if (index3 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
      let inner = replaceOuter($from, $to, slice2, depth + 1);
      return node.copy(node.content.replaceChild(index3, inner));
    } else if (!slice2.content.size) {
      return close(node, replaceTwoWay($from, $to, depth));
    } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
      let parent = $from.parent, content = parent.content;
      return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
    } else {
      let { start: start3, end: end2 } = prepareSliceForReplace(slice2, $from);
      return close(node, replaceThreeWay($from, start3, end2, $to, depth));
    }
  }
  function checkJoin(main2, sub) {
    if (!sub.type.compatibleContent(main2.type))
      throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
  function joinable($before, $after, depth) {
    let node = $before.node(depth);
    checkJoin(node, $after.node(depth));
    return node;
  }
  function addNode(child, target) {
    let last = target.length - 1;
    if (last >= 0 && child.isText && child.sameMarkup(target[last]))
      target[last] = child.withText(target[last].text + child.text);
    else
      target.push(child);
  }
  function addRange($start, $end, depth, target) {
    let node = ($end || $start).node(depth);
    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (let i = startIndex; i < endIndex; i++)
      addNode(node.child(i), target);
    if ($end && $end.depth == depth && $end.textOffset)
      addNode($end.nodeBefore, target);
  }
  function close(node, content) {
    node.type.checkContent(content);
    return node.copy(content);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
    let content = [];
    addRange(null, $from, depth, content);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
    } else {
      if (openStart)
        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
      addRange($start, $end, depth, content);
      if (openEnd)
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function replaceTwoWay($from, $to, depth) {
    let content = [];
    addRange(null, $from, depth, content);
    if ($from.depth > depth) {
      let type = joinable($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function prepareSliceForReplace(slice2, $along) {
    let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
    let node = parent.copy(slice2.content);
    for (let i = extra - 1; i >= 0; i--)
      node = $along.node(i).copy(Fragment.from(node));
    return {
      start: node.resolveNoCache(slice2.openStart + extra),
      end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
    };
  }
  function wrapMarks(marks, str) {
    for (let i = marks.length - 1; i >= 0; i--)
      str = marks[i].type.name + "(" + str + ")";
    return str;
  }
  function parseExpr(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (; ; ) {
      if (stream.eat("+"))
        expr = { type: "plus", expr };
      else if (stream.eat("*"))
        expr = { type: "star", expr };
      else if (stream.eat("?"))
        expr = { type: "opt", expr };
      else if (stream.eat("{"))
        expr = parseExprRange(stream, expr);
      else
        break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next))
      stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    let min2 = parseNum(stream), max2 = min2;
    if (stream.eat(",")) {
      if (stream.next != "}")
        max2 = parseNum(stream);
      else
        max2 = -1;
    }
    if (!stream.eat("}"))
      stream.err("Unclosed braced range");
    return { type: "range", min: min2, max: max2, expr };
  }
  function resolveName(stream, name) {
    let types = stream.nodeTypes, type = types[name];
    if (type)
      return [type];
    let result = [];
    for (let typeName in types) {
      let type2 = types[typeName];
      if (type2.groups.indexOf(name) > -1)
        result.push(type2);
    }
    if (result.length == 0)
      stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      let expr = parseExpr(stream);
      if (!stream.eat(")"))
        stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      let exprs = resolveName(stream, stream.next).map((type) => {
        if (stream.inline == null)
          stream.inline = type.isInline;
        else if (stream.inline != type.isInline)
          stream.err("Mixing inline and block content");
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    let nfa2 = [[]];
    connect(compile(expr, 0), node());
    return nfa2;
    function node() {
      return nfa2.push([]) - 1;
    }
    function edge(from3, to2, term) {
      let edge2 = { term, to: to2 };
      nfa2[from3].push(edge2);
      return edge2;
    }
    function connect(edges, to2) {
      edges.forEach((edge2) => edge2.to = to2);
    }
    function compile(expr2, from3) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from3)), []);
      } else if (expr2.type == "seq") {
        for (let i = 0; ; i++) {
          let next = compile(expr2.exprs[i], from3);
          if (i == expr2.exprs.length - 1)
            return next;
          connect(next, from3 = node());
        }
      } else if (expr2.type == "star") {
        let loop = node();
        edge(from3, loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        let loop = node();
        connect(compile(expr2.expr, from3), loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "opt") {
        return [edge(from3)].concat(compile(expr2.expr, from3));
      } else if (expr2.type == "range") {
        let cur = from3;
        for (let i = 0; i < expr2.min; i++) {
          let next = node();
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
        if (expr2.max == -1) {
          connect(compile(expr2.expr, cur), cur);
        } else {
          for (let i = expr2.min; i < expr2.max; i++) {
            let next = node();
            edge(cur, next);
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from3, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a, b) {
    return b - a;
  }
  function nullFrom(nfa2, node) {
    let result = [];
    scan(node);
    return result.sort(cmp);
    function scan(node2) {
      let edges = nfa2[node2];
      if (edges.length == 1 && !edges[0].term)
        return scan(edges[0].to);
      result.push(node2);
      for (let i = 0; i < edges.length; i++) {
        let { term, to: to2 } = edges[i];
        if (!term && result.indexOf(to2) == -1)
          scan(to2);
      }
    }
  }
  function dfa(nfa2) {
    let labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      let out = [];
      states.forEach((node) => {
        nfa2[node].forEach(({ term, to: to2 }) => {
          if (!term)
            return;
          let set2;
          for (let i = 0; i < out.length; i++)
            if (out[i][0] == term)
              set2 = out[i][1];
          nullFrom(nfa2, to2).forEach((node2) => {
            if (!set2)
              out.push([term, set2 = []]);
            if (set2.indexOf(node2) == -1)
              set2.push(node2);
          });
        });
      });
      let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
      for (let i = 0; i < out.length; i++) {
        let states2 = out[i][1].sort(cmp);
        state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (let i = 0, work = [match]; i < work.length; i++) {
      let state = work[i], dead = !state.validEnd, nodes = [];
      for (let j = 0; j < state.next.length; j++) {
        let { type, next } = state.next[j];
        nodes.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs()))
          dead = false;
        if (work.indexOf(next) == -1)
          work.push(next);
      }
      if (dead)
        stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function defaultAttrs(attrs) {
    let defaults4 = /* @__PURE__ */ Object.create(null);
    for (let attrName in attrs) {
      let attr = attrs[attrName];
      if (!attr.hasDefault)
        return null;
      defaults4[attrName] = attr.default;
    }
    return defaults4;
  }
  function computeAttrs(attrs, value) {
    let built = /* @__PURE__ */ Object.create(null);
    for (let name in attrs) {
      let given = value && value[name];
      if (given === void 0) {
        let attr = attrs[name];
        if (attr.hasDefault)
          given = attr.default;
        else
          throw new RangeError("No value supplied for attribute " + name);
      }
      built[name] = given;
    }
    return built;
  }
  function initAttrs(attrs) {
    let result = /* @__PURE__ */ Object.create(null);
    if (attrs)
      for (let name in attrs)
        result[name] = new Attribute(attrs[name]);
    return result;
  }
  function gatherMarks(schema, marks) {
    let found2 = [];
    for (let i = 0; i < marks.length; i++) {
      let name = marks[i], mark = schema.marks[name], ok = mark;
      if (mark) {
        found2.push(mark);
      } else {
        for (let prop in schema.marks) {
          let mark2 = schema.marks[prop];
          if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
            found2.push(ok = mark2);
        }
      }
      if (!ok)
        throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
    }
    return found2;
  }
  function wsOptionsFor(type, preserveWhitespace, base2) {
    if (preserveWhitespace != null)
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
  }
  function normalizeList(dom) {
    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches2(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
  }
  function parseStyles(style2) {
    let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
    while (m = re.exec(style2))
      result.push(m[1], m[2].trim());
    return result;
  }
  function copy(obj) {
    let copy2 = {};
    for (let prop in obj)
      copy2[prop] = obj[prop];
    return copy2;
  }
  function markMayApply(markType, nodeType) {
    let nodes = nodeType.schema.nodes;
    for (let name in nodes) {
      let parent = nodes[name];
      if (!parent.allowsMarkType(markType))
        continue;
      let seen = [], scan = (match) => {
        seen.push(match);
        for (let i = 0; i < match.edgeCount; i++) {
          let { type, next } = match.edge(i);
          if (type == nodeType)
            return true;
          if (seen.indexOf(next) < 0 && scan(next))
            return true;
        }
      };
      if (scan(parent.contentMatch))
        return true;
    }
  }
  function findSameMarkInSet(mark, set2) {
    for (let i = 0; i < set2.length; i++) {
      if (mark.eq(set2[i]))
        return set2[i];
    }
  }
  function gatherToDOM(obj) {
    let result = {};
    for (let name in obj) {
      let toDOM = obj[name].spec.toDOM;
      if (toDOM)
        result[name] = toDOM;
    }
    return result;
  }
  function doc(options) {
    return options.document || window.document;
  }
  var Fragment, found, Mark, ReplaceError, Slice, ResolvedPos, resolveCache, resolveCachePos, resolveCacheSize, NodeRange, emptyAttrs, Node2, TextNode, ContentMatch, TokenStream, NodeType, Attribute, MarkType, Schema, DOMParser2, blockTags, ignoreTags, listTags, OPT_PRESERVE_WS, OPT_PRESERVE_WS_FULL, OPT_OPEN_LEFT, NodeContext, ParseContext, DOMSerializer;
  var init_dist2 = __esm({
    "node_modules/prosemirror-model/dist/index.js"() {
      init_dist();
      Fragment = class _Fragment {
        /**
        @internal
        */
        constructor(content, size) {
          this.content = content;
          this.size = size || 0;
          if (size == null)
            for (let i = 0; i < content.length; i++)
              this.size += content[i].nodeSize;
        }
        /**
        Invoke a callback for all descendant nodes between the given two
        positions (relative to start of this fragment). Doesn't descend
        into a node when the callback returns `false`.
        */
        nodesBetween(from3, to2, f, nodeStart = 0, parent) {
          for (let i = 0, pos = 0; pos < to2; i++) {
            let child = this.content[i], end2 = pos + child.nodeSize;
            if (end2 > from3 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
              let start3 = pos + 1;
              child.nodesBetween(Math.max(0, from3 - start3), Math.min(child.content.size, to2 - start3), f, nodeStart + start3);
            }
            pos = end2;
          }
        }
        /**
        Call the given callback for every descendant node. `pos` will be
        relative to the start of the fragment. The callback may return
        `false` to prevent traversal of a given node's children.
        */
        descendants(f) {
          this.nodesBetween(0, this.size, f);
        }
        /**
        Extract the text between `from` and `to`. See the same method on
        [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
        */
        textBetween(from3, to2, blockSeparator, leafText) {
          let text = "", first2 = true;
          this.nodesBetween(from3, to2, (node, pos) => {
            let nodeText = node.isText ? node.text.slice(Math.max(from3, pos) - pos, to2 - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
            if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
              if (first2)
                first2 = false;
              else
                text += blockSeparator;
            }
            text += nodeText;
          }, 0);
          return text;
        }
        /**
        Create a new fragment containing the combined content of this
        fragment and the other.
        */
        append(other) {
          if (!other.size)
            return this;
          if (!this.size)
            return other;
          let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
          if (last.isText && last.sameMarkup(first2)) {
            content[content.length - 1] = last.withText(last.text + first2.text);
            i = 1;
          }
          for (; i < other.content.length; i++)
            content.push(other.content[i]);
          return new _Fragment(content, this.size + other.size);
        }
        /**
        Cut out the sub-fragment between the two given positions.
        */
        cut(from3, to2 = this.size) {
          if (from3 == 0 && to2 == this.size)
            return this;
          let result = [], size = 0;
          if (to2 > from3)
            for (let i = 0, pos = 0; pos < to2; i++) {
              let child = this.content[i], end2 = pos + child.nodeSize;
              if (end2 > from3) {
                if (pos < from3 || end2 > to2) {
                  if (child.isText)
                    child = child.cut(Math.max(0, from3 - pos), Math.min(child.text.length, to2 - pos));
                  else
                    child = child.cut(Math.max(0, from3 - pos - 1), Math.min(child.content.size, to2 - pos - 1));
                }
                result.push(child);
                size += child.nodeSize;
              }
              pos = end2;
            }
          return new _Fragment(result, size);
        }
        /**
        @internal
        */
        cutByIndex(from3, to2) {
          if (from3 == to2)
            return _Fragment.empty;
          if (from3 == 0 && to2 == this.content.length)
            return this;
          return new _Fragment(this.content.slice(from3, to2));
        }
        /**
        Create a new fragment in which the node at the given index is
        replaced by the given node.
        */
        replaceChild(index3, node) {
          let current = this.content[index3];
          if (current == node)
            return this;
          let copy2 = this.content.slice();
          let size = this.size + node.nodeSize - current.nodeSize;
          copy2[index3] = node;
          return new _Fragment(copy2, size);
        }
        /**
        Create a new fragment by prepending the given node to this
        fragment.
        */
        addToStart(node) {
          return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
        }
        /**
        Create a new fragment by appending the given node to this
        fragment.
        */
        addToEnd(node) {
          return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
        }
        /**
        Compare this fragment to another one.
        */
        eq(other) {
          if (this.content.length != other.content.length)
            return false;
          for (let i = 0; i < this.content.length; i++)
            if (!this.content[i].eq(other.content[i]))
              return false;
          return true;
        }
        /**
        The first child of the fragment, or `null` if it is empty.
        */
        get firstChild() {
          return this.content.length ? this.content[0] : null;
        }
        /**
        The last child of the fragment, or `null` if it is empty.
        */
        get lastChild() {
          return this.content.length ? this.content[this.content.length - 1] : null;
        }
        /**
        The number of child nodes in this fragment.
        */
        get childCount() {
          return this.content.length;
        }
        /**
        Get the child node at the given index. Raise an error when the
        index is out of range.
        */
        child(index3) {
          let found2 = this.content[index3];
          if (!found2)
            throw new RangeError("Index " + index3 + " out of range for " + this);
          return found2;
        }
        /**
        Get the child node at the given index, if it exists.
        */
        maybeChild(index3) {
          return this.content[index3] || null;
        }
        /**
        Call `f` for every child node, passing the node, its offset
        into this parent node, and its index.
        */
        forEach(f) {
          for (let i = 0, p = 0; i < this.content.length; i++) {
            let child = this.content[i];
            f(child, p, i);
            p += child.nodeSize;
          }
        }
        /**
        Find the first position at which this fragment and another
        fragment differ, or `null` if they are the same.
        */
        findDiffStart(other, pos = 0) {
          return findDiffStart(this, other, pos);
        }
        /**
        Find the first position, searching from the end, at which this
        fragment and the given fragment differ, or `null` if they are
        the same. Since this position will not be the same in both
        nodes, an object with two separate positions is returned.
        */
        findDiffEnd(other, pos = this.size, otherPos = other.size) {
          return findDiffEnd(this, other, pos, otherPos);
        }
        /**
        Find the index and inner offset corresponding to a given relative
        position in this fragment. The result object will be reused
        (overwritten) the next time the function is called. (Not public.)
        */
        findIndex(pos, round3 = -1) {
          if (pos == 0)
            return retIndex(0, pos);
          if (pos == this.size)
            return retIndex(this.content.length, pos);
          if (pos > this.size || pos < 0)
            throw new RangeError(`Position ${pos} outside of fragment (${this})`);
          for (let i = 0, curPos = 0; ; i++) {
            let cur = this.child(i), end2 = curPos + cur.nodeSize;
            if (end2 >= pos) {
              if (end2 == pos || round3 > 0)
                return retIndex(i + 1, end2);
              return retIndex(i, curPos);
            }
            curPos = end2;
          }
        }
        /**
        Return a debugging string that describes this fragment.
        */
        toString() {
          return "<" + this.toStringInner() + ">";
        }
        /**
        @internal
        */
        toStringInner() {
          return this.content.join(", ");
        }
        /**
        Create a JSON-serializeable representation of this fragment.
        */
        toJSON() {
          return this.content.length ? this.content.map((n) => n.toJSON()) : null;
        }
        /**
        Deserialize a fragment from its JSON representation.
        */
        static fromJSON(schema, value) {
          if (!value)
            return _Fragment.empty;
          if (!Array.isArray(value))
            throw new RangeError("Invalid input for Fragment.fromJSON");
          return new _Fragment(value.map(schema.nodeFromJSON));
        }
        /**
        Build a fragment from an array of nodes. Ensures that adjacent
        text nodes with the same marks are joined together.
        */
        static fromArray(array) {
          if (!array.length)
            return _Fragment.empty;
          let joined, size = 0;
          for (let i = 0; i < array.length; i++) {
            let node = array[i];
            size += node.nodeSize;
            if (i && node.isText && array[i - 1].sameMarkup(node)) {
              if (!joined)
                joined = array.slice(0, i);
              joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
            } else if (joined) {
              joined.push(node);
            }
          }
          return new _Fragment(joined || array, size);
        }
        /**
        Create a fragment from something that can be interpreted as a
        set of nodes. For `null`, it returns the empty fragment. For a
        fragment, the fragment itself. For a node or array of nodes, a
        fragment containing those nodes.
        */
        static from(nodes) {
          if (!nodes)
            return _Fragment.empty;
          if (nodes instanceof _Fragment)
            return nodes;
          if (Array.isArray(nodes))
            return this.fromArray(nodes);
          if (nodes.attrs)
            return new _Fragment([nodes], nodes.nodeSize);
          throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
        }
      };
      Fragment.empty = new Fragment([], 0);
      found = { index: 0, offset: 0 };
      Mark = class _Mark {
        /**
        @internal
        */
        constructor(type, attrs) {
          this.type = type;
          this.attrs = attrs;
        }
        /**
        Given a set of marks, create a new set which contains this one as
        well, in the right position. If this mark is already in the set,
        the set itself is returned. If any marks that are set to be
        [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
        those are replaced by this one.
        */
        addToSet(set2) {
          let copy2, placed = false;
          for (let i = 0; i < set2.length; i++) {
            let other = set2[i];
            if (this.eq(other))
              return set2;
            if (this.type.excludes(other.type)) {
              if (!copy2)
                copy2 = set2.slice(0, i);
            } else if (other.type.excludes(this.type)) {
              return set2;
            } else {
              if (!placed && other.type.rank > this.type.rank) {
                if (!copy2)
                  copy2 = set2.slice(0, i);
                copy2.push(this);
                placed = true;
              }
              if (copy2)
                copy2.push(other);
            }
          }
          if (!copy2)
            copy2 = set2.slice();
          if (!placed)
            copy2.push(this);
          return copy2;
        }
        /**
        Remove this mark from the given set, returning a new set. If this
        mark is not in the set, the set itself is returned.
        */
        removeFromSet(set2) {
          for (let i = 0; i < set2.length; i++)
            if (this.eq(set2[i]))
              return set2.slice(0, i).concat(set2.slice(i + 1));
          return set2;
        }
        /**
        Test whether this mark is in the given set of marks.
        */
        isInSet(set2) {
          for (let i = 0; i < set2.length; i++)
            if (this.eq(set2[i]))
              return true;
          return false;
        }
        /**
        Test whether this mark has the same type and attributes as
        another mark.
        */
        eq(other) {
          return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
        }
        /**
        Convert this mark to a JSON-serializeable representation.
        */
        toJSON() {
          let obj = { type: this.type.name };
          for (let _ in this.attrs) {
            obj.attrs = this.attrs;
            break;
          }
          return obj;
        }
        /**
        Deserialize a mark from JSON.
        */
        static fromJSON(schema, json2) {
          if (!json2)
            throw new RangeError("Invalid input for Mark.fromJSON");
          let type = schema.marks[json2.type];
          if (!type)
            throw new RangeError(`There is no mark type ${json2.type} in this schema`);
          return type.create(json2.attrs);
        }
        /**
        Test whether two sets of marks are identical.
        */
        static sameSet(a, b) {
          if (a == b)
            return true;
          if (a.length != b.length)
            return false;
          for (let i = 0; i < a.length; i++)
            if (!a[i].eq(b[i]))
              return false;
          return true;
        }
        /**
        Create a properly sorted mark set from null, a single mark, or an
        unsorted array of marks.
        */
        static setFrom(marks) {
          if (!marks || Array.isArray(marks) && marks.length == 0)
            return _Mark.none;
          if (marks instanceof _Mark)
            return [marks];
          let copy2 = marks.slice();
          copy2.sort((a, b) => a.type.rank - b.type.rank);
          return copy2;
        }
      };
      Mark.none = [];
      ReplaceError = class extends Error {
      };
      Slice = class _Slice {
        /**
        Create a slice. When specifying a non-zero open depth, you must
        make sure that there are nodes of at least that depth at the
        appropriate side of the fragmenti.e. if the fragment is an
        empty paragraph node, `openStart` and `openEnd` can't be greater
        than 1.
        
        It is not necessary for the content of open nodes to conform to
        the schema's content constraints, though it should be a valid
        start/end/middle for such a node, depending on which sides are
        open.
        */
        constructor(content, openStart, openEnd) {
          this.content = content;
          this.openStart = openStart;
          this.openEnd = openEnd;
        }
        /**
        The size this slice would add when inserted into a document.
        */
        get size() {
          return this.content.size - this.openStart - this.openEnd;
        }
        /**
        @internal
        */
        insertAt(pos, fragment) {
          let content = insertInto(this.content, pos + this.openStart, fragment);
          return content && new _Slice(content, this.openStart, this.openEnd);
        }
        /**
        @internal
        */
        removeBetween(from3, to2) {
          return new _Slice(removeRange(this.content, from3 + this.openStart, to2 + this.openStart), this.openStart, this.openEnd);
        }
        /**
        Tests whether this slice is equal to another slice.
        */
        eq(other) {
          return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
        }
        /**
        @internal
        */
        toString() {
          return this.content + "(" + this.openStart + "," + this.openEnd + ")";
        }
        /**
        Convert a slice to a JSON-serializable representation.
        */
        toJSON() {
          if (!this.content.size)
            return null;
          let json2 = { content: this.content.toJSON() };
          if (this.openStart > 0)
            json2.openStart = this.openStart;
          if (this.openEnd > 0)
            json2.openEnd = this.openEnd;
          return json2;
        }
        /**
        Deserialize a slice from its JSON representation.
        */
        static fromJSON(schema, json2) {
          if (!json2)
            return _Slice.empty;
          let openStart = json2.openStart || 0, openEnd = json2.openEnd || 0;
          if (typeof openStart != "number" || typeof openEnd != "number")
            throw new RangeError("Invalid input for Slice.fromJSON");
          return new _Slice(Fragment.fromJSON(schema, json2.content), openStart, openEnd);
        }
        /**
        Create a slice from a fragment by taking the maximum possible
        open value on both side of the fragment.
        */
        static maxOpen(fragment, openIsolating = true) {
          let openStart = 0, openEnd = 0;
          for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
            openStart++;
          for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
            openEnd++;
          return new _Slice(fragment, openStart, openEnd);
        }
      };
      Slice.empty = new Slice(Fragment.empty, 0, 0);
      ResolvedPos = class _ResolvedPos {
        /**
        @internal
        */
        constructor(pos, path, parentOffset) {
          this.pos = pos;
          this.path = path;
          this.parentOffset = parentOffset;
          this.depth = path.length / 3 - 1;
        }
        /**
        @internal
        */
        resolveDepth(val) {
          if (val == null)
            return this.depth;
          if (val < 0)
            return this.depth + val;
          return val;
        }
        /**
        The parent node that the position points into. Note that even if
        a position points into a text node, that node is not considered
        the parenttext nodes are flat in this model, and have no content.
        */
        get parent() {
          return this.node(this.depth);
        }
        /**
        The root node in which the position was resolved.
        */
        get doc() {
          return this.node(0);
        }
        /**
        The ancestor node at the given level. `p.node(p.depth)` is the
        same as `p.parent`.
        */
        node(depth) {
          return this.path[this.resolveDepth(depth) * 3];
        }
        /**
        The index into the ancestor at the given level. If this points
        at the 3rd node in the 2nd paragraph on the top level, for
        example, `p.index(0)` is 1 and `p.index(1)` is 2.
        */
        index(depth) {
          return this.path[this.resolveDepth(depth) * 3 + 1];
        }
        /**
        The index pointing after this position into the ancestor at the
        given level.
        */
        indexAfter(depth) {
          depth = this.resolveDepth(depth);
          return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
        }
        /**
        The (absolute) position at the start of the node at the given
        level.
        */
        start(depth) {
          depth = this.resolveDepth(depth);
          return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
        }
        /**
        The (absolute) position at the end of the node at the given
        level.
        */
        end(depth) {
          depth = this.resolveDepth(depth);
          return this.start(depth) + this.node(depth).content.size;
        }
        /**
        The (absolute) position directly before the wrapping node at the
        given level, or, when `depth` is `this.depth + 1`, the original
        position.
        */
        before(depth) {
          depth = this.resolveDepth(depth);
          if (!depth)
            throw new RangeError("There is no position before the top-level node");
          return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
        }
        /**
        The (absolute) position directly after the wrapping node at the
        given level, or the original position when `depth` is `this.depth + 1`.
        */
        after(depth) {
          depth = this.resolveDepth(depth);
          if (!depth)
            throw new RangeError("There is no position after the top-level node");
          return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
        }
        /**
        When this position points into a text node, this returns the
        distance between the position and the start of the text node.
        Will be zero for positions that point between nodes.
        */
        get textOffset() {
          return this.pos - this.path[this.path.length - 1];
        }
        /**
        Get the node directly after the position, if any. If the position
        points into a text node, only the part of that node after the
        position is returned.
        */
        get nodeAfter() {
          let parent = this.parent, index3 = this.index(this.depth);
          if (index3 == parent.childCount)
            return null;
          let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index3);
          return dOff ? parent.child(index3).cut(dOff) : child;
        }
        /**
        Get the node directly before the position, if any. If the
        position points into a text node, only the part of that node
        before the position is returned.
        */
        get nodeBefore() {
          let index3 = this.index(this.depth);
          let dOff = this.pos - this.path[this.path.length - 1];
          if (dOff)
            return this.parent.child(index3).cut(0, dOff);
          return index3 == 0 ? null : this.parent.child(index3 - 1);
        }
        /**
        Get the position at the given index in the parent node at the
        given depth (which defaults to `this.depth`).
        */
        posAtIndex(index3, depth) {
          depth = this.resolveDepth(depth);
          let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
          for (let i = 0; i < index3; i++)
            pos += node.child(i).nodeSize;
          return pos;
        }
        /**
        Get the marks at this position, factoring in the surrounding
        marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
        position is at the start of a non-empty node, the marks of the
        node after it (if any) are returned.
        */
        marks() {
          let parent = this.parent, index3 = this.index();
          if (parent.content.size == 0)
            return Mark.none;
          if (this.textOffset)
            return parent.child(index3).marks;
          let main2 = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
          if (!main2) {
            let tmp = main2;
            main2 = other;
            other = tmp;
          }
          let marks = main2.marks;
          for (var i = 0; i < marks.length; i++)
            if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
              marks = marks[i--].removeFromSet(marks);
          return marks;
        }
        /**
        Get the marks after the current position, if any, except those
        that are non-inclusive and not present at position `$end`. This
        is mostly useful for getting the set of marks to preserve after a
        deletion. Will return `null` if this position is at the end of
        its parent node or its parent node isn't a textblock (in which
        case no marks should be preserved).
        */
        marksAcross($end) {
          let after = this.parent.maybeChild(this.index());
          if (!after || !after.isInline)
            return null;
          let marks = after.marks, next = $end.parent.maybeChild($end.index());
          for (var i = 0; i < marks.length; i++)
            if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
              marks = marks[i--].removeFromSet(marks);
          return marks;
        }
        /**
        The depth up to which this position and the given (non-resolved)
        position share the same parent nodes.
        */
        sharedDepth(pos) {
          for (let depth = this.depth; depth > 0; depth--)
            if (this.start(depth) <= pos && this.end(depth) >= pos)
              return depth;
          return 0;
        }
        /**
        Returns a range based on the place where this position and the
        given position diverge around block content. If both point into
        the same textblock, for example, a range around that textblock
        will be returned. If they point into different blocks, the range
        around those blocks in their shared ancestor is returned. You can
        pass in an optional predicate that will be called with a parent
        node to see if a range into that parent is acceptable.
        */
        blockRange(other = this, pred) {
          if (other.pos < this.pos)
            return other.blockRange(this);
          for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
            if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
              return new NodeRange(this, other, d);
          return null;
        }
        /**
        Query whether the given position shares the same parent node.
        */
        sameParent(other) {
          return this.pos - this.parentOffset == other.pos - other.parentOffset;
        }
        /**
        Return the greater of this and the given position.
        */
        max(other) {
          return other.pos > this.pos ? other : this;
        }
        /**
        Return the smaller of this and the given position.
        */
        min(other) {
          return other.pos < this.pos ? other : this;
        }
        /**
        @internal
        */
        toString() {
          let str = "";
          for (let i = 1; i <= this.depth; i++)
            str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
          return str + ":" + this.parentOffset;
        }
        /**
        @internal
        */
        static resolve(doc3, pos) {
          if (!(pos >= 0 && pos <= doc3.content.size))
            throw new RangeError("Position " + pos + " out of range");
          let path = [];
          let start3 = 0, parentOffset = pos;
          for (let node = doc3; ; ) {
            let { index: index3, offset: offset2 } = node.content.findIndex(parentOffset);
            let rem = parentOffset - offset2;
            path.push(node, index3, start3 + offset2);
            if (!rem)
              break;
            node = node.child(index3);
            if (node.isText)
              break;
            parentOffset = rem - 1;
            start3 += offset2 + 1;
          }
          return new _ResolvedPos(pos, path, parentOffset);
        }
        /**
        @internal
        */
        static resolveCached(doc3, pos) {
          for (let i = 0; i < resolveCache.length; i++) {
            let cached = resolveCache[i];
            if (cached.pos == pos && cached.doc == doc3)
              return cached;
          }
          let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc3, pos);
          resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
          return result;
        }
      };
      resolveCache = [];
      resolveCachePos = 0;
      resolveCacheSize = 12;
      NodeRange = class {
        /**
        Construct a node range. `$from` and `$to` should point into the
        same node until at least the given `depth`, since a node range
        denotes an adjacent set of nodes in a single parent node.
        */
        constructor($from, $to, depth) {
          this.$from = $from;
          this.$to = $to;
          this.depth = depth;
        }
        /**
        The position at the start of the range.
        */
        get start() {
          return this.$from.before(this.depth + 1);
        }
        /**
        The position at the end of the range.
        */
        get end() {
          return this.$to.after(this.depth + 1);
        }
        /**
        The parent node that the range points into.
        */
        get parent() {
          return this.$from.node(this.depth);
        }
        /**
        The start index of the range in the parent node.
        */
        get startIndex() {
          return this.$from.index(this.depth);
        }
        /**
        The end index of the range in the parent node.
        */
        get endIndex() {
          return this.$to.indexAfter(this.depth);
        }
      };
      emptyAttrs = /* @__PURE__ */ Object.create(null);
      Node2 = class _Node {
        /**
        @internal
        */
        constructor(type, attrs, content, marks = Mark.none) {
          this.type = type;
          this.attrs = attrs;
          this.marks = marks;
          this.content = content || Fragment.empty;
        }
        /**
        The size of this node, as defined by the integer-based [indexing
        scheme](/docs/guide/#doc.indexing). For text nodes, this is the
        amount of characters. For other leaf nodes, it is one. For
        non-leaf nodes, it is the size of the content plus two (the
        start and end token).
        */
        get nodeSize() {
          return this.isLeaf ? 1 : 2 + this.content.size;
        }
        /**
        The number of children that the node has.
        */
        get childCount() {
          return this.content.childCount;
        }
        /**
        Get the child node at the given index. Raises an error when the
        index is out of range.
        */
        child(index3) {
          return this.content.child(index3);
        }
        /**
        Get the child node at the given index, if it exists.
        */
        maybeChild(index3) {
          return this.content.maybeChild(index3);
        }
        /**
        Call `f` for every child node, passing the node, its offset
        into this parent node, and its index.
        */
        forEach(f) {
          this.content.forEach(f);
        }
        /**
        Invoke a callback for all descendant nodes recursively between
        the given two positions that are relative to start of this
        node's content. The callback is invoked with the node, its
        position relative to the original node (method receiver),
        its parent node, and its child index. When the callback returns
        false for a given node, that node's children will not be
        recursed over. The last parameter can be used to specify a
        starting position to count from.
        */
        nodesBetween(from3, to2, f, startPos = 0) {
          this.content.nodesBetween(from3, to2, f, startPos, this);
        }
        /**
        Call the given callback for every descendant node. Doesn't
        descend into a node when the callback returns `false`.
        */
        descendants(f) {
          this.nodesBetween(0, this.content.size, f);
        }
        /**
        Concatenates all the text nodes found in this fragment and its
        children.
        */
        get textContent() {
          return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
        }
        /**
        Get all text between positions `from` and `to`. When
        `blockSeparator` is given, it will be inserted to separate text
        from different block nodes. If `leafText` is given, it'll be
        inserted for every non-text leaf node encountered, otherwise
        [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
        */
        textBetween(from3, to2, blockSeparator, leafText) {
          return this.content.textBetween(from3, to2, blockSeparator, leafText);
        }
        /**
        Returns this node's first child, or `null` if there are no
        children.
        */
        get firstChild() {
          return this.content.firstChild;
        }
        /**
        Returns this node's last child, or `null` if there are no
        children.
        */
        get lastChild() {
          return this.content.lastChild;
        }
        /**
        Test whether two nodes represent the same piece of document.
        */
        eq(other) {
          return this == other || this.sameMarkup(other) && this.content.eq(other.content);
        }
        /**
        Compare the markup (type, attributes, and marks) of this node to
        those of another. Returns `true` if both have the same markup.
        */
        sameMarkup(other) {
          return this.hasMarkup(other.type, other.attrs, other.marks);
        }
        /**
        Check whether this node's markup correspond to the given type,
        attributes, and marks.
        */
        hasMarkup(type, attrs, marks) {
          return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
        }
        /**
        Create a new node with the same markup as this node, containing
        the given content (or empty, if no content is given).
        */
        copy(content = null) {
          if (content == this.content)
            return this;
          return new _Node(this.type, this.attrs, content, this.marks);
        }
        /**
        Create a copy of this node, with the given set of marks instead
        of the node's own marks.
        */
        mark(marks) {
          return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
        }
        /**
        Create a copy of this node with only the content between the
        given positions. If `to` is not given, it defaults to the end of
        the node.
        */
        cut(from3, to2 = this.content.size) {
          if (from3 == 0 && to2 == this.content.size)
            return this;
          return this.copy(this.content.cut(from3, to2));
        }
        /**
        Cut out the part of the document between the given positions, and
        return it as a `Slice` object.
        */
        slice(from3, to2 = this.content.size, includeParents = false) {
          if (from3 == to2)
            return Slice.empty;
          let $from = this.resolve(from3), $to = this.resolve(to2);
          let depth = includeParents ? 0 : $from.sharedDepth(to2);
          let start3 = $from.start(depth), node = $from.node(depth);
          let content = node.content.cut($from.pos - start3, $to.pos - start3);
          return new Slice(content, $from.depth - depth, $to.depth - depth);
        }
        /**
        Replace the part of the document between the given positions with
        the given slice. The slice must 'fit', meaning its open sides
        must be able to connect to the surrounding content, and its
        content nodes must be valid children for the node they are placed
        into. If any of this is violated, an error of type
        [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
        */
        replace(from3, to2, slice2) {
          return replace(this.resolve(from3), this.resolve(to2), slice2);
        }
        /**
        Find the node directly after the given position.
        */
        nodeAt(pos) {
          for (let node = this; ; ) {
            let { index: index3, offset: offset2 } = node.content.findIndex(pos);
            node = node.maybeChild(index3);
            if (!node)
              return null;
            if (offset2 == pos || node.isText)
              return node;
            pos -= offset2 + 1;
          }
        }
        /**
        Find the (direct) child node after the given offset, if any,
        and return it along with its index and offset relative to this
        node.
        */
        childAfter(pos) {
          let { index: index3, offset: offset2 } = this.content.findIndex(pos);
          return { node: this.content.maybeChild(index3), index: index3, offset: offset2 };
        }
        /**
        Find the (direct) child node before the given offset, if any,
        and return it along with its index and offset relative to this
        node.
        */
        childBefore(pos) {
          if (pos == 0)
            return { node: null, index: 0, offset: 0 };
          let { index: index3, offset: offset2 } = this.content.findIndex(pos);
          if (offset2 < pos)
            return { node: this.content.child(index3), index: index3, offset: offset2 };
          let node = this.content.child(index3 - 1);
          return { node, index: index3 - 1, offset: offset2 - node.nodeSize };
        }
        /**
        Resolve the given position in the document, returning an
        [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
        */
        resolve(pos) {
          return ResolvedPos.resolveCached(this, pos);
        }
        /**
        @internal
        */
        resolveNoCache(pos) {
          return ResolvedPos.resolve(this, pos);
        }
        /**
        Test whether a given mark or mark type occurs in this document
        between the two given positions.
        */
        rangeHasMark(from3, to2, type) {
          let found2 = false;
          if (to2 > from3)
            this.nodesBetween(from3, to2, (node) => {
              if (type.isInSet(node.marks))
                found2 = true;
              return !found2;
            });
          return found2;
        }
        /**
        True when this is a block (non-inline node)
        */
        get isBlock() {
          return this.type.isBlock;
        }
        /**
        True when this is a textblock node, a block node with inline
        content.
        */
        get isTextblock() {
          return this.type.isTextblock;
        }
        /**
        True when this node allows inline content.
        */
        get inlineContent() {
          return this.type.inlineContent;
        }
        /**
        True when this is an inline node (a text node or a node that can
        appear among text).
        */
        get isInline() {
          return this.type.isInline;
        }
        /**
        True when this is a text node.
        */
        get isText() {
          return this.type.isText;
        }
        /**
        True when this is a leaf node.
        */
        get isLeaf() {
          return this.type.isLeaf;
        }
        /**
        True when this is an atom, i.e. when it does not have directly
        editable content. This is usually the same as `isLeaf`, but can
        be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
        on a node's spec (typically used when the node is displayed as
        an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
        */
        get isAtom() {
          return this.type.isAtom;
        }
        /**
        Return a string representation of this node for debugging
        purposes.
        */
        toString() {
          if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
          let name = this.type.name;
          if (this.content.size)
            name += "(" + this.content.toStringInner() + ")";
          return wrapMarks(this.marks, name);
        }
        /**
        Get the content match in this node at the given index.
        */
        contentMatchAt(index3) {
          let match = this.type.contentMatch.matchFragment(this.content, 0, index3);
          if (!match)
            throw new Error("Called contentMatchAt on a node with invalid content");
          return match;
        }
        /**
        Test whether replacing the range between `from` and `to` (by
        child index) with the given replacement fragment (which defaults
        to the empty fragment) would leave the node's content valid. You
        can optionally pass `start` and `end` indices into the
        replacement fragment.
        */
        canReplace(from3, to2, replacement = Fragment.empty, start3 = 0, end2 = replacement.childCount) {
          let one = this.contentMatchAt(from3).matchFragment(replacement, start3, end2);
          let two = one && one.matchFragment(this.content, to2);
          if (!two || !two.validEnd)
            return false;
          for (let i = start3; i < end2; i++)
            if (!this.type.allowsMarks(replacement.child(i).marks))
              return false;
          return true;
        }
        /**
        Test whether replacing the range `from` to `to` (by index) with
        a node of the given type would leave the node's content valid.
        */
        canReplaceWith(from3, to2, type, marks) {
          if (marks && !this.type.allowsMarks(marks))
            return false;
          let start3 = this.contentMatchAt(from3).matchType(type);
          let end2 = start3 && start3.matchFragment(this.content, to2);
          return end2 ? end2.validEnd : false;
        }
        /**
        Test whether the given node's content could be appended to this
        node. If that node is empty, this will only return true if there
        is at least one node type that can appear in both nodes (to avoid
        merging completely incompatible nodes).
        */
        canAppend(other) {
          if (other.content.size)
            return this.canReplace(this.childCount, this.childCount, other.content);
          else
            return this.type.compatibleContent(other.type);
        }
        /**
        Check whether this node and its descendants conform to the
        schema, and raise error when they do not.
        */
        check() {
          this.type.checkContent(this.content);
          let copy2 = Mark.none;
          for (let i = 0; i < this.marks.length; i++)
            copy2 = this.marks[i].addToSet(copy2);
          if (!Mark.sameSet(copy2, this.marks))
            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
          this.content.forEach((node) => node.check());
        }
        /**
        Return a JSON-serializeable representation of this node.
        */
        toJSON() {
          let obj = { type: this.type.name };
          for (let _ in this.attrs) {
            obj.attrs = this.attrs;
            break;
          }
          if (this.content.size)
            obj.content = this.content.toJSON();
          if (this.marks.length)
            obj.marks = this.marks.map((n) => n.toJSON());
          return obj;
        }
        /**
        Deserialize a node from its JSON representation.
        */
        static fromJSON(schema, json2) {
          if (!json2)
            throw new RangeError("Invalid input for Node.fromJSON");
          let marks = null;
          if (json2.marks) {
            if (!Array.isArray(json2.marks))
              throw new RangeError("Invalid mark data for Node.fromJSON");
            marks = json2.marks.map(schema.markFromJSON);
          }
          if (json2.type == "text") {
            if (typeof json2.text != "string")
              throw new RangeError("Invalid text node in JSON");
            return schema.text(json2.text, marks);
          }
          let content = Fragment.fromJSON(schema, json2.content);
          return schema.nodeType(json2.type).create(json2.attrs, content, marks);
        }
      };
      Node2.prototype.text = void 0;
      TextNode = class _TextNode extends Node2 {
        /**
        @internal
        */
        constructor(type, attrs, content, marks) {
          super(type, attrs, null, marks);
          if (!content)
            throw new RangeError("Empty text nodes are not allowed");
          this.text = content;
        }
        toString() {
          if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
          return wrapMarks(this.marks, JSON.stringify(this.text));
        }
        get textContent() {
          return this.text;
        }
        textBetween(from3, to2) {
          return this.text.slice(from3, to2);
        }
        get nodeSize() {
          return this.text.length;
        }
        mark(marks) {
          return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
        }
        withText(text) {
          if (text == this.text)
            return this;
          return new _TextNode(this.type, this.attrs, text, this.marks);
        }
        cut(from3 = 0, to2 = this.text.length) {
          if (from3 == 0 && to2 == this.text.length)
            return this;
          return this.withText(this.text.slice(from3, to2));
        }
        eq(other) {
          return this.sameMarkup(other) && this.text == other.text;
        }
        toJSON() {
          let base2 = super.toJSON();
          base2.text = this.text;
          return base2;
        }
      };
      ContentMatch = class _ContentMatch {
        /**
        @internal
        */
        constructor(validEnd) {
          this.validEnd = validEnd;
          this.next = [];
          this.wrapCache = [];
        }
        /**
        @internal
        */
        static parse(string, nodeTypes) {
          let stream = new TokenStream(string, nodeTypes);
          if (stream.next == null)
            return _ContentMatch.empty;
          let expr = parseExpr(stream);
          if (stream.next)
            stream.err("Unexpected trailing text");
          let match = dfa(nfa(expr));
          checkForDeadEnds(match, stream);
          return match;
        }
        /**
        Match a node type, returning a match after that node if
        successful.
        */
        matchType(type) {
          for (let i = 0; i < this.next.length; i++)
            if (this.next[i].type == type)
              return this.next[i].next;
          return null;
        }
        /**
        Try to match a fragment. Returns the resulting match when
        successful.
        */
        matchFragment(frag, start3 = 0, end2 = frag.childCount) {
          let cur = this;
          for (let i = start3; cur && i < end2; i++)
            cur = cur.matchType(frag.child(i).type);
          return cur;
        }
        /**
        @internal
        */
        get inlineContent() {
          return this.next.length != 0 && this.next[0].type.isInline;
        }
        /**
        Get the first matching node type at this match position that can
        be generated.
        */
        get defaultType() {
          for (let i = 0; i < this.next.length; i++) {
            let { type } = this.next[i];
            if (!(type.isText || type.hasRequiredAttrs()))
              return type;
          }
          return null;
        }
        /**
        @internal
        */
        compatible(other) {
          for (let i = 0; i < this.next.length; i++)
            for (let j = 0; j < other.next.length; j++)
              if (this.next[i].type == other.next[j].type)
                return true;
          return false;
        }
        /**
        Try to match the given fragment, and if that fails, see if it can
        be made to match by inserting nodes in front of it. When
        successful, return a fragment of inserted nodes (which may be
        empty if nothing had to be inserted). When `toEnd` is true, only
        return a fragment if the resulting match goes to the end of the
        content expression.
        */
        fillBefore(after, toEnd = false, startIndex = 0) {
          let seen = [this];
          function search(match, types) {
            let finished = match.matchFragment(after, startIndex);
            if (finished && (!toEnd || finished.validEnd))
              return Fragment.from(types.map((tp) => tp.createAndFill()));
            for (let i = 0; i < match.next.length; i++) {
              let { type, next } = match.next[i];
              if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
                seen.push(next);
                let found2 = search(next, types.concat(type));
                if (found2)
                  return found2;
              }
            }
            return null;
          }
          return search(this, []);
        }
        /**
        Find a set of wrapping node types that would allow a node of the
        given type to appear at this position. The result may be empty
        (when it fits directly) and will be null when no such wrapping
        exists.
        */
        findWrapping(target) {
          for (let i = 0; i < this.wrapCache.length; i += 2)
            if (this.wrapCache[i] == target)
              return this.wrapCache[i + 1];
          let computed = this.computeWrapping(target);
          this.wrapCache.push(target, computed);
          return computed;
        }
        /**
        @internal
        */
        computeWrapping(target) {
          let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
          while (active.length) {
            let current = active.shift(), match = current.match;
            if (match.matchType(target)) {
              let result = [];
              for (let obj = current; obj.type; obj = obj.via)
                result.push(obj.type);
              return result.reverse();
            }
            for (let i = 0; i < match.next.length; i++) {
              let { type, next } = match.next[i];
              if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
                active.push({ match: type.contentMatch, type, via: current });
                seen[type.name] = true;
              }
            }
          }
          return null;
        }
        /**
        The number of outgoing edges this node has in the finite
        automaton that describes the content expression.
        */
        get edgeCount() {
          return this.next.length;
        }
        /**
        Get the _n_th outgoing edge from this node in the finite
        automaton that describes the content expression.
        */
        edge(n) {
          if (n >= this.next.length)
            throw new RangeError(`There's no ${n}th edge in this content match`);
          return this.next[n];
        }
        /**
        @internal
        */
        toString() {
          let seen = [];
          function scan(m) {
            seen.push(m);
            for (let i = 0; i < m.next.length; i++)
              if (seen.indexOf(m.next[i].next) == -1)
                scan(m.next[i].next);
          }
          scan(this);
          return seen.map((m, i) => {
            let out = i + (m.validEnd ? "*" : " ") + " ";
            for (let i2 = 0; i2 < m.next.length; i2++)
              out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
            return out;
          }).join("\n");
        }
      };
      ContentMatch.empty = new ContentMatch(true);
      TokenStream = class {
        constructor(string, nodeTypes) {
          this.string = string;
          this.nodeTypes = nodeTypes;
          this.inline = null;
          this.pos = 0;
          this.tokens = string.split(/\s*(?=\b|\W|$)/);
          if (this.tokens[this.tokens.length - 1] == "")
            this.tokens.pop();
          if (this.tokens[0] == "")
            this.tokens.shift();
        }
        get next() {
          return this.tokens[this.pos];
        }
        eat(tok) {
          return this.next == tok && (this.pos++ || true);
        }
        err(str) {
          throw new SyntaxError(str + " (in content expression '" + this.string + "')");
        }
      };
      NodeType = class _NodeType {
        /**
        @internal
        */
        constructor(name, schema, spec) {
          this.name = name;
          this.schema = schema;
          this.spec = spec;
          this.markSet = null;
          this.groups = spec.group ? spec.group.split(" ") : [];
          this.attrs = initAttrs(spec.attrs);
          this.defaultAttrs = defaultAttrs(this.attrs);
          this.contentMatch = null;
          this.inlineContent = null;
          this.isBlock = !(spec.inline || name == "text");
          this.isText = name == "text";
        }
        /**
        True if this is an inline type.
        */
        get isInline() {
          return !this.isBlock;
        }
        /**
        True if this is a textblock type, a block that contains inline
        content.
        */
        get isTextblock() {
          return this.isBlock && this.inlineContent;
        }
        /**
        True for node types that allow no content.
        */
        get isLeaf() {
          return this.contentMatch == ContentMatch.empty;
        }
        /**
        True when this node is an atom, i.e. when it does not have
        directly editable content.
        */
        get isAtom() {
          return this.isLeaf || !!this.spec.atom;
        }
        /**
        The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
        */
        get whitespace() {
          return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
        }
        /**
        Tells you whether this node type has any required attributes.
        */
        hasRequiredAttrs() {
          for (let n in this.attrs)
            if (this.attrs[n].isRequired)
              return true;
          return false;
        }
        /**
        Indicates whether this node allows some of the same content as
        the given node type.
        */
        compatibleContent(other) {
          return this == other || this.contentMatch.compatible(other.contentMatch);
        }
        /**
        @internal
        */
        computeAttrs(attrs) {
          if (!attrs && this.defaultAttrs)
            return this.defaultAttrs;
          else
            return computeAttrs(this.attrs, attrs);
        }
        /**
        Create a `Node` of this type. The given attributes are
        checked and defaulted (you can pass `null` to use the type's
        defaults entirely, if no required attributes exist). `content`
        may be a `Fragment`, a node, an array of nodes, or
        `null`. Similarly `marks` may be `null` to default to the empty
        set of marks.
        */
        create(attrs = null, content, marks) {
          if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
          return new Node2(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
        }
        /**
        Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
        against the node type's content restrictions, and throw an error
        if it doesn't match.
        */
        createChecked(attrs = null, content, marks) {
          content = Fragment.from(content);
          this.checkContent(content);
          return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
        }
        /**
        Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
        necessary to add nodes to the start or end of the given fragment
        to make it fit the node. If no fitting wrapping can be found,
        return null. Note that, due to the fact that required nodes can
        always be created, this will always succeed if you pass null or
        `Fragment.empty` as content.
        */
        createAndFill(attrs = null, content, marks) {
          attrs = this.computeAttrs(attrs);
          content = Fragment.from(content);
          if (content.size) {
            let before = this.contentMatch.fillBefore(content);
            if (!before)
              return null;
            content = before.append(content);
          }
          let matched = this.contentMatch.matchFragment(content);
          let after = matched && matched.fillBefore(Fragment.empty, true);
          if (!after)
            return null;
          return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
        }
        /**
        Returns true if the given fragment is valid content for this node
        type with the given attributes.
        */
        validContent(content) {
          let result = this.contentMatch.matchFragment(content);
          if (!result || !result.validEnd)
            return false;
          for (let i = 0; i < content.childCount; i++)
            if (!this.allowsMarks(content.child(i).marks))
              return false;
          return true;
        }
        /**
        Throws a RangeError if the given fragment is not valid content for this
        node type.
        @internal
        */
        checkContent(content) {
          if (!this.validContent(content))
            throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
        }
        /**
        Check whether the given mark type is allowed in this node.
        */
        allowsMarkType(markType) {
          return this.markSet == null || this.markSet.indexOf(markType) > -1;
        }
        /**
        Test whether the given set of marks are allowed in this node.
        */
        allowsMarks(marks) {
          if (this.markSet == null)
            return true;
          for (let i = 0; i < marks.length; i++)
            if (!this.allowsMarkType(marks[i].type))
              return false;
          return true;
        }
        /**
        Removes the marks that are not allowed in this node from the given set.
        */
        allowedMarks(marks) {
          if (this.markSet == null)
            return marks;
          let copy2;
          for (let i = 0; i < marks.length; i++) {
            if (!this.allowsMarkType(marks[i].type)) {
              if (!copy2)
                copy2 = marks.slice(0, i);
            } else if (copy2) {
              copy2.push(marks[i]);
            }
          }
          return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
        }
        /**
        @internal
        */
        static compile(nodes, schema) {
          let result = /* @__PURE__ */ Object.create(null);
          nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
          let topType = schema.spec.topNode || "doc";
          if (!result[topType])
            throw new RangeError("Schema is missing its top node type ('" + topType + "')");
          if (!result.text)
            throw new RangeError("Every schema needs a 'text' type");
          for (let _ in result.text.attrs)
            throw new RangeError("The text node type should not have attributes");
          return result;
        }
      };
      Attribute = class {
        constructor(options) {
          this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
          this.default = options.default;
        }
        get isRequired() {
          return !this.hasDefault;
        }
      };
      MarkType = class _MarkType {
        /**
        @internal
        */
        constructor(name, rank, schema, spec) {
          this.name = name;
          this.rank = rank;
          this.schema = schema;
          this.spec = spec;
          this.attrs = initAttrs(spec.attrs);
          this.excluded = null;
          let defaults4 = defaultAttrs(this.attrs);
          this.instance = defaults4 ? new Mark(this, defaults4) : null;
        }
        /**
        Create a mark of this type. `attrs` may be `null` or an object
        containing only some of the mark's attributes. The others, if
        they have defaults, will be added.
        */
        create(attrs = null) {
          if (!attrs && this.instance)
            return this.instance;
          return new Mark(this, computeAttrs(this.attrs, attrs));
        }
        /**
        @internal
        */
        static compile(marks, schema) {
          let result = /* @__PURE__ */ Object.create(null), rank = 0;
          marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
          return result;
        }
        /**
        When there is a mark of this type in the given set, a new set
        without it is returned. Otherwise, the input set is returned.
        */
        removeFromSet(set2) {
          for (var i = 0; i < set2.length; i++)
            if (set2[i].type == this) {
              set2 = set2.slice(0, i).concat(set2.slice(i + 1));
              i--;
            }
          return set2;
        }
        /**
        Tests whether there is a mark of this type in the given set.
        */
        isInSet(set2) {
          for (let i = 0; i < set2.length; i++)
            if (set2[i].type == this)
              return set2[i];
        }
        /**
        Queries whether a given mark type is
        [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
        */
        excludes(other) {
          return this.excluded.indexOf(other) > -1;
        }
      };
      Schema = class {
        /**
        Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
        */
        constructor(spec) {
          this.cached = /* @__PURE__ */ Object.create(null);
          let instanceSpec = this.spec = {};
          for (let prop in spec)
            instanceSpec[prop] = spec[prop];
          instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
          this.marks = MarkType.compile(this.spec.marks, this);
          let contentExprCache = /* @__PURE__ */ Object.create(null);
          for (let prop in this.nodes) {
            if (prop in this.marks)
              throw new RangeError(prop + " can not be both a node and a mark");
            let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
            type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
            type.inlineContent = type.contentMatch.inlineContent;
            type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
          }
          for (let prop in this.marks) {
            let type = this.marks[prop], excl = type.spec.excludes;
            type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
          }
          this.nodeFromJSON = this.nodeFromJSON.bind(this);
          this.markFromJSON = this.markFromJSON.bind(this);
          this.topNodeType = this.nodes[this.spec.topNode || "doc"];
          this.cached.wrappings = /* @__PURE__ */ Object.create(null);
        }
        /**
        Create a node in this schema. The `type` may be a string or a
        `NodeType` instance. Attributes will be extended with defaults,
        `content` may be a `Fragment`, `null`, a `Node`, or an array of
        nodes.
        */
        node(type, attrs = null, content, marks) {
          if (typeof type == "string")
            type = this.nodeType(type);
          else if (!(type instanceof NodeType))
            throw new RangeError("Invalid node type: " + type);
          else if (type.schema != this)
            throw new RangeError("Node type from different schema used (" + type.name + ")");
          return type.createChecked(attrs, content, marks);
        }
        /**
        Create a text node in the schema. Empty text nodes are not
        allowed.
        */
        text(text, marks) {
          let type = this.nodes.text;
          return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
        }
        /**
        Create a mark with the given type and attributes.
        */
        mark(type, attrs) {
          if (typeof type == "string")
            type = this.marks[type];
          return type.create(attrs);
        }
        /**
        Deserialize a node from its JSON representation. This method is
        bound.
        */
        nodeFromJSON(json2) {
          return Node2.fromJSON(this, json2);
        }
        /**
        Deserialize a mark from its JSON representation. This method is
        bound.
        */
        markFromJSON(json2) {
          return Mark.fromJSON(this, json2);
        }
        /**
        @internal
        */
        nodeType(name) {
          let found2 = this.nodes[name];
          if (!found2)
            throw new RangeError("Unknown node type: " + name);
          return found2;
        }
      };
      DOMParser2 = class _DOMParser {
        /**
        Create a parser that targets the given schema, using the given
        parsing rules.
        */
        constructor(schema, rules) {
          this.schema = schema;
          this.rules = rules;
          this.tags = [];
          this.styles = [];
          rules.forEach((rule) => {
            if (rule.tag)
              this.tags.push(rule);
            else if (rule.style)
              this.styles.push(rule);
          });
          this.normalizeLists = !this.tags.some((r) => {
            if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
              return false;
            let node = schema.nodes[r.node];
            return node.contentMatch.matchType(node);
          });
        }
        /**
        Parse a document from the content of a DOM node.
        */
        parse(dom, options = {}) {
          let context = new ParseContext(this, options, false);
          context.addAll(dom, options.from, options.to);
          return context.finish();
        }
        /**
        Parses the content of the given DOM node, like
        [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
        options. But unlike that method, which produces a whole node,
        this one returns a slice that is open at the sides, meaning that
        the schema constraints aren't applied to the start of nodes to
        the left of the input and the end of nodes at the end.
        */
        parseSlice(dom, options = {}) {
          let context = new ParseContext(this, options, true);
          context.addAll(dom, options.from, options.to);
          return Slice.maxOpen(context.finish());
        }
        /**
        @internal
        */
        matchTag(dom, context, after) {
          for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
            let rule = this.tags[i];
            if (matches2(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
              if (rule.getAttrs) {
                let result = rule.getAttrs(dom);
                if (result === false)
                  continue;
                rule.attrs = result || void 0;
              }
              return rule;
            }
          }
        }
        /**
        @internal
        */
        matchStyle(prop, value, context, after) {
          for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
            let rule = this.styles[i], style2 = rule.style;
            if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
            // or has an '=' sign after the prop, followed by the given
            // value.
            style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
              continue;
            if (rule.getAttrs) {
              let result = rule.getAttrs(value);
              if (result === false)
                continue;
              rule.attrs = result || void 0;
            }
            return rule;
          }
        }
        /**
        @internal
        */
        static schemaRules(schema) {
          let result = [];
          function insert(rule) {
            let priority = rule.priority == null ? 50 : rule.priority, i = 0;
            for (; i < result.length; i++) {
              let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
              if (nextPriority < priority)
                break;
            }
            result.splice(i, 0, rule);
          }
          for (let name in schema.marks) {
            let rules = schema.marks[name].spec.parseDOM;
            if (rules)
              rules.forEach((rule) => {
                insert(rule = copy(rule));
                if (!(rule.mark || rule.ignore || rule.clearMark))
                  rule.mark = name;
              });
          }
          for (let name in schema.nodes) {
            let rules = schema.nodes[name].spec.parseDOM;
            if (rules)
              rules.forEach((rule) => {
                insert(rule = copy(rule));
                if (!(rule.node || rule.ignore || rule.mark))
                  rule.node = name;
              });
          }
          return result;
        }
        /**
        Construct a DOM parser using the parsing rules listed in a
        schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
        [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
        */
        static fromSchema(schema) {
          return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
        }
      };
      blockTags = {
        address: true,
        article: true,
        aside: true,
        blockquote: true,
        canvas: true,
        dd: true,
        div: true,
        dl: true,
        fieldset: true,
        figcaption: true,
        figure: true,
        footer: true,
        form: true,
        h1: true,
        h2: true,
        h3: true,
        h4: true,
        h5: true,
        h6: true,
        header: true,
        hgroup: true,
        hr: true,
        li: true,
        noscript: true,
        ol: true,
        output: true,
        p: true,
        pre: true,
        section: true,
        table: true,
        tfoot: true,
        ul: true
      };
      ignoreTags = {
        head: true,
        noscript: true,
        object: true,
        script: true,
        style: true,
        title: true
      };
      listTags = { ol: true, ul: true };
      OPT_PRESERVE_WS = 1;
      OPT_PRESERVE_WS_FULL = 2;
      OPT_OPEN_LEFT = 4;
      NodeContext = class {
        constructor(type, attrs, marks, pendingMarks, solid, match, options) {
          this.type = type;
          this.attrs = attrs;
          this.marks = marks;
          this.pendingMarks = pendingMarks;
          this.solid = solid;
          this.options = options;
          this.content = [];
          this.activeMarks = Mark.none;
          this.stashMarks = [];
          this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
        }
        findWrapping(node) {
          if (!this.match) {
            if (!this.type)
              return [];
            let fill2 = this.type.contentMatch.fillBefore(Fragment.from(node));
            if (fill2) {
              this.match = this.type.contentMatch.matchFragment(fill2);
            } else {
              let start3 = this.type.contentMatch, wrap2;
              if (wrap2 = start3.findWrapping(node.type)) {
                this.match = start3;
                return wrap2;
              } else {
                return null;
              }
            }
          }
          return this.match.findWrapping(node.type);
        }
        finish(openEnd) {
          if (!(this.options & OPT_PRESERVE_WS)) {
            let last = this.content[this.content.length - 1], m;
            if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
              let text = last;
              if (last.text.length == m[0].length)
                this.content.pop();
              else
                this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
            }
          }
          let content = Fragment.from(this.content);
          if (!openEnd && this.match)
            content = content.append(this.match.fillBefore(Fragment.empty, true));
          return this.type ? this.type.create(this.attrs, content, this.marks) : content;
        }
        popFromStashMark(mark) {
          for (let i = this.stashMarks.length - 1; i >= 0; i--)
            if (mark.eq(this.stashMarks[i]))
              return this.stashMarks.splice(i, 1)[0];
        }
        applyPending(nextType) {
          for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
            let mark = pending[i];
            if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
              this.activeMarks = mark.addToSet(this.activeMarks);
              this.pendingMarks = mark.removeFromSet(this.pendingMarks);
            }
          }
        }
        inlineContext(node) {
          if (this.type)
            return this.type.inlineContent;
          if (this.content.length)
            return this.content[0].isInline;
          return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
        }
      };
      ParseContext = class {
        constructor(parser, options, isOpen) {
          this.parser = parser;
          this.options = options;
          this.isOpen = isOpen;
          this.open = 0;
          let topNode = options.topNode, topContext;
          let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
          if (topNode)
            topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
          else if (isOpen)
            topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
          else
            topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
          this.nodes = [topContext];
          this.find = options.findPositions;
          this.needsBlock = false;
        }
        get top() {
          return this.nodes[this.open];
        }
        // Add a DOM node to the content. Text is inserted as text node,
        // otherwise, the node is passed to `addElement` or, if it has a
        // `style` attribute, `addElementWithStyles`.
        addDOM(dom) {
          if (dom.nodeType == 3)
            this.addTextNode(dom);
          else if (dom.nodeType == 1)
            this.addElement(dom);
        }
        withStyleRules(dom, f) {
          let style2 = dom.getAttribute("style");
          if (!style2)
            return f();
          let marks = this.readStyles(parseStyles(style2));
          if (!marks)
            return;
          let [addMarks, removeMarks] = marks, top2 = this.top;
          for (let i = 0; i < removeMarks.length; i++)
            this.removePendingMark(removeMarks[i], top2);
          for (let i = 0; i < addMarks.length; i++)
            this.addPendingMark(addMarks[i]);
          f();
          for (let i = 0; i < addMarks.length; i++)
            this.removePendingMark(addMarks[i], top2);
          for (let i = 0; i < removeMarks.length; i++)
            this.addPendingMark(removeMarks[i]);
        }
        addTextNode(dom) {
          let value = dom.nodeValue;
          let top2 = this.top;
          if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
            if (!(top2.options & OPT_PRESERVE_WS)) {
              value = value.replace(/[ \t\r\n\u000c]+/g, " ");
              if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
                let nodeBefore = top2.content[top2.content.length - 1];
                let domNodeBefore = dom.previousSibling;
                if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
                  value = value.slice(1);
              }
            } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
              value = value.replace(/\r?\n|\r/g, " ");
            } else {
              value = value.replace(/\r\n?/g, "\n");
            }
            if (value)
              this.insertNode(this.parser.schema.text(value));
            this.findInText(dom);
          } else {
            this.findInside(dom);
          }
        }
        // Try to find a handler for the given tag and use that to parse. If
        // none is found, the element's content nodes are added directly.
        addElement(dom, matchAfter) {
          let name = dom.nodeName.toLowerCase(), ruleID;
          if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
            normalizeList(dom);
          let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
          if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
            this.findInside(dom);
            this.ignoreFallback(dom);
          } else if (!rule || rule.skip || rule.closeParent) {
            if (rule && rule.closeParent)
              this.open = Math.max(0, this.open - 1);
            else if (rule && rule.skip.nodeType)
              dom = rule.skip;
            let sync, top2 = this.top, oldNeedsBlock = this.needsBlock;
            if (blockTags.hasOwnProperty(name)) {
              if (top2.content.length && top2.content[0].isInline && this.open) {
                this.open--;
                top2 = this.top;
              }
              sync = true;
              if (!top2.type)
                this.needsBlock = true;
            } else if (!dom.firstChild) {
              this.leafFallback(dom);
              return;
            }
            if (rule && rule.skip)
              this.addAll(dom);
            else
              this.withStyleRules(dom, () => this.addAll(dom));
            if (sync)
              this.sync(top2);
            this.needsBlock = oldNeedsBlock;
          } else {
            this.withStyleRules(dom, () => {
              this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
            });
          }
        }
        // Called for leaf DOM nodes that would otherwise be ignored
        leafFallback(dom) {
          if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
            this.addTextNode(dom.ownerDocument.createTextNode("\n"));
        }
        // Called for ignored nodes
        ignoreFallback(dom) {
          if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
            this.findPlace(this.parser.schema.text("-"));
        }
        // Run any style parser associated with the node's styles. Either
        // return an array of marks, or null to indicate some of the styles
        // had a rule with `ignore` set.
        readStyles(styles) {
          let add2 = Mark.none, remove = Mark.none;
          for (let i = 0; i < styles.length; i += 2) {
            for (let after = void 0; ; ) {
              let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
              if (!rule)
                break;
              if (rule.ignore)
                return null;
              if (rule.clearMark) {
                this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
                  if (rule.clearMark(m))
                    remove = m.addToSet(remove);
                });
              } else {
                add2 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add2);
              }
              if (rule.consuming === false)
                after = rule;
              else
                break;
            }
          }
          return [add2, remove];
        }
        // Look up a handler for the given node. If none are found, return
        // false. Otherwise, apply it, use its return value to drive the way
        // the node's content is wrapped, and return true.
        addElementByRule(dom, rule, continueAfter) {
          let sync, nodeType, mark;
          if (rule.node) {
            nodeType = this.parser.schema.nodes[rule.node];
            if (!nodeType.isLeaf) {
              sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
            } else if (!this.insertNode(nodeType.create(rule.attrs))) {
              this.leafFallback(dom);
            }
          } else {
            let markType = this.parser.schema.marks[rule.mark];
            mark = markType.create(rule.attrs);
            this.addPendingMark(mark);
          }
          let startIn = this.top;
          if (nodeType && nodeType.isLeaf) {
            this.findInside(dom);
          } else if (continueAfter) {
            this.addElement(dom, continueAfter);
          } else if (rule.getContent) {
            this.findInside(dom);
            rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));
          } else {
            let contentDOM = dom;
            if (typeof rule.contentElement == "string")
              contentDOM = dom.querySelector(rule.contentElement);
            else if (typeof rule.contentElement == "function")
              contentDOM = rule.contentElement(dom);
            else if (rule.contentElement)
              contentDOM = rule.contentElement;
            this.findAround(dom, contentDOM, true);
            this.addAll(contentDOM);
          }
          if (sync && this.sync(startIn))
            this.open--;
          if (mark)
            this.removePendingMark(mark, startIn);
        }
        // Add all child nodes between `startIndex` and `endIndex` (or the
        // whole node, if not given). If `sync` is passed, use it to
        // synchronize after every block element.
        addAll(parent, startIndex, endIndex) {
          let index3 = startIndex || 0;
          for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index3) {
            this.findAtPoint(parent, index3);
            this.addDOM(dom);
          }
          this.findAtPoint(parent, index3);
        }
        // Try to find a way to fit the given node type into the current
        // context. May add intermediate wrappers and/or leave non-solid
        // nodes that we're in.
        findPlace(node) {
          let route, sync;
          for (let depth = this.open; depth >= 0; depth--) {
            let cx = this.nodes[depth];
            let found2 = cx.findWrapping(node);
            if (found2 && (!route || route.length > found2.length)) {
              route = found2;
              sync = cx;
              if (!found2.length)
                break;
            }
            if (cx.solid)
              break;
          }
          if (!route)
            return false;
          this.sync(sync);
          for (let i = 0; i < route.length; i++)
            this.enterInner(route[i], null, false);
          return true;
        }
        // Try to insert the given node, adjusting the context when needed.
        insertNode(node) {
          if (node.isInline && this.needsBlock && !this.top.type) {
            let block = this.textblockFromContext();
            if (block)
              this.enterInner(block);
          }
          if (this.findPlace(node)) {
            this.closeExtra();
            let top2 = this.top;
            top2.applyPending(node.type);
            if (top2.match)
              top2.match = top2.match.matchType(node.type);
            let marks = top2.activeMarks;
            for (let i = 0; i < node.marks.length; i++)
              if (!top2.type || top2.type.allowsMarkType(node.marks[i].type))
                marks = node.marks[i].addToSet(marks);
            top2.content.push(node.mark(marks));
            return true;
          }
          return false;
        }
        // Try to start a node of the given type, adjusting the context when
        // necessary.
        enter(type, attrs, preserveWS) {
          let ok = this.findPlace(type.create(attrs));
          if (ok)
            this.enterInner(type, attrs, true, preserveWS);
          return ok;
        }
        // Open a node of the given type
        enterInner(type, attrs = null, solid = false, preserveWS) {
          this.closeExtra();
          let top2 = this.top;
          top2.applyPending(type);
          top2.match = top2.match && top2.match.matchType(type);
          let options = wsOptionsFor(type, preserveWS, top2.options);
          if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
            options |= OPT_OPEN_LEFT;
          this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
          this.open++;
        }
        // Make sure all nodes above this.open are finished and added to
        // their parents
        closeExtra(openEnd = false) {
          let i = this.nodes.length - 1;
          if (i > this.open) {
            for (; i > this.open; i--)
              this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
            this.nodes.length = this.open + 1;
          }
        }
        finish() {
          this.open = 0;
          this.closeExtra(this.isOpen);
          return this.nodes[0].finish(this.isOpen || this.options.topOpen);
        }
        sync(to2) {
          for (let i = this.open; i >= 0; i--)
            if (this.nodes[i] == to2) {
              this.open = i;
              return true;
            }
          return false;
        }
        get currentPos() {
          this.closeExtra();
          let pos = 0;
          for (let i = this.open; i >= 0; i--) {
            let content = this.nodes[i].content;
            for (let j = content.length - 1; j >= 0; j--)
              pos += content[j].nodeSize;
            if (i)
              pos++;
          }
          return pos;
        }
        findAtPoint(parent, offset2) {
          if (this.find)
            for (let i = 0; i < this.find.length; i++) {
              if (this.find[i].node == parent && this.find[i].offset == offset2)
                this.find[i].pos = this.currentPos;
            }
        }
        findInside(parent) {
          if (this.find)
            for (let i = 0; i < this.find.length; i++) {
              if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
                this.find[i].pos = this.currentPos;
            }
        }
        findAround(parent, content, before) {
          if (parent != content && this.find)
            for (let i = 0; i < this.find.length; i++) {
              if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
                let pos = content.compareDocumentPosition(this.find[i].node);
                if (pos & (before ? 2 : 4))
                  this.find[i].pos = this.currentPos;
              }
            }
        }
        findInText(textNode) {
          if (this.find)
            for (let i = 0; i < this.find.length; i++) {
              if (this.find[i].node == textNode)
                this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
            }
        }
        // Determines whether the given context string matches this context.
        matchesContext(context) {
          if (context.indexOf("|") > -1)
            return context.split(/\s*\|\s*/).some(this.matchesContext, this);
          let parts = context.split("/");
          let option2 = this.options.context;
          let useRoot = !this.isOpen && (!option2 || option2.parent.type == this.nodes[0].type);
          let minDepth = -(option2 ? option2.depth + 1 : 0) + (useRoot ? 0 : 1);
          let match = (i, depth) => {
            for (; i >= 0; i--) {
              let part = parts[i];
              if (part == "") {
                if (i == parts.length - 1 || i == 0)
                  continue;
                for (; depth >= minDepth; depth--)
                  if (match(i - 1, depth))
                    return true;
                return false;
              } else {
                let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option2 && depth >= minDepth ? option2.node(depth - minDepth).type : null;
                if (!next || next.name != part && next.groups.indexOf(part) == -1)
                  return false;
                depth--;
              }
            }
            return true;
          };
          return match(parts.length - 1, this.open);
        }
        textblockFromContext() {
          let $context = this.options.context;
          if ($context)
            for (let d = $context.depth; d >= 0; d--) {
              let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
              if (deflt && deflt.isTextblock && deflt.defaultAttrs)
                return deflt;
            }
          for (let name in this.parser.schema.nodes) {
            let type = this.parser.schema.nodes[name];
            if (type.isTextblock && type.defaultAttrs)
              return type;
          }
        }
        addPendingMark(mark) {
          let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
          if (found2)
            this.top.stashMarks.push(found2);
          this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
        }
        removePendingMark(mark, upto) {
          for (let depth = this.open; depth >= 0; depth--) {
            let level = this.nodes[depth];
            let found2 = level.pendingMarks.lastIndexOf(mark);
            if (found2 > -1) {
              level.pendingMarks = mark.removeFromSet(level.pendingMarks);
            } else {
              level.activeMarks = mark.removeFromSet(level.activeMarks);
              let stashMark = level.popFromStashMark(mark);
              if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
                level.activeMarks = stashMark.addToSet(level.activeMarks);
            }
            if (level == upto)
              break;
          }
        }
      };
      DOMSerializer = class _DOMSerializer {
        /**
        Create a serializer. `nodes` should map node names to functions
        that take a node and return a description of the corresponding
        DOM. `marks` does the same for mark names, but also gets an
        argument that tells it whether the mark's content is block or
        inline content (for typical use, it'll always be inline). A mark
        serializer may be `null` to indicate that marks of that type
        should not be serialized.
        */
        constructor(nodes, marks) {
          this.nodes = nodes;
          this.marks = marks;
        }
        /**
        Serialize the content of this fragment to a DOM fragment. When
        not in the browser, the `document` option, containing a DOM
        document, should be passed so that the serializer can create
        nodes.
        */
        serializeFragment(fragment, options = {}, target) {
          if (!target)
            target = doc(options).createDocumentFragment();
          let top2 = target, active = [];
          fragment.forEach((node) => {
            if (active.length || node.marks.length) {
              let keep = 0, rendered = 0;
              while (keep < active.length && rendered < node.marks.length) {
                let next = node.marks[rendered];
                if (!this.marks[next.type.name]) {
                  rendered++;
                  continue;
                }
                if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
                  break;
                keep++;
                rendered++;
              }
              while (keep < active.length)
                top2 = active.pop()[1];
              while (rendered < node.marks.length) {
                let add2 = node.marks[rendered++];
                let markDOM = this.serializeMark(add2, node.isInline, options);
                if (markDOM) {
                  active.push([add2, top2]);
                  top2.appendChild(markDOM.dom);
                  top2 = markDOM.contentDOM || markDOM.dom;
                }
              }
            }
            top2.appendChild(this.serializeNodeInner(node, options));
          });
          return target;
        }
        /**
        @internal
        */
        serializeNodeInner(node, options) {
          let { dom, contentDOM } = _DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
          if (contentDOM) {
            if (node.isLeaf)
              throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(node.content, options, contentDOM);
          }
          return dom;
        }
        /**
        Serialize this node to a DOM node. This can be useful when you
        need to serialize a part of a document, as opposed to the whole
        document. To serialize a whole document, use
        [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
        its [content](https://prosemirror.net/docs/ref/#model.Node.content).
        */
        serializeNode(node, options = {}) {
          let dom = this.serializeNodeInner(node, options);
          for (let i = node.marks.length - 1; i >= 0; i--) {
            let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
            if (wrap2) {
              (wrap2.contentDOM || wrap2.dom).appendChild(dom);
              dom = wrap2.dom;
            }
          }
          return dom;
        }
        /**
        @internal
        */
        serializeMark(mark, inline, options = {}) {
          let toDOM = this.marks[mark.type.name];
          return toDOM && _DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
        }
        /**
        Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
        the spec has a hole (zero) in it, `contentDOM` will point at the
        node with the hole.
        */
        static renderSpec(doc3, structure, xmlNS = null) {
          if (typeof structure == "string")
            return { dom: doc3.createTextNode(structure) };
          if (structure.nodeType != null)
            return { dom: structure };
          if (structure.dom && structure.dom.nodeType != null)
            return structure;
          let tagName = structure[0], space = tagName.indexOf(" ");
          if (space > 0) {
            xmlNS = tagName.slice(0, space);
            tagName = tagName.slice(space + 1);
          }
          let contentDOM;
          let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
          let attrs = structure[1], start3 = 1;
          if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
            start3 = 2;
            for (let name in attrs)
              if (attrs[name] != null) {
                let space2 = name.indexOf(" ");
                if (space2 > 0)
                  dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
                else
                  dom.setAttribute(name, attrs[name]);
              }
          }
          for (let i = start3; i < structure.length; i++) {
            let child = structure[i];
            if (child === 0) {
              if (i < structure.length - 1 || i > start3)
                throw new RangeError("Content hole must be the only child of its parent node");
              return { dom, contentDOM: dom };
            } else {
              let { dom: inner, contentDOM: innerContent } = _DOMSerializer.renderSpec(doc3, child, xmlNS);
              dom.appendChild(inner);
              if (innerContent) {
                if (contentDOM)
                  throw new RangeError("Multiple content holes");
                contentDOM = innerContent;
              }
            }
          }
          return { dom, contentDOM };
        }
        /**
        Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
        properties in a schema's node and mark specs.
        */
        static fromSchema(schema) {
          return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
        }
        /**
        Gather the serializers in a schema's node specs into an object.
        This can be useful as a base to build a custom serializer from.
        */
        static nodesFromSchema(schema) {
          let result = gatherToDOM(schema.nodes);
          if (!result.text)
            result.text = (node) => node.text;
          return result;
        }
        /**
        Gather the serializers in a schema's mark specs into an object.
        */
        static marksFromSchema(schema) {
          return gatherToDOM(schema.marks);
        }
      };
    }
  });

  // node_modules/prosemirror-transform/dist/index.js
  function makeRecover(index3, offset2) {
    return index3 + offset2 * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  function mapFragment(fragment, f, parent) {
    let mapped = [];
    for (let i = 0; i < fragment.childCount; i++) {
      let child = fragment.child(i);
      if (child.content.size)
        child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline)
        child = f(child, parent, i);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  function contentBetween(doc3, from3, to2) {
    let $from = doc3.resolve(from3), dist = to2 - from3, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      let next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf)
          return true;
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function addMark(tr2, from3, to2, mark) {
    let removed = [], added = [];
    let removing, adding;
    tr2.doc.nodesBetween(from3, to2, (node, pos, parent) => {
      if (!node.isInline)
        return;
      let marks = node.marks;
      if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
        let start3 = Math.max(pos, from3), end2 = Math.min(pos + node.nodeSize, to2);
        let newSet = mark.addToSet(marks);
        for (let i = 0; i < marks.length; i++) {
          if (!marks[i].isInSet(newSet)) {
            if (removing && removing.to == start3 && removing.mark.eq(marks[i]))
              removing.to = end2;
            else
              removed.push(removing = new RemoveMarkStep(start3, end2, marks[i]));
          }
        }
        if (adding && adding.to == start3)
          adding.to = end2;
        else
          added.push(adding = new AddMarkStep(start3, end2, mark));
      }
    });
    removed.forEach((s) => tr2.step(s));
    added.forEach((s) => tr2.step(s));
  }
  function removeMark(tr2, from3, to2, mark) {
    let matched = [], step = 0;
    tr2.doc.nodesBetween(from3, to2, (node, pos) => {
      if (!node.isInline)
        return;
      step++;
      let toRemove = null;
      if (mark instanceof MarkType) {
        let set2 = node.marks, found2;
        while (found2 = mark.isInSet(set2)) {
          (toRemove || (toRemove = [])).push(found2);
          set2 = found2.removeFromSet(set2);
        }
      } else if (mark) {
        if (mark.isInSet(node.marks))
          toRemove = [mark];
      } else {
        toRemove = node.marks;
      }
      if (toRemove && toRemove.length) {
        let end2 = Math.min(pos + node.nodeSize, to2);
        for (let i = 0; i < toRemove.length; i++) {
          let style2 = toRemove[i], found2;
          for (let j = 0; j < matched.length; j++) {
            let m = matched[j];
            if (m.step == step - 1 && style2.eq(matched[j].style))
              found2 = m;
          }
          if (found2) {
            found2.to = end2;
            found2.step = step;
          } else {
            matched.push({ style: style2, from: Math.max(pos, from3), to: end2, step });
          }
        }
      }
    });
    matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
  }
  function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch) {
    let node = tr2.doc.nodeAt(pos);
    let replSteps = [], cur = pos + 1;
    for (let i = 0; i < node.childCount; i++) {
      let child = node.child(i), end2 = cur + child.nodeSize;
      let allowed = match.matchType(child.type);
      if (!allowed) {
        replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
      } else {
        match = allowed;
        for (let j = 0; j < child.marks.length; j++)
          if (!parentType.allowsMarkType(child.marks[j].type))
            tr2.step(new RemoveMarkStep(cur, end2, child.marks[j]));
        if (child.isText && !parentType.spec.code) {
          let m, newline = /\r?\n|\r/g, slice2;
          while (m = newline.exec(child.text)) {
            if (!slice2)
              slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
            replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
          }
        }
      }
      cur = end2;
    }
    if (!match.validEnd) {
      let fill2 = match.fillBefore(Fragment.empty, true);
      tr2.replace(cur, cur, new Slice(fill2, 0, 0));
    }
    for (let i = replSteps.length - 1; i >= 0; i--)
      tr2.step(replSteps[i]);
  }
  function canCut(node, start3, end2) {
    return (start3 == 0 || node.canReplace(start3, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
  }
  function liftTarget(range) {
    let parent = range.parent;
    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth; ; --depth) {
      let node = range.$from.node(depth);
      let index3 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node.canReplace(index3, endIndex, content))
        return depth;
      if (depth == 0 || node.type.spec.isolating || !canCut(node, index3, endIndex))
        break;
    }
    return null;
  }
  function lift(tr2, range, target) {
    let { $from, $to, depth } = range;
    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    let start3 = gapStart, end2 = gapEnd;
    let before = Fragment.empty, openStart = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $from.index(d) > 0) {
        splitting = true;
        before = Fragment.from($from.node(d).copy(before));
        openStart++;
      } else {
        start3--;
      }
    let after = Fragment.empty, openEnd = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $to.after(d + 1) < $to.end(d)) {
        splitting = true;
        after = Fragment.from($to.node(d).copy(after));
        openEnd++;
      } else {
        end2++;
      }
    tr2.step(new ReplaceAroundStep(start3, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
  }
  function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around = findWrappingOutside(range, nodeType);
    let inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner)
      return null;
    return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around)
      return null;
    let outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside)
      return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i = startIndex; innerMatch && i < endIndex; i++)
      innerMatch = innerMatch.matchType(parent.child(i).type);
    if (!innerMatch || !innerMatch.validEnd)
      return null;
    return inside;
  }
  function wrap(tr2, range, wrappers) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--) {
      if (content.size) {
        let match = wrappers[i].type.contentMatch.matchFragment(content);
        if (!match || !match.validEnd)
          throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    }
    let start3 = range.start, end2 = range.end;
    tr2.step(new ReplaceAroundStep(start3, end2, start3, end2, new Slice(content, 0, 0), wrappers.length, true));
  }
  function setBlockType(tr2, from3, to2, type, attrs) {
    if (!type.isTextblock)
      throw new RangeError("Type given to setBlockType should be a textblock");
    let mapFrom = tr2.steps.length;
    tr2.doc.nodesBetween(from3, to2, (node, pos) => {
      if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
        tr2.clearIncompatible(tr2.mapping.slice(mapFrom).map(pos, 1), type);
        let mapping = tr2.mapping.slice(mapFrom);
        let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
        tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
        return false;
      }
    });
  }
  function canChangeType(doc3, pos, type) {
    let $pos = doc3.resolve(pos), index3 = $pos.index();
    return $pos.parent.canReplaceWith(index3, index3 + 1, type);
  }
  function setNodeMarkup(tr2, pos, type, attrs, marks) {
    let node = tr2.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at given position");
    if (!type)
      type = node.type;
    let newNode2 = type.create(attrs, null, marks || node.marks);
    if (node.isLeaf)
      return tr2.replaceWith(pos, pos + node.nodeSize, newNode2);
    if (!type.validContent(node.content))
      throw new RangeError("Invalid content for node type " + type.name);
    tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode2), 0, 0), 1, true));
  }
  function canSplit(doc3, pos, depth = 1, typesAfter) {
    let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
      return false;
    for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
      let node = $pos.node(d), index4 = $pos.index(d);
      if (node.type.spec.isolating)
        return false;
      let rest = node.content.cutByIndex(index4, node.childCount);
      let overrideChild = typesAfter && typesAfter[i + 1];
      if (overrideChild)
        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
      let after = typesAfter && typesAfter[i] || node;
      if (!node.canReplace(index4 + 1, node.childCount) || !after.type.validContent(rest))
        return false;
    }
    let index3 = $pos.indexAfter(base2);
    let baseType = typesAfter && typesAfter[0];
    return $pos.node(base2).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base2 + 1).type);
  }
  function split(tr2, pos, depth = 1, typesAfter) {
    let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
      before = Fragment.from($pos.node(d).copy(before));
      let typeAfter = typesAfter && typesAfter[i];
      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
    }
    tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
  }
  function canJoin(doc3, pos) {
    let $pos = doc3.resolve(pos), index3 = $pos.index();
    return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
  }
  function joinable2(a, b) {
    return !!(a && b && !a.isLeaf && a.canAppend(b));
  }
  function joinPoint(doc3, pos, dir = -1) {
    let $pos = doc3.resolve(pos);
    for (let d = $pos.depth; ; d--) {
      let before, after, index3 = $pos.index(d);
      if (d == $pos.depth) {
        before = $pos.nodeBefore;
        after = $pos.nodeAfter;
      } else if (dir > 0) {
        before = $pos.node(d + 1);
        index3++;
        after = $pos.node(d).maybeChild(index3);
      } else {
        before = $pos.node(d).maybeChild(index3 - 1);
        after = $pos.node(d + 1);
      }
      if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index3, index3 + 1))
        return pos;
      if (d == 0)
        break;
      pos = dir < 0 ? $pos.before(d) : $pos.after(d);
    }
  }
  function join(tr2, pos, depth) {
    let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
    tr2.step(step);
  }
  function insertPoint(doc3, pos, nodeType) {
    let $pos = doc3.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
      return pos;
    if ($pos.parentOffset == 0)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index3 = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index3, index3, nodeType))
          return $pos.before(d + 1);
        if (index3 > 0)
          return null;
      }
    if ($pos.parentOffset == $pos.parent.content.size)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index3 = $pos.indexAfter(d);
        if ($pos.node(d).canReplaceWith(index3, index3, nodeType))
          return $pos.after(d + 1);
        if (index3 < $pos.node(d).childCount)
          return null;
      }
    return null;
  }
  function dropPoint(doc3, pos, slice2) {
    let $pos = doc3.resolve(pos);
    if (!slice2.content.size)
      return pos;
    let content = slice2.content;
    for (let i = 0; i < slice2.openStart; i++)
      content = content.firstChild.content;
    for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
      for (let d = $pos.depth; d >= 0; d--) {
        let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
        let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
        let parent = $pos.node(d), fits = false;
        if (pass == 1) {
          fits = parent.canReplace(insertPos, insertPos, content);
        } else {
          let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
        }
        if (fits)
          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
    return null;
  }
  function replaceStep(doc3, from3, to2 = from3, slice2 = Slice.empty) {
    if (from3 == to2 && !slice2.size)
      return null;
    let $from = doc3.resolve(from3), $to = doc3.resolve(to2);
    if (fitsTrivially($from, $to, slice2))
      return new ReplaceStep(from3, to2, slice2);
    return new Fitter($from, $to, slice2).fit();
  }
  function fitsTrivially($from, $to, slice2) {
    return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
  }
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0)
      return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment, depth, content) {
    if (depth == 0)
      return fragment.append(content);
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
  }
  function contentAt(fragment, depth) {
    for (let i = 0; i < depth; i++)
      fragment = fragment.firstChild.content;
    return fragment;
  }
  function closeNodeStart(node, openStart, openEnd) {
    if (openStart <= 0)
      return node;
    let frag = node.content;
    if (openStart > 1)
      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
      frag = node.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0)
        frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    let node = $to.node(depth), index3 = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index3 == node.childCount && !type.compatibleContent(node.type))
      return null;
    let fit = match.fillBefore(node.content, true, index3);
    return fit && !invalidMarks(type, node.content, index3) ? fit : null;
  }
  function invalidMarks(type, fragment, start3) {
    for (let i = start3; i < fragment.childCount; i++)
      if (!type.allowsMarks(fragment.child(i).marks))
        return true;
    return false;
  }
  function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
  }
  function replaceRange(tr2, from3, to2, slice2) {
    if (!slice2.size)
      return tr2.deleteRange(from3, to2);
    let $from = tr2.doc.resolve(from3), $to = tr2.doc.resolve(to2);
    if (fitsTrivially($from, $to, slice2))
      return tr2.step(new ReplaceStep(from3, to2, slice2));
    let targetDepths = coveredDepths($from, tr2.doc.resolve(to2));
    if (targetDepths[targetDepths.length - 1] == 0)
      targetDepths.pop();
    let preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      let spec = $from.node(d).type.spec;
      if (spec.defining || spec.definingAsContext || spec.isolating)
        break;
      if (targetDepths.indexOf(d) > -1)
        preferredTarget = d;
      else if ($from.before(d) == pos)
        targetDepths.splice(1, 0, -d);
    }
    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    let leftNodes = [], preferredDepth = slice2.openStart;
    for (let content = slice2.content, i = 0; ; i++) {
      let node = content.firstChild;
      leftNodes.push(node);
      if (i == slice2.openStart)
        break;
      content = node.content;
    }
    for (let d = preferredDepth - 1; d >= 0; d--) {
      let leftNode = leftNodes[d], def = definesContent(leftNode.type);
      if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
        preferredDepth = d;
      else if (def || !leftNode.type.isTextblock)
        break;
    }
    for (let j = slice2.openStart; j >= 0; j--) {
      let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
      let insert = leftNodes[openDepth];
      if (!insert)
        continue;
      for (let i = 0; i < targetDepths.length; i++) {
        let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        let parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index3, index3, insert.type, insert.marks))
          return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to2, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
      }
    }
    let startSteps = tr2.steps.length;
    for (let i = targetDepths.length - 1; i >= 0; i--) {
      tr2.replace(from3, to2, slice2);
      if (tr2.steps.length > startSteps)
        break;
      let depth = targetDepths[i];
      if (depth < 0)
        continue;
      from3 = $from.before(depth);
      to2 = $to.after(depth);
    }
  }
  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      let first2 = fragment.firstChild;
      fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
    }
    if (depth > newOpen) {
      let match = parent.contentMatchAt(0);
      let start3 = match.fillBefore(fragment).append(fragment);
      fragment = start3.append(match.matchFragment(start3).fillBefore(Fragment.empty, true));
    }
    return fragment;
  }
  function replaceRangeWith(tr2, from3, to2, node) {
    if (!node.isInline && from3 == to2 && tr2.doc.resolve(from3).parent.content.size) {
      let point = insertPoint(tr2.doc, from3, node.type);
      if (point != null)
        from3 = to2 = point;
    }
    tr2.replaceRange(from3, to2, new Slice(Fragment.from(node), 0, 0));
  }
  function deleteRange(tr2, from3, to2) {
    let $from = tr2.doc.resolve(from3), $to = tr2.doc.resolve(to2);
    let covered = coveredDepths($from, $to);
    for (let i = 0; i < covered.length; i++) {
      let depth = covered[i], last = i == covered.length - 1;
      if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
        return tr2.delete($from.start(depth), $to.end(depth));
      if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
        return tr2.delete($from.before(depth), $to.after(depth));
    }
    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from3 - $from.start(d) == $from.depth - d && to2 > $from.end(d) && $to.end(d) - to2 != $to.depth - d)
        return tr2.delete($from.before(d), to2);
    }
    tr2.delete(from3, to2);
  }
  function coveredDepths($from, $to) {
    let result = [], minDepth = Math.min($from.depth, $to.depth);
    for (let d = minDepth; d >= 0; d--) {
      let start3 = $from.start(d);
      if (start3 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
        break;
      if (start3 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start3 - 1)
        result.push(d);
    }
    return result;
  }
  var lower16, factor16, DEL_BEFORE, DEL_AFTER, DEL_ACROSS, DEL_SIDE, MapResult, StepMap, Mapping, stepsByID, Step, StepResult, AddMarkStep, RemoveMarkStep, AddNodeMarkStep, RemoveNodeMarkStep, ReplaceStep, ReplaceAroundStep, Fitter, AttrStep, DocAttrStep, TransformError, Transform;
  var init_dist3 = __esm({
    "node_modules/prosemirror-transform/dist/index.js"() {
      init_dist2();
      lower16 = 65535;
      factor16 = Math.pow(2, 16);
      DEL_BEFORE = 1;
      DEL_AFTER = 2;
      DEL_ACROSS = 4;
      DEL_SIDE = 8;
      MapResult = class {
        /**
        @internal
        */
        constructor(pos, delInfo, recover) {
          this.pos = pos;
          this.delInfo = delInfo;
          this.recover = recover;
        }
        /**
        Tells you whether the position was deleted, that is, whether the
        step removed the token on the side queried (via the `assoc`)
        argument from the document.
        */
        get deleted() {
          return (this.delInfo & DEL_SIDE) > 0;
        }
        /**
        Tells you whether the token before the mapped position was deleted.
        */
        get deletedBefore() {
          return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
        }
        /**
        True when the token after the mapped position was deleted.
        */
        get deletedAfter() {
          return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
        }
        /**
        Tells whether any of the steps mapped through deletes across the
        position (including both the token before and after the
        position).
        */
        get deletedAcross() {
          return (this.delInfo & DEL_ACROSS) > 0;
        }
      };
      StepMap = class _StepMap {
        /**
        Create a position map. The modifications to the document are
        represented as an array of numbers, in which each group of three
        represents a modified chunk as `[start, oldSize, newSize]`.
        */
        constructor(ranges, inverted = false) {
          this.ranges = ranges;
          this.inverted = inverted;
          if (!ranges.length && _StepMap.empty)
            return _StepMap.empty;
        }
        /**
        @internal
        */
        recover(value) {
          let diff = 0, index3 = recoverIndex(value);
          if (!this.inverted)
            for (let i = 0; i < index3; i++)
              diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
          return this.ranges[index3 * 3] + diff + recoverOffset(value);
        }
        mapResult(pos, assoc = 1) {
          return this._map(pos, assoc, false);
        }
        map(pos, assoc = 1) {
          return this._map(pos, assoc, true);
        }
        /**
        @internal
        */
        _map(pos, assoc, simple) {
          let diff = 0, oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
          for (let i = 0; i < this.ranges.length; i += 3) {
            let start3 = this.ranges[i] - (this.inverted ? diff : 0);
            if (start3 > pos)
              break;
            let oldSize = this.ranges[i + oldIndex2], newSize = this.ranges[i + newIndex2], end2 = start3 + oldSize;
            if (pos <= end2) {
              let side = !oldSize ? assoc : pos == start3 ? -1 : pos == end2 ? 1 : assoc;
              let result = start3 + diff + (side < 0 ? 0 : newSize);
              if (simple)
                return result;
              let recover = pos == (assoc < 0 ? start3 : end2) ? null : makeRecover(i / 3, pos - start3);
              let del3 = pos == start3 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
              if (assoc < 0 ? pos != start3 : pos != end2)
                del3 |= DEL_SIDE;
              return new MapResult(result, del3, recover);
            }
            diff += newSize - oldSize;
          }
          return simple ? pos + diff : new MapResult(pos + diff, 0, null);
        }
        /**
        @internal
        */
        touches(pos, recover) {
          let diff = 0, index3 = recoverIndex(recover);
          let oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
          for (let i = 0; i < this.ranges.length; i += 3) {
            let start3 = this.ranges[i] - (this.inverted ? diff : 0);
            if (start3 > pos)
              break;
            let oldSize = this.ranges[i + oldIndex2], end2 = start3 + oldSize;
            if (pos <= end2 && i == index3 * 3)
              return true;
            diff += this.ranges[i + newIndex2] - oldSize;
          }
          return false;
        }
        /**
        Calls the given function on each of the changed ranges included in
        this map.
        */
        forEach(f) {
          let oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
          for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
            let start3 = this.ranges[i], oldStart = start3 - (this.inverted ? diff : 0), newStart = start3 + (this.inverted ? 0 : diff);
            let oldSize = this.ranges[i + oldIndex2], newSize = this.ranges[i + newIndex2];
            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
            diff += newSize - oldSize;
          }
        }
        /**
        Create an inverted version of this map. The result can be used to
        map positions in the post-step document to the pre-step document.
        */
        invert() {
          return new _StepMap(this.ranges, !this.inverted);
        }
        /**
        @internal
        */
        toString() {
          return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
        }
        /**
        Create a map that moves all positions by offset `n` (which may be
        negative). This can be useful when applying steps meant for a
        sub-document to a larger document, or vice-versa.
        */
        static offset(n) {
          return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
        }
      };
      StepMap.empty = new StepMap([]);
      Mapping = class _Mapping {
        /**
        Create a new mapping with the given position maps.
        */
        constructor(maps = [], mirror, from3 = 0, to2 = maps.length) {
          this.maps = maps;
          this.mirror = mirror;
          this.from = from3;
          this.to = to2;
        }
        /**
        Create a mapping that maps only through a part of this one.
        */
        slice(from3 = 0, to2 = this.maps.length) {
          return new _Mapping(this.maps, this.mirror, from3, to2);
        }
        /**
        @internal
        */
        copy() {
          return new _Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
        }
        /**
        Add a step map to the end of this mapping. If `mirrors` is
        given, it should be the index of the step map that is the mirror
        image of this one.
        */
        appendMap(map4, mirrors) {
          this.to = this.maps.push(map4);
          if (mirrors != null)
            this.setMirror(this.maps.length - 1, mirrors);
        }
        /**
        Add all the step maps in a given mapping to this one (preserving
        mirroring information).
        */
        appendMapping(mapping) {
          for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
            let mirr = mapping.getMirror(i);
            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
          }
        }
        /**
        Finds the offset of the step map that mirrors the map at the
        given offset, in this mapping (as per the second argument to
        `appendMap`).
        */
        getMirror(n) {
          if (this.mirror) {
            for (let i = 0; i < this.mirror.length; i++)
              if (this.mirror[i] == n)
                return this.mirror[i + (i % 2 ? -1 : 1)];
          }
        }
        /**
        @internal
        */
        setMirror(n, m) {
          if (!this.mirror)
            this.mirror = [];
          this.mirror.push(n, m);
        }
        /**
        Append the inverse of the given mapping to this one.
        */
        appendMappingInverted(mapping) {
          for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
            let mirr = mapping.getMirror(i);
            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
          }
        }
        /**
        Create an inverted version of this mapping.
        */
        invert() {
          let inverse = new _Mapping();
          inverse.appendMappingInverted(this);
          return inverse;
        }
        /**
        Map a position through this mapping.
        */
        map(pos, assoc = 1) {
          if (this.mirror)
            return this._map(pos, assoc, true);
          for (let i = this.from; i < this.to; i++)
            pos = this.maps[i].map(pos, assoc);
          return pos;
        }
        /**
        Map a position through this mapping, returning a mapping
        result.
        */
        mapResult(pos, assoc = 1) {
          return this._map(pos, assoc, false);
        }
        /**
        @internal
        */
        _map(pos, assoc, simple) {
          let delInfo = 0;
          for (let i = this.from; i < this.to; i++) {
            let map4 = this.maps[i], result = map4.mapResult(pos, assoc);
            if (result.recover != null) {
              let corr = this.getMirror(i);
              if (corr != null && corr > i && corr < this.to) {
                i = corr;
                pos = this.maps[corr].recover(result.recover);
                continue;
              }
            }
            delInfo |= result.delInfo;
            pos = result.pos;
          }
          return simple ? pos : new MapResult(pos, delInfo, null);
        }
      };
      stepsByID = /* @__PURE__ */ Object.create(null);
      Step = class {
        /**
        Get the step map that represents the changes made by this step,
        and which can be used to transform between positions in the old
        and the new document.
        */
        getMap() {
          return StepMap.empty;
        }
        /**
        Try to merge this step with another one, to be applied directly
        after it. Returns the merged step when possible, null if the
        steps can't be merged.
        */
        merge(other) {
          return null;
        }
        /**
        Deserialize a step from its JSON representation. Will call
        through to the step class' own implementation of this method.
        */
        static fromJSON(schema, json2) {
          if (!json2 || !json2.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
          let type = stepsByID[json2.stepType];
          if (!type)
            throw new RangeError(`No step type ${json2.stepType} defined`);
          return type.fromJSON(schema, json2);
        }
        /**
        To be able to serialize steps to JSON, each step needs a string
        ID to attach to its JSON representation. Use this method to
        register an ID for your step classes. Try to pick something
        that's unlikely to clash with steps from other modules.
        */
        static jsonID(id, stepClass) {
          if (id in stepsByID)
            throw new RangeError("Duplicate use of step JSON ID " + id);
          stepsByID[id] = stepClass;
          stepClass.prototype.jsonID = id;
          return stepClass;
        }
      };
      StepResult = class _StepResult {
        /**
        @internal
        */
        constructor(doc3, failed) {
          this.doc = doc3;
          this.failed = failed;
        }
        /**
        Create a successful step result.
        */
        static ok(doc3) {
          return new _StepResult(doc3, null);
        }
        /**
        Create a failed step result.
        */
        static fail(message) {
          return new _StepResult(null, message);
        }
        /**
        Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
        arguments. Create a successful result if it succeeds, and a
        failed one if it throws a `ReplaceError`.
        */
        static fromReplace(doc3, from3, to2, slice2) {
          try {
            return _StepResult.ok(doc3.replace(from3, to2, slice2));
          } catch (e) {
            if (e instanceof ReplaceError)
              return _StepResult.fail(e.message);
            throw e;
          }
        }
      };
      AddMarkStep = class _AddMarkStep extends Step {
        /**
        Create a mark step.
        */
        constructor(from3, to2, mark) {
          super();
          this.from = from3;
          this.to = to2;
          this.mark = mark;
        }
        apply(doc3) {
          let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
          let parent = $from.node($from.sharedDepth(this.to));
          let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
            if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
              return node;
            return node.mark(this.mark.addToSet(node.marks));
          }, parent), oldSlice.openStart, oldSlice.openEnd);
          return StepResult.fromReplace(doc3, this.from, this.to, slice2);
        }
        invert() {
          return new RemoveMarkStep(this.from, this.to, this.mark);
        }
        map(mapping) {
          let from3 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
          if (from3.deleted && to2.deleted || from3.pos >= to2.pos)
            return null;
          return new _AddMarkStep(from3.pos, to2.pos, this.mark);
        }
        merge(other) {
          if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
            return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
          return null;
        }
        toJSON() {
          return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
        /**
        @internal
        */
        static fromJSON(schema, json2) {
          if (typeof json2.from != "number" || typeof json2.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
          return new _AddMarkStep(json2.from, json2.to, schema.markFromJSON(json2.mark));
        }
      };
      Step.jsonID("addMark", AddMarkStep);
      RemoveMarkStep = class _RemoveMarkStep extends Step {
        /**
        Create a mark-removing step.
        */
        constructor(from3, to2, mark) {
          super();
          this.from = from3;
          this.to = to2;
          this.mark = mark;
        }
        apply(doc3) {
          let oldSlice = doc3.slice(this.from, this.to);
          let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
            return node.mark(this.mark.removeFromSet(node.marks));
          }, doc3), oldSlice.openStart, oldSlice.openEnd);
          return StepResult.fromReplace(doc3, this.from, this.to, slice2);
        }
        invert() {
          return new AddMarkStep(this.from, this.to, this.mark);
        }
        map(mapping) {
          let from3 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
          if (from3.deleted && to2.deleted || from3.pos >= to2.pos)
            return null;
          return new _RemoveMarkStep(from3.pos, to2.pos, this.mark);
        }
        merge(other) {
          if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
            return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
          return null;
        }
        toJSON() {
          return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
        /**
        @internal
        */
        static fromJSON(schema, json2) {
          if (typeof json2.from != "number" || typeof json2.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
          return new _RemoveMarkStep(json2.from, json2.to, schema.markFromJSON(json2.mark));
        }
      };
      Step.jsonID("removeMark", RemoveMarkStep);
      AddNodeMarkStep = class _AddNodeMarkStep extends Step {
        /**
        Create a node mark step.
        */
        constructor(pos, mark) {
          super();
          this.pos = pos;
          this.mark = mark;
        }
        apply(doc3) {
          let node = doc3.nodeAt(this.pos);
          if (!node)
            return StepResult.fail("No node at mark step's position");
          let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
          return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
        invert(doc3) {
          let node = doc3.nodeAt(this.pos);
          if (node) {
            let newSet = this.mark.addToSet(node.marks);
            if (newSet.length == node.marks.length) {
              for (let i = 0; i < node.marks.length; i++)
                if (!node.marks[i].isInSet(newSet))
                  return new _AddNodeMarkStep(this.pos, node.marks[i]);
              return new _AddNodeMarkStep(this.pos, this.mark);
            }
          }
          return new RemoveNodeMarkStep(this.pos, this.mark);
        }
        map(mapping) {
          let pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
        }
        toJSON() {
          return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
        }
        /**
        @internal
        */
        static fromJSON(schema, json2) {
          if (typeof json2.pos != "number")
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
          return new _AddNodeMarkStep(json2.pos, schema.markFromJSON(json2.mark));
        }
      };
      Step.jsonID("addNodeMark", AddNodeMarkStep);
      RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
        /**
        Create a mark-removing step.
        */
        constructor(pos, mark) {
          super();
          this.pos = pos;
          this.mark = mark;
        }
        apply(doc3) {
          let node = doc3.nodeAt(this.pos);
          if (!node)
            return StepResult.fail("No node at mark step's position");
          let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
          return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
        invert(doc3) {
          let node = doc3.nodeAt(this.pos);
          if (!node || !this.mark.isInSet(node.marks))
            return this;
          return new AddNodeMarkStep(this.pos, this.mark);
        }
        map(mapping) {
          let pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
        }
        toJSON() {
          return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
        }
        /**
        @internal
        */
        static fromJSON(schema, json2) {
          if (typeof json2.pos != "number")
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
          return new _RemoveNodeMarkStep(json2.pos, schema.markFromJSON(json2.mark));
        }
      };
      Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
      ReplaceStep = class _ReplaceStep extends Step {
        /**
        The given `slice` should fit the 'gap' between `from` and
        `to`the depths must line up, and the surrounding nodes must be
        able to be joined with the open sides of the slice. When
        `structure` is true, the step will fail if the content between
        from and to is not just a sequence of closing and then opening
        tokens (this is to guard against rebased replace steps
        overwriting something they weren't supposed to).
        */
        constructor(from3, to2, slice2, structure = false) {
          super();
          this.from = from3;
          this.to = to2;
          this.slice = slice2;
          this.structure = structure;
        }
        apply(doc3) {
          if (this.structure && contentBetween(doc3, this.from, this.to))
            return StepResult.fail("Structure replace would overwrite content");
          return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
        }
        getMap() {
          return new StepMap([this.from, this.to - this.from, this.slice.size]);
        }
        invert(doc3) {
          return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
        }
        map(mapping) {
          let from3 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
          if (from3.deletedAcross && to2.deletedAcross)
            return null;
          return new _ReplaceStep(from3.pos, Math.max(from3.pos, to2.pos), this.slice);
        }
        merge(other) {
          if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
            return null;
          if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
            let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
            return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
          } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
            let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
            return new _ReplaceStep(other.from, this.to, slice2, this.structure);
          } else {
            return null;
          }
        }
        toJSON() {
          let json2 = { stepType: "replace", from: this.from, to: this.to };
          if (this.slice.size)
            json2.slice = this.slice.toJSON();
          if (this.structure)
            json2.structure = true;
          return json2;
        }
        /**
        @internal
        */
        static fromJSON(schema, json2) {
          if (typeof json2.from != "number" || typeof json2.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
          return new _ReplaceStep(json2.from, json2.to, Slice.fromJSON(schema, json2.slice), !!json2.structure);
        }
      };
      Step.jsonID("replace", ReplaceStep);
      ReplaceAroundStep = class _ReplaceAroundStep extends Step {
        /**
        Create a replace-around step with the given range and gap.
        `insert` should be the point in the slice into which the content
        of the gap should be moved. `structure` has the same meaning as
        it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
        */
        constructor(from3, to2, gapFrom, gapTo, slice2, insert, structure = false) {
          super();
          this.from = from3;
          this.to = to2;
          this.gapFrom = gapFrom;
          this.gapTo = gapTo;
          this.slice = slice2;
          this.insert = insert;
          this.structure = structure;
        }
        apply(doc3) {
          if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
            return StepResult.fail("Structure gap-replace would overwrite content");
          let gap = doc3.slice(this.gapFrom, this.gapTo);
          if (gap.openStart || gap.openEnd)
            return StepResult.fail("Gap is not a flat range");
          let inserted = this.slice.insertAt(this.insert, gap.content);
          if (!inserted)
            return StepResult.fail("Content does not fit in gap");
          return StepResult.fromReplace(doc3, this.from, this.to, inserted);
        }
        getMap() {
          return new StepMap([
            this.from,
            this.gapFrom - this.from,
            this.insert,
            this.gapTo,
            this.to - this.gapTo,
            this.slice.size - this.insert
          ]);
        }
        invert(doc3) {
          let gap = this.gapTo - this.gapFrom;
          return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
        }
        map(mapping) {
          let from3 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
          let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
          if (from3.deletedAcross && to2.deletedAcross || gapFrom < from3.pos || gapTo > to2.pos)
            return null;
          return new _ReplaceAroundStep(from3.pos, to2.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
        }
        toJSON() {
          let json2 = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
          };
          if (this.slice.size)
            json2.slice = this.slice.toJSON();
          if (this.structure)
            json2.structure = true;
          return json2;
        }
        /**
        @internal
        */
        static fromJSON(schema, json2) {
          if (typeof json2.from != "number" || typeof json2.to != "number" || typeof json2.gapFrom != "number" || typeof json2.gapTo != "number" || typeof json2.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
          return new _ReplaceAroundStep(json2.from, json2.to, json2.gapFrom, json2.gapTo, Slice.fromJSON(schema, json2.slice), json2.insert, !!json2.structure);
        }
      };
      Step.jsonID("replaceAround", ReplaceAroundStep);
      Fitter = class {
        constructor($from, $to, unplaced) {
          this.$from = $from;
          this.$to = $to;
          this.unplaced = unplaced;
          this.frontier = [];
          this.placed = Fragment.empty;
          for (let i = 0; i <= $from.depth; i++) {
            let node = $from.node(i);
            this.frontier.push({
              type: node.type,
              match: node.contentMatchAt($from.indexAfter(i))
            });
          }
          for (let i = $from.depth; i > 0; i--)
            this.placed = Fragment.from($from.node(i).copy(this.placed));
        }
        get depth() {
          return this.frontier.length - 1;
        }
        fit() {
          while (this.unplaced.size) {
            let fit = this.findFittable();
            if (fit)
              this.placeNodes(fit);
            else
              this.openMore() || this.dropNode();
          }
          let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
          let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
          if (!$to)
            return null;
          let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
          while (openStart && openEnd && content.childCount == 1) {
            content = content.firstChild.content;
            openStart--;
            openEnd--;
          }
          let slice2 = new Slice(content, openStart, openEnd);
          if (moveInline > -1)
            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
          if (slice2.size || $from.pos != this.$to.pos)
            return new ReplaceStep($from.pos, $to.pos, slice2);
          return null;
        }
        // Find a position on the start spine of `this.unplaced` that has
        // content that can be moved somewhere on the frontier. Returns two
        // depths, one for the slice and one for the frontier.
        findFittable() {
          let startDepth = this.unplaced.openStart;
          for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
            let node = cur.firstChild;
            if (cur.childCount > 1)
              openEnd = 0;
            if (node.type.spec.isolating && openEnd <= d) {
              startDepth = d;
              break;
            }
            cur = node.content;
          }
          for (let pass = 1; pass <= 2; pass++) {
            for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
              let fragment, parent = null;
              if (sliceDepth) {
                parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
                fragment = parent.content;
              } else {
                fragment = this.unplaced.content;
              }
              let first2 = fragment.firstChild;
              for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
                let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
                if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
                  return { sliceDepth, frontierDepth, parent, inject };
                else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
                  return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
                if (parent && match.matchType(parent.type))
                  break;
              }
            }
          }
        }
        openMore() {
          let { content, openStart, openEnd } = this.unplaced;
          let inner = contentAt(content, openStart);
          if (!inner.childCount || inner.firstChild.isLeaf)
            return false;
          this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
          return true;
        }
        dropNode() {
          let { content, openStart, openEnd } = this.unplaced;
          let inner = contentAt(content, openStart);
          if (inner.childCount <= 1 && openStart > 0) {
            let openAtEnd = content.size - openStart <= openStart + inner.size;
            this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
          } else {
            this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
          }
        }
        // Move content from the unplaced slice at `sliceDepth` to the
        // frontier node at `frontierDepth`. Close that frontier node when
        // applicable.
        placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
          while (this.depth > frontierDepth)
            this.closeFrontierNode();
          if (wrap2)
            for (let i = 0; i < wrap2.length; i++)
              this.openFrontierNode(wrap2[i]);
          let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
          let openStart = slice2.openStart - sliceDepth;
          let taken = 0, add2 = [];
          let { match, type } = this.frontier[frontierDepth];
          if (inject) {
            for (let i = 0; i < inject.childCount; i++)
              add2.push(inject.child(i));
            match = match.matchFragment(inject);
          }
          let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
          while (taken < fragment.childCount) {
            let next = fragment.child(taken), matches3 = match.matchType(next.type);
            if (!matches3)
              break;
            taken++;
            if (taken > 1 || openStart == 0 || next.content.size) {
              match = matches3;
              add2.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
            }
          }
          let toEnd = taken == fragment.childCount;
          if (!toEnd)
            openEndCount = -1;
          this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));
          this.frontier[frontierDepth].match = match;
          if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
            this.closeFrontierNode();
          for (let i = 0, cur = fragment; i < openEndCount; i++) {
            let node = cur.lastChild;
            this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
            cur = node.content;
          }
          this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
        }
        mustMoveInline() {
          if (!this.$to.parent.isTextblock)
            return -1;
          let top2 = this.frontier[this.depth], level;
          if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
            return -1;
          let { depth } = this.$to, after = this.$to.after(depth);
          while (depth > 1 && after == this.$to.end(--depth))
            ++after;
          return after;
        }
        findCloseLevel($to) {
          scan:
            for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
              let { match, type } = this.frontier[i];
              let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
              let fit = contentAfterFits($to, i, type, match, dropInner);
              if (!fit)
                continue;
              for (let d = i - 1; d >= 0; d--) {
                let { match: match2, type: type2 } = this.frontier[d];
                let matches3 = contentAfterFits($to, d, type2, match2, true);
                if (!matches3 || matches3.childCount)
                  continue scan;
              }
              return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
            }
        }
        close($to) {
          let close2 = this.findCloseLevel($to);
          if (!close2)
            return null;
          while (this.depth > close2.depth)
            this.closeFrontierNode();
          if (close2.fit.childCount)
            this.placed = addToFragment(this.placed, close2.depth, close2.fit);
          $to = close2.move;
          for (let d = close2.depth + 1; d <= $to.depth; d++) {
            let node = $to.node(d), add2 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
            this.openFrontierNode(node.type, node.attrs, add2);
          }
          return $to;
        }
        openFrontierNode(type, attrs = null, content) {
          let top2 = this.frontier[this.depth];
          top2.match = top2.match.matchType(type);
          this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
          this.frontier.push({ type, match: type.contentMatch });
        }
        closeFrontierNode() {
          let open = this.frontier.pop();
          let add2 = open.match.fillBefore(Fragment.empty, true);
          if (add2.childCount)
            this.placed = addToFragment(this.placed, this.frontier.length, add2);
        }
      };
      AttrStep = class _AttrStep extends Step {
        /**
        Construct an attribute step.
        */
        constructor(pos, attr, value) {
          super();
          this.pos = pos;
          this.attr = attr;
          this.value = value;
        }
        apply(doc3) {
          let node = doc3.nodeAt(this.pos);
          if (!node)
            return StepResult.fail("No node at attribute step's position");
          let attrs = /* @__PURE__ */ Object.create(null);
          for (let name in node.attrs)
            attrs[name] = node.attrs[name];
          attrs[this.attr] = this.value;
          let updated = node.type.create(attrs, null, node.marks);
          return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
        getMap() {
          return StepMap.empty;
        }
        invert(doc3) {
          return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
        }
        map(mapping) {
          let pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
        }
        toJSON() {
          return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
        }
        static fromJSON(schema, json2) {
          if (typeof json2.pos != "number" || typeof json2.attr != "string")
            throw new RangeError("Invalid input for AttrStep.fromJSON");
          return new _AttrStep(json2.pos, json2.attr, json2.value);
        }
      };
      Step.jsonID("attr", AttrStep);
      DocAttrStep = class _DocAttrStep extends Step {
        /**
        Construct an attribute step.
        */
        constructor(attr, value) {
          super();
          this.attr = attr;
          this.value = value;
        }
        apply(doc3) {
          let attrs = /* @__PURE__ */ Object.create(null);
          for (let name in doc3.attrs)
            attrs[name] = doc3.attrs[name];
          attrs[this.attr] = this.value;
          let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
          return StepResult.ok(updated);
        }
        getMap() {
          return StepMap.empty;
        }
        invert(doc3) {
          return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
        }
        map(mapping) {
          return this;
        }
        toJSON() {
          return { stepType: "docAttr", attr: this.attr, value: this.value };
        }
        static fromJSON(schema, json2) {
          if (typeof json2.attr != "string")
            throw new RangeError("Invalid input for DocAttrStep.fromJSON");
          return new _DocAttrStep(json2.attr, json2.value);
        }
      };
      Step.jsonID("docAttr", DocAttrStep);
      TransformError = class extends Error {
      };
      TransformError = function TransformError2(message) {
        let err = Error.call(this, message);
        err.__proto__ = TransformError2.prototype;
        return err;
      };
      TransformError.prototype = Object.create(Error.prototype);
      TransformError.prototype.constructor = TransformError;
      TransformError.prototype.name = "TransformError";
      Transform = class {
        /**
        Create a transform that starts with the given document.
        */
        constructor(doc3) {
          this.doc = doc3;
          this.steps = [];
          this.docs = [];
          this.mapping = new Mapping();
        }
        /**
        The starting document.
        */
        get before() {
          return this.docs.length ? this.docs[0] : this.doc;
        }
        /**
        Apply a new step in this transform, saving the result. Throws an
        error when the step fails.
        */
        step(step) {
          let result = this.maybeStep(step);
          if (result.failed)
            throw new TransformError(result.failed);
          return this;
        }
        /**
        Try to apply a step in this transformation, ignoring it if it
        fails. Returns the step result.
        */
        maybeStep(step) {
          let result = step.apply(this.doc);
          if (!result.failed)
            this.addStep(step, result.doc);
          return result;
        }
        /**
        True when the document has been changed (when there are any
        steps).
        */
        get docChanged() {
          return this.steps.length > 0;
        }
        /**
        @internal
        */
        addStep(step, doc3) {
          this.docs.push(this.doc);
          this.steps.push(step);
          this.mapping.appendMap(step.getMap());
          this.doc = doc3;
        }
        /**
        Replace the part of the document between `from` and `to` with the
        given `slice`.
        */
        replace(from3, to2 = from3, slice2 = Slice.empty) {
          let step = replaceStep(this.doc, from3, to2, slice2);
          if (step)
            this.step(step);
          return this;
        }
        /**
        Replace the given range with the given content, which may be a
        fragment, node, or array of nodes.
        */
        replaceWith(from3, to2, content) {
          return this.replace(from3, to2, new Slice(Fragment.from(content), 0, 0));
        }
        /**
        Delete the content between the given positions.
        */
        delete(from3, to2) {
          return this.replace(from3, to2, Slice.empty);
        }
        /**
        Insert the given content at the given position.
        */
        insert(pos, content) {
          return this.replaceWith(pos, pos, content);
        }
        /**
        Replace a range of the document with a given slice, using
        `from`, `to`, and the slice's
        [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
        than fixed start and end points. This method may grow the
        replaced area or close open nodes in the slice in order to get a
        fit that is more in line with WYSIWYG expectations, by dropping
        fully covered parent nodes of the replaced region when they are
        marked [non-defining as
        context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
        open parent node from the slice that _is_ marked as [defining
        its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
        
        This is the method, for example, to handle paste. The similar
        [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
        primitive tool which will _not_ move the start and end of its given
        range, and is useful in situations where you need more precise
        control over what happens.
        */
        replaceRange(from3, to2, slice2) {
          replaceRange(this, from3, to2, slice2);
          return this;
        }
        /**
        Replace the given range with a node, but use `from` and `to` as
        hints, rather than precise positions. When from and to are the same
        and are at the start or end of a parent node in which the given
        node doesn't fit, this method may _move_ them out towards a parent
        that does allow the given node to be placed. When the given range
        completely covers a parent node, this method may completely replace
        that parent node.
        */
        replaceRangeWith(from3, to2, node) {
          replaceRangeWith(this, from3, to2, node);
          return this;
        }
        /**
        Delete the given range, expanding it to cover fully covered
        parent nodes until a valid replace is found.
        */
        deleteRange(from3, to2) {
          deleteRange(this, from3, to2);
          return this;
        }
        /**
        Split the content in the given range off from its parent, if there
        is sibling content before or after it, and move it up the tree to
        the depth specified by `target`. You'll probably want to use
        [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
        sure the lift is valid.
        */
        lift(range, target) {
          lift(this, range, target);
          return this;
        }
        /**
        Join the blocks around the given position. If depth is 2, their
        last and first siblings are also joined, and so on.
        */
        join(pos, depth = 1) {
          join(this, pos, depth);
          return this;
        }
        /**
        Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
        The wrappers are assumed to be valid in this position, and should
        probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
        */
        wrap(range, wrappers) {
          wrap(this, range, wrappers);
          return this;
        }
        /**
        Set the type of all textblocks (partly) between `from` and `to` to
        the given node type with the given attributes.
        */
        setBlockType(from3, to2 = from3, type, attrs = null) {
          setBlockType(this, from3, to2, type, attrs);
          return this;
        }
        /**
        Change the type, attributes, and/or marks of the node at `pos`.
        When `type` isn't given, the existing node type is preserved,
        */
        setNodeMarkup(pos, type, attrs = null, marks) {
          setNodeMarkup(this, pos, type, attrs, marks);
          return this;
        }
        /**
        Set a single attribute on a given node to a new value.
        The `pos` addresses the document content. Use `setDocAttribute`
        to set attributes on the document itself.
        */
        setNodeAttribute(pos, attr, value) {
          this.step(new AttrStep(pos, attr, value));
          return this;
        }
        /**
        Set a single attribute on the document to a new value.
        */
        setDocAttribute(attr, value) {
          this.step(new DocAttrStep(attr, value));
          return this;
        }
        /**
        Add a mark to the node at position `pos`.
        */
        addNodeMark(pos, mark) {
          this.step(new AddNodeMarkStep(pos, mark));
          return this;
        }
        /**
        Remove a mark (or a mark of the given type) from the node at
        position `pos`.
        */
        removeNodeMark(pos, mark) {
          if (!(mark instanceof Mark)) {
            let node = this.doc.nodeAt(pos);
            if (!node)
              throw new RangeError("No node at position " + pos);
            mark = mark.isInSet(node.marks);
            if (!mark)
              return this;
          }
          this.step(new RemoveNodeMarkStep(pos, mark));
          return this;
        }
        /**
        Split the node at the given position, and optionally, if `depth` is
        greater than one, any number of nodes above that. By default, the
        parts split off will inherit the node type of the original node.
        This can be changed by passing an array of types and attributes to
        use after the split.
        */
        split(pos, depth = 1, typesAfter) {
          split(this, pos, depth, typesAfter);
          return this;
        }
        /**
        Add the given mark to the inline content between `from` and `to`.
        */
        addMark(from3, to2, mark) {
          addMark(this, from3, to2, mark);
          return this;
        }
        /**
        Remove marks from inline nodes between `from` and `to`. When
        `mark` is a single mark, remove precisely that mark. When it is
        a mark type, remove all marks of that type. When it is null,
        remove all marks of any type.
        */
        removeMark(from3, to2, mark) {
          removeMark(this, from3, to2, mark);
          return this;
        }
        /**
        Removes all marks and nodes from the content of the node at
        `pos` that don't match the given new parent node type. Accepts
        an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
        third argument.
        */
        clearIncompatible(pos, parentType, match) {
          clearIncompatible(this, pos, parentType, match);
          return this;
        }
      };
    }
  });

  // node_modules/prosemirror-state/dist/index.js
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
  }
  function findSelectionIn(doc3, node, pos, index3, dir, text = false) {
    if (node.inlineContent)
      return TextSelection.create(doc3, pos);
    for (let i = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
      let child = node.child(i);
      if (!child.isAtom) {
        let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
        if (inner)
          return inner;
      } else if (!text && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd(tr2, startLen, bias) {
    let last = tr2.steps.length - 1;
    if (last < startLen)
      return;
    let step = tr2.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
      return;
    let map4 = tr2.mapping.maps[last], end2;
    map4.forEach((_from, _to, _newFrom, newTo) => {
      if (end2 == null)
        end2 = newTo;
    });
    tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
  }
  function bind(f, self2) {
    return !self2 || !f ? f : f.bind(self2);
  }
  function bindProps(obj, self2, target) {
    for (let prop in obj) {
      let val = obj[prop];
      if (val instanceof Function)
        val = val.bind(self2);
      else if (prop == "handleDOMEvents")
        val = bindProps(val, self2, {});
      target[prop] = val;
    }
    return target;
  }
  function createKey(name) {
    if (name in keys)
      return name + "$" + ++keys[name];
    keys[name] = 0;
    return name + "$";
  }
  var classesById, Selection, SelectionRange, warnedAboutTextSelection, TextSelection, TextBookmark, NodeSelection, NodeBookmark, AllSelection, AllBookmark, UPDATED_SEL, UPDATED_MARKS, UPDATED_SCROLL, Transaction, FieldDesc, baseFields, Configuration, EditorState, Plugin, keys, PluginKey;
  var init_dist4 = __esm({
    "node_modules/prosemirror-state/dist/index.js"() {
      init_dist2();
      init_dist3();
      classesById = /* @__PURE__ */ Object.create(null);
      Selection = class {
        /**
        Initialize a selection with the head and anchor and ranges. If no
        ranges are given, constructs a single range across `$anchor` and
        `$head`.
        */
        constructor($anchor, $head, ranges) {
          this.$anchor = $anchor;
          this.$head = $head;
          this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
        }
        /**
        The selection's anchor, as an unresolved position.
        */
        get anchor() {
          return this.$anchor.pos;
        }
        /**
        The selection's head.
        */
        get head() {
          return this.$head.pos;
        }
        /**
        The lower bound of the selection's main range.
        */
        get from() {
          return this.$from.pos;
        }
        /**
        The upper bound of the selection's main range.
        */
        get to() {
          return this.$to.pos;
        }
        /**
        The resolved lower  bound of the selection's main range.
        */
        get $from() {
          return this.ranges[0].$from;
        }
        /**
        The resolved upper bound of the selection's main range.
        */
        get $to() {
          return this.ranges[0].$to;
        }
        /**
        Indicates whether the selection contains any content.
        */
        get empty() {
          let ranges = this.ranges;
          for (let i = 0; i < ranges.length; i++)
            if (ranges[i].$from.pos != ranges[i].$to.pos)
              return false;
          return true;
        }
        /**
        Get the content of this selection as a slice.
        */
        content() {
          return this.$from.doc.slice(this.from, this.to, true);
        }
        /**
        Replace the selection with a slice or, if no slice is given,
        delete the selection. Will append to the given transaction.
        */
        replace(tr2, content = Slice.empty) {
          let lastNode = content.content.lastChild, lastParent = null;
          for (let i = 0; i < content.openEnd; i++) {
            lastParent = lastNode;
            lastNode = lastNode.lastChild;
          }
          let mapFrom = tr2.steps.length, ranges = this.ranges;
          for (let i = 0; i < ranges.length; i++) {
            let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
            tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
            if (i == 0)
              selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
          }
        }
        /**
        Replace the selection with the given node, appending the changes
        to the given transaction.
        */
        replaceWith(tr2, node) {
          let mapFrom = tr2.steps.length, ranges = this.ranges;
          for (let i = 0; i < ranges.length; i++) {
            let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
            let from3 = mapping.map($from.pos), to2 = mapping.map($to.pos);
            if (i) {
              tr2.deleteRange(from3, to2);
            } else {
              tr2.replaceRangeWith(from3, to2, node);
              selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
            }
          }
        }
        /**
        Find a valid cursor or leaf node selection starting at the given
        position and searching back if `dir` is negative, and forward if
        positive. When `textOnly` is true, only consider cursor
        selections. Will return null when no valid selection position is
        found.
        */
        static findFrom($pos, dir, textOnly = false) {
          let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
          if (inner)
            return inner;
          for (let depth = $pos.depth - 1; depth >= 0; depth--) {
            let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
            if (found2)
              return found2;
          }
          return null;
        }
        /**
        Find a valid cursor or leaf node selection near the given
        position. Searches forward first by default, but if `bias` is
        negative, it will search backwards first.
        */
        static near($pos, bias = 1) {
          return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
        }
        /**
        Find the cursor or leaf node selection closest to the start of
        the given document. Will return an
        [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
        exists.
        */
        static atStart(doc3) {
          return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
        }
        /**
        Find the cursor or leaf node selection closest to the end of the
        given document.
        */
        static atEnd(doc3) {
          return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
        }
        /**
        Deserialize the JSON representation of a selection. Must be
        implemented for custom classes (as a static class method).
        */
        static fromJSON(doc3, json2) {
          if (!json2 || !json2.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
          let cls = classesById[json2.type];
          if (!cls)
            throw new RangeError(`No selection type ${json2.type} defined`);
          return cls.fromJSON(doc3, json2);
        }
        /**
        To be able to deserialize selections from JSON, custom selection
        classes must register themselves with an ID string, so that they
        can be disambiguated. Try to pick something that's unlikely to
        clash with classes from other modules.
        */
        static jsonID(id, selectionClass) {
          if (id in classesById)
            throw new RangeError("Duplicate use of selection JSON ID " + id);
          classesById[id] = selectionClass;
          selectionClass.prototype.jsonID = id;
          return selectionClass;
        }
        /**
        Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
        which is a value that can be mapped without having access to a
        current document, and later resolved to a real selection for a
        given document again. (This is used mostly by the history to
        track and restore old selections.) The default implementation of
        this method just converts the selection to a text selection and
        returns the bookmark for that.
        */
        getBookmark() {
          return TextSelection.between(this.$anchor, this.$head).getBookmark();
        }
      };
      Selection.prototype.visible = true;
      SelectionRange = class {
        /**
        Create a range.
        */
        constructor($from, $to) {
          this.$from = $from;
          this.$to = $to;
        }
      };
      warnedAboutTextSelection = false;
      TextSelection = class _TextSelection extends Selection {
        /**
        Construct a text selection between the given points.
        */
        constructor($anchor, $head = $anchor) {
          checkTextSelection($anchor);
          checkTextSelection($head);
          super($anchor, $head);
        }
        /**
        Returns a resolved position if this is a cursor selection (an
        empty text selection), and null otherwise.
        */
        get $cursor() {
          return this.$anchor.pos == this.$head.pos ? this.$head : null;
        }
        map(doc3, mapping) {
          let $head = doc3.resolve(mapping.map(this.head));
          if (!$head.parent.inlineContent)
            return Selection.near($head);
          let $anchor = doc3.resolve(mapping.map(this.anchor));
          return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
        }
        replace(tr2, content = Slice.empty) {
          super.replace(tr2, content);
          if (content == Slice.empty) {
            let marks = this.$from.marksAcross(this.$to);
            if (marks)
              tr2.ensureMarks(marks);
          }
        }
        eq(other) {
          return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
        }
        getBookmark() {
          return new TextBookmark(this.anchor, this.head);
        }
        toJSON() {
          return { type: "text", anchor: this.anchor, head: this.head };
        }
        /**
        @internal
        */
        static fromJSON(doc3, json2) {
          if (typeof json2.anchor != "number" || typeof json2.head != "number")
            throw new RangeError("Invalid input for TextSelection.fromJSON");
          return new _TextSelection(doc3.resolve(json2.anchor), doc3.resolve(json2.head));
        }
        /**
        Create a text selection from non-resolved positions.
        */
        static create(doc3, anchor, head = anchor) {
          let $anchor = doc3.resolve(anchor);
          return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
        }
        /**
        Return a text selection that spans the given positions or, if
        they aren't text positions, find a text selection near them.
        `bias` determines whether the method searches forward (default)
        or backwards (negative number) first. Will fall back to calling
        [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
        doesn't contain a valid text position.
        */
        static between($anchor, $head, bias) {
          let dPos = $anchor.pos - $head.pos;
          if (!bias || dPos)
            bias = dPos >= 0 ? 1 : -1;
          if (!$head.parent.inlineContent) {
            let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
            if (found2)
              $head = found2.$head;
            else
              return Selection.near($head, bias);
          }
          if (!$anchor.parent.inlineContent) {
            if (dPos == 0) {
              $anchor = $head;
            } else {
              $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
              if ($anchor.pos < $head.pos != dPos < 0)
                $anchor = $head;
            }
          }
          return new _TextSelection($anchor, $head);
        }
      };
      Selection.jsonID("text", TextSelection);
      TextBookmark = class _TextBookmark {
        constructor(anchor, head) {
          this.anchor = anchor;
          this.head = head;
        }
        map(mapping) {
          return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
        }
        resolve(doc3) {
          return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
        }
      };
      NodeSelection = class _NodeSelection extends Selection {
        /**
        Create a node selection. Does not verify the validity of its
        argument.
        */
        constructor($pos) {
          let node = $pos.nodeAfter;
          let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
          super($pos, $end);
          this.node = node;
        }
        map(doc3, mapping) {
          let { deleted, pos } = mapping.mapResult(this.anchor);
          let $pos = doc3.resolve(pos);
          if (deleted)
            return Selection.near($pos);
          return new _NodeSelection($pos);
        }
        content() {
          return new Slice(Fragment.from(this.node), 0, 0);
        }
        eq(other) {
          return other instanceof _NodeSelection && other.anchor == this.anchor;
        }
        toJSON() {
          return { type: "node", anchor: this.anchor };
        }
        getBookmark() {
          return new NodeBookmark(this.anchor);
        }
        /**
        @internal
        */
        static fromJSON(doc3, json2) {
          if (typeof json2.anchor != "number")
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
          return new _NodeSelection(doc3.resolve(json2.anchor));
        }
        /**
        Create a node selection from non-resolved positions.
        */
        static create(doc3, from3) {
          return new _NodeSelection(doc3.resolve(from3));
        }
        /**
        Determines whether the given node may be selected as a node
        selection.
        */
        static isSelectable(node) {
          return !node.isText && node.type.spec.selectable !== false;
        }
      };
      NodeSelection.prototype.visible = false;
      Selection.jsonID("node", NodeSelection);
      NodeBookmark = class _NodeBookmark {
        constructor(anchor) {
          this.anchor = anchor;
        }
        map(mapping) {
          let { deleted, pos } = mapping.mapResult(this.anchor);
          return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
        }
        resolve(doc3) {
          let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
          if (node && NodeSelection.isSelectable(node))
            return new NodeSelection($pos);
          return Selection.near($pos);
        }
      };
      AllSelection = class _AllSelection extends Selection {
        /**
        Create an all-selection over the given document.
        */
        constructor(doc3) {
          super(doc3.resolve(0), doc3.resolve(doc3.content.size));
        }
        replace(tr2, content = Slice.empty) {
          if (content == Slice.empty) {
            tr2.delete(0, tr2.doc.content.size);
            let sel = Selection.atStart(tr2.doc);
            if (!sel.eq(tr2.selection))
              tr2.setSelection(sel);
          } else {
            super.replace(tr2, content);
          }
        }
        toJSON() {
          return { type: "all" };
        }
        /**
        @internal
        */
        static fromJSON(doc3) {
          return new _AllSelection(doc3);
        }
        map(doc3) {
          return new _AllSelection(doc3);
        }
        eq(other) {
          return other instanceof _AllSelection;
        }
        getBookmark() {
          return AllBookmark;
        }
      };
      Selection.jsonID("all", AllSelection);
      AllBookmark = {
        map() {
          return this;
        },
        resolve(doc3) {
          return new AllSelection(doc3);
        }
      };
      UPDATED_SEL = 1;
      UPDATED_MARKS = 2;
      UPDATED_SCROLL = 4;
      Transaction = class extends Transform {
        /**
        @internal
        */
        constructor(state) {
          super(state.doc);
          this.curSelectionFor = 0;
          this.updated = 0;
          this.meta = /* @__PURE__ */ Object.create(null);
          this.time = Date.now();
          this.curSelection = state.selection;
          this.storedMarks = state.storedMarks;
        }
        /**
        The transaction's current selection. This defaults to the editor
        selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
        transaction, but can be overwritten with
        [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
        */
        get selection() {
          if (this.curSelectionFor < this.steps.length) {
            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
            this.curSelectionFor = this.steps.length;
          }
          return this.curSelection;
        }
        /**
        Update the transaction's current selection. Will determine the
        selection that the editor gets when the transaction is applied.
        */
        setSelection(selection) {
          if (selection.$from.doc != this.doc)
            throw new RangeError("Selection passed to setSelection must point at the current document");
          this.curSelection = selection;
          this.curSelectionFor = this.steps.length;
          this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
          this.storedMarks = null;
          return this;
        }
        /**
        Whether the selection was explicitly updated by this transaction.
        */
        get selectionSet() {
          return (this.updated & UPDATED_SEL) > 0;
        }
        /**
        Set the current stored marks.
        */
        setStoredMarks(marks) {
          this.storedMarks = marks;
          this.updated |= UPDATED_MARKS;
          return this;
        }
        /**
        Make sure the current stored marks or, if that is null, the marks
        at the selection, match the given set of marks. Does nothing if
        this is already the case.
        */
        ensureMarks(marks) {
          if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
            this.setStoredMarks(marks);
          return this;
        }
        /**
        Add a mark to the set of stored marks.
        */
        addStoredMark(mark) {
          return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
        }
        /**
        Remove a mark or mark type from the set of stored marks.
        */
        removeStoredMark(mark) {
          return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
        }
        /**
        Whether the stored marks were explicitly set for this transaction.
        */
        get storedMarksSet() {
          return (this.updated & UPDATED_MARKS) > 0;
        }
        /**
        @internal
        */
        addStep(step, doc3) {
          super.addStep(step, doc3);
          this.updated = this.updated & ~UPDATED_MARKS;
          this.storedMarks = null;
        }
        /**
        Update the timestamp for the transaction.
        */
        setTime(time) {
          this.time = time;
          return this;
        }
        /**
        Replace the current selection with the given slice.
        */
        replaceSelection(slice2) {
          this.selection.replace(this, slice2);
          return this;
        }
        /**
        Replace the selection with the given node. When `inheritMarks` is
        true and the content is inline, it inherits the marks from the
        place where it is inserted.
        */
        replaceSelectionWith(node, inheritMarks = true) {
          let selection = this.selection;
          if (inheritMarks)
            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
          selection.replaceWith(this, node);
          return this;
        }
        /**
        Delete the selection.
        */
        deleteSelection() {
          this.selection.replace(this);
          return this;
        }
        /**
        Replace the given range, or the selection if no range is given,
        with a text node containing the given string.
        */
        insertText(text, from3, to2) {
          let schema = this.doc.type.schema;
          if (from3 == null) {
            if (!text)
              return this.deleteSelection();
            return this.replaceSelectionWith(schema.text(text), true);
          } else {
            if (to2 == null)
              to2 = from3;
            to2 = to2 == null ? from3 : to2;
            if (!text)
              return this.deleteRange(from3, to2);
            let marks = this.storedMarks;
            if (!marks) {
              let $from = this.doc.resolve(from3);
              marks = to2 == from3 ? $from.marks() : $from.marksAcross(this.doc.resolve(to2));
            }
            this.replaceRangeWith(from3, to2, schema.text(text, marks));
            if (!this.selection.empty)
              this.setSelection(Selection.near(this.selection.$to));
            return this;
          }
        }
        /**
        Store a metadata property in this transaction, keyed either by
        name or by plugin.
        */
        setMeta(key, value) {
          this.meta[typeof key == "string" ? key : key.key] = value;
          return this;
        }
        /**
        Retrieve a metadata property for a given name or plugin.
        */
        getMeta(key) {
          return this.meta[typeof key == "string" ? key : key.key];
        }
        /**
        Returns true if this transaction doesn't contain any metadata,
        and can thus safely be extended.
        */
        get isGeneric() {
          for (let _ in this.meta)
            return false;
          return true;
        }
        /**
        Indicate that the editor should scroll the selection into view
        when updated to the state produced by this transaction.
        */
        scrollIntoView() {
          this.updated |= UPDATED_SCROLL;
          return this;
        }
        /**
        True when this transaction has had `scrollIntoView` called on it.
        */
        get scrolledIntoView() {
          return (this.updated & UPDATED_SCROLL) > 0;
        }
      };
      FieldDesc = class {
        constructor(name, desc, self2) {
          this.name = name;
          this.init = bind(desc.init, self2);
          this.apply = bind(desc.apply, self2);
        }
      };
      baseFields = [
        new FieldDesc("doc", {
          init(config) {
            return config.doc || config.schema.topNodeType.createAndFill();
          },
          apply(tr2) {
            return tr2.doc;
          }
        }),
        new FieldDesc("selection", {
          init(config, instance) {
            return config.selection || Selection.atStart(instance.doc);
          },
          apply(tr2) {
            return tr2.selection;
          }
        }),
        new FieldDesc("storedMarks", {
          init(config) {
            return config.storedMarks || null;
          },
          apply(tr2, _marks, _old, state) {
            return state.selection.$cursor ? tr2.storedMarks : null;
          }
        }),
        new FieldDesc("scrollToSelection", {
          init() {
            return 0;
          },
          apply(tr2, prev) {
            return tr2.scrolledIntoView ? prev + 1 : prev;
          }
        })
      ];
      Configuration = class {
        constructor(schema, plugins3) {
          this.schema = schema;
          this.plugins = [];
          this.pluginsByKey = /* @__PURE__ */ Object.create(null);
          this.fields = baseFields.slice();
          if (plugins3)
            plugins3.forEach((plugin) => {
              if (this.pluginsByKey[plugin.key])
                throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
              this.plugins.push(plugin);
              this.pluginsByKey[plugin.key] = plugin;
              if (plugin.spec.state)
                this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
            });
        }
      };
      EditorState = class _EditorState {
        /**
        @internal
        */
        constructor(config) {
          this.config = config;
        }
        /**
        The schema of the state's document.
        */
        get schema() {
          return this.config.schema;
        }
        /**
        The plugins that are active in this state.
        */
        get plugins() {
          return this.config.plugins;
        }
        /**
        Apply the given transaction to produce a new state.
        */
        apply(tr2) {
          return this.applyTransaction(tr2).state;
        }
        /**
        @internal
        */
        filterTransaction(tr2, ignore = -1) {
          for (let i = 0; i < this.config.plugins.length; i++)
            if (i != ignore) {
              let plugin = this.config.plugins[i];
              if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
                return false;
            }
          return true;
        }
        /**
        Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
        returns the precise transactions that were applied (which might
        be influenced by the [transaction
        hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
        plugins) along with the new state.
        */
        applyTransaction(rootTr) {
          if (!this.filterTransaction(rootTr))
            return { state: this, transactions: [] };
          let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
          for (; ; ) {
            let haveNew = false;
            for (let i = 0; i < this.config.plugins.length; i++) {
              let plugin = this.config.plugins[i];
              if (plugin.spec.appendTransaction) {
                let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
                let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
                if (tr2 && newState.filterTransaction(tr2, i)) {
                  tr2.setMeta("appendedTransaction", rootTr);
                  if (!seen) {
                    seen = [];
                    for (let j = 0; j < this.config.plugins.length; j++)
                      seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
                  }
                  trs.push(tr2);
                  newState = newState.applyInner(tr2);
                  haveNew = true;
                }
                if (seen)
                  seen[i] = { state: newState, n: trs.length };
              }
            }
            if (!haveNew)
              return { state: newState, transactions: trs };
          }
        }
        /**
        @internal
        */
        applyInner(tr2) {
          if (!tr2.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
          let newInstance = new _EditorState(this.config), fields = this.config.fields;
          for (let i = 0; i < fields.length; i++) {
            let field = fields[i];
            newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
          }
          return newInstance;
        }
        /**
        Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
        */
        get tr() {
          return new Transaction(this);
        }
        /**
        Create a new state.
        */
        static create(config) {
          let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
          let instance = new _EditorState($config);
          for (let i = 0; i < $config.fields.length; i++)
            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
          return instance;
        }
        /**
        Create a new state based on this one, but with an adjusted set
        of active plugins. State fields that exist in both sets of
        plugins are kept unchanged. Those that no longer exist are
        dropped, and those that are new are initialized using their
        [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
        configuration object..
        */
        reconfigure(config) {
          let $config = new Configuration(this.schema, config.plugins);
          let fields = $config.fields, instance = new _EditorState($config);
          for (let i = 0; i < fields.length; i++) {
            let name = fields[i].name;
            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
          }
          return instance;
        }
        /**
        Serialize this state to JSON. If you want to serialize the state
        of plugins, pass an object mapping property names to use in the
        resulting JSON object to plugin objects. The argument may also be
        a string or number, in which case it is ignored, to support the
        way `JSON.stringify` calls `toString` methods.
        */
        toJSON(pluginFields) {
          let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
          if (this.storedMarks)
            result.storedMarks = this.storedMarks.map((m) => m.toJSON());
          if (pluginFields && typeof pluginFields == "object")
            for (let prop in pluginFields) {
              if (prop == "doc" || prop == "selection")
                throw new RangeError("The JSON fields `doc` and `selection` are reserved");
              let plugin = pluginFields[prop], state = plugin.spec.state;
              if (state && state.toJSON)
                result[prop] = state.toJSON.call(plugin, this[plugin.key]);
            }
          return result;
        }
        /**
        Deserialize a JSON representation of a state. `config` should
        have at least a `schema` field, and should contain array of
        plugins to initialize the state with. `pluginFields` can be used
        to deserialize the state of plugins, by associating plugin
        instances with the property names they use in the JSON object.
        */
        static fromJSON(config, json2, pluginFields) {
          if (!json2)
            throw new RangeError("Invalid input for EditorState.fromJSON");
          if (!config.schema)
            throw new RangeError("Required config field 'schema' missing");
          let $config = new Configuration(config.schema, config.plugins);
          let instance = new _EditorState($config);
          $config.fields.forEach((field) => {
            if (field.name == "doc") {
              instance.doc = Node2.fromJSON(config.schema, json2.doc);
            } else if (field.name == "selection") {
              instance.selection = Selection.fromJSON(instance.doc, json2.selection);
            } else if (field.name == "storedMarks") {
              if (json2.storedMarks)
                instance.storedMarks = json2.storedMarks.map(config.schema.markFromJSON);
            } else {
              if (pluginFields)
                for (let prop in pluginFields) {
                  let plugin = pluginFields[prop], state = plugin.spec.state;
                  if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json2, prop)) {
                    instance[field.name] = state.fromJSON.call(plugin, config, json2[prop], instance);
                    return;
                  }
                }
              instance[field.name] = field.init(config, instance);
            }
          });
          return instance;
        }
      };
      Plugin = class {
        /**
        Create a plugin.
        */
        constructor(spec) {
          this.spec = spec;
          this.props = {};
          if (spec.props)
            bindProps(spec.props, this, this.props);
          this.key = spec.key ? spec.key.key : createKey("plugin");
        }
        /**
        Extract the plugin's state field from an editor state.
        */
        getState(state) {
          return state[this.key];
        }
      };
      keys = /* @__PURE__ */ Object.create(null);
      PluginKey = class {
        /**
        Create a plugin key.
        */
        constructor(name = "key") {
          this.key = createKey(name);
        }
        /**
        Get the active plugin with this key, if any, from an editor
        state.
        */
        get(state) {
          return state.config.pluginsByKey[this.key];
        }
        /**
        Get the plugin's state from an editor state.
        */
        getState(state) {
          return state[this.key];
        }
      };
    }
  });

  // node_modules/@tiptap/pm/state/dist/index.js
  var init_dist5 = __esm({
    "node_modules/@tiptap/pm/state/dist/index.js"() {
      init_dist4();
    }
  });

  // node_modules/prosemirror-view/dist/index.js
  function scanFor(node, off2, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off2 == targetOff)
        return true;
      if (off2 == (dir < 0 ? 0 : nodeSize(node))) {
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
          return false;
        off2 = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off2 + (dir < 0 ? -1 : 0)];
        if (node.contentEditable == "false")
          return false;
        off2 = dir < 0 ? nodeSize(node) : 0;
      } else {
        return false;
      }
    }
  }
  function nodeSize(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function isOnEdge(node, offset2, parent) {
    for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
      if (node == parent)
        return true;
      let index3 = domIndex(node);
      node = node.parentNode;
      if (!node)
        return false;
      atStart = atStart && index3 == 0;
      atEnd = atEnd && index3 == nodeSize(node);
    }
  }
  function hasBlockDesc(dom) {
    let desc;
    for (let cur = dom; cur; cur = cur.parentNode)
      if (desc = cur.pmViewDesc)
        break;
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
  }
  function keyEvent(keyCode, key) {
    let event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key;
    return event;
  }
  function deepActiveElement(doc3) {
    let elt = doc3.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function caretFromPoint(doc3, x, y) {
    if (doc3.caretPositionFromPoint) {
      try {
        let pos = doc3.caretPositionFromPoint(x, y);
        if (pos)
          return { node: pos.offsetNode, offset: pos.offset };
      } catch (_) {
      }
    }
    if (doc3.caretRangeFromPoint) {
      let range = doc3.caretRangeFromPoint(x, y);
      if (range)
        return { node: range.startContainer, offset: range.startOffset };
    }
  }
  function windowRect(doc3) {
    return {
      left: 0,
      right: doc3.documentElement.clientWidth,
      top: 0,
      bottom: doc3.documentElement.clientHeight
    };
  }
  function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
  }
  function clientRect(node) {
    let rect = node.getBoundingClientRect();
    let scaleX = rect.width / node.offsetWidth || 1;
    let scaleY = rect.height / node.offsetHeight || 1;
    return {
      left: rect.left,
      right: rect.left + node.clientWidth * scaleX,
      top: rect.top,
      bottom: rect.top + node.clientHeight * scaleY
    };
  }
  function scrollRectIntoView(view, rect, startDOM) {
    let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
    let doc3 = view.dom.ownerDocument;
    for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
      if (!parent)
        break;
      if (parent.nodeType != 1)
        continue;
      let elt = parent;
      let atTop = elt == doc3.body;
      let bounding = atTop ? windowRect(doc3) : clientRect(elt);
      let moveX = 0, moveY = 0;
      if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
        moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
      else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
        moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
      if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
        moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
      else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
        moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
      if (moveX || moveY) {
        if (atTop) {
          doc3.defaultView.scrollBy(moveX, moveY);
        } else {
          let startX = elt.scrollLeft, startY = elt.scrollTop;
          if (moveY)
            elt.scrollTop += moveY;
          if (moveX)
            elt.scrollLeft += moveX;
          let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
        }
      }
      if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
        break;
    }
  }
  function storeScrollPos(view) {
    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
    let refDOM, refTop;
    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
      let dom = view.root.elementFromPoint(x, y);
      if (!dom || dom == view.dom || !view.dom.contains(dom))
        continue;
      let localRect = dom.getBoundingClientRect();
      if (localRect.top >= startY - 20) {
        refDOM = dom;
        refTop = localRect.top;
        break;
      }
    }
    return { refDOM, refTop, stack: scrollStack(view.dom) };
  }
  function scrollStack(dom) {
    let stack = [], doc3 = dom.ownerDocument;
    for (let cur = dom; cur; cur = parentNode(cur)) {
      stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
      if (dom == doc3)
        break;
    }
    return stack;
  }
  function resetScrollPos({ refDOM, refTop, stack }) {
    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
  }
  function restoreScrollStack(stack, dTop) {
    for (let i = 0; i < stack.length; i++) {
      let { dom, top: top2, left: left2 } = stack[i];
      if (dom.scrollTop != top2 + dTop)
        dom.scrollTop = top2 + dTop;
      if (dom.scrollLeft != left2)
        dom.scrollLeft = left2;
    }
  }
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      restoreScrollStack(stored, 0);
    }
  }
  function findOffsetInNode(node, coords) {
    let closest2, dxClosest = 2e8, coordsClosest, offset2 = 0;
    let rowBot = coords.top, rowTop = coords.top;
    let firstBelow, coordsBelow;
    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
      let rects;
      if (child.nodeType == 1)
        rects = child.getClientRects();
      else if (child.nodeType == 3)
        rects = textRange(child).getClientRects();
      else
        continue;
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.top <= rowBot && rect.bottom >= rowTop) {
          rowBot = Math.max(rect.bottom, rowBot);
          rowTop = Math.min(rect.top, rowTop);
          let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
          if (dx < dxClosest) {
            closest2 = child;
            dxClosest = dx;
            coordsClosest = dx && closest2.nodeType == 3 ? {
              left: rect.right < coords.left ? rect.right : rect.left,
              top: coords.top
            } : coords;
            if (child.nodeType == 1 && dx)
              offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
            continue;
          }
        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
          firstBelow = child;
          coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
        }
        if (!closest2 && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
          offset2 = childIndex + 1;
      }
    }
    if (!closest2 && firstBelow) {
      closest2 = firstBelow;
      coordsClosest = coordsBelow;
      dxClosest = 0;
    }
    if (closest2 && closest2.nodeType == 3)
      return findOffsetInText(closest2, coordsClosest);
    if (!closest2 || dxClosest && closest2.nodeType == 1)
      return { node, offset: offset2 };
    return findOffsetInNode(closest2, coordsClosest);
  }
  function findOffsetInText(node, coords) {
    let len = node.nodeValue.length;
    let range = document.createRange();
    for (let i = 0; i < len; i++) {
      range.setEnd(node, i + 1);
      range.setStart(node, i);
      let rect = singleRect(range, 1);
      if (rect.top == rect.bottom)
        continue;
      if (inRect(coords, rect))
        return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
    return { node, offset: 0 };
  }
  function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
  }
  function targetKludge(dom, coords) {
    let parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
      return parent;
    return dom;
  }
  function posFromElement(view, elt, coords) {
    let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
    if (node.nodeType == 1 && !node.firstChild) {
      let rect = node.getBoundingClientRect();
      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node, offset2, bias);
  }
  function posFromCaret(view, node, offset2, coords) {
    let outsideBlock = -1;
    for (let cur = node, sawBlock = false; ; ) {
      if (cur == view.dom)
        break;
      let desc = view.docView.nearestDesc(cur, true);
      if (!desc)
        return null;
      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
        let rect = desc.dom.getBoundingClientRect();
        if (desc.node.isBlock && desc.parent && !sawBlock) {
          sawBlock = true;
          if (rect.left > coords.left || rect.top > coords.top)
            outsideBlock = desc.posBefore;
          else if (rect.right < coords.left || rect.bottom < coords.top)
            outsideBlock = desc.posAfter;
        }
        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
          let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
          return before ? desc.posBefore : desc.posAfter;
        }
      }
      cur = desc.dom.parentNode;
    }
    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
  }
  function elementFromPoint(element, coords, box) {
    let len = element.childNodes.length;
    if (len && box.top < box.bottom) {
      for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
        let child = element.childNodes[i];
        if (child.nodeType == 1) {
          let rects = child.getClientRects();
          for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (inRect(coords, rect))
              return elementFromPoint(child, coords, rect);
          }
        }
        if ((i = (i + 1) % len) == startI)
          break;
      }
    }
    return element;
  }
  function posAtCoords(view, coords) {
    let doc3 = view.dom.ownerDocument, node, offset2 = 0;
    let caret = caretFromPoint(doc3, coords.left, coords.top);
    if (caret)
      ({ node, offset: offset2 } = caret);
    let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
    let pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
      let box = view.dom.getBoundingClientRect();
      if (!inRect(coords, box))
        return null;
      elt = elementFromPoint(view.dom, coords, box);
      if (!elt)
        return null;
    }
    if (safari) {
      for (let p = elt; node && p; p = parentNode(p))
        if (p.draggable)
          node = void 0;
    }
    elt = targetKludge(elt, coords);
    if (node) {
      if (gecko && node.nodeType == 1) {
        offset2 = Math.min(offset2, node.childNodes.length);
        if (offset2 < node.childNodes.length) {
          let next = node.childNodes[offset2], box;
          if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
            offset2++;
        }
      }
      let prev;
      if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
        offset2--;
      if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
        pos = view.state.doc.content.size;
      else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
        pos = posFromCaret(view, node, offset2, coords);
    }
    if (pos == null)
      pos = posFromElement(view, elt, coords);
    let desc = view.docView.nearestDesc(elt, true);
    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
  }
  function nonZero(rect) {
    return rect.top < rect.bottom || rect.left < rect.right;
  }
  function singleRect(target, bias) {
    let rects = target.getClientRects();
    if (rects.length) {
      let first2 = rects[bias < 0 ? 0 : rects.length - 1];
      if (nonZero(first2))
        return first2;
    }
    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
  }
  function coordsAtPos(view, pos, side) {
    let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
    let supportEmptyRange = webkit || gecko;
    if (node.nodeType == 3) {
      if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
        let rect = singleRect(textRange(node, offset2, offset2), side);
        if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
          let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
          if (rectBefore.top == rect.top) {
            let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
            if (rectAfter.top != rect.top)
              return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
        return rect;
      } else {
        let from3 = offset2, to2 = offset2, takeSide = side < 0 ? 1 : -1;
        if (side < 0 && !offset2) {
          to2++;
          takeSide = -1;
        } else if (side >= 0 && offset2 == node.nodeValue.length) {
          from3--;
          takeSide = 1;
        } else if (side < 0) {
          from3--;
        } else {
          to2++;
        }
        return flattenV(singleRect(textRange(node, from3, to2), takeSide), takeSide < 0);
      }
    }
    let $dom = view.state.doc.resolve(pos - (atom || 0));
    if (!$dom.parent.inlineContent) {
      if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
        let before = node.childNodes[offset2 - 1];
        if (before.nodeType == 1)
          return flattenH(before.getBoundingClientRect(), false);
      }
      if (atom == null && offset2 < nodeSize(node)) {
        let after = node.childNodes[offset2];
        if (after.nodeType == 1)
          return flattenH(after.getBoundingClientRect(), true);
      }
      return flattenH(node.getBoundingClientRect(), side >= 0);
    }
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
      if (target)
        return flattenV(singleRect(target, 1), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
        after = after.nextSibling;
      let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
      if (target)
        return flattenV(singleRect(target, -1), true);
    }
    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
  }
  function flattenV(rect, left2) {
    if (rect.width == 0)
      return rect;
    let x = left2 ? rect.left : rect.right;
    return { top: rect.top, bottom: rect.bottom, left: x, right: x };
  }
  function flattenH(rect, top2) {
    if (rect.height == 0)
      return rect;
    let y = top2 ? rect.top : rect.bottom;
    return { top: y, bottom: y, left: rect.left, right: rect.right };
  }
  function withFlushedState(view, state, f) {
    let viewState = view.state, active = view.root.activeElement;
    if (viewState != state)
      view.updateState(state);
    if (active != view.dom)
      view.focus();
    try {
      return f();
    } finally {
      if (viewState != state)
        view.updateState(viewState);
      if (active != view.dom && active)
        active.focus();
    }
  }
  function endOfTextblockVertical(view, state, dir) {
    let sel = state.selection;
    let $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, () => {
      let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
      for (; ; ) {
        let nearest = view.docView.nearestDesc(dom, true);
        if (!nearest)
          break;
        if (nearest.node.isBlock) {
          dom = nearest.contentDOM || nearest.dom;
          break;
        }
        dom = nearest.dom.parentNode;
      }
      let coords = coordsAtPos(view, $pos.pos, 1);
      for (let child = dom.firstChild; child; child = child.nextSibling) {
        let boxes;
        if (child.nodeType == 1)
          boxes = child.getClientRects();
        else if (child.nodeType == 3)
          boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
        else
          continue;
        for (let i = 0; i < boxes.length; i++) {
          let box = boxes[i];
          if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
            return false;
        }
      }
      return true;
    });
  }
  function endOfTextblockHorizontal(view, state, dir) {
    let { $head } = state.selection;
    if (!$head.parent.isTextblock)
      return false;
    let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
    let sel = view.domSelection();
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
      return dir == "left" || dir == "backward" ? atStart : atEnd;
    return withFlushedState(view, state, () => {
      let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
      let oldBidiLevel = sel.caretBidiLevel;
      sel.modify("move", dir, "character");
      let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
      let { focusNode: newNode2, focusOffset: newOff } = view.domSelectionRange();
      let result = newNode2 && !parentDOM.contains(newNode2.nodeType == 1 ? newNode2 : newNode2.parentNode) || oldNode == newNode2 && oldOff == newOff;
      try {
        sel.collapse(anchorNode, anchorOffset);
        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
          sel.extend(oldNode, oldOff);
      } catch (_) {
      }
      if (oldBidiLevel != null)
        sel.caretBidiLevel = oldBidiLevel;
      return result;
    });
  }
  function endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir)
      return cachedResult;
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
  }
  function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc3);
    let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
    if (docView.contentDOM)
      docView.updateChildren(view, 0);
    return docView;
  }
  function renderDescs(parentDOM, descs, view) {
    let dom = parentDOM.firstChild, written = false;
    for (let i = 0; i < descs.length; i++) {
      let desc = descs[i], childDOM = desc.dom;
      if (childDOM.parentNode == parentDOM) {
        while (childDOM != dom) {
          dom = rm(dom);
          written = true;
        }
        dom = dom.nextSibling;
      } else {
        written = true;
        parentDOM.insertBefore(childDOM, dom);
      }
      if (desc instanceof MarkViewDesc) {
        let pos = dom ? dom.previousSibling : parentDOM.lastChild;
        renderDescs(desc.contentDOM, desc.children, view);
        dom = pos ? pos.nextSibling : parentDOM.firstChild;
      }
    }
    while (dom) {
      dom = rm(dom);
      written = true;
    }
    if (written && view.trackWrites == parentDOM)
      view.trackWrites = null;
  }
  function computeOuterDeco(outerDeco, node, needsWrap) {
    if (outerDeco.length == 0)
      return noDeco;
    let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
    for (let i = 0; i < outerDeco.length; i++) {
      let attrs = outerDeco[i].type.attrs;
      if (!attrs)
        continue;
      if (attrs.nodeName)
        result.push(top2 = new OuterDecoLevel(attrs.nodeName));
      for (let name in attrs) {
        let val = attrs[name];
        if (val == null)
          continue;
        if (needsWrap && result.length == 1)
          result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
        if (name == "class")
          top2.class = (top2.class ? top2.class + " " : "") + val;
        else if (name == "style")
          top2.style = (top2.style ? top2.style + ";" : "") + val;
        else if (name != "nodeName")
          top2[name] = val;
      }
    }
    return result;
  }
  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
    if (prevComputed == noDeco && curComputed == noDeco)
      return nodeDOM;
    let curDOM = nodeDOM;
    for (let i = 0; i < curComputed.length; i++) {
      let deco = curComputed[i], prev = prevComputed[i];
      if (i) {
        let parent;
        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
          curDOM = parent;
        } else {
          parent = document.createElement(deco.nodeName);
          parent.pmIsDeco = true;
          parent.appendChild(curDOM);
          prev = noDeco[0];
          curDOM = parent;
        }
      }
      patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
  }
  function patchAttributes(dom, prev, cur) {
    for (let name in prev)
      if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
        dom.removeAttribute(name);
    for (let name in cur)
      if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
        dom.setAttribute(name, cur[name]);
    if (prev.class != cur.class) {
      let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
      let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
      for (let i = 0; i < prevList.length; i++)
        if (curList.indexOf(prevList[i]) == -1)
          dom.classList.remove(prevList[i]);
      for (let i = 0; i < curList.length; i++)
        if (prevList.indexOf(curList[i]) == -1)
          dom.classList.add(curList[i]);
      if (dom.classList.length == 0)
        dom.removeAttribute("class");
    }
    if (prev.style != cur.style) {
      if (prev.style) {
        let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
        while (m = prop.exec(prev.style))
          dom.style.removeProperty(m[1]);
      }
      if (cur.style)
        dom.style.cssText += cur.style;
    }
  }
  function applyOuterDeco(dom, deco, node) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
  }
  function sameOuterDeco(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].type.eq(b[i].type))
        return false;
    return true;
  }
  function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  function preMatch(frag, parentDesc) {
    let curDesc = parentDesc, descI = curDesc.children.length;
    let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches3 = [];
    outer:
      while (fI > 0) {
        let desc;
        for (; ; ) {
          if (descI) {
            let next = curDesc.children[descI - 1];
            if (next instanceof MarkViewDesc) {
              curDesc = next;
              descI = next.children.length;
            } else {
              desc = next;
              descI--;
              break;
            }
          } else if (curDesc == parentDesc) {
            break outer;
          } else {
            descI = curDesc.parent.children.indexOf(curDesc);
            curDesc = curDesc.parent;
          }
        }
        let node = desc.node;
        if (!node)
          continue;
        if (node != frag.child(fI - 1))
          break;
        --fI;
        matched.set(desc, fI);
        matches3.push(desc);
      }
    return { index: fI, matched, matches: matches3.reverse() };
  }
  function compareSide(a, b) {
    return a.type.side - b.type.side;
  }
  function iterDeco(parent, deco, onWidget, onNode) {
    let locals = deco.locals(parent), offset2 = 0;
    if (locals.length == 0) {
      for (let i = 0; i < parent.childCount; i++) {
        let child = parent.child(i);
        onNode(child, locals, deco.forChild(offset2, child), i);
        offset2 += child.nodeSize;
      }
      return;
    }
    let decoIndex = 0, active = [], restNode = null;
    for (let parentIndex = 0; ; ) {
      let widget, widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
        let next = locals[decoIndex++];
        if (next.widget) {
          if (!widget)
            widget = next;
          else
            (widgets || (widgets = [widget])).push(next);
        }
      }
      if (widget) {
        if (widgets) {
          widgets.sort(compareSide);
          for (let i = 0; i < widgets.length; i++)
            onWidget(widgets[i], parentIndex, !!restNode);
        } else {
          onWidget(widget, parentIndex, !!restNode);
        }
      }
      let child, index3;
      if (restNode) {
        index3 = -1;
        child = restNode;
        restNode = null;
      } else if (parentIndex < parent.childCount) {
        index3 = parentIndex;
        child = parent.child(parentIndex++);
      } else {
        break;
      }
      for (let i = 0; i < active.length; i++)
        if (active[i].to <= offset2)
          active.splice(i--, 1);
      while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
        active.push(locals[decoIndex++]);
      let end2 = offset2 + child.nodeSize;
      if (child.isText) {
        let cutAt = end2;
        if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
          cutAt = locals[decoIndex].from;
        for (let i = 0; i < active.length; i++)
          if (active[i].to < cutAt)
            cutAt = active[i].to;
        if (cutAt < end2) {
          restNode = child.cut(cutAt - offset2);
          child = child.cut(0, cutAt - offset2);
          end2 = cutAt;
          index3 = -1;
        }
      } else {
        while (decoIndex < locals.length && locals[decoIndex].to < end2)
          decoIndex++;
      }
      let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
      onNode(child, outerDeco, deco.forChild(offset2, child), index3);
      offset2 = end2;
    }
  }
  function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
      let oldCSS = dom.style.cssText;
      dom.style.cssText = oldCSS + "; list-style: square !important";
      window.getComputedStyle(dom).listStyle;
      dom.style.cssText = oldCSS;
    }
  }
  function nearbyTextNode(node, offset2) {
    for (; ; ) {
      if (node.nodeType == 3)
        return node;
      if (node.nodeType == 1 && offset2 > 0) {
        if (node.childNodes.length > offset2 && node.childNodes[offset2].nodeType == 3)
          return node.childNodes[offset2];
        node = node.childNodes[offset2 - 1];
        offset2 = nodeSize(node);
      } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
        node = node.childNodes[offset2];
        offset2 = 0;
      } else {
        return null;
      }
    }
  }
  function findTextInFragment(frag, text, from3, to2) {
    for (let i = 0, pos = 0; i < frag.childCount && pos <= to2; ) {
      let child = frag.child(i++), childStart = pos;
      pos += child.nodeSize;
      if (!child.isText)
        continue;
      let str = child.text;
      while (i < frag.childCount) {
        let next = frag.child(i++);
        pos += next.nodeSize;
        if (!next.isText)
          break;
        str += next.text;
      }
      if (pos >= from3) {
        if (pos >= to2 && str.slice(to2 - text.length - childStart, to2 - childStart) == text)
          return to2 - text.length;
        let found2 = childStart < to2 ? str.lastIndexOf(text, to2 - childStart - 1) : -1;
        if (found2 >= 0 && found2 + text.length + childStart >= from3)
          return childStart + found2;
        if (from3 == to2 && str.length >= to2 + text.length - childStart && str.slice(to2 - childStart, to2 - childStart + text.length) == text)
          return to2;
      }
    }
    return -1;
  }
  function replaceNodes(nodes, from3, to2, view, replacement) {
    let result = [];
    for (let i = 0, off2 = 0; i < nodes.length; i++) {
      let child = nodes[i], start3 = off2, end2 = off2 += child.size;
      if (start3 >= to2 || end2 <= from3) {
        result.push(child);
      } else {
        if (start3 < from3)
          result.push(child.slice(0, from3 - start3, view));
        if (replacement) {
          result.push(replacement);
          replacement = void 0;
        }
        if (end2 > to2)
          result.push(child.slice(to2 - start3, child.size, view));
      }
    }
    return result;
  }
  function selectionFromDOM(view, origin = null) {
    let domSel = view.domSelectionRange(), doc3 = view.state.doc;
    if (!domSel.focusNode)
      return null;
    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
    if (head < 0)
      return null;
    let $head = doc3.resolve(head), $anchor, selection;
    if (selectionCollapsed(domSel)) {
      $anchor = $head;
      while (nearestDesc && !nearestDesc.node)
        nearestDesc = nearestDesc.parent;
      let nearestDescNode = nearestDesc.node;
      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
        let pos = nearestDesc.posBefore;
        selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
      }
    } else {
      let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
      if (anchor < 0)
        return null;
      $anchor = doc3.resolve(anchor);
    }
    if (!selection) {
      let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
      selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
  }
  function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
  }
  function selectionToDOM(view, force = false) {
    let sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view))
      return;
    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
      let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
        view.input.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
      selectCursorWrapper(view);
    } else {
      let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
        if (!sel.$from.parent.inlineContent)
          resetEditableFrom = temporarilyEditableNear(view, sel.from);
        if (!sel.empty && !sel.$from.parent.inlineContent)
          resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
      view.docView.setSelection(anchor, head, view.root, force);
      if (brokenSelectBetweenUneditable) {
        if (resetEditableFrom)
          resetEditable(resetEditableFrom);
        if (resetEditableTo)
          resetEditable(resetEditableTo);
      }
      if (sel.visible) {
        view.dom.classList.remove("ProseMirror-hideselection");
      } else {
        view.dom.classList.add("ProseMirror-hideselection");
        if ("onselectionchange" in document)
          removeClassOnSelectionChange(view);
      }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
  }
  function temporarilyEditableNear(view, pos) {
    let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
    let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
    let before = offset2 ? node.childNodes[offset2 - 1] : null;
    if (safari && after && after.contentEditable == "false")
      return setEditable(after);
    if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
      if (after)
        return setEditable(after);
      else if (before)
        return setEditable(before);
    }
  }
  function setEditable(element) {
    element.contentEditable = "true";
    if (safari && element.draggable) {
      element.draggable = false;
      element.wasDraggable = true;
    }
    return element;
  }
  function resetEditable(element) {
    element.contentEditable = "false";
    if (element.wasDraggable) {
      element.draggable = true;
      element.wasDraggable = null;
    }
  }
  function removeClassOnSelectionChange(view) {
    let doc3 = view.dom.ownerDocument;
    doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
    let domSel = view.domSelectionRange();
    let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
    doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
      if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
        doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
        setTimeout(() => {
          if (!editorOwnsSelection(view) || view.state.selection.visible)
            view.dom.classList.remove("ProseMirror-hideselection");
        }, 20);
      }
    });
  }
  function selectCursorWrapper(view) {
    let domSel = view.domSelection(), range = document.createRange();
    let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
    if (img)
      range.setEnd(node.parentNode, domIndex(node) + 1);
    else
      range.setEnd(node, 0);
    range.collapse(false);
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
      node.disabled = true;
      node.disabled = false;
    }
  }
  function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
      let desc = view.docView.descAt(sel.from);
      if (desc != view.lastSelectedViewDesc) {
        clearNodeSelection(view);
        if (desc)
          desc.selectNode();
        view.lastSelectedViewDesc = desc;
      }
    } else {
      clearNodeSelection(view);
    }
  }
  function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
      if (view.lastSelectedViewDesc.parent)
        view.lastSelectedViewDesc.deselectNode();
      view.lastSelectedViewDesc = void 0;
    }
  }
  function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
  }
  function hasFocusAndSelection(view) {
    if (view.editable && !view.hasFocus())
      return false;
    return hasSelection(view);
  }
  function hasSelection(view) {
    let sel = view.domSelectionRange();
    if (!sel.anchorNode)
      return false;
    try {
      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    } catch (_) {
      return false;
    }
  }
  function anchorInRightPlace(view) {
    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    let domSel = view.domSelectionRange();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
  }
  function moveSelectionBlock(state, dir) {
    let { $anchor, $head } = state.selection;
    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
  }
  function apply(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
  }
  function selectHorizontally(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection) {
      if (mods.indexOf("s") > -1) {
        let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
        if (!node || node.isText || !node.isLeaf)
          return false;
        let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
        return apply(view, new TextSelection(sel.$anchor, $newHead));
      } else if (!sel.empty) {
        return false;
      } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
        let next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection)
          return apply(view, next);
        return false;
      } else if (!(mac && mods.indexOf("m") > -1)) {
        let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
        if (!node || node.isText)
          return false;
        let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
        if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
          return false;
        if (NodeSelection.isSelectable(node)) {
          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
        } else if (webkit) {
          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
        } else {
          return false;
        }
      }
    } else if (sel instanceof NodeSelection && sel.node.isInline) {
      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    } else {
      let next = moveSelectionBlock(view.state, dir);
      if (next)
        return apply(view, next);
      return false;
    }
  }
  function nodeLen(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function isIgnorable(dom, dir) {
    let desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
  }
  function skipIgnoredNodes(view, dir) {
    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
  }
  function skipIgnoredNodesBefore(view) {
    let sel = view.domSelectionRange();
    let node = sel.focusNode, offset2 = sel.focusOffset;
    if (!node)
      return;
    let moveNode, moveOffset, force = false;
    if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
      force = true;
    for (; ; ) {
      if (offset2 > 0) {
        if (node.nodeType != 1) {
          break;
        } else {
          let before = node.childNodes[offset2 - 1];
          if (isIgnorable(before, -1)) {
            moveNode = node;
            moveOffset = --offset2;
          } else if (before.nodeType == 3) {
            node = before;
            offset2 = node.nodeValue.length;
          } else
            break;
        }
      } else if (isBlockNode(node)) {
        break;
      } else {
        let prev = node.previousSibling;
        while (prev && isIgnorable(prev, -1)) {
          moveNode = node.parentNode;
          moveOffset = domIndex(prev);
          prev = prev.previousSibling;
        }
        if (!prev) {
          node = node.parentNode;
          if (node == view.dom)
            break;
          offset2 = 0;
        } else {
          node = prev;
          offset2 = nodeLen(node);
        }
      }
    }
    if (force)
      setSelFocus(view, node, offset2);
    else if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function skipIgnoredNodesAfter(view) {
    let sel = view.domSelectionRange();
    let node = sel.focusNode, offset2 = sel.focusOffset;
    if (!node)
      return;
    let len = nodeLen(node);
    let moveNode, moveOffset;
    for (; ; ) {
      if (offset2 < len) {
        if (node.nodeType != 1)
          break;
        let after = node.childNodes[offset2];
        if (isIgnorable(after, 1)) {
          moveNode = node;
          moveOffset = ++offset2;
        } else
          break;
      } else if (isBlockNode(node)) {
        break;
      } else {
        let next = node.nextSibling;
        while (next && isIgnorable(next, 1)) {
          moveNode = next.parentNode;
          moveOffset = domIndex(next) + 1;
          next = next.nextSibling;
        }
        if (!next) {
          node = node.parentNode;
          if (node == view.dom)
            break;
          offset2 = len = 0;
        } else {
          node = next;
          offset2 = 0;
          len = nodeLen(node);
        }
      }
    }
    if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function isBlockNode(dom) {
    let desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
  }
  function textNodeAfter(node, offset2) {
    while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    }
    while (node && offset2 < node.childNodes.length) {
      let next = node.childNodes[offset2];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node = next;
      offset2 = 0;
    }
  }
  function textNodeBefore(node, offset2) {
    while (node && !offset2 && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    }
    while (node && offset2) {
      let next = node.childNodes[offset2 - 1];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node = next;
      offset2 = node.childNodes.length;
    }
  }
  function setSelFocus(view, node, offset2) {
    if (node.nodeType != 3) {
      let before, after;
      if (after = textNodeAfter(node, offset2)) {
        node = after;
        offset2 = 0;
      } else if (before = textNodeBefore(node, offset2)) {
        node = before;
        offset2 = before.nodeValue.length;
      }
    }
    let sel = view.domSelection();
    if (selectionCollapsed(sel)) {
      let range = document.createRange();
      range.setEnd(node, offset2);
      range.setStart(node, offset2);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (sel.extend) {
      sel.extend(node, offset2);
    }
    view.domObserver.setCurSelection();
    let { state } = view;
    setTimeout(() => {
      if (view.state == state)
        selectionToDOM(view);
    }, 50);
  }
  function findDirection(view, pos) {
    let $pos = view.state.doc.resolve(pos);
    if (!(chrome || windows) && $pos.parent.inlineContent) {
      let coords = view.coordsAtPos(pos);
      if (pos > $pos.start()) {
        let before = view.coordsAtPos(pos - 1);
        let mid = (before.top + before.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
          return before.left < coords.left ? "ltr" : "rtl";
      }
      if (pos < $pos.end()) {
        let after = view.coordsAtPos(pos + 1);
        let mid = (after.top + after.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
          return after.left > coords.left ? "ltr" : "rtl";
      }
    }
    let computed = getComputedStyle(view.dom).direction;
    return computed == "rtl" ? "rtl" : "ltr";
  }
  function selectVertically(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
      return false;
    if (mac && mods.indexOf("m") > -1)
      return false;
    let { $from, $to } = sel;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
    }
    if (!$from.parent.inlineContent) {
      let side = dir < 0 ? $from : $to;
      let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
      return beyond ? apply(view, beyond) : false;
    }
    return false;
  }
  function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection))
      return true;
    let { $head, $anchor, empty: empty2 } = view.state.selection;
    if (!$head.sameParent($anchor))
      return true;
    if (!empty2)
      return false;
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
      return true;
    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
      let tr2 = view.state.tr;
      if (dir < 0)
        tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
      else
        tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
      view.dispatch(tr2);
      return true;
    }
    return false;
  }
  function switchEditable(view, node, state) {
    view.domObserver.stop();
    node.contentEditable = state;
    view.domObserver.start();
  }
  function safariDownArrowBug(view) {
    if (!safari || view.state.selection.$head.parentOffset > 0)
      return false;
    let { focusNode, focusOffset } = view.domSelectionRange();
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
      let child = focusNode.firstChild;
      switchEditable(view, child, "true");
      setTimeout(() => switchEditable(view, child, "false"), 20);
    }
    return false;
  }
  function getMods(event) {
    let result = "";
    if (event.ctrlKey)
      result += "c";
    if (event.metaKey)
      result += "m";
    if (event.altKey)
      result += "a";
    if (event.shiftKey)
      result += "s";
    return result;
  }
  function captureKeyDown(view, event) {
    let code = event.keyCode, mods = getMods(event);
    if (code == 8 || mac && code == 72 && mods == "c") {
      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
    } else if (code == 13 || code == 27) {
      return true;
    } else if (code == 37 || mac && code == 66 && mods == "c") {
      let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code == 39 || mac && code == 70 && mods == "c") {
      let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code == 38 || mac && code == 80 && mods == "c") {
      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
    } else if (code == 40 || mac && code == 78 && mods == "c") {
      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
    } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
      return true;
    }
    return false;
  }
  function serializeForClipboard(view, slice2) {
    view.someProp("transformCopied", (f) => {
      slice2 = f(slice2, view);
    });
    let context = [], { content, openStart, openEnd } = slice2;
    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
      openStart--;
      openEnd--;
      let node = content.firstChild;
      context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
      content = node.content;
    }
    let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
    wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
    let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
      for (let i = needsWrap.length - 1; i >= 0; i--) {
        let wrapper = doc3.createElement(needsWrap[i]);
        while (wrap2.firstChild)
          wrapper.appendChild(wrap2.firstChild);
        wrap2.appendChild(wrapper);
        wrappers++;
      }
      firstChild = wrap2.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1)
      firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
    let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
    return { dom: wrap2, text };
  }
  function parseFromClipboard(view, text, html, plainText, $context) {
    let inCode = $context.parent.type.spec.code;
    let dom, slice2;
    if (!html && !text)
      return null;
    let asText = text && (plainText || inCode || !html);
    if (asText) {
      view.someProp("transformPastedText", (f) => {
        text = f(text, inCode || plainText, view);
      });
      if (inCode)
        return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
      let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
      if (parsed) {
        slice2 = parsed;
      } else {
        let marks = $context.marks();
        let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
        dom = document.createElement("div");
        text.split(/(?:\r\n?|\n)+/).forEach((block) => {
          let p = dom.appendChild(document.createElement("p"));
          if (block)
            p.appendChild(serializer.serializeNode(schema.text(block, marks)));
        });
      }
    } else {
      view.someProp("transformPastedHTML", (f) => {
        html = f(html, view);
      });
      dom = readHTML(html);
      if (webkit)
        restoreReplacedSpaces(dom);
    }
    let contextNode = dom && dom.querySelector("[data-pm-slice]");
    let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
    if (sliceData && sliceData[3])
      for (let i = +sliceData[3]; i > 0; i--) {
        let child = dom.firstChild;
        while (child && child.nodeType != 1)
          child = child.nextSibling;
        if (!child)
          break;
        dom = child;
      }
    if (!slice2) {
      let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
      slice2 = parser.parseSlice(dom, {
        preserveWhitespace: !!(asText || sliceData),
        context: $context,
        ruleFromNode(dom2) {
          if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
            return { ignore: true };
          return null;
        }
      });
    }
    if (sliceData) {
      slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
    } else {
      slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
      if (slice2.openStart || slice2.openEnd) {
        let openStart = 0, openEnd = 0;
        for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
        }
        for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
        }
        slice2 = closeSlice(slice2, openStart, openEnd);
      }
    }
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
    return slice2;
  }
  function normalizeSiblings(fragment, $context) {
    if (fragment.childCount < 2)
      return fragment;
    for (let d = $context.depth; d >= 0; d--) {
      let parent = $context.node(d);
      let match = parent.contentMatchAt($context.index(d));
      let lastWrap, result = [];
      fragment.forEach((node) => {
        if (!result)
          return;
        let wrap2 = match.findWrapping(node.type), inLast;
        if (!wrap2)
          return result = null;
        if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
          result[result.length - 1] = inLast;
        } else {
          if (result.length)
            result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
          let wrapped = withWrappers(node, wrap2);
          result.push(wrapped);
          match = match.matchType(wrapped.type);
          lastWrap = wrap2;
        }
      });
      if (result)
        return Fragment.from(result);
    }
    return fragment;
  }
  function withWrappers(node, wrap2, from3 = 0) {
    for (let i = wrap2.length - 1; i >= from3; i--)
      node = wrap2[i].create(null, Fragment.from(node));
    return node;
  }
  function addToSibling(wrap2, lastWrap, node, sibling, depth) {
    if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
      let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
      if (inner)
        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
      let match = sibling.contentMatchAt(sibling.childCount);
      if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
    }
  }
  function closeRight(node, depth) {
    if (depth == 0)
      return node;
    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
    let fill2 = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
    return node.copy(fragment.append(fill2));
  }
  function closeRange(fragment, side, from3, to2, depth, openEnd) {
    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
    if (fragment.childCount > 1)
      openEnd = 0;
    if (depth < to2 - 1)
      inner = closeRange(inner, side, from3, to2, depth + 1, openEnd);
    if (depth >= from3)
      inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
  }
  function closeSlice(slice2, openStart, openEnd) {
    if (openStart < slice2.openStart)
      slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
    if (openEnd < slice2.openEnd)
      slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
    return slice2;
  }
  function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
  }
  function readHTML(html) {
    let metas = /^(\s*<meta [^>]*>)*/.exec(html);
    if (metas)
      html = html.slice(metas[0].length);
    let elt = detachedDoc().createElement("div");
    let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
    if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
      html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
    elt.innerHTML = html;
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        elt = elt.querySelector(wrap2[i]) || elt;
    return elt;
  }
  function restoreReplacedSpaces(dom) {
    let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let i = 0; i < nodes.length; i++) {
      let node = nodes[i];
      if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
        node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
    }
  }
  function addContext(slice2, context) {
    if (!slice2.size)
      return slice2;
    let schema = slice2.content.firstChild.type.schema, array;
    try {
      array = JSON.parse(context);
    } catch (e) {
      return slice2;
    }
    let { content, openStart, openEnd } = slice2;
    for (let i = array.length - 2; i >= 0; i -= 2) {
      let type = schema.nodes[array[i]];
      if (!type || type.hasRequiredAttrs())
        break;
      content = Fragment.from(type.create(array[i + 1], content));
      openStart++;
      openEnd++;
    }
    return new Slice(content, openStart, openEnd);
  }
  function initInput(view) {
    for (let event in handlers) {
      let handler = handlers[event];
      view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
          handler(view, event2);
      }, passiveHandlers[event] ? { passive: true } : void 0);
    }
    if (safari)
      view.dom.addEventListener("input", () => null);
    ensureListeners(view);
  }
  function setSelectionOrigin(view, origin) {
    view.input.lastSelectionOrigin = origin;
    view.input.lastSelectionTime = Date.now();
  }
  function destroyInput(view) {
    view.domObserver.stop();
    for (let type in view.input.eventHandlers)
      view.dom.removeEventListener(type, view.input.eventHandlers[type]);
    clearTimeout(view.input.composingTimeout);
    clearTimeout(view.input.lastIOSEnterFallbackTimeout);
  }
  function ensureListeners(view) {
    view.someProp("handleDOMEvents", (currentHandlers) => {
      for (let type in currentHandlers)
        if (!view.input.eventHandlers[type])
          view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
    });
  }
  function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", (handlers2) => {
      let handler = handlers2[event.type];
      return handler ? handler(view, event) || event.defaultPrevented : false;
    });
  }
  function eventBelongsToView(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target; node != view.dom; node = node.parentNode)
      if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
        return false;
    return true;
  }
  function dispatchEvent3(view, event) {
    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
      handlers[event.type](view, event);
  }
  function eventCoords(event) {
    return { left: event.clientX, top: event.clientY };
  }
  function isNear(event, click) {
    let dx = click.x - event.clientX, dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
  }
  function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
        return true;
    }
    return false;
  }
  function updateSelection(view, selection, origin) {
    if (!view.focused)
      view.focus();
    let tr2 = view.state.tr.setSelection(selection);
    if (origin == "pointer")
      tr2.setMeta("pointer", true);
    view.dispatch(tr2);
  }
  function selectClickedLeaf(view, inside) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
    if (node && node.isAtom && NodeSelection.isSelectable(node)) {
      updateSelection(view, new NodeSelection($pos), "pointer");
      return true;
    }
    return false;
  }
  function selectClickedNode(view, inside) {
    if (inside == -1)
      return false;
    let sel = view.state.selection, selectedNode, selectAt;
    if (sel instanceof NodeSelection)
      selectedNode = sel.node;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      if (NodeSelection.isSelectable(node)) {
        if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
          selectAt = $pos.before(sel.$from.depth);
        else
          selectAt = $pos.before(i);
        break;
      }
    }
    if (selectAt != null) {
      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
      return true;
    } else {
      return false;
    }
  }
  function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
  }
  function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
  }
  function handleTripleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
  }
  function defaultTripleClick(view, inside, event) {
    if (event.button != 0)
      return false;
    let doc3 = view.state.doc;
    if (inside == -1) {
      if (doc3.inlineContent) {
        updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
        return true;
      }
      return false;
    }
    let $pos = doc3.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      let nodePos = $pos.before(i);
      if (node.inlineContent)
        updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
      else if (NodeSelection.isSelectable(node))
        updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
      else
        continue;
      return true;
    }
  }
  function forceDOMFlush(view) {
    return endComposition(view);
  }
  function inOrNearComposition(view, event) {
    if (view.composing)
      return true;
    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
      view.input.compositionEndedAt = -2e8;
      return true;
    }
    return false;
  }
  function scheduleComposeEnd(view, delay) {
    clearTimeout(view.input.composingTimeout);
    if (delay > -1)
      view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
  }
  function clearComposition(view) {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.input.compositionNodes.length > 0)
      view.input.compositionNodes.pop().markParentsDirty();
  }
  function timestampFromCustomEvent() {
    let event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
  }
  function endComposition(view, forceUpdate = false) {
    if (android && view.domObserver.flushingSoon >= 0)
      return;
    view.domObserver.forceFlush();
    clearComposition(view);
    if (forceUpdate || view.docView && view.docView.dirty) {
      let sel = selectionFromDOM(view);
      if (sel && !sel.eq(view.state.selection))
        view.dispatch(view.state.tr.setSelection(sel));
      else
        view.updateState(view.state);
      return true;
    }
    return false;
  }
  function captureCopy(view, dom) {
    if (!view.dom.parentNode)
      return;
    let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap2.appendChild(dom);
    wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let sel = getSelection(), range = document.createRange();
    range.selectNodeContents(dom);
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(() => {
      if (wrap2.parentNode)
        wrap2.parentNode.removeChild(wrap2);
      view.focus();
    }, 50);
  }
  function sliceSingleNode(slice2) {
    return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
  }
  function capturePaste(view, event) {
    if (!view.dom.parentNode)
      return;
    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText)
      target.contentEditable = "true";
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    setTimeout(() => {
      view.focus();
      if (target.parentNode)
        target.parentNode.removeChild(target);
      if (plainText)
        doPaste(view, target.value, null, plain, event);
      else
        doPaste(view, target.textContent, target.innerHTML, plain, event);
    }, 50);
  }
  function doPaste(view, text, html, preferPlain, event) {
    let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
    if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
      return true;
    if (!slice2)
      return false;
    let singleNode = sliceSingleNode(slice2);
    let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
    view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
  }
  function getText(clipboardData) {
    let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
    if (text)
      return text;
    let uris = clipboardData.getData("text/uri-list");
    return uris ? uris.replace(/\r?\n/g, " ") : "";
  }
  function compareObjs(a, b) {
    if (a == b)
      return true;
    for (let p in a)
      if (a[p] !== b[p])
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
    return true;
  }
  function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
    let children = oldChildren.slice();
    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
      let moved2 = 0;
      mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
        let dSize = newEnd - newStart - (oldEnd - oldStart);
        for (let i2 = 0; i2 < children.length; i2 += 3) {
          let end2 = children[i2 + 1];
          if (end2 < 0 || oldStart > end2 + baseOffset - moved2)
            continue;
          let start3 = children[i2] + baseOffset - moved2;
          if (oldEnd >= start3) {
            children[i2 + 1] = oldStart <= start3 ? -2 : -1;
          } else if (oldStart >= baseOffset && dSize) {
            children[i2] += dSize;
            children[i2 + 1] += dSize;
          }
        }
        moved2 += dSize;
      });
      baseOffset = mapping.maps[i].map(baseOffset, -1);
    }
    let mustRebuild = false;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        if (children[i + 1] == -2) {
          mustRebuild = true;
          children[i + 1] = -1;
          continue;
        }
        let from3 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from3 - offset2;
        if (fromLocal < 0 || fromLocal >= node.content.size) {
          mustRebuild = true;
          continue;
        }
        let to2 = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to2 - offset2;
        let { index: index3, offset: childOffset } = node.content.findIndex(fromLocal);
        let childNode = node.maybeChild(index3);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          let mapped = children[i + 2].mapInner(mapping, childNode, from3 + 1, oldChildren[i] + oldOffset + 1, options);
          if (mapped != empty) {
            children[i] = fromLocal;
            children[i + 1] = toLocal;
            children[i + 2] = mapped;
          } else {
            children[i + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      }
    if (mustRebuild) {
      let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
      let built = buildTree(decorations, node, 0, options);
      newLocal = built.local;
      for (let i = 0; i < children.length; i += 3)
        if (children[i + 1] < 0) {
          children.splice(i, 3);
          i -= 3;
        }
      for (let i = 0, j = 0; i < built.children.length; i += 3) {
        let from3 = built.children[i];
        while (j < children.length && children[j] < from3)
          j += 3;
        children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
      }
    }
    return new DecorationSet(newLocal.sort(byPos), children);
  }
  function moveSpans(spans, offset2) {
    if (!offset2 || !spans.length)
      return spans;
    let result = [];
    for (let i = 0; i < spans.length; i++) {
      let span = spans[i];
      result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
    }
    return result;
  }
  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
    function gather(set2, oldOffset2) {
      for (let i = 0; i < set2.local.length; i++) {
        let mapped = set2.local[i].map(mapping, offset2, oldOffset2);
        if (mapped)
          decorations.push(mapped);
        else if (options.onRemove)
          options.onRemove(set2.local[i].spec);
      }
      for (let i = 0; i < set2.children.length; i += 3)
        gather(set2.children[i + 2], set2.children[i] + oldOffset2 + 1);
    }
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] == -1)
        gather(children[i + 2], oldChildren[i] + oldOffset + 1);
    return decorations;
  }
  function takeSpansForNode(spans, node, offset2) {
    if (node.isLeaf)
      return null;
    let end2 = offset2 + node.nodeSize, found2 = null;
    for (let i = 0, span; i < spans.length; i++) {
      if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
        (found2 || (found2 = [])).push(span);
        spans[i] = null;
      }
    }
    return found2;
  }
  function withoutNulls(array) {
    let result = [];
    for (let i = 0; i < array.length; i++)
      if (array[i] != null)
        result.push(array[i]);
    return result;
  }
  function buildTree(spans, node, offset2, options) {
    let children = [], hasNulls = false;
    node.forEach((childNode, localStart) => {
      let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
      if (found2) {
        hasNulls = true;
        let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
        if (subtree != empty)
          children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    });
    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
    for (let i = 0; i < locals.length; i++)
      if (!locals[i].type.valid(node, locals[i])) {
        if (options.onRemove)
          options.onRemove(locals[i].spec);
        locals.splice(i--, 1);
      }
    return locals.length || children.length ? new DecorationSet(locals, children) : empty;
  }
  function byPos(a, b) {
    return a.from - b.from || a.to - b.to;
  }
  function removeOverlap(spans) {
    let working = spans;
    for (let i = 0; i < working.length - 1; i++) {
      let span = working[i];
      if (span.from != span.to)
        for (let j = i + 1; j < working.length; j++) {
          let next = working[j];
          if (next.from == span.from) {
            if (next.to != span.to) {
              if (working == spans)
                working = spans.slice();
              working[j] = next.copy(next.from, span.to);
              insertAhead(working, j + 1, next.copy(span.to, next.to));
            }
            continue;
          } else {
            if (next.from < span.to) {
              if (working == spans)
                working = spans.slice();
              working[i] = span.copy(span.from, next.from);
              insertAhead(working, j, span.copy(next.from, span.to));
            }
            break;
          }
        }
    }
    return working;
  }
  function insertAhead(array, i, deco) {
    while (i < array.length && byPos(deco, array[i]) > 0)
      i++;
    array.splice(i, 0, deco);
  }
  function viewDecorations(view) {
    let found2 = [];
    view.someProp("decorations", (f) => {
      let result = f(view.state);
      if (result && result != empty)
        found2.push(result);
    });
    if (view.cursorWrapper)
      found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    return DecorationGroup.from(found2);
  }
  function checkCSS(view) {
    if (cssChecked.has(view))
      return;
    cssChecked.set(view, null);
    if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
      view.requiresGeckoHackNode = gecko;
      if (cssCheckWarned)
        return;
      console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      cssCheckWarned = true;
    }
  }
  function safariShadowSelectionRange(view) {
    let found2;
    function read2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found2 = event.getTargetRanges()[0];
    }
    view.dom.addEventListener("beforeinput", read2, true);
    document.execCommand("indent");
    view.dom.removeEventListener("beforeinput", read2, true);
    let anchorNode = found2.startContainer, anchorOffset = found2.startOffset;
    let focusNode = found2.endContainer, focusOffset = found2.endOffset;
    let currentAnchor = view.domAtPos(view.state.selection.anchor);
    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function parseBetween(view, from_, to_) {
    let { node: parent, fromOffset, toOffset, from: from3, to: to2 } = view.docView.parseRange(from_, to_);
    let domSel = view.domSelectionRange();
    let find3;
    let anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
      find3 = [{ node: anchor, offset: domSel.anchorOffset }];
      if (!selectionCollapsed(domSel))
        find3.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
    if (chrome && view.input.lastKeyCode === 8) {
      for (let off2 = toOffset; off2 > fromOffset; off2--) {
        let node = parent.childNodes[off2 - 1], desc = node.pmViewDesc;
        if (node.nodeName == "BR" && !desc) {
          toOffset = off2;
          break;
        }
        if (!desc || desc.size)
          break;
      }
    }
    let startDoc = view.state.doc;
    let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    let $from = startDoc.resolve(from3);
    let sel = null, doc3 = parser.parse(parent, {
      topNode: $from.parent,
      topMatch: $from.parent.contentMatchAt($from.index()),
      topOpen: true,
      from: fromOffset,
      to: toOffset,
      preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: find3,
      ruleFromNode,
      context: $from
    });
    if (find3 && find3[0].pos != null) {
      let anchor2 = find3[0].pos, head = find3[1] && find3[1].pos;
      if (head == null)
        head = anchor2;
      sel = { anchor: anchor2 + from3, head: head + from3 };
    }
    return { doc: doc3, sel, from: from3, to: to2 };
  }
  function ruleFromNode(dom) {
    let desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        let skip2 = document.createElement("div");
        skip2.appendChild(document.createElement("li"));
        return { skip: skip2 };
      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
        return { ignore: true };
      }
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return { ignore: true };
    }
    return null;
  }
  function readDOMChange(view, from3, to2, typeOver, addedNodes) {
    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
    view.input.compositionPendingChanges = 0;
    if (from3 < 0) {
      let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
      let newSel = selectionFromDOM(view, origin);
      if (newSel && !view.state.selection.eq(newSel)) {
        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
          return;
        let tr3 = view.state.tr.setSelection(newSel);
        if (origin == "pointer")
          tr3.setMeta("pointer", true);
        else if (origin == "key")
          tr3.scrollIntoView();
        if (compositionID)
          tr3.setMeta("composition", compositionID);
        view.dispatch(tr3);
      }
      return;
    }
    let $before = view.state.doc.resolve(from3);
    let shared = $before.sharedDepth(to2);
    from3 = $before.before(shared + 1);
    to2 = view.state.doc.resolve(to2).after(shared + 1);
    let sel = view.state.selection;
    let parse2 = parseBetween(view, from3, to2);
    let doc3 = view.state.doc, compare = doc3.slice(parse2.from, parse2.to);
    let preferredPos, preferredSide;
    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
      preferredPos = view.state.selection.to;
      preferredSide = "end";
    } else {
      preferredPos = view.state.selection.from;
      preferredSide = "start";
    }
    view.input.lastKeyCode = null;
    let change = findDiff(compare.content, parse2.doc.content, parse2.from, preferredPos, preferredSide);
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (!change) {
      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse2.sel && parse2.sel.anchor != parse2.sel.head)) {
        change = { start: sel.from, endA: sel.to, endB: sel.to };
      } else {
        if (parse2.sel) {
          let sel2 = resolveSelection(view, view.state.doc, parse2.sel);
          if (sel2 && !sel2.eq(view.state.selection)) {
            let tr3 = view.state.tr.setSelection(sel2);
            if (compositionID)
              tr3.setMeta("composition", compositionID);
            view.dispatch(tr3);
          }
        }
        return;
      }
    }
    if (chrome && view.cursorWrapper && parse2.sel && parse2.sel.anchor == view.cursorWrapper.deco.from && parse2.sel.head == parse2.sel.anchor) {
      let size = change.endB - change.start;
      parse2.sel = { anchor: parse2.sel.anchor + size, head: parse2.sel.anchor + size };
    }
    view.input.domChangeCount++;
    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse2.from) {
        change.start = view.state.selection.from;
      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse2.to) {
        change.endB += view.state.selection.to - change.endA;
        change.endA = view.state.selection.to;
      }
    }
    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse2.from && parse2.doc.textBetween(change.start - parse2.from - 1, change.start - parse2.from + 1) == " \xA0") {
      change.start--;
      change.endA--;
      change.endB--;
    }
    let $from = parse2.doc.resolveNoCache(change.start - parse2.from);
    let $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
    let $fromA = doc3.resolve(change.start);
    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
    let nextSel;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse2.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse2.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (view.state.selection.anchor > change.start && looksLikeJoin(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
      if (android && chrome)
        view.domObserver.suppressSelectionUpdates();
      return;
    }
    if (chrome && android && change.endB == change.start)
      view.input.lastAndroidDelete = Date.now();
    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse2.sel && parse2.sel.anchor == parse2.sel.head && parse2.sel.head == change.endA) {
      change.endB -= 2;
      $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
      setTimeout(() => {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        });
      }, 20);
    }
    let chFrom = change.start, chTo = change.endA;
    let tr2, storedMarks, markChange;
    if (inlineChange) {
      if ($from.pos == $to.pos) {
        if (ie && ie_version <= 11 && $from.parentOffset == 0) {
          view.domObserver.suppressSelectionUpdates();
          setTimeout(() => selectionToDOM(view), 20);
        }
        tr2 = view.state.tr.delete(chFrom, chTo);
        storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
      } else if (
        // Adding or removing a mark
        change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
      ) {
        tr2 = view.state.tr;
        if (markChange.type == "add")
          tr2.addMark(chFrom, chTo, markChange.mark);
        else
          tr2.removeMark(chFrom, chTo, markChange.mark);
      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
        let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
        if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
          return;
        tr2 = view.state.tr.insertText(text, chFrom, chTo);
      }
    }
    if (!tr2)
      tr2 = view.state.tr.replace(chFrom, chTo, parse2.doc.slice(change.start - parse2.from, change.endB - parse2.from));
    if (parse2.sel) {
      let sel2 = resolveSelection(view, tr2.doc, parse2.sel);
      if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
        tr2.setSelection(sel2);
    }
    if (storedMarks)
      tr2.ensureMarks(storedMarks);
    if (compositionID)
      tr2.setMeta("composition", compositionID);
    view.dispatch(tr2.scrollIntoView());
  }
  function resolveSelection(view, doc3, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
      return null;
    return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
  }
  function isMarkChange(cur, prev) {
    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
    let added = curMarks, removed = prevMarks, type, mark, update;
    for (let i = 0; i < prevMarks.length; i++)
      added = prevMarks[i].removeFromSet(added);
    for (let i = 0; i < curMarks.length; i++)
      removed = curMarks[i].removeFromSet(removed);
    if (added.length == 1 && removed.length == 0) {
      mark = added[0];
      type = "add";
      update = (node) => node.mark(mark.addToSet(node.marks));
    } else if (added.length == 0 && removed.length == 1) {
      mark = removed[0];
      type = "remove";
      update = (node) => node.mark(mark.removeFromSet(node.marks));
    } else {
      return null;
    }
    let updated = [];
    for (let i = 0; i < prev.childCount; i++)
      updated.push(update(prev.child(i)));
    if (Fragment.from(updated).eq(cur))
      return { mark, type };
  }
  function looksLikeJoin(old, start3, end2, $newStart, $newEnd) {
    if (!$newStart.parent.isTextblock || // The content must have shrunk
    end2 - start3 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
      return false;
    let $start = old.resolve(start3);
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
      return false;
    let $next = old.resolve(skipClosingAndOpening($start, true, true));
    if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
      return false;
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
  }
  function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
      depth--;
      end2++;
      fromEnd = false;
    }
    if (mayOpen) {
      let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
      while (next && !next.isLeaf) {
        next = next.firstChild;
        end2++;
      }
    }
    return end2;
  }
  function findDiff(a, b, pos, preferredPos, preferredSide) {
    let start3 = a.findDiffStart(b, pos);
    if (start3 == null)
      return null;
    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
    if (preferredSide == "end") {
      let adjust = Math.max(0, start3 - Math.min(endA, endB));
      preferredPos -= endA + adjust - start3;
    }
    if (endA < start3 && a.size < b.size) {
      let move = preferredPos <= start3 && preferredPos >= endA ? start3 - preferredPos : 0;
      start3 -= move;
      if (start3 && start3 < b.size && isSurrogatePair(b.textBetween(start3 - 1, start3 + 1)))
        start3 += move ? 1 : -1;
      endB = start3 + (endB - endA);
      endA = start3;
    } else if (endB < start3) {
      let move = preferredPos <= start3 && preferredPos >= endB ? start3 - preferredPos : 0;
      start3 -= move;
      if (start3 && start3 < a.size && isSurrogatePair(a.textBetween(start3 - 1, start3 + 1)))
        start3 += move ? 1 : -1;
      endA = start3 + (endA - endB);
      endB = start3;
    }
    return { start: start3, endA, endB };
  }
  function isSurrogatePair(str) {
    if (str.length != 2)
      return false;
    let a = str.charCodeAt(0), b = str.charCodeAt(1);
    return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
  }
  function computeDocDeco(view) {
    let attrs = /* @__PURE__ */ Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    view.someProp("attributes", (value) => {
      if (typeof value == "function")
        value = value(view.state);
      if (value)
        for (let attr in value) {
          if (attr == "class")
            attrs.class += " " + value[attr];
          else if (attr == "style")
            attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
          else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
            attrs[attr] = String(value[attr]);
        }
    });
    if (!attrs.translate)
      attrs.translate = "no";
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
  }
  function updateCursorWrapper(view) {
    if (view.markCursor) {
      let dom = document.createElement("img");
      dom.className = "ProseMirror-separator";
      dom.setAttribute("mark-placeholder", "true");
      dom.setAttribute("alt", "");
      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
    } else {
      view.cursorWrapper = null;
    }
  }
  function getEditable(view) {
    return !view.someProp("editable", (value) => value(view.state) === false);
  }
  function selectionContextChanged(sel1, sel2) {
    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
  }
  function buildNodeViews(view) {
    let result = /* @__PURE__ */ Object.create(null);
    function add2(obj) {
      for (let prop in obj)
        if (!Object.prototype.hasOwnProperty.call(result, prop))
          result[prop] = obj[prop];
    }
    view.someProp("nodeViews", add2);
    view.someProp("markViews", add2);
    return result;
  }
  function changedNodeViews(a, b) {
    let nA = 0, nB = 0;
    for (let prop in a) {
      if (a[prop] != b[prop])
        return true;
      nA++;
    }
    for (let _ in b)
      nB++;
    return nA != nB;
  }
  function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  var domIndex, parentNode, reusedRange, textRange, isEquivalentPosition, atomElements, selectionCollapsed, nav, doc2, agent, ie_edge, ie_upto10, ie_11up, ie, ie_version, gecko, _chrome, chrome, chrome_version, safari, ios, mac, windows, android, webkit, webkit_version, preventScrollSupported, BIDI, maybeRTL, cachedState, cachedDir, cachedResult, NOT_DIRTY, CHILD_DIRTY, CONTENT_DIRTY, NODE_DIRTY, ViewDesc, WidgetViewDesc, CompositionViewDesc, MarkViewDesc, NodeViewDesc, TextViewDesc, TrailingHackViewDesc, CustomNodeViewDesc, OuterDecoLevel, noDeco, ViewTreeUpdater, brokenSelectBetweenUneditable, inlineParents, wrapMap, _detachedDoc, handlers, editHandlers, passiveHandlers, InputState, selectNodeModifier, MouseDown, timeoutComposition, brokenClipboardAPI, Dragging, dragCopyModifier, WidgetType, InlineType, NodeType2, Decoration, none, noSpec, DecorationSet, empty, DecorationGroup, observeOptions, useCharData, SelectionState, DOMObserver, cssChecked, cssCheckWarned, isInline, EditorView;
  var init_dist6 = __esm({
    "node_modules/prosemirror-view/dist/index.js"() {
      init_dist4();
      init_dist2();
      init_dist3();
      domIndex = function(node) {
        for (var index3 = 0; ; index3++) {
          node = node.previousSibling;
          if (!node)
            return index3;
        }
      };
      parentNode = function(node) {
        let parent = node.assignedSlot || node.parentNode;
        return parent && parent.nodeType == 11 ? parent.host : parent;
      };
      reusedRange = null;
      textRange = function(node, from3, to2) {
        let range = reusedRange || (reusedRange = document.createRange());
        range.setEnd(node, to2 == null ? node.nodeValue.length : to2);
        range.setStart(node, from3 || 0);
        return range;
      };
      isEquivalentPosition = function(node, off2, targetNode, targetOff) {
        return targetNode && (scanFor(node, off2, targetNode, targetOff, -1) || scanFor(node, off2, targetNode, targetOff, 1));
      };
      atomElements = /^(img|br|input|textarea|hr)$/i;
      selectionCollapsed = function(domSel) {
        return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
      };
      nav = typeof navigator != "undefined" ? navigator : null;
      doc2 = typeof document != "undefined" ? document : null;
      agent = nav && nav.userAgent || "";
      ie_edge = /Edge\/(\d+)/.exec(agent);
      ie_upto10 = /MSIE \d/.exec(agent);
      ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
      ie = !!(ie_upto10 || ie_11up || ie_edge);
      ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
      gecko = !ie && /gecko\/(\d+)/i.test(agent);
      gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
      _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
      chrome = !!_chrome;
      chrome_version = _chrome ? +_chrome[1] : 0;
      safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
      ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
      mac = ios || (nav ? /Mac/.test(nav.platform) : false);
      windows = nav ? /Win/.test(nav.platform) : false;
      android = /Android \d/.test(agent);
      webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
      webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
      preventScrollSupported = null;
      BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      maybeRTL = /[\u0590-\u08ac]/;
      cachedState = null;
      cachedDir = null;
      cachedResult = false;
      NOT_DIRTY = 0;
      CHILD_DIRTY = 1;
      CONTENT_DIRTY = 2;
      NODE_DIRTY = 3;
      ViewDesc = class {
        constructor(parent, children, dom, contentDOM) {
          this.parent = parent;
          this.children = children;
          this.dom = dom;
          this.contentDOM = contentDOM;
          this.dirty = NOT_DIRTY;
          dom.pmViewDesc = this;
        }
        // Used to check whether a given description corresponds to a
        // widget/mark/node.
        matchesWidget(widget) {
          return false;
        }
        matchesMark(mark) {
          return false;
        }
        matchesNode(node, outerDeco, innerDeco) {
          return false;
        }
        matchesHack(nodeName) {
          return false;
        }
        // When parsing in-editor content (in domchange.js), we allow
        // descriptions to determine the parse rules that should be used to
        // parse them.
        parseRule() {
          return null;
        }
        // Used by the editor's event handler to ignore events that come
        // from certain descs.
        stopEvent(event) {
          return false;
        }
        // The size of the content represented by this desc.
        get size() {
          let size = 0;
          for (let i = 0; i < this.children.length; i++)
            size += this.children[i].size;
          return size;
        }
        // For block nodes, this represents the space taken up by their
        // start/end tokens.
        get border() {
          return 0;
        }
        destroy() {
          this.parent = void 0;
          if (this.dom.pmViewDesc == this)
            this.dom.pmViewDesc = void 0;
          for (let i = 0; i < this.children.length; i++)
            this.children[i].destroy();
        }
        posBeforeChild(child) {
          for (let i = 0, pos = this.posAtStart; ; i++) {
            let cur = this.children[i];
            if (cur == child)
              return pos;
            pos += cur.size;
          }
        }
        get posBefore() {
          return this.parent.posBeforeChild(this);
        }
        get posAtStart() {
          return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
        }
        get posAfter() {
          return this.posBefore + this.size;
        }
        get posAtEnd() {
          return this.posAtStart + this.size - 2 * this.border;
        }
        localPosFromDOM(dom, offset2, bias) {
          if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
            if (bias < 0) {
              let domBefore, desc;
              if (dom == this.contentDOM) {
                domBefore = dom.childNodes[offset2 - 1];
              } else {
                while (dom.parentNode != this.contentDOM)
                  dom = dom.parentNode;
                domBefore = dom.previousSibling;
              }
              while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
                domBefore = domBefore.previousSibling;
              return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
            } else {
              let domAfter, desc;
              if (dom == this.contentDOM) {
                domAfter = dom.childNodes[offset2];
              } else {
                while (dom.parentNode != this.contentDOM)
                  dom = dom.parentNode;
                domAfter = dom.nextSibling;
              }
              while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
                domAfter = domAfter.nextSibling;
              return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
            }
          }
          let atEnd;
          if (dom == this.dom && this.contentDOM) {
            atEnd = offset2 > domIndex(this.contentDOM);
          } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
          } else if (this.dom.firstChild) {
            if (offset2 == 0)
              for (let search = dom; ; search = search.parentNode) {
                if (search == this.dom) {
                  atEnd = false;
                  break;
                }
                if (search.previousSibling)
                  break;
              }
            if (atEnd == null && offset2 == dom.childNodes.length)
              for (let search = dom; ; search = search.parentNode) {
                if (search == this.dom) {
                  atEnd = true;
                  break;
                }
                if (search.nextSibling)
                  break;
              }
          }
          return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
        }
        nearestDesc(dom, onlyNodes = false) {
          for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
            let desc = this.getDesc(cur), nodeDOM;
            if (desc && (!onlyNodes || desc.node)) {
              if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
                first2 = false;
              else
                return desc;
            }
          }
        }
        getDesc(dom) {
          let desc = dom.pmViewDesc;
          for (let cur = desc; cur; cur = cur.parent)
            if (cur == this)
              return desc;
        }
        posFromDOM(dom, offset2, bias) {
          for (let scan = dom; scan; scan = scan.parentNode) {
            let desc = this.getDesc(scan);
            if (desc)
              return desc.localPosFromDOM(dom, offset2, bias);
          }
          return -1;
        }
        // Find the desc for the node after the given pos, if any. (When a
        // parent node overrode rendering, there might not be one.)
        descAt(pos) {
          for (let i = 0, offset2 = 0; i < this.children.length; i++) {
            let child = this.children[i], end2 = offset2 + child.size;
            if (offset2 == pos && end2 != offset2) {
              while (!child.border && child.children.length)
                child = child.children[0];
              return child;
            }
            if (pos < end2)
              return child.descAt(pos - offset2 - child.border);
            offset2 = end2;
          }
        }
        domFromPos(pos, side) {
          if (!this.contentDOM)
            return { node: this.dom, offset: 0, atom: pos + 1 };
          let i = 0, offset2 = 0;
          for (let curPos = 0; i < this.children.length; i++) {
            let child = this.children[i], end2 = curPos + child.size;
            if (end2 > pos || child instanceof TrailingHackViewDesc) {
              offset2 = pos - curPos;
              break;
            }
            curPos = end2;
          }
          if (offset2)
            return this.children[i].domFromPos(offset2 - this.children[i].border, side);
          for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
          }
          if (side <= 0) {
            let prev, enter2 = true;
            for (; ; i--, enter2 = false) {
              prev = i ? this.children[i - 1] : null;
              if (!prev || prev.dom.parentNode == this.contentDOM)
                break;
            }
            if (prev && side && enter2 && !prev.border && !prev.domAtom)
              return prev.domFromPos(prev.size, side);
            return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
          } else {
            let next, enter2 = true;
            for (; ; i++, enter2 = false) {
              next = i < this.children.length ? this.children[i] : null;
              if (!next || next.dom.parentNode == this.contentDOM)
                break;
            }
            if (next && enter2 && !next.border && !next.domAtom)
              return next.domFromPos(0, side);
            return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
          }
        }
        // Used to find a DOM range in a single parent for a given changed
        // range.
        parseRange(from3, to2, base2 = 0) {
          if (this.children.length == 0)
            return { node: this.contentDOM, from: from3, to: to2, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
          let fromOffset = -1, toOffset = -1;
          for (let offset2 = base2, i = 0; ; i++) {
            let child = this.children[i], end2 = offset2 + child.size;
            if (fromOffset == -1 && from3 <= end2) {
              let childBase = offset2 + child.border;
              if (from3 >= childBase && to2 <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
                return child.parseRange(from3, to2, childBase);
              from3 = offset2;
              for (let j = i; j > 0; j--) {
                let prev = this.children[j - 1];
                if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
                  fromOffset = domIndex(prev.dom) + 1;
                  break;
                }
                from3 -= prev.size;
              }
              if (fromOffset == -1)
                fromOffset = 0;
            }
            if (fromOffset > -1 && (end2 > to2 || i == this.children.length - 1)) {
              to2 = end2;
              for (let j = i + 1; j < this.children.length; j++) {
                let next = this.children[j];
                if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
                  toOffset = domIndex(next.dom);
                  break;
                }
                to2 += next.size;
              }
              if (toOffset == -1)
                toOffset = this.contentDOM.childNodes.length;
              break;
            }
            offset2 = end2;
          }
          return { node: this.contentDOM, from: from3, to: to2, fromOffset, toOffset };
        }
        emptyChildAt(side) {
          if (this.border || !this.contentDOM || !this.children.length)
            return false;
          let child = this.children[side < 0 ? 0 : this.children.length - 1];
          return child.size == 0 || child.emptyChildAt(side);
        }
        domAfterPos(pos) {
          let { node, offset: offset2 } = this.domFromPos(pos, 0);
          if (node.nodeType != 1 || offset2 == node.childNodes.length)
            throw new RangeError("No node after pos " + pos);
          return node.childNodes[offset2];
        }
        // View descs are responsible for setting any selection that falls
        // entirely inside of them, so that custom implementations can do
        // custom things with the selection. Note that this falls apart when
        // a selection starts in such a node and ends in another, in which
        // case we just use whatever domFromPos produces as a best effort.
        setSelection(anchor, head, root, force = false) {
          let from3 = Math.min(anchor, head), to2 = Math.max(anchor, head);
          for (let i = 0, offset2 = 0; i < this.children.length; i++) {
            let child = this.children[i], end2 = offset2 + child.size;
            if (from3 > offset2 && to2 < end2)
              return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, root, force);
            offset2 = end2;
          }
          let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
          let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
          let domSel = root.getSelection();
          let brKludge = false;
          if ((gecko || safari) && anchor == head) {
            let { node, offset: offset2 } = anchorDOM;
            if (node.nodeType == 3) {
              brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
              if (brKludge && offset2 == node.nodeValue.length) {
                for (let scan = node, after; scan; scan = scan.parentNode) {
                  if (after = scan.nextSibling) {
                    if (after.nodeName == "BR")
                      anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                    break;
                  }
                  let desc = scan.pmViewDesc;
                  if (desc && desc.node && desc.node.isBlock)
                    break;
                }
              }
            } else {
              let prev = node.childNodes[offset2 - 1];
              brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
            }
          }
          if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
            let after = domSel.focusNode.childNodes[domSel.focusOffset];
            if (after && after.contentEditable == "false")
              force = true;
          }
          if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
            return;
          let domSelExtended = false;
          if ((domSel.extend || anchor == head) && !brKludge) {
            domSel.collapse(anchorDOM.node, anchorDOM.offset);
            try {
              if (anchor != head)
                domSel.extend(headDOM.node, headDOM.offset);
              domSelExtended = true;
            } catch (_) {
            }
          }
          if (!domSelExtended) {
            if (anchor > head) {
              let tmp = anchorDOM;
              anchorDOM = headDOM;
              headDOM = tmp;
            }
            let range = document.createRange();
            range.setEnd(headDOM.node, headDOM.offset);
            range.setStart(anchorDOM.node, anchorDOM.offset);
            domSel.removeAllRanges();
            domSel.addRange(range);
          }
        }
        ignoreMutation(mutation) {
          return !this.contentDOM && mutation.type != "selection";
        }
        get contentLost() {
          return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
        }
        // Remove a subtree of the element tree that has been touched
        // by a DOM change, so that the next update will redraw it.
        markDirty(from3, to2) {
          for (let offset2 = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end2 = offset2 + child.size;
            if (offset2 == end2 ? from3 <= end2 && to2 >= offset2 : from3 < end2 && to2 > offset2) {
              let startInside = offset2 + child.border, endInside = end2 - child.border;
              if (from3 >= startInside && to2 <= endInside) {
                this.dirty = from3 == offset2 || to2 == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
                if (from3 == startInside && to2 == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
                  child.dirty = NODE_DIRTY;
                else
                  child.markDirty(from3 - startInside, to2 - startInside);
                return;
              } else {
                child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
              }
            }
            offset2 = end2;
          }
          this.dirty = CONTENT_DIRTY;
        }
        markParentsDirty() {
          let level = 1;
          for (let node = this.parent; node; node = node.parent, level++) {
            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
            if (node.dirty < dirty)
              node.dirty = dirty;
          }
        }
        get domAtom() {
          return false;
        }
        get ignoreForCoords() {
          return false;
        }
      };
      WidgetViewDesc = class extends ViewDesc {
        constructor(parent, widget, view, pos) {
          let self2, dom = widget.type.toDOM;
          if (typeof dom == "function")
            dom = dom(view, () => {
              if (!self2)
                return pos;
              if (self2.parent)
                return self2.parent.posBeforeChild(self2);
            });
          if (!widget.type.spec.raw) {
            if (dom.nodeType != 1) {
              let wrap2 = document.createElement("span");
              wrap2.appendChild(dom);
              dom = wrap2;
            }
            dom.contentEditable = "false";
            dom.classList.add("ProseMirror-widget");
          }
          super(parent, [], dom, null);
          this.widget = widget;
          this.widget = widget;
          self2 = this;
        }
        matchesWidget(widget) {
          return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
        }
        parseRule() {
          return { ignore: true };
        }
        stopEvent(event) {
          let stop = this.widget.spec.stopEvent;
          return stop ? stop(event) : false;
        }
        ignoreMutation(mutation) {
          return mutation.type != "selection" || this.widget.spec.ignoreSelection;
        }
        destroy() {
          this.widget.type.destroy(this.dom);
          super.destroy();
        }
        get domAtom() {
          return true;
        }
        get side() {
          return this.widget.type.side;
        }
      };
      CompositionViewDesc = class extends ViewDesc {
        constructor(parent, dom, textDOM, text) {
          super(parent, [], dom, null);
          this.textDOM = textDOM;
          this.text = text;
        }
        get size() {
          return this.text.length;
        }
        localPosFromDOM(dom, offset2) {
          if (dom != this.textDOM)
            return this.posAtStart + (offset2 ? this.size : 0);
          return this.posAtStart + offset2;
        }
        domFromPos(pos) {
          return { node: this.textDOM, offset: pos };
        }
        ignoreMutation(mut) {
          return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
        }
      };
      MarkViewDesc = class _MarkViewDesc extends ViewDesc {
        constructor(parent, mark, dom, contentDOM) {
          super(parent, [], dom, contentDOM);
          this.mark = mark;
        }
        static create(parent, mark, inline, view) {
          let custom = view.nodeViews[mark.type.name];
          let spec = custom && custom(mark, view, inline);
          if (!spec || !spec.dom)
            spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
          return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
        }
        parseRule() {
          if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
            return null;
          return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
        }
        matchesMark(mark) {
          return this.dirty != NODE_DIRTY && this.mark.eq(mark);
        }
        markDirty(from3, to2) {
          super.markDirty(from3, to2);
          if (this.dirty != NOT_DIRTY) {
            let parent = this.parent;
            while (!parent.node)
              parent = parent.parent;
            if (parent.dirty < this.dirty)
              parent.dirty = this.dirty;
            this.dirty = NOT_DIRTY;
          }
        }
        slice(from3, to2, view) {
          let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
          let nodes = this.children, size = this.size;
          if (to2 < size)
            nodes = replaceNodes(nodes, to2, size, view);
          if (from3 > 0)
            nodes = replaceNodes(nodes, 0, from3, view);
          for (let i = 0; i < nodes.length; i++)
            nodes[i].parent = copy2;
          copy2.children = nodes;
          return copy2;
        }
      };
      NodeViewDesc = class _NodeViewDesc extends ViewDesc {
        constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
          super(parent, [], dom, contentDOM);
          this.node = node;
          this.outerDeco = outerDeco;
          this.innerDeco = innerDeco;
          this.nodeDOM = nodeDOM;
        }
        // By default, a node is rendered using the `toDOM` method from the
        // node type spec. But client code can use the `nodeViews` spec to
        // supply a custom node view, which can influence various aspects of
        // the way the node works.
        //
        // (Using subclassing for this was intentionally decided against,
        // since it'd require exposing a whole slew of finicky
        // implementation details to the user code that they probably will
        // never need.)
        static create(parent, node, outerDeco, innerDeco, view, pos) {
          let custom = view.nodeViews[node.type.name], descObj;
          let spec = custom && custom(node, view, () => {
            if (!descObj)
              return pos;
            if (descObj.parent)
              return descObj.parent.posBeforeChild(descObj);
          }, outerDeco, innerDeco);
          let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
          if (node.isText) {
            if (!dom)
              dom = document.createTextNode(node.text);
            else if (dom.nodeType != 3)
              throw new RangeError("Text must be rendered as a DOM text node");
          } else if (!dom) {
            ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
          }
          if (!contentDOM && !node.isText && dom.nodeName != "BR") {
            if (!dom.hasAttribute("contenteditable"))
              dom.contentEditable = "false";
            if (node.type.spec.draggable)
              dom.draggable = true;
          }
          let nodeDOM = dom;
          dom = applyOuterDeco(dom, outerDeco, node);
          if (spec)
            return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
          else if (node.isText)
            return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
          else
            return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
        }
        parseRule() {
          if (this.node.type.spec.reparseInView)
            return null;
          let rule = { node: this.node.type.name, attrs: this.node.attrs };
          if (this.node.type.whitespace == "pre")
            rule.preserveWhitespace = "full";
          if (!this.contentDOM) {
            rule.getContent = () => this.node.content;
          } else if (!this.contentLost) {
            rule.contentElement = this.contentDOM;
          } else {
            for (let i = this.children.length - 1; i >= 0; i--) {
              let child = this.children[i];
              if (this.dom.contains(child.dom.parentNode)) {
                rule.contentElement = child.dom.parentNode;
                break;
              }
            }
            if (!rule.contentElement)
              rule.getContent = () => Fragment.empty;
          }
          return rule;
        }
        matchesNode(node, outerDeco, innerDeco) {
          return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
        }
        get size() {
          return this.node.nodeSize;
        }
        get border() {
          return this.node.isLeaf ? 0 : 1;
        }
        // Syncs `this.children` to match `this.node.content` and the local
        // decorations, possibly introducing nesting for marks. Then, in a
        // separate step, syncs the DOM inside `this.contentDOM` to
        // `this.children`.
        updateChildren(view, pos) {
          let inline = this.node.inlineContent, off2 = pos;
          let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
          let localComposition = composition && composition.pos > -1 ? composition : null;
          let compositionInChild = composition && composition.pos < 0;
          let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
          iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
            if (widget.spec.marks)
              updater.syncToMarks(widget.spec.marks, inline, view);
            else if (widget.type.side >= 0 && !insideNode)
              updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
            updater.placeWidget(widget, view, off2);
          }, (child, outerDeco, innerDeco, i) => {
            updater.syncToMarks(child.marks, inline, view);
            let compIndex;
            if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
              ;
            else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
              ;
            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off2))
              ;
            else {
              updater.addNode(child, outerDeco, innerDeco, view, off2);
            }
            off2 += child.nodeSize;
          });
          updater.syncToMarks([], inline, view);
          if (this.node.isTextblock)
            updater.addTextblockHacks();
          updater.destroyRest();
          if (updater.changed || this.dirty == CONTENT_DIRTY) {
            if (localComposition)
              this.protectLocalComposition(view, localComposition);
            renderDescs(this.contentDOM, this.children, view);
            if (ios)
              iosHacks(this.dom);
          }
        }
        localCompositionInfo(view, pos) {
          let { from: from3, to: to2 } = view.state.selection;
          if (!(view.state.selection instanceof TextSelection) || from3 < pos || to2 > pos + this.node.content.size)
            return null;
          let sel = view.domSelectionRange();
          let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
          if (!textNode || !this.dom.contains(textNode.parentNode))
            return null;
          if (this.node.inlineContent) {
            let text = textNode.nodeValue;
            let textPos = findTextInFragment(this.node.content, text, from3 - pos, to2 - pos);
            return textPos < 0 ? null : { node: textNode, pos: textPos, text };
          } else {
            return { node: textNode, pos: -1, text: "" };
          }
        }
        protectLocalComposition(view, { node, pos, text }) {
          if (this.getDesc(node))
            return;
          let topNode = node;
          for (; ; topNode = topNode.parentNode) {
            if (topNode.parentNode == this.contentDOM)
              break;
            while (topNode.previousSibling)
              topNode.parentNode.removeChild(topNode.previousSibling);
            while (topNode.nextSibling)
              topNode.parentNode.removeChild(topNode.nextSibling);
            if (topNode.pmViewDesc)
              topNode.pmViewDesc = void 0;
          }
          let desc = new CompositionViewDesc(this, topNode, node, text);
          view.input.compositionNodes.push(desc);
          this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
        }
        // If this desc must be updated to match the given node decoration,
        // do so and return true.
        update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
            return false;
          this.updateInner(node, outerDeco, innerDeco, view);
          return true;
        }
        updateInner(node, outerDeco, innerDeco, view) {
          this.updateOuterDeco(outerDeco);
          this.node = node;
          this.innerDeco = innerDeco;
          if (this.contentDOM)
            this.updateChildren(view, this.posAtStart);
          this.dirty = NOT_DIRTY;
        }
        updateOuterDeco(outerDeco) {
          if (sameOuterDeco(outerDeco, this.outerDeco))
            return;
          let needsWrap = this.nodeDOM.nodeType != 1;
          let oldDOM = this.dom;
          this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
          if (this.dom != oldDOM) {
            oldDOM.pmViewDesc = void 0;
            this.dom.pmViewDesc = this;
          }
          this.outerDeco = outerDeco;
        }
        // Mark this node as being the selected node.
        selectNode() {
          if (this.nodeDOM.nodeType == 1)
            this.nodeDOM.classList.add("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable)
            this.dom.draggable = true;
        }
        // Remove selected node marking from this node.
        deselectNode() {
          if (this.nodeDOM.nodeType == 1)
            this.nodeDOM.classList.remove("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable)
            this.dom.removeAttribute("draggable");
        }
        get domAtom() {
          return this.node.isAtom;
        }
      };
      TextViewDesc = class _TextViewDesc extends NodeViewDesc {
        constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
          super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
        }
        parseRule() {
          let skip2 = this.nodeDOM.parentNode;
          while (skip2 && skip2 != this.dom && !skip2.pmIsDeco)
            skip2 = skip2.parentNode;
          return { skip: skip2 || true };
        }
        update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
            return false;
          this.updateOuterDeco(outerDeco);
          if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
            this.nodeDOM.nodeValue = node.text;
            if (view.trackWrites == this.nodeDOM)
              view.trackWrites = null;
          }
          this.node = node;
          this.dirty = NOT_DIRTY;
          return true;
        }
        inParent() {
          let parentDOM = this.parent.contentDOM;
          for (let n = this.nodeDOM; n; n = n.parentNode)
            if (n == parentDOM)
              return true;
          return false;
        }
        domFromPos(pos) {
          return { node: this.nodeDOM, offset: pos };
        }
        localPosFromDOM(dom, offset2, bias) {
          if (dom == this.nodeDOM)
            return this.posAtStart + Math.min(offset2, this.node.text.length);
          return super.localPosFromDOM(dom, offset2, bias);
        }
        ignoreMutation(mutation) {
          return mutation.type != "characterData" && mutation.type != "selection";
        }
        slice(from3, to2, view) {
          let node = this.node.cut(from3, to2), dom = document.createTextNode(node.text);
          return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
        }
        markDirty(from3, to2) {
          super.markDirty(from3, to2);
          if (this.dom != this.nodeDOM && (from3 == 0 || to2 == this.nodeDOM.nodeValue.length))
            this.dirty = NODE_DIRTY;
        }
        get domAtom() {
          return false;
        }
      };
      TrailingHackViewDesc = class extends ViewDesc {
        parseRule() {
          return { ignore: true };
        }
        matchesHack(nodeName) {
          return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
        }
        get domAtom() {
          return true;
        }
        get ignoreForCoords() {
          return this.dom.nodeName == "IMG";
        }
      };
      CustomNodeViewDesc = class extends NodeViewDesc {
        constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
          super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
          this.spec = spec;
        }
        // A custom `update` method gets to decide whether the update goes
        // through. If it does, and there's a `contentDOM` node, our logic
        // updates the children.
        update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY)
            return false;
          if (this.spec.update) {
            let result = this.spec.update(node, outerDeco, innerDeco);
            if (result)
              this.updateInner(node, outerDeco, innerDeco, view);
            return result;
          } else if (!this.contentDOM && !node.isLeaf) {
            return false;
          } else {
            return super.update(node, outerDeco, innerDeco, view);
          }
        }
        selectNode() {
          this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
        }
        deselectNode() {
          this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
        }
        setSelection(anchor, head, root, force) {
          this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);
        }
        destroy() {
          if (this.spec.destroy)
            this.spec.destroy();
          super.destroy();
        }
        stopEvent(event) {
          return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
        }
        ignoreMutation(mutation) {
          return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
        }
      };
      OuterDecoLevel = function(nodeName) {
        if (nodeName)
          this.nodeName = nodeName;
      };
      OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
      noDeco = [new OuterDecoLevel()];
      ViewTreeUpdater = class {
        constructor(top2, lock, view) {
          this.lock = lock;
          this.view = view;
          this.index = 0;
          this.stack = [];
          this.changed = false;
          this.top = top2;
          this.preMatch = preMatch(top2.node.content, top2);
        }
        // Destroy and remove the children between the given indices in
        // `this.top`.
        destroyBetween(start3, end2) {
          if (start3 == end2)
            return;
          for (let i = start3; i < end2; i++)
            this.top.children[i].destroy();
          this.top.children.splice(start3, end2 - start3);
          this.changed = true;
        }
        // Destroy all remaining children in `this.top`.
        destroyRest() {
          this.destroyBetween(this.index, this.top.children.length);
        }
        // Sync the current stack of mark descs with the given array of
        // marks, reusing existing mark descs when possible.
        syncToMarks(marks, inline, view) {
          let keep = 0, depth = this.stack.length >> 1;
          let maxKeep = Math.min(depth, marks.length);
          while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
            keep++;
          while (keep < depth) {
            this.destroyRest();
            this.top.dirty = NOT_DIRTY;
            this.index = this.stack.pop();
            this.top = this.stack.pop();
            depth--;
          }
          while (depth < marks.length) {
            this.stack.push(this.top, this.index + 1);
            let found2 = -1;
            for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
              let next = this.top.children[i];
              if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
                found2 = i;
                break;
              }
            }
            if (found2 > -1) {
              if (found2 > this.index) {
                this.changed = true;
                this.destroyBetween(this.index, found2);
              }
              this.top = this.top.children[this.index];
            } else {
              let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
              this.top.children.splice(this.index, 0, markDesc);
              this.top = markDesc;
              this.changed = true;
            }
            this.index = 0;
            depth++;
          }
        }
        // Try to find a node desc matching the given data. Skip over it and
        // return true when successful.
        findNodeMatch(node, outerDeco, innerDeco, index3) {
          let found2 = -1, targetDesc;
          if (index3 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index3 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
            found2 = this.top.children.indexOf(targetDesc, this.index);
          } else {
            for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
              let child = this.top.children[i];
              if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
                found2 = i;
                break;
              }
            }
          }
          if (found2 < 0)
            return false;
          this.destroyBetween(this.index, found2);
          this.index++;
          return true;
        }
        updateNodeAt(node, outerDeco, innerDeco, index3, view) {
          let child = this.top.children[index3];
          if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
            child.dirty = CONTENT_DIRTY;
          if (!child.update(node, outerDeco, innerDeco, view))
            return false;
          this.destroyBetween(this.index, index3);
          this.index++;
          return true;
        }
        findIndexWithChild(domNode) {
          for (; ; ) {
            let parent = domNode.parentNode;
            if (!parent)
              return -1;
            if (parent == this.top.contentDOM) {
              let desc = domNode.pmViewDesc;
              if (desc)
                for (let i = this.index; i < this.top.children.length; i++) {
                  if (this.top.children[i] == desc)
                    return i;
                }
              return -1;
            }
            domNode = parent;
          }
        }
        // Try to update the next node, if any, to the given data. Checks
        // pre-matches to avoid overwriting nodes that could still be used.
        updateNextNode(node, outerDeco, innerDeco, view, index3, pos) {
          for (let i = this.index; i < this.top.children.length; i++) {
            let next = this.top.children[i];
            if (next instanceof NodeViewDesc) {
              let preMatch2 = this.preMatch.matched.get(next);
              if (preMatch2 != null && preMatch2 != index3)
                return false;
              let nextDOM = next.dom, updated;
              let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
              if (!locked && next.update(node, outerDeco, innerDeco, view)) {
                this.destroyBetween(this.index, i);
                if (next.dom != nextDOM)
                  this.changed = true;
                this.index++;
                return true;
              } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
                this.top.children[this.index] = updated;
                if (updated.contentDOM) {
                  updated.dirty = CONTENT_DIRTY;
                  updated.updateChildren(view, pos + 1);
                  updated.dirty = NOT_DIRTY;
                }
                this.changed = true;
                this.index++;
                return true;
              }
              break;
            }
          }
          return false;
        }
        // When a node with content is replaced by a different node with
        // identical content, move over its children.
        recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
          if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content))
            return null;
          let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
          if (wrapper.contentDOM) {
            wrapper.children = next.children;
            next.children = [];
            for (let ch of wrapper.children)
              ch.parent = wrapper;
          }
          next.destroy();
          return wrapper;
        }
        // Insert the node as a newly created node desc.
        addNode(node, outerDeco, innerDeco, view, pos) {
          let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
          if (desc.contentDOM)
            desc.updateChildren(view, pos + 1);
          this.top.children.splice(this.index++, 0, desc);
          this.changed = true;
        }
        placeWidget(widget, view, pos) {
          let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
          if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
            this.index++;
          } else {
            let desc = new WidgetViewDesc(this.top, widget, view, pos);
            this.top.children.splice(this.index++, 0, desc);
            this.changed = true;
          }
        }
        // Make sure a textblock looks and behaves correctly in
        // contentEditable.
        addTextblockHacks() {
          let lastChild2 = this.top.children[this.index - 1], parent = this.top;
          while (lastChild2 instanceof MarkViewDesc) {
            parent = lastChild2;
            lastChild2 = parent.children[parent.children.length - 1];
          }
          if (!lastChild2 || // Empty textblock
          !(lastChild2 instanceof TextViewDesc) || /\n$/.test(lastChild2.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild2.node.text)) {
            if ((safari || chrome) && lastChild2 && lastChild2.dom.contentEditable == "false")
              this.addHackNode("IMG", parent);
            this.addHackNode("BR", this.top);
          }
        }
        addHackNode(nodeName, parent) {
          if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
            this.index++;
          } else {
            let dom = document.createElement(nodeName);
            if (nodeName == "IMG") {
              dom.className = "ProseMirror-separator";
              dom.alt = "";
            }
            if (nodeName == "BR")
              dom.className = "ProseMirror-trailingBreak";
            let hack = new TrailingHackViewDesc(this.top, [], dom, null);
            if (parent != this.top)
              parent.children.push(hack);
            else
              parent.children.splice(this.index++, 0, hack);
            this.changed = true;
          }
        }
        isLocked(node) {
          return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
        }
      };
      brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
      inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
      wrapMap = {
        thead: ["table"],
        tbody: ["table"],
        tfoot: ["table"],
        caption: ["table"],
        colgroup: ["table"],
        col: ["table", "colgroup"],
        tr: ["table", "tbody"],
        td: ["table", "tbody", "tr"],
        th: ["table", "tbody", "tr"]
      };
      _detachedDoc = null;
      handlers = {};
      editHandlers = {};
      passiveHandlers = { touchstart: true, touchmove: true };
      InputState = class {
        constructor() {
          this.shiftKey = false;
          this.mouseDown = null;
          this.lastKeyCode = null;
          this.lastKeyCodeTime = 0;
          this.lastClick = { time: 0, x: 0, y: 0, type: "" };
          this.lastSelectionOrigin = null;
          this.lastSelectionTime = 0;
          this.lastIOSEnter = 0;
          this.lastIOSEnterFallbackTimeout = -1;
          this.lastFocus = 0;
          this.lastTouch = 0;
          this.lastAndroidDelete = 0;
          this.composing = false;
          this.composingTimeout = -1;
          this.compositionNodes = [];
          this.compositionEndedAt = -2e8;
          this.compositionID = 1;
          this.compositionPendingChanges = 0;
          this.domChangeCount = 0;
          this.eventHandlers = /* @__PURE__ */ Object.create(null);
          this.hideSelectionGuard = null;
        }
      };
      editHandlers.keydown = (view, _event) => {
        let event = _event;
        view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
        if (inOrNearComposition(view, event))
          return;
        view.input.lastKeyCode = event.keyCode;
        view.input.lastKeyCodeTime = Date.now();
        if (android && chrome && event.keyCode == 13)
          return;
        if (event.keyCode != 229)
          view.domObserver.forceFlush();
        if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
          let now2 = Date.now();
          view.input.lastIOSEnter = now2;
          view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
            if (view.input.lastIOSEnter == now2) {
              view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
              view.input.lastIOSEnter = 0;
            }
          }, 200);
        } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
          event.preventDefault();
        } else {
          setSelectionOrigin(view, "key");
        }
      };
      editHandlers.keyup = (view, event) => {
        if (event.keyCode == 16)
          view.input.shiftKey = false;
      };
      editHandlers.keypress = (view, _event) => {
        let event = _event;
        if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
          return;
        if (view.someProp("handleKeyPress", (f) => f(view, event))) {
          event.preventDefault();
          return;
        }
        let sel = view.state.selection;
        if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
          let text = String.fromCharCode(event.charCode);
          if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
            view.dispatch(view.state.tr.insertText(text).scrollIntoView());
          event.preventDefault();
        }
      };
      selectNodeModifier = mac ? "metaKey" : "ctrlKey";
      handlers.mousedown = (view, _event) => {
        let event = _event;
        view.input.shiftKey = event.shiftKey;
        let flushed = forceDOMFlush(view);
        let now2 = Date.now(), type = "singleClick";
        if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
          if (view.input.lastClick.type == "singleClick")
            type = "doubleClick";
          else if (view.input.lastClick.type == "doubleClick")
            type = "tripleClick";
        }
        view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
        let pos = view.posAtCoords(eventCoords(event));
        if (!pos)
          return;
        if (type == "singleClick") {
          if (view.input.mouseDown)
            view.input.mouseDown.done();
          view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
        } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
          event.preventDefault();
        } else {
          setSelectionOrigin(view, "pointer");
        }
      };
      MouseDown = class {
        constructor(view, pos, event, flushed) {
          this.view = view;
          this.pos = pos;
          this.event = event;
          this.flushed = flushed;
          this.delayedSelectionSync = false;
          this.mightDrag = null;
          this.startDoc = view.state.doc;
          this.selectNode = !!event[selectNodeModifier];
          this.allowDefault = event.shiftKey;
          let targetNode, targetPos;
          if (pos.inside > -1) {
            targetNode = view.state.doc.nodeAt(pos.inside);
            targetPos = pos.inside;
          } else {
            let $pos = view.state.doc.resolve(pos.pos);
            targetNode = $pos.parent;
            targetPos = $pos.depth ? $pos.before() : 0;
          }
          const target = flushed ? null : event.target;
          const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
          this.target = targetDesc ? targetDesc.dom : null;
          let { selection } = view.state;
          if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
            this.mightDrag = {
              node: targetNode,
              pos: targetPos,
              addAttr: !!(this.target && !this.target.draggable),
              setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
            };
          if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
            this.view.domObserver.stop();
            if (this.mightDrag.addAttr)
              this.target.draggable = true;
            if (this.mightDrag.setUneditable)
              setTimeout(() => {
                if (this.view.input.mouseDown == this)
                  this.target.setAttribute("contentEditable", "false");
              }, 20);
            this.view.domObserver.start();
          }
          view.root.addEventListener("mouseup", this.up = this.up.bind(this));
          view.root.addEventListener("mousemove", this.move = this.move.bind(this));
          setSelectionOrigin(view, "pointer");
        }
        done() {
          this.view.root.removeEventListener("mouseup", this.up);
          this.view.root.removeEventListener("mousemove", this.move);
          if (this.mightDrag && this.target) {
            this.view.domObserver.stop();
            if (this.mightDrag.addAttr)
              this.target.removeAttribute("draggable");
            if (this.mightDrag.setUneditable)
              this.target.removeAttribute("contentEditable");
            this.view.domObserver.start();
          }
          if (this.delayedSelectionSync)
            setTimeout(() => selectionToDOM(this.view));
          this.view.input.mouseDown = null;
        }
        up(event) {
          this.done();
          if (!this.view.dom.contains(event.target))
            return;
          let pos = this.pos;
          if (this.view.state.doc != this.startDoc)
            pos = this.view.posAtCoords(eventCoords(event));
          this.updateAllowDefault(event);
          if (this.allowDefault || !pos) {
            setSelectionOrigin(this.view, "pointer");
          } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
            event.preventDefault();
          } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
          safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
          // cursor, but still report that the node is selected
          // when asked through getSelection. You'll then get a
          // situation where clicking at the point where that
          // (hidden) cursor is doesn't change the selection, and
          // thus doesn't get a reaction from ProseMirror. This
          // works around that.
          chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
            updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
            event.preventDefault();
          } else {
            setSelectionOrigin(this.view, "pointer");
          }
        }
        move(event) {
          this.updateAllowDefault(event);
          setSelectionOrigin(this.view, "pointer");
          if (event.buttons == 0)
            this.done();
        }
        updateAllowDefault(event) {
          if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
            this.allowDefault = true;
        }
      };
      handlers.touchstart = (view) => {
        view.input.lastTouch = Date.now();
        forceDOMFlush(view);
        setSelectionOrigin(view, "pointer");
      };
      handlers.touchmove = (view) => {
        view.input.lastTouch = Date.now();
        setSelectionOrigin(view, "pointer");
      };
      handlers.contextmenu = (view) => forceDOMFlush(view);
      timeoutComposition = android ? 5e3 : -1;
      editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
        if (!view.composing) {
          view.domObserver.flush();
          let { state } = view, $pos = state.selection.$from;
          if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
            view.markCursor = view.state.storedMarks || $pos.marks();
            endComposition(view, true);
            view.markCursor = null;
          } else {
            endComposition(view);
            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
              let sel = view.domSelectionRange();
              for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
                let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
                if (!before)
                  break;
                if (before.nodeType == 3) {
                  view.domSelection().collapse(before, before.nodeValue.length);
                  break;
                } else {
                  node = before;
                  offset2 = -1;
                }
              }
            }
          }
          view.input.composing = true;
        }
        scheduleComposeEnd(view, timeoutComposition);
      };
      editHandlers.compositionend = (view, event) => {
        if (view.composing) {
          view.input.composing = false;
          view.input.compositionEndedAt = event.timeStamp;
          view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
          if (view.input.compositionPendingChanges)
            Promise.resolve().then(() => view.domObserver.flush());
          view.input.compositionID++;
          scheduleComposeEnd(view, 20);
        }
      };
      brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
      handlers.copy = editHandlers.cut = (view, _event) => {
        let event = _event;
        let sel = view.state.selection, cut2 = event.type == "cut";
        if (sel.empty)
          return;
        let data = brokenClipboardAPI ? null : event.clipboardData;
        let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
        if (data) {
          event.preventDefault();
          data.clearData();
          data.setData("text/html", dom.innerHTML);
          data.setData("text/plain", text);
        } else {
          captureCopy(view, dom);
        }
        if (cut2)
          view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
      };
      editHandlers.paste = (view, _event) => {
        let event = _event;
        if (view.composing && !android)
          return;
        let data = brokenClipboardAPI ? null : event.clipboardData;
        let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
        if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
          event.preventDefault();
        else
          capturePaste(view, event);
      };
      Dragging = class {
        constructor(slice2, move, node) {
          this.slice = slice2;
          this.move = move;
          this.node = node;
        }
      };
      dragCopyModifier = mac ? "altKey" : "ctrlKey";
      handlers.dragstart = (view, _event) => {
        let event = _event;
        let mouseDown = view.input.mouseDown;
        if (mouseDown)
          mouseDown.done();
        if (!event.dataTransfer)
          return;
        let sel = view.state.selection;
        let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
        let node;
        if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
          ;
        else if (mouseDown && mouseDown.mightDrag) {
          node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
        } else if (event.target && event.target.nodeType == 1) {
          let desc = view.docView.nearestDesc(event.target, true);
          if (desc && desc.node.type.spec.draggable && desc != view.docView)
            node = NodeSelection.create(view.state.doc, desc.posBefore);
        }
        let slice2 = (node || view.state.selection).content(), { dom, text } = serializeForClipboard(view, slice2);
        event.dataTransfer.clearData();
        event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
        event.dataTransfer.effectAllowed = "copyMove";
        if (!brokenClipboardAPI)
          event.dataTransfer.setData("text/plain", text);
        view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
      };
      handlers.dragend = (view) => {
        let dragging = view.dragging;
        window.setTimeout(() => {
          if (view.dragging == dragging)
            view.dragging = null;
        }, 50);
      };
      editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
      editHandlers.drop = (view, _event) => {
        let event = _event;
        let dragging = view.dragging;
        view.dragging = null;
        if (!event.dataTransfer)
          return;
        let eventPos = view.posAtCoords(eventCoords(event));
        if (!eventPos)
          return;
        let $mouse = view.state.doc.resolve(eventPos.pos);
        let slice2 = dragging && dragging.slice;
        if (slice2) {
          view.someProp("transformPasted", (f) => {
            slice2 = f(slice2, view);
          });
        } else {
          slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
        }
        let move = !!(dragging && !event[dragCopyModifier]);
        if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
          event.preventDefault();
          return;
        }
        if (!slice2)
          return;
        event.preventDefault();
        let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
        if (insertPos == null)
          insertPos = $mouse.pos;
        let tr2 = view.state.tr;
        if (move) {
          let { node } = dragging;
          if (node)
            node.replace(tr2);
          else
            tr2.deleteSelection();
        }
        let pos = tr2.mapping.map(insertPos);
        let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
        let beforeInsert = tr2.doc;
        if (isNode)
          tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
        else
          tr2.replaceRange(pos, pos, slice2);
        if (tr2.doc.eq(beforeInsert))
          return;
        let $pos = tr2.doc.resolve(pos);
        if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
          tr2.setSelection(new NodeSelection($pos));
        } else {
          let end2 = tr2.mapping.map(insertPos);
          tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
          tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end2)));
        }
        view.focus();
        view.dispatch(tr2.setMeta("uiEvent", "drop"));
      };
      handlers.focus = (view) => {
        view.input.lastFocus = Date.now();
        if (!view.focused) {
          view.domObserver.stop();
          view.dom.classList.add("ProseMirror-focused");
          view.domObserver.start();
          view.focused = true;
          setTimeout(() => {
            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
              selectionToDOM(view);
          }, 20);
        }
      };
      handlers.blur = (view, _event) => {
        let event = _event;
        if (view.focused) {
          view.domObserver.stop();
          view.dom.classList.remove("ProseMirror-focused");
          view.domObserver.start();
          if (event.relatedTarget && view.dom.contains(event.relatedTarget))
            view.domObserver.currentSelection.clear();
          view.focused = false;
        }
      };
      handlers.beforeinput = (view, _event) => {
        let event = _event;
        if (chrome && android && event.inputType == "deleteContentBackward") {
          view.domObserver.flushSoon();
          let { domChangeCount } = view.input;
          setTimeout(() => {
            if (view.input.domChangeCount != domChangeCount)
              return;
            view.dom.blur();
            view.focus();
            if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
              return;
            let { $cursor } = view.state.selection;
            if ($cursor && $cursor.pos > 0)
              view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
          }, 50);
        }
      };
      for (let prop in editHandlers)
        handlers[prop] = editHandlers[prop];
      WidgetType = class _WidgetType {
        constructor(toDOM, spec) {
          this.toDOM = toDOM;
          this.spec = spec || noSpec;
          this.side = this.spec.side || 0;
        }
        map(mapping, span, offset2, oldOffset) {
          let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
          return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
        }
        valid() {
          return true;
        }
        eq(other) {
          return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
        }
        destroy(node) {
          if (this.spec.destroy)
            this.spec.destroy(node);
        }
      };
      InlineType = class _InlineType {
        constructor(attrs, spec) {
          this.attrs = attrs;
          this.spec = spec || noSpec;
        }
        map(mapping, span, offset2, oldOffset) {
          let from3 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
          let to2 = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
          return from3 >= to2 ? null : new Decoration(from3, to2, this);
        }
        valid(_, span) {
          return span.from < span.to;
        }
        eq(other) {
          return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
        }
        static is(span) {
          return span.type instanceof _InlineType;
        }
        destroy() {
        }
      };
      NodeType2 = class _NodeType {
        constructor(attrs, spec) {
          this.attrs = attrs;
          this.spec = spec || noSpec;
        }
        map(mapping, span, offset2, oldOffset) {
          let from3 = mapping.mapResult(span.from + oldOffset, 1);
          if (from3.deleted)
            return null;
          let to2 = mapping.mapResult(span.to + oldOffset, -1);
          if (to2.deleted || to2.pos <= from3.pos)
            return null;
          return new Decoration(from3.pos - offset2, to2.pos - offset2, this);
        }
        valid(node, span) {
          let { index: index3, offset: offset2 } = node.content.findIndex(span.from), child;
          return offset2 == span.from && !(child = node.child(index3)).isText && offset2 + child.nodeSize == span.to;
        }
        eq(other) {
          return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
        }
        destroy() {
        }
      };
      Decoration = class _Decoration {
        /**
        @internal
        */
        constructor(from3, to2, type) {
          this.from = from3;
          this.to = to2;
          this.type = type;
        }
        /**
        @internal
        */
        copy(from3, to2) {
          return new _Decoration(from3, to2, this.type);
        }
        /**
        @internal
        */
        eq(other, offset2 = 0) {
          return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
        }
        /**
        @internal
        */
        map(mapping, offset2, oldOffset) {
          return this.type.map(mapping, this, offset2, oldOffset);
        }
        /**
        Creates a widget decoration, which is a DOM node that's shown in
        the document at the given position. It is recommended that you
        delay rendering the widget by passing a function that will be
        called when the widget is actually drawn in a view, but you can
        also directly pass a DOM node. `getPos` can be used to find the
        widget's current document position.
        */
        static widget(pos, toDOM, spec) {
          return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
        }
        /**
        Creates an inline decoration, which adds the given attributes to
        each inline node between `from` and `to`.
        */
        static inline(from3, to2, attrs, spec) {
          return new _Decoration(from3, to2, new InlineType(attrs, spec));
        }
        /**
        Creates a node decoration. `from` and `to` should point precisely
        before and after a node in the document. That node, and only that
        node, will receive the given attributes.
        */
        static node(from3, to2, attrs, spec) {
          return new _Decoration(from3, to2, new NodeType2(attrs, spec));
        }
        /**
        The spec provided when creating this decoration. Can be useful
        if you've stored extra information in that object.
        */
        get spec() {
          return this.type.spec;
        }
        /**
        @internal
        */
        get inline() {
          return this.type instanceof InlineType;
        }
        /**
        @internal
        */
        get widget() {
          return this.type instanceof WidgetType;
        }
      };
      none = [];
      noSpec = {};
      DecorationSet = class _DecorationSet {
        /**
        @internal
        */
        constructor(local, children) {
          this.local = local.length ? local : none;
          this.children = children.length ? children : none;
        }
        /**
        Create a set of decorations, using the structure of the given
        document. This will consume (modify) the `decorations` array, so
        you must make a copy if you want need to preserve that.
        */
        static create(doc3, decorations) {
          return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
        }
        /**
        Find all decorations in this set which touch the given range
        (including decorations that start or end directly at the
        boundaries) and match the given predicate on their spec. When
        `start` and `end` are omitted, all decorations in the set are
        considered. When `predicate` isn't given, all decorations are
        assumed to match.
        */
        find(start3, end2, predicate) {
          let result = [];
          this.findInner(start3 == null ? 0 : start3, end2 == null ? 1e9 : end2, result, 0, predicate);
          return result;
        }
        findInner(start3, end2, result, offset2, predicate) {
          for (let i = 0; i < this.local.length; i++) {
            let span = this.local[i];
            if (span.from <= end2 && span.to >= start3 && (!predicate || predicate(span.spec)))
              result.push(span.copy(span.from + offset2, span.to + offset2));
          }
          for (let i = 0; i < this.children.length; i += 3) {
            if (this.children[i] < end2 && this.children[i + 1] > start3) {
              let childOff = this.children[i] + 1;
              this.children[i + 2].findInner(start3 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
            }
          }
        }
        /**
        Map the set of decorations in response to a change in the
        document.
        */
        map(mapping, doc3, options) {
          if (this == empty || mapping.maps.length == 0)
            return this;
          return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
        }
        /**
        @internal
        */
        mapInner(mapping, node, offset2, oldOffset, options) {
          let newLocal;
          for (let i = 0; i < this.local.length; i++) {
            let mapped = this.local[i].map(mapping, offset2, oldOffset);
            if (mapped && mapped.type.valid(node, mapped))
              (newLocal || (newLocal = [])).push(mapped);
            else if (options.onRemove)
              options.onRemove(this.local[i].spec);
          }
          if (this.children.length)
            return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
          else
            return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
        }
        /**
        Add the given array of decorations to the ones in the set,
        producing a new set. Consumes the `decorations` array. Needs
        access to the current document to create the appropriate tree
        structure.
        */
        add(doc3, decorations) {
          if (!decorations.length)
            return this;
          if (this == empty)
            return _DecorationSet.create(doc3, decorations);
          return this.addInner(doc3, decorations, 0);
        }
        addInner(doc3, decorations, offset2) {
          let children, childIndex = 0;
          doc3.forEach((childNode, childOffset) => {
            let baseOffset = childOffset + offset2, found2;
            if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
              return;
            if (!children)
              children = this.children.slice();
            while (childIndex < children.length && children[childIndex] < childOffset)
              childIndex += 3;
            if (children[childIndex] == childOffset)
              children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
            else
              children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
            childIndex += 3;
          });
          let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
          for (let i = 0; i < local.length; i++)
            if (!local[i].type.valid(doc3, local[i]))
              local.splice(i--, 1);
          return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
        }
        /**
        Create a new set that contains the decorations in this set, minus
        the ones in the given array.
        */
        remove(decorations) {
          if (decorations.length == 0 || this == empty)
            return this;
          return this.removeInner(decorations, 0);
        }
        removeInner(decorations, offset2) {
          let children = this.children, local = this.local;
          for (let i = 0; i < children.length; i += 3) {
            let found2;
            let from3 = children[i] + offset2, to2 = children[i + 1] + offset2;
            for (let j = 0, span; j < decorations.length; j++)
              if (span = decorations[j]) {
                if (span.from > from3 && span.to < to2) {
                  decorations[j] = null;
                  (found2 || (found2 = [])).push(span);
                }
              }
            if (!found2)
              continue;
            if (children == this.children)
              children = this.children.slice();
            let removed = children[i + 2].removeInner(found2, from3 + 1);
            if (removed != empty) {
              children[i + 2] = removed;
            } else {
              children.splice(i, 3);
              i -= 3;
            }
          }
          if (local.length) {
            for (let i = 0, span; i < decorations.length; i++)
              if (span = decorations[i]) {
                for (let j = 0; j < local.length; j++)
                  if (local[j].eq(span, offset2)) {
                    if (local == this.local)
                      local = this.local.slice();
                    local.splice(j--, 1);
                  }
              }
          }
          if (children == this.children && local == this.local)
            return this;
          return local.length || children.length ? new _DecorationSet(local, children) : empty;
        }
        /**
        @internal
        */
        forChild(offset2, node) {
          if (this == empty)
            return this;
          if (node.isLeaf)
            return _DecorationSet.empty;
          let child, local;
          for (let i = 0; i < this.children.length; i += 3)
            if (this.children[i] >= offset2) {
              if (this.children[i] == offset2)
                child = this.children[i + 2];
              break;
            }
          let start3 = offset2 + 1, end2 = start3 + node.content.size;
          for (let i = 0; i < this.local.length; i++) {
            let dec = this.local[i];
            if (dec.from < end2 && dec.to > start3 && dec.type instanceof InlineType) {
              let from3 = Math.max(start3, dec.from) - start3, to2 = Math.min(end2, dec.to) - start3;
              if (from3 < to2)
                (local || (local = [])).push(dec.copy(from3, to2));
            }
          }
          if (local) {
            let localSet = new _DecorationSet(local.sort(byPos), none);
            return child ? new DecorationGroup([localSet, child]) : localSet;
          }
          return child || empty;
        }
        /**
        @internal
        */
        eq(other) {
          if (this == other)
            return true;
          if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
            return false;
          for (let i = 0; i < this.local.length; i++)
            if (!this.local[i].eq(other.local[i]))
              return false;
          for (let i = 0; i < this.children.length; i += 3)
            if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
              return false;
          return true;
        }
        /**
        @internal
        */
        locals(node) {
          return removeOverlap(this.localsInner(node));
        }
        /**
        @internal
        */
        localsInner(node) {
          if (this == empty)
            return none;
          if (node.inlineContent || !this.local.some(InlineType.is))
            return this.local;
          let result = [];
          for (let i = 0; i < this.local.length; i++) {
            if (!(this.local[i].type instanceof InlineType))
              result.push(this.local[i]);
          }
          return result;
        }
      };
      DecorationSet.empty = new DecorationSet([], []);
      DecorationSet.removeOverlap = removeOverlap;
      empty = DecorationSet.empty;
      DecorationGroup = class _DecorationGroup {
        constructor(members) {
          this.members = members;
        }
        map(mapping, doc3) {
          const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
          return _DecorationGroup.from(mappedDecos);
        }
        forChild(offset2, child) {
          if (child.isLeaf)
            return DecorationSet.empty;
          let found2 = [];
          for (let i = 0; i < this.members.length; i++) {
            let result = this.members[i].forChild(offset2, child);
            if (result == empty)
              continue;
            if (result instanceof _DecorationGroup)
              found2 = found2.concat(result.members);
            else
              found2.push(result);
          }
          return _DecorationGroup.from(found2);
        }
        eq(other) {
          if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
            return false;
          for (let i = 0; i < this.members.length; i++)
            if (!this.members[i].eq(other.members[i]))
              return false;
          return true;
        }
        locals(node) {
          let result, sorted = true;
          for (let i = 0; i < this.members.length; i++) {
            let locals = this.members[i].localsInner(node);
            if (!locals.length)
              continue;
            if (!result) {
              result = locals;
            } else {
              if (sorted) {
                result = result.slice();
                sorted = false;
              }
              for (let j = 0; j < locals.length; j++)
                result.push(locals[j]);
            }
          }
          return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
        }
        // Create a group for the given array of decoration sets, or return
        // a single set when possible.
        static from(members) {
          switch (members.length) {
            case 0:
              return empty;
            case 1:
              return members[0];
            default:
              return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
          }
        }
      };
      observeOptions = {
        childList: true,
        characterData: true,
        characterDataOldValue: true,
        attributes: true,
        attributeOldValue: true,
        subtree: true
      };
      useCharData = ie && ie_version <= 11;
      SelectionState = class {
        constructor() {
          this.anchorNode = null;
          this.anchorOffset = 0;
          this.focusNode = null;
          this.focusOffset = 0;
        }
        set(sel) {
          this.anchorNode = sel.anchorNode;
          this.anchorOffset = sel.anchorOffset;
          this.focusNode = sel.focusNode;
          this.focusOffset = sel.focusOffset;
        }
        clear() {
          this.anchorNode = this.focusNode = null;
        }
        eq(sel) {
          return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
        }
      };
      DOMObserver = class {
        constructor(view, handleDOMChange) {
          this.view = view;
          this.handleDOMChange = handleDOMChange;
          this.queue = [];
          this.flushingSoon = -1;
          this.observer = null;
          this.currentSelection = new SelectionState();
          this.onCharData = null;
          this.suppressingSelectionUpdates = false;
          this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
            for (let i = 0; i < mutations.length; i++)
              this.queue.push(mutations[i]);
            if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
              this.flushSoon();
            else
              this.flush();
          });
          if (useCharData) {
            this.onCharData = (e) => {
              this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
              this.flushSoon();
            };
          }
          this.onSelectionChange = this.onSelectionChange.bind(this);
        }
        flushSoon() {
          if (this.flushingSoon < 0)
            this.flushingSoon = window.setTimeout(() => {
              this.flushingSoon = -1;
              this.flush();
            }, 20);
        }
        forceFlush() {
          if (this.flushingSoon > -1) {
            window.clearTimeout(this.flushingSoon);
            this.flushingSoon = -1;
            this.flush();
          }
        }
        start() {
          if (this.observer) {
            this.observer.takeRecords();
            this.observer.observe(this.view.dom, observeOptions);
          }
          if (this.onCharData)
            this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
          this.connectSelection();
        }
        stop() {
          if (this.observer) {
            let take = this.observer.takeRecords();
            if (take.length) {
              for (let i = 0; i < take.length; i++)
                this.queue.push(take[i]);
              window.setTimeout(() => this.flush(), 20);
            }
            this.observer.disconnect();
          }
          if (this.onCharData)
            this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
          this.disconnectSelection();
        }
        connectSelection() {
          this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
        }
        disconnectSelection() {
          this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
        }
        suppressSelectionUpdates() {
          this.suppressingSelectionUpdates = true;
          setTimeout(() => this.suppressingSelectionUpdates = false, 50);
        }
        onSelectionChange() {
          if (!hasFocusAndSelection(this.view))
            return;
          if (this.suppressingSelectionUpdates)
            return selectionToDOM(this.view);
          if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
            let sel = this.view.domSelectionRange();
            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
              return this.flushSoon();
          }
          this.flush();
        }
        setCurSelection() {
          this.currentSelection.set(this.view.domSelectionRange());
        }
        ignoreSelectionChange(sel) {
          if (!sel.focusNode)
            return true;
          let ancestors = /* @__PURE__ */ new Set(), container;
          for (let scan = sel.focusNode; scan; scan = parentNode(scan))
            ancestors.add(scan);
          for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
            if (ancestors.has(scan)) {
              container = scan;
              break;
            }
          let desc = container && this.view.docView.nearestDesc(container);
          if (desc && desc.ignoreMutation({
            type: "selection",
            target: container.nodeType == 3 ? container.parentNode : container
          })) {
            this.setCurSelection();
            return true;
          }
        }
        pendingRecords() {
          if (this.observer)
            for (let mut of this.observer.takeRecords())
              this.queue.push(mut);
          return this.queue;
        }
        flush() {
          let { view } = this;
          if (!view.docView || this.flushingSoon > -1)
            return;
          let mutations = this.pendingRecords();
          if (mutations.length)
            this.queue = [];
          let sel = view.domSelectionRange();
          let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
          let from3 = -1, to2 = -1, typeOver = false, added = [];
          if (view.editable) {
            for (let i = 0; i < mutations.length; i++) {
              let result = this.registerMutation(mutations[i], added);
              if (result) {
                from3 = from3 < 0 ? result.from : Math.min(result.from, from3);
                to2 = to2 < 0 ? result.to : Math.max(result.to, to2);
                if (result.typeOver)
                  typeOver = true;
              }
            }
          }
          if (gecko && added.length > 1) {
            let brs = added.filter((n) => n.nodeName == "BR");
            if (brs.length == 2) {
              let a = brs[0], b = brs[1];
              if (a.parentNode && a.parentNode.parentNode == b.parentNode)
                b.remove();
              else
                a.remove();
            }
          }
          let readSel = null;
          if (from3 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
            view.input.lastFocus = 0;
            selectionToDOM(view);
            this.currentSelection.set(sel);
            view.scrollToSelection();
          } else if (from3 > -1 || newSel) {
            if (from3 > -1) {
              view.docView.markDirty(from3, to2);
              checkCSS(view);
            }
            this.handleDOMChange(from3, to2, typeOver, added);
            if (view.docView && view.docView.dirty)
              view.updateState(view.state);
            else if (!this.currentSelection.eq(sel))
              selectionToDOM(view);
            this.currentSelection.set(sel);
          }
        }
        registerMutation(mut, added) {
          if (added.indexOf(mut.target) > -1)
            return null;
          let desc = this.view.docView.nearestDesc(mut.target);
          if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
          mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
            return null;
          if (!desc || desc.ignoreMutation(mut))
            return null;
          if (mut.type == "childList") {
            for (let i = 0; i < mut.addedNodes.length; i++)
              added.push(mut.addedNodes[i]);
            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
              return { from: desc.posBefore, to: desc.posAfter };
            let prev = mut.previousSibling, next = mut.nextSibling;
            if (ie && ie_version <= 11 && mut.addedNodes.length) {
              for (let i = 0; i < mut.addedNodes.length; i++) {
                let { previousSibling: previousSibling2, nextSibling: nextSibling2 } = mut.addedNodes[i];
                if (!previousSibling2 || Array.prototype.indexOf.call(mut.addedNodes, previousSibling2) < 0)
                  prev = previousSibling2;
                if (!nextSibling2 || Array.prototype.indexOf.call(mut.addedNodes, nextSibling2) < 0)
                  next = nextSibling2;
              }
            }
            let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
            let from3 = desc.localPosFromDOM(mut.target, fromOffset, -1);
            let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
            let to2 = desc.localPosFromDOM(mut.target, toOffset, 1);
            return { from: from3, to: to2 };
          } else if (mut.type == "attributes") {
            return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
          } else {
            return {
              from: desc.posAtStart,
              to: desc.posAtEnd,
              // An event was generated for a text change that didn't change
              // any text. Mark the dom change to fall back to assuming the
              // selection was typed over with an identical value if it can't
              // find another change.
              typeOver: mut.target.nodeValue == mut.oldValue
            };
          }
        }
      };
      cssChecked = /* @__PURE__ */ new WeakMap();
      cssCheckWarned = false;
      isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
      EditorView = class {
        /**
        Create a view. `place` may be a DOM node that the editor should
        be appended to, a function that will place it into the document,
        or an object whose `mount` property holds the node to use as the
        document container. If it is `null`, the editor will not be
        added to the document.
        */
        constructor(place, props) {
          this._root = null;
          this.focused = false;
          this.trackWrites = null;
          this.mounted = false;
          this.markCursor = null;
          this.cursorWrapper = null;
          this.lastSelectedViewDesc = void 0;
          this.input = new InputState();
          this.prevDirectPlugins = [];
          this.pluginViews = [];
          this.requiresGeckoHackNode = false;
          this.dragging = null;
          this._props = props;
          this.state = props.state;
          this.directPlugins = props.plugins || [];
          this.directPlugins.forEach(checkStateComponent);
          this.dispatch = this.dispatch.bind(this);
          this.dom = place && place.mount || document.createElement("div");
          if (place) {
            if (place.appendChild)
              place.appendChild(this.dom);
            else if (typeof place == "function")
              place(this.dom);
            else if (place.mount)
              this.mounted = true;
          }
          this.editable = getEditable(this);
          updateCursorWrapper(this);
          this.nodeViews = buildNodeViews(this);
          this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
          this.domObserver = new DOMObserver(this, (from3, to2, typeOver, added) => readDOMChange(this, from3, to2, typeOver, added));
          this.domObserver.start();
          initInput(this);
          this.updatePluginViews();
        }
        /**
        Holds `true` when a
        [composition](https://w3c.github.io/uievents/#events-compositionevents)
        is active.
        */
        get composing() {
          return this.input.composing;
        }
        /**
        The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
        */
        get props() {
          if (this._props.state != this.state) {
            let prev = this._props;
            this._props = {};
            for (let name in prev)
              this._props[name] = prev[name];
            this._props.state = this.state;
          }
          return this._props;
        }
        /**
        Update the view's props. Will immediately cause an update to
        the DOM.
        */
        update(props) {
          if (props.handleDOMEvents != this._props.handleDOMEvents)
            ensureListeners(this);
          let prevProps = this._props;
          this._props = props;
          if (props.plugins) {
            props.plugins.forEach(checkStateComponent);
            this.directPlugins = props.plugins;
          }
          this.updateStateInner(props.state, prevProps);
        }
        /**
        Update the view by updating existing props object with the object
        given as argument. Equivalent to `view.update(Object.assign({},
        view.props, props))`.
        */
        setProps(props) {
          let updated = {};
          for (let name in this._props)
            updated[name] = this._props[name];
          updated.state = this.state;
          for (let name in props)
            updated[name] = props[name];
          this.update(updated);
        }
        /**
        Update the editor's `state` prop, without touching any of the
        other props.
        */
        updateState(state) {
          this.updateStateInner(state, this._props);
        }
        updateStateInner(state, prevProps) {
          var _a;
          let prev = this.state, redraw = false, updateSel = false;
          if (state.storedMarks && this.composing) {
            clearComposition(this);
            updateSel = true;
          }
          this.state = state;
          let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
          if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
            let nodeViews = buildNodeViews(this);
            if (changedNodeViews(nodeViews, this.nodeViews)) {
              this.nodeViews = nodeViews;
              redraw = true;
            }
          }
          if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
            ensureListeners(this);
          }
          this.editable = getEditable(this);
          updateCursorWrapper(this);
          let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
          let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
          let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
          if (updateDoc || !state.selection.eq(prev.selection))
            updateSel = true;
          let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
          if (updateSel) {
            this.domObserver.stop();
            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
            if (updateDoc) {
              let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
              if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
                this.docView.updateOuterDeco([]);
                this.docView.destroy();
                this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
              }
              if (chromeKludge && !this.trackWrites)
                forceSelUpdate = true;
            }
            if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
              selectionToDOM(this, forceSelUpdate);
            } else {
              syncNodeSelection(this, state.selection);
              this.domObserver.setCurSelection();
            }
            this.domObserver.start();
          }
          this.updatePluginViews(prev);
          if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
            this.updateDraggedNode(this.dragging, prev);
          if (scroll == "reset") {
            this.dom.scrollTop = 0;
          } else if (scroll == "to selection") {
            this.scrollToSelection();
          } else if (oldScrollPos) {
            resetScrollPos(oldScrollPos);
          }
        }
        /**
        @internal
        */
        scrollToSelection() {
          let startDOM = this.domSelectionRange().focusNode;
          if (this.someProp("handleScrollToSelection", (f) => f(this)))
            ;
          else if (this.state.selection instanceof NodeSelection) {
            let target = this.docView.domAfterPos(this.state.selection.from);
            if (target.nodeType == 1)
              scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
          } else {
            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
          }
        }
        destroyPluginViews() {
          let view;
          while (view = this.pluginViews.pop())
            if (view.destroy)
              view.destroy();
        }
        updatePluginViews(prevState) {
          if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins;
            this.destroyPluginViews();
            for (let i = 0; i < this.directPlugins.length; i++) {
              let plugin = this.directPlugins[i];
              if (plugin.spec.view)
                this.pluginViews.push(plugin.spec.view(this));
            }
            for (let i = 0; i < this.state.plugins.length; i++) {
              let plugin = this.state.plugins[i];
              if (plugin.spec.view)
                this.pluginViews.push(plugin.spec.view(this));
            }
          } else {
            for (let i = 0; i < this.pluginViews.length; i++) {
              let pluginView = this.pluginViews[i];
              if (pluginView.update)
                pluginView.update(this, prevState);
            }
          }
        }
        updateDraggedNode(dragging, prev) {
          let sel = dragging.node, found2 = -1;
          if (this.state.doc.nodeAt(sel.from) == sel.node) {
            found2 = sel.from;
          } else {
            let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
            let moved2 = movedPos > 0 && this.state.doc.nodeAt(movedPos);
            if (moved2 == sel.node)
              found2 = movedPos;
          }
          this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
        }
        someProp(propName, f) {
          let prop = this._props && this._props[propName], value;
          if (prop != null && (value = f ? f(prop) : prop))
            return value;
          for (let i = 0; i < this.directPlugins.length; i++) {
            let prop2 = this.directPlugins[i].props[propName];
            if (prop2 != null && (value = f ? f(prop2) : prop2))
              return value;
          }
          let plugins3 = this.state.plugins;
          if (plugins3)
            for (let i = 0; i < plugins3.length; i++) {
              let prop2 = plugins3[i].props[propName];
              if (prop2 != null && (value = f ? f(prop2) : prop2))
                return value;
            }
        }
        /**
        Query whether the view has focus.
        */
        hasFocus() {
          if (ie) {
            let node = this.root.activeElement;
            if (node == this.dom)
              return true;
            if (!node || !this.dom.contains(node))
              return false;
            while (node && this.dom != node && this.dom.contains(node)) {
              if (node.contentEditable == "false")
                return false;
              node = node.parentElement;
            }
            return true;
          }
          return this.root.activeElement == this.dom;
        }
        /**
        Focus the editor.
        */
        focus() {
          this.domObserver.stop();
          if (this.editable)
            focusPreventScroll(this.dom);
          selectionToDOM(this);
          this.domObserver.start();
        }
        /**
        Get the document root in which the editor exists. This will
        usually be the top-level `document`, but might be a [shadow
        DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
        root if the editor is inside one.
        */
        get root() {
          let cached = this._root;
          if (cached == null)
            for (let search = this.dom.parentNode; search; search = search.parentNode) {
              if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
                if (!search.getSelection)
                  Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
                return this._root = search;
              }
            }
          return cached || document;
        }
        /**
        When an existing editor view is moved to a new document or
        shadow tree, call this to make it recompute its root.
        */
        updateRoot() {
          this._root = null;
        }
        /**
        Given a pair of viewport coordinates, return the document
        position that corresponds to them. May return null if the given
        coordinates aren't inside of the editor. When an object is
        returned, its `pos` property is the position nearest to the
        coordinates, and its `inside` property holds the position of the
        inner node that the position falls inside of, or -1 if it is at
        the top level, not in any node.
        */
        posAtCoords(coords) {
          return posAtCoords(this, coords);
        }
        /**
        Returns the viewport rectangle at a given document position.
        `left` and `right` will be the same number, as this returns a
        flat cursor-ish rectangle. If the position is between two things
        that aren't directly adjacent, `side` determines which element
        is used. When < 0, the element before the position is used,
        otherwise the element after.
        */
        coordsAtPos(pos, side = 1) {
          return coordsAtPos(this, pos, side);
        }
        /**
        Find the DOM position that corresponds to the given document
        position. When `side` is negative, find the position as close as
        possible to the content before the position. When positive,
        prefer positions close to the content after the position. When
        zero, prefer as shallow a position as possible.
        
        Note that you should **not** mutate the editor's internal DOM,
        only inspect it (and even that is usually not necessary).
        */
        domAtPos(pos, side = 0) {
          return this.docView.domFromPos(pos, side);
        }
        /**
        Find the DOM node that represents the document node after the
        given position. May return `null` when the position doesn't point
        in front of a node or if the node is inside an opaque node view.
        
        This is intended to be able to call things like
        `getBoundingClientRect` on that DOM node. Do **not** mutate the
        editor DOM directly, or add styling this way, since that will be
        immediately overriden by the editor as it redraws the node.
        */
        nodeDOM(pos) {
          let desc = this.docView.descAt(pos);
          return desc ? desc.nodeDOM : null;
        }
        /**
        Find the document position that corresponds to a given DOM
        position. (Whenever possible, it is preferable to inspect the
        document structure directly, rather than poking around in the
        DOM, but sometimesfor example when interpreting an event
        targetyou don't have a choice.)
        
        The `bias` parameter can be used to influence which side of a DOM
        node to use when the position is inside a leaf node.
        */
        posAtDOM(node, offset2, bias = -1) {
          let pos = this.docView.posFromDOM(node, offset2, bias);
          if (pos == null)
            throw new RangeError("DOM position not inside the editor");
          return pos;
        }
        /**
        Find out whether the selection is at the end of a textblock when
        moving in a given direction. When, for example, given `"left"`,
        it will return true if moving left from the current cursor
        position would leave that position's parent textblock. Will apply
        to the view's current state by default, but it is possible to
        pass a different state.
        */
        endOfTextblock(dir, state) {
          return endOfTextblock(this, state || this.state, dir);
        }
        /**
        Run the editor's paste logic with the given HTML string. The
        `event`, if given, will be passed to the
        [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
        */
        pasteHTML(html, event) {
          return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
        }
        /**
        Run the editor's paste logic with the given plain-text input.
        */
        pasteText(text, event) {
          return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
        }
        /**
        Removes the editor from the DOM and destroys all [node
        views](https://prosemirror.net/docs/ref/#view.NodeView).
        */
        destroy() {
          if (!this.docView)
            return;
          destroyInput(this);
          this.destroyPluginViews();
          if (this.mounted) {
            this.docView.update(this.state.doc, [], viewDecorations(this), this);
            this.dom.textContent = "";
          } else if (this.dom.parentNode) {
            this.dom.parentNode.removeChild(this.dom);
          }
          this.docView.destroy();
          this.docView = null;
        }
        /**
        This is true when the view has been
        [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
        used anymore).
        */
        get isDestroyed() {
          return this.docView == null;
        }
        /**
        Used for testing.
        */
        dispatchEvent(event) {
          return dispatchEvent3(this, event);
        }
        /**
        Dispatch a transaction. Will call
        [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
        when given, and otherwise defaults to applying the transaction to
        the current state and calling
        [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
        This method is bound to the view instance, so that it can be
        easily passed around.
        */
        dispatch(tr2) {
          let dispatchTransaction = this._props.dispatchTransaction;
          if (dispatchTransaction)
            dispatchTransaction.call(this, tr2);
          else
            this.updateState(this.state.apply(tr2));
        }
        /**
        @internal
        */
        domSelectionRange() {
          return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
        }
        /**
        @internal
        */
        domSelection() {
          return this.root.getSelection();
        }
      };
    }
  });

  // node_modules/@tiptap/pm/view/dist/index.js
  var init_dist7 = __esm({
    "node_modules/@tiptap/pm/view/dist/index.js"() {
      init_dist6();
    }
  });

  // node_modules/w3c-keyname/index.js
  function keyName(event) {
    var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name == "Esc")
      name = "Escape";
    if (name == "Del")
      name = "Delete";
    if (name == "Left")
      name = "ArrowLeft";
    if (name == "Up")
      name = "ArrowUp";
    if (name == "Right")
      name = "ArrowRight";
    if (name == "Down")
      name = "ArrowDown";
    return name;
  }
  var base, shift, mac2, ie2, i, i, i, code;
  var init_w3c_keyname = __esm({
    "node_modules/w3c-keyname/index.js"() {
      base = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      };
      shift = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"'
      };
      mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
      ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
      for (i = 0; i < 10; i++)
        base[48 + i] = base[96 + i] = String(i);
      for (i = 1; i <= 24; i++)
        base[i + 111] = "F" + i;
      for (i = 65; i <= 90; i++) {
        base[i] = String.fromCharCode(i + 32);
        shift[i] = String.fromCharCode(i);
      }
      for (code in base)
        if (!shift.hasOwnProperty(code))
          shift[code] = base[code];
    }
  });

  // node_modules/prosemirror-keymap/dist/index.js
  function normalizeKeyName(name) {
    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta;
    for (let i = 0; i < parts.length - 1; i++) {
      let mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (mac3)
          meta = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function normalize(map4) {
    let copy2 = /* @__PURE__ */ Object.create(null);
    for (let prop in map4)
      copy2[normalizeKeyName(prop)] = map4[prop];
    return copy2;
  }
  function modifiers(name, event, shift2 = true) {
    if (event.altKey)
      name = "Alt-" + name;
    if (event.ctrlKey)
      name = "Ctrl-" + name;
    if (event.metaKey)
      name = "Meta-" + name;
    if (shift2 && event.shiftKey)
      name = "Shift-" + name;
    return name;
  }
  function keymap(bindings) {
    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
  }
  function keydownHandler(bindings) {
    let map4 = normalize(bindings);
    return function(view, event) {
      let name = keyName(event), baseName, direct = map4[modifiers(name, event)];
      if (direct && direct(view.state, view.dispatch, view))
        return true;
      if (name.length == 1 && name != " ") {
        if (event.shiftKey) {
          let noShift = map4[modifiers(name, event, false)];
          if (noShift && noShift(view.state, view.dispatch, view))
            return true;
        }
        if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
          let fromCode = map4[modifiers(baseName, event)];
          if (fromCode && fromCode(view.state, view.dispatch, view))
            return true;
        }
      }
      return false;
    };
  }
  var mac3;
  var init_dist8 = __esm({
    "node_modules/prosemirror-keymap/dist/index.js"() {
      init_w3c_keyname();
      init_dist4();
      mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
    }
  });

  // node_modules/@tiptap/pm/keymap/dist/index.js
  var init_dist9 = __esm({
    "node_modules/@tiptap/pm/keymap/dist/index.js"() {
      init_dist8();
    }
  });

  // node_modules/@tiptap/pm/model/dist/index.js
  var init_dist10 = __esm({
    "node_modules/@tiptap/pm/model/dist/index.js"() {
      init_dist2();
    }
  });

  // node_modules/@tiptap/pm/transform/dist/index.js
  var init_dist11 = __esm({
    "node_modules/@tiptap/pm/transform/dist/index.js"() {
      init_dist3();
    }
  });

  // node_modules/prosemirror-commands/dist/index.js
  function atBlockStart(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
      return null;
    return $cursor;
  }
  function joinTextblocksAround(state, $cut, dispatch2) {
    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
    for (; !beforeText.isTextblock; beforePos--) {
      if (beforeText.type.spec.isolating)
        return false;
      let child = beforeText.lastChild;
      if (!child)
        return false;
      beforeText = child;
    }
    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
    for (; !afterText.isTextblock; afterPos++) {
      if (afterText.type.spec.isolating)
        return false;
      let child = afterText.firstChild;
      if (!child)
        return false;
      afterText = child;
    }
    let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
    if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
      return false;
    if (dispatch2) {
      let tr2 = state.tr.step(step);
      tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  }
  function textblockAt(node, side, only = false) {
    for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
      if (scan.isTextblock)
        return true;
      if (only && scan.childCount != 1)
        return false;
    }
    return false;
  }
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0)
          return $pos.doc.resolve($pos.before(i + 1));
        if ($pos.node(i).type.spec.isolating)
          break;
      }
    return null;
  }
  function atBlockEnd(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
      return null;
    return $cursor;
  }
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        let parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount)
          return $pos.doc.resolve($pos.after(i + 1));
        if (parent.type.spec.isolating)
          break;
      }
    return null;
  }
  function defaultBlockAt(match) {
    for (let i = 0; i < match.edgeCount; i++) {
      let { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs())
        return type;
    }
    return null;
  }
  function splitBlockAs(splitNode) {
    return (state, dispatch2) => {
      let { $from, $to } = state.selection;
      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
          return false;
        if (dispatch2)
          dispatch2(state.tr.split($from.pos).scrollIntoView());
        return true;
      }
      if (!$from.parent.isBlock)
        return false;
      if (dispatch2) {
        let atEnd = $to.parentOffset == $to.parent.content.size;
        let tr2 = state.tr;
        if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
          tr2.deleteSelection();
        let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
        let splitType = splitNode && splitNode($to.parent, atEnd);
        let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
        let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
        if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
          if (deflt)
            types = [{ type: deflt }];
          can = true;
        }
        if (can) {
          tr2.split(tr2.mapping.map($from.pos), 1, types);
          if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
            let first2 = tr2.mapping.map($from.before()), $first = tr2.doc.resolve(first2);
            if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
              tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
          }
        }
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    };
  }
  function joinMaybeClear(state, $pos, dispatch2) {
    let before = $pos.nodeBefore, after = $pos.nodeAfter, index3 = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
      return false;
    if (!before.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
      if (dispatch2)
        dispatch2(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
      return true;
    }
    if (!$pos.parent.canReplace(index3, index3 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
      return false;
    if (dispatch2)
      dispatch2(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
    return true;
  }
  function deleteBarrier(state, $cut, dispatch2) {
    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
    if (before.type.spec.isolating || after.type.spec.isolating)
      return false;
    if (joinMaybeClear(state, $cut, dispatch2))
      return true;
    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
      if (dispatch2) {
        let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
        for (let i = conn.length - 1; i >= 0; i--)
          wrap2 = Fragment.from(conn[i].create(null, wrap2));
        wrap2 = Fragment.from(before.copy(wrap2));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
        let joinAt = end2 + 2 * conn.length;
        if (canJoin(tr2.doc, joinAt))
          tr2.join(joinAt);
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
    let selAfter = Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch2)
        dispatch2(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
      let at = before, wrap2 = [];
      for (; ; ) {
        wrap2.push(at);
        if (at.isTextblock)
          break;
        at = at.lastChild;
      }
      let afterText = after, afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild)
        afterDepth++;
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch2) {
          let end2 = Fragment.empty;
          for (let i = wrap2.length - 1; i >= 0; i--)
            end2 = Fragment.from(wrap2[i].copy(end2));
          let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
          dispatch2(tr2.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function(state, dispatch2) {
      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
      let depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth)
          return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock)
        return false;
      if (dispatch2)
        dispatch2(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      return true;
    };
  }
  function wrapIn(nodeType, attrs = null) {
    return function(state, dispatch2) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping)
        return false;
      if (dispatch2)
        dispatch2(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType2(nodeType, attrs = null) {
    return function(state, dispatch2) {
      let applicable = false;
      for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
        let { $from: { pos: from3 }, $to: { pos: to2 } } = state.selection.ranges[i];
        state.doc.nodesBetween(from3, to2, (node, pos) => {
          if (applicable)
            return false;
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
            return;
          if (node.type == nodeType) {
            applicable = true;
          } else {
            let $pos = state.doc.resolve(pos), index3 = $pos.index();
            applicable = $pos.parent.canReplaceWith(index3, index3 + 1, nodeType);
          }
        });
      }
      if (!applicable)
        return false;
      if (dispatch2) {
        let tr2 = state.tr;
        for (let i = 0; i < state.selection.ranges.length; i++) {
          let { $from: { pos: from3 }, $to: { pos: to2 } } = state.selection.ranges[i];
          tr2.setBlockType(from3, to2, nodeType, attrs);
        }
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    };
  }
  function chainCommands(...commands2) {
    return function(state, dispatch2, view) {
      for (let i = 0; i < commands2.length; i++)
        if (commands2[i](state, dispatch2, view))
          return true;
      return false;
    };
  }
  var deleteSelection, joinBackward, joinTextblockBackward, joinTextblockForward, selectNodeBackward, joinForward, selectNodeForward, joinUp, joinDown, lift2, newlineInCode, exitCode, createParagraphNear, liftEmptyBlock, splitBlock, selectParentNode, selectAll, selectTextblockStart, selectTextblockEnd, backspace, del2, pcBaseKeymap, macBaseKeymap, mac4;
  var init_dist12 = __esm({
    "node_modules/prosemirror-commands/dist/index.js"() {
      init_dist3();
      init_dist2();
      init_dist4();
      deleteSelection = (state, dispatch2) => {
        if (state.selection.empty)
          return false;
        if (dispatch2)
          dispatch2(state.tr.deleteSelection().scrollIntoView());
        return true;
      };
      joinBackward = (state, dispatch2, view) => {
        let $cursor = atBlockStart(state, view);
        if (!$cursor)
          return false;
        let $cut = findCutBefore($cursor);
        if (!$cut) {
          let range = $cursor.blockRange(), target = range && liftTarget(range);
          if (target == null)
            return false;
          if (dispatch2)
            dispatch2(state.tr.lift(range, target).scrollIntoView());
          return true;
        }
        let before = $cut.nodeBefore;
        if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch2))
          return true;
        if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
          let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
          if (delStep && delStep.slice.size < delStep.to - delStep.from) {
            if (dispatch2) {
              let tr2 = state.tr.step(delStep);
              tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
              dispatch2(tr2.scrollIntoView());
            }
            return true;
          }
        }
        if (before.isAtom && $cut.depth == $cursor.depth - 1) {
          if (dispatch2)
            dispatch2(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
          return true;
        }
        return false;
      };
      joinTextblockBackward = (state, dispatch2, view) => {
        let $cursor = atBlockStart(state, view);
        if (!$cursor)
          return false;
        let $cut = findCutBefore($cursor);
        return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
      };
      joinTextblockForward = (state, dispatch2, view) => {
        let $cursor = atBlockEnd(state, view);
        if (!$cursor)
          return false;
        let $cut = findCutAfter($cursor);
        return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
      };
      selectNodeBackward = (state, dispatch2, view) => {
        let { $head, empty: empty2 } = state.selection, $cut = $head;
        if (!empty2)
          return false;
        if ($head.parent.isTextblock) {
          if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
            return false;
          $cut = findCutBefore($head);
        }
        let node = $cut && $cut.nodeBefore;
        if (!node || !NodeSelection.isSelectable(node))
          return false;
        if (dispatch2)
          dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
        return true;
      };
      joinForward = (state, dispatch2, view) => {
        let $cursor = atBlockEnd(state, view);
        if (!$cursor)
          return false;
        let $cut = findCutAfter($cursor);
        if (!$cut)
          return false;
        let after = $cut.nodeAfter;
        if (deleteBarrier(state, $cut, dispatch2))
          return true;
        if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
          let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
          if (delStep && delStep.slice.size < delStep.to - delStep.from) {
            if (dispatch2) {
              let tr2 = state.tr.step(delStep);
              tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
              dispatch2(tr2.scrollIntoView());
            }
            return true;
          }
        }
        if (after.isAtom && $cut.depth == $cursor.depth - 1) {
          if (dispatch2)
            dispatch2(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
          return true;
        }
        return false;
      };
      selectNodeForward = (state, dispatch2, view) => {
        let { $head, empty: empty2 } = state.selection, $cut = $head;
        if (!empty2)
          return false;
        if ($head.parent.isTextblock) {
          if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
            return false;
          $cut = findCutAfter($head);
        }
        let node = $cut && $cut.nodeAfter;
        if (!node || !NodeSelection.isSelectable(node))
          return false;
        if (dispatch2)
          dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
        return true;
      };
      joinUp = (state, dispatch2) => {
        let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
        if (nodeSel) {
          if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
            return false;
          point = sel.from;
        } else {
          point = joinPoint(state.doc, sel.from, -1);
          if (point == null)
            return false;
        }
        if (dispatch2) {
          let tr2 = state.tr.join(point);
          if (nodeSel)
            tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
          dispatch2(tr2.scrollIntoView());
        }
        return true;
      };
      joinDown = (state, dispatch2) => {
        let sel = state.selection, point;
        if (sel instanceof NodeSelection) {
          if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
            return false;
          point = sel.to;
        } else {
          point = joinPoint(state.doc, sel.to, 1);
          if (point == null)
            return false;
        }
        if (dispatch2)
          dispatch2(state.tr.join(point).scrollIntoView());
        return true;
      };
      lift2 = (state, dispatch2) => {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to), target = range && liftTarget(range);
        if (target == null)
          return false;
        if (dispatch2)
          dispatch2(state.tr.lift(range, target).scrollIntoView());
        return true;
      };
      newlineInCode = (state, dispatch2) => {
        let { $head, $anchor } = state.selection;
        if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
          return false;
        if (dispatch2)
          dispatch2(state.tr.insertText("\n").scrollIntoView());
        return true;
      };
      exitCode = (state, dispatch2) => {
        let { $head, $anchor } = state.selection;
        if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
          return false;
        let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
        if (!type || !above.canReplaceWith(after, after, type))
          return false;
        if (dispatch2) {
          let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
          tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
          dispatch2(tr2.scrollIntoView());
        }
        return true;
      };
      createParagraphNear = (state, dispatch2) => {
        let sel = state.selection, { $from, $to } = sel;
        if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
          return false;
        let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
        if (!type || !type.isTextblock)
          return false;
        if (dispatch2) {
          let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
          let tr2 = state.tr.insert(side, type.createAndFill());
          tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
          dispatch2(tr2.scrollIntoView());
        }
        return true;
      };
      liftEmptyBlock = (state, dispatch2) => {
        let { $cursor } = state.selection;
        if (!$cursor || $cursor.parent.content.size)
          return false;
        if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
          let before = $cursor.before();
          if (canSplit(state.doc, before)) {
            if (dispatch2)
              dispatch2(state.tr.split(before).scrollIntoView());
            return true;
          }
        }
        let range = $cursor.blockRange(), target = range && liftTarget(range);
        if (target == null)
          return false;
        if (dispatch2)
          dispatch2(state.tr.lift(range, target).scrollIntoView());
        return true;
      };
      splitBlock = splitBlockAs();
      selectParentNode = (state, dispatch2) => {
        let { $from, to: to2 } = state.selection, pos;
        let same = $from.sharedDepth(to2);
        if (same == 0)
          return false;
        pos = $from.before(same);
        if (dispatch2)
          dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
        return true;
      };
      selectAll = (state, dispatch2) => {
        if (dispatch2)
          dispatch2(state.tr.setSelection(new AllSelection(state.doc)));
        return true;
      };
      selectTextblockStart = selectTextblockSide(-1);
      selectTextblockEnd = selectTextblockSide(1);
      backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
      del2 = chainCommands(deleteSelection, joinForward, selectNodeForward);
      pcBaseKeymap = {
        "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
        "Mod-Enter": exitCode,
        "Backspace": backspace,
        "Mod-Backspace": backspace,
        "Shift-Backspace": backspace,
        "Delete": del2,
        "Mod-Delete": del2,
        "Mod-a": selectAll
      };
      macBaseKeymap = {
        "Ctrl-h": pcBaseKeymap["Backspace"],
        "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
        "Ctrl-d": pcBaseKeymap["Delete"],
        "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
        "Alt-Delete": pcBaseKeymap["Mod-Delete"],
        "Alt-d": pcBaseKeymap["Mod-Delete"],
        "Ctrl-a": selectTextblockStart,
        "Ctrl-e": selectTextblockEnd
      };
      for (let key in pcBaseKeymap)
        macBaseKeymap[key] = pcBaseKeymap[key];
      mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
    }
  });

  // node_modules/@tiptap/pm/commands/dist/index.js
  var init_dist13 = __esm({
    "node_modules/@tiptap/pm/commands/dist/index.js"() {
      init_dist12();
    }
  });

  // node_modules/prosemirror-schema-list/dist/index.js
  function wrapInList(listType, attrs = null) {
    return function(state, dispatch2) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), doJoin = false, outerRange = range;
      if (!range)
        return false;
      if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
        if ($from.index(range.depth - 1) == 0)
          return false;
        let $insert = state.doc.resolve(range.start - 2);
        outerRange = new NodeRange($insert, $insert, range.depth);
        if (range.endIndex < range.parent.childCount)
          range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
        doJoin = true;
      }
      let wrap2 = findWrapping(outerRange, listType, attrs, range);
      if (!wrap2)
        return false;
      if (dispatch2)
        dispatch2(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
      return true;
    };
  }
  function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--)
      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
    let found2 = 0;
    for (let i = 0; i < wrappers.length; i++)
      if (wrappers[i].type == listType)
        found2 = i + 1;
    let splitDepth = wrappers.length - found2;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
      if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
        tr2.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i).nodeSize;
    }
    return tr2;
  }
  function liftListItem(itemType) {
    return function(state, dispatch2) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      if (!dispatch2)
        return true;
      if ($from.node(range.depth - 1).type == itemType)
        return liftToOuterList(state, dispatch2, itemType, range);
      else
        return liftOutOfList(state, dispatch2, range);
    };
  }
  function liftToOuterList(state, dispatch2, itemType, range) {
    let tr2 = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
    if (end2 < endOfList) {
      tr2.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
    }
    const target = liftTarget(range);
    if (target == null)
      return false;
    tr2.lift(range, target);
    let after = tr2.mapping.map(end2, -1) - 1;
    if (canJoin(tr2.doc, after))
      tr2.join(after);
    dispatch2(tr2.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch2, range) {
    let tr2 = state.tr, list = range.parent;
    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
      pos -= list.child(i).nodeSize;
      tr2.delete(pos - 1, pos + 1);
    }
    let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
      return false;
    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
    let parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
      return false;
    let start3 = $start.pos, end2 = start3 + item.nodeSize;
    tr2.step(new ReplaceAroundStep(start3 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start3 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch2(tr2.scrollIntoView());
    return true;
  }
  function sinkListItem(itemType) {
    return function(state, dispatch2) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      let startIndex = range.startIndex;
      if (startIndex == 0)
        return false;
      let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType)
        return false;
      if (dispatch2) {
        let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        let inner = Fragment.from(nestedBefore ? itemType.create() : null);
        let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        let before = range.start, after = range.end;
        dispatch2(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
      }
      return true;
    };
  }
  var init_dist14 = __esm({
    "node_modules/prosemirror-schema-list/dist/index.js"() {
      init_dist3();
      init_dist2();
    }
  });

  // node_modules/@tiptap/pm/schema-list/dist/index.js
  var init_dist15 = __esm({
    "node_modules/@tiptap/pm/schema-list/dist/index.js"() {
      init_dist14();
    }
  });

  // node_modules/@tiptap/core/dist/index.js
  var dist_exports = {};
  __export(dist_exports, {
    CommandManager: () => CommandManager,
    Editor: () => Editor,
    Extension: () => Extension,
    InputRule: () => InputRule,
    Mark: () => Mark2,
    Node: () => Node3,
    NodePos: () => NodePos,
    NodeView: () => NodeView,
    PasteRule: () => PasteRule,
    Tracker: () => Tracker,
    callOrReturn: () => callOrReturn,
    combineTransactionSteps: () => combineTransactionSteps,
    createChainableState: () => createChainableState,
    createDocument: () => createDocument,
    createNodeFromContent: () => createNodeFromContent,
    createStyleTag: () => createStyleTag,
    defaultBlockAt: () => defaultBlockAt2,
    deleteProps: () => deleteProps,
    elementFromString: () => elementFromString,
    escapeForRegEx: () => escapeForRegEx,
    extensions: () => extensions,
    findChildren: () => findChildren,
    findChildrenInRange: () => findChildrenInRange,
    findDuplicates: () => findDuplicates,
    findParentNode: () => findParentNode,
    findParentNodeClosestToPos: () => findParentNodeClosestToPos,
    fromString: () => fromString,
    generateHTML: () => generateHTML,
    generateJSON: () => generateJSON,
    generateText: () => generateText,
    getAttributes: () => getAttributes,
    getAttributesFromExtensions: () => getAttributesFromExtensions,
    getChangedRanges: () => getChangedRanges,
    getDebugJSON: () => getDebugJSON,
    getExtensionField: () => getExtensionField,
    getHTMLFromFragment: () => getHTMLFromFragment,
    getMarkAttributes: () => getMarkAttributes,
    getMarkRange: () => getMarkRange,
    getMarkType: () => getMarkType,
    getMarksBetween: () => getMarksBetween,
    getNodeAtPosition: () => getNodeAtPosition,
    getNodeAttributes: () => getNodeAttributes,
    getNodeType: () => getNodeType,
    getRenderedAttributes: () => getRenderedAttributes,
    getSchema: () => getSchema,
    getSchemaByResolvedExtensions: () => getSchemaByResolvedExtensions,
    getSchemaTypeByName: () => getSchemaTypeByName,
    getSchemaTypeNameByName: () => getSchemaTypeNameByName,
    getSplittedAttributes: () => getSplittedAttributes,
    getText: () => getText2,
    getTextBetween: () => getTextBetween,
    getTextContentFromNodes: () => getTextContentFromNodes,
    getTextSerializersFromSchema: () => getTextSerializersFromSchema,
    injectExtensionAttributesToParseRule: () => injectExtensionAttributesToParseRule,
    inputRulesPlugin: () => inputRulesPlugin,
    isActive: () => isActive,
    isAtEndOfNode: () => isAtEndOfNode,
    isAtStartOfNode: () => isAtStartOfNode,
    isEmptyObject: () => isEmptyObject,
    isExtensionRulesEnabled: () => isExtensionRulesEnabled,
    isFunction: () => isFunction2,
    isList: () => isList,
    isMacOS: () => isMacOS,
    isMarkActive: () => isMarkActive,
    isNodeActive: () => isNodeActive,
    isNodeEmpty: () => isNodeEmpty,
    isNodeSelection: () => isNodeSelection,
    isNumber: () => isNumber2,
    isPlainObject: () => isPlainObject,
    isRegExp: () => isRegExp,
    isString: () => isString,
    isTextSelection: () => isTextSelection,
    isiOS: () => isiOS,
    markInputRule: () => markInputRule,
    markPasteRule: () => markPasteRule,
    mergeAttributes: () => mergeAttributes,
    mergeDeep: () => mergeDeep,
    minMax: () => minMax,
    nodeInputRule: () => nodeInputRule,
    nodePasteRule: () => nodePasteRule,
    objectIncludes: () => objectIncludes,
    pasteRulesPlugin: () => pasteRulesPlugin,
    posToDOMRect: () => posToDOMRect,
    removeDuplicates: () => removeDuplicates,
    resolveFocusPosition: () => resolveFocusPosition,
    selectionToInsertionEnd: () => selectionToInsertionEnd2,
    splitExtensions: () => splitExtensions,
    textInputRule: () => textInputRule,
    textPasteRule: () => textPasteRule,
    textblockTypeInputRule: () => textblockTypeInputRule,
    wrappingInputRule: () => wrappingInputRule
  });
  function createChainableState(config) {
    const { state, transaction } = config;
    let { selection } = transaction;
    let { doc: doc3 } = transaction;
    let { storedMarks } = transaction;
    return {
      ...state,
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      plugins: state.plugins,
      schema: state.schema,
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc3;
      },
      get tr() {
        selection = transaction.selection;
        doc3 = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      }
    };
  }
  function getExtensionField(extension, field, context) {
    if (extension.config[field] === void 0 && extension.parent) {
      return getExtensionField(extension.parent, field, context);
    }
    if (typeof extension.config[field] === "function") {
      const value = extension.config[field].bind({
        ...context,
        parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
      });
      return value;
    }
    return extension.config[field];
  }
  function splitExtensions(extensions2) {
    const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
    const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
    const markExtensions = extensions2.filter((extension) => extension.type === "mark");
    return {
      baseExtensions,
      nodeExtensions,
      markExtensions
    };
  }
  function getAttributesFromExtensions(extensions2) {
    const extensionAttributes = [];
    const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: true,
      isRequired: false
    };
    extensions2.forEach((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
      if (!addGlobalAttributes) {
        return;
      }
      const globalAttributes = addGlobalAttributes();
      globalAttributes.forEach((globalAttribute) => {
        globalAttribute.types.forEach((type) => {
          Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
            extensionAttributes.push({
              type,
              name,
              attribute: {
                ...defaultAttribute,
                ...attribute
              }
            });
          });
        });
      });
    });
    nodeAndMarkExtensions.forEach((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addAttributes = getExtensionField(extension, "addAttributes", context);
      if (!addAttributes) {
        return;
      }
      const attributes = addAttributes();
      Object.entries(attributes).forEach(([name, attribute]) => {
        const mergedAttr = {
          ...defaultAttribute,
          ...attribute
        };
        if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
          mergedAttr.default = mergedAttr.default();
        }
        if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
          delete mergedAttr.default;
        }
        extensionAttributes.push({
          type: extension.name,
          name,
          attribute: mergedAttr
        });
      });
    });
    return extensionAttributes;
  }
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  function mergeAttributes(...objects) {
    return objects.filter((item) => !!item).reduce((items, item) => {
      const mergedAttributes = { ...items };
      Object.entries(item).forEach(([key, value]) => {
        const exists = mergedAttributes[key];
        if (!exists) {
          mergedAttributes[key] = value;
          return;
        }
        if (key === "class") {
          const valueClasses = value ? value.split(" ") : [];
          const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
          const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key === "style") {
          mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
        } else {
          mergedAttributes[key] = value;
        }
      });
      return mergedAttributes;
    }, {});
  }
  function getRenderedAttributes(nodeOrMark, extensionAttributes) {
    return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderHTML) {
        return {
          [item.name]: nodeOrMark.attrs[item.name]
        };
      }
      return item.attribute.renderHTML(nodeOrMark.attrs) || {};
    }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function callOrReturn(value, context = void 0, ...props) {
    if (isFunction2(value)) {
      if (context) {
        return value.bind(context)(...props);
      }
      return value(...props);
    }
    return value;
  }
  function isEmptyObject(value = {}) {
    return Object.keys(value).length === 0 && value.constructor === Object;
  }
  function fromString(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
      return Number(value);
    }
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
    if (parseRule.style) {
      return parseRule;
    }
    return {
      ...parseRule,
      getAttrs: (node) => {
        const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
        if (oldAttributes === false) {
          return false;
        }
        const newAttributes = extensionAttributes.reduce((items, item) => {
          const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
          if (value === null || value === void 0) {
            return items;
          }
          return {
            ...items,
            [item.name]: value
          };
        }, {});
        return { ...oldAttributes, ...newAttributes };
      }
    };
  }
  function cleanUpSchemaItem(data) {
    return Object.fromEntries(
      // @ts-ignore
      Object.entries(data).filter(([key, value]) => {
        if (key === "attrs" && isEmptyObject(value)) {
          return false;
        }
        return value !== null && value !== void 0;
      })
    );
  }
  function getSchemaByResolvedExtensions(extensions2, editor) {
    var _a;
    const allAttributes = getAttributesFromExtensions(extensions2);
    const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
    const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
    const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions2.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension, "content", context)),
        marks: callOrReturn(getExtensionField(extension, "marks", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        inline: callOrReturn(getExtensionField(extension, "inline", context)),
        atom: callOrReturn(getExtensionField(extension, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        defining: callOrReturn(getExtensionField(extension, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a2;
          return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
        });
      }
      const renderText2 = getExtensionField(extension, "renderText", context);
      if (renderText2) {
        schema.toText = renderText2;
      }
      return [extension.name, schema];
    }));
    const marks = Object.fromEntries(markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions2.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a2;
          return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    }));
    return new Schema({
      topNode,
      nodes,
      marks
    });
  }
  function getSchemaTypeByName(name, schema) {
    return schema.nodes[name] || schema.marks[name] || null;
  }
  function isExtensionRulesEnabled(extension, enabled) {
    if (Array.isArray(enabled)) {
      return enabled.some((enabledExtension) => {
        const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
        return name === extension.name;
      });
    }
    return enabled;
  }
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  function run$1(config) {
    var _a;
    const { editor, from: from3, to: to2, text, rules, plugin } = config;
    const { view } = editor;
    if (view.composing) {
      return false;
    }
    const $from = view.state.doc.resolve(from3);
    if (
      // check for code node
      $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
    ) {
      return false;
    }
    let matched = false;
    const textBefore = getTextContentFromNodes($from) + text;
    rules.forEach((rule) => {
      if (matched) {
        return;
      }
      const match = inputRuleMatcherHandler(textBefore, rule.find);
      if (!match) {
        return;
      }
      const tr2 = view.state.tr;
      const state = createChainableState({
        state: view.state,
        transaction: tr2
      });
      const range = {
        from: from3 - (match[0].length - text.length),
        to: to2
      };
      const { commands: commands2, chain, can } = new CommandManager({
        editor,
        state
      });
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can
      });
      if (handler === null || !tr2.steps.length) {
        return;
      }
      tr2.setMeta(plugin, {
        transform: tr2,
        from: from3,
        to: to2,
        text
      });
      view.dispatch(tr2);
      matched = true;
    });
    return matched;
  }
  function inputRulesPlugin(props) {
    const { editor, rules } = props;
    const plugin = new Plugin({
      state: {
        init() {
          return null;
        },
        apply(tr2, prev) {
          const stored = tr2.getMeta(plugin);
          if (stored) {
            return stored;
          }
          return tr2.selectionSet || tr2.docChanged ? null : prev;
        }
      },
      props: {
        handleTextInput(view, from3, to2, text) {
          return run$1({
            editor,
            from: from3,
            to: to2,
            text,
            rules,
            plugin
          });
        },
        handleDOMEvents: {
          compositionend: (view) => {
            setTimeout(() => {
              const { $cursor } = view.state.selection;
              if ($cursor) {
                run$1({
                  editor,
                  from: $cursor.pos,
                  to: $cursor.pos,
                  text: "",
                  rules,
                  plugin
                });
              }
            });
            return false;
          }
        },
        // add support for input rules to trigger on enter
        // this is useful for example for code blocks
        handleKeyDown(view, event) {
          if (event.key !== "Enter") {
            return false;
          }
          const { $cursor } = view.state.selection;
          if ($cursor) {
            return run$1({
              editor,
              from: $cursor.pos,
              to: $cursor.pos,
              text: "\n",
              rules,
              plugin
            });
          }
          return false;
        }
      },
      // @ts-ignore
      isInputRules: true
    });
    return plugin;
  }
  function isNumber2(value) {
    return typeof value === "number";
  }
  function run(config) {
    const { editor, state, from: from3, to: to2, rule, pasteEvent, dropEvent } = config;
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handlers2 = [];
    state.doc.nodesBetween(from3, to2, (node, pos) => {
      if (!node.isTextblock || node.type.spec.code) {
        return;
      }
      const resolvedFrom = Math.max(from3, pos);
      const resolvedTo = Math.min(to2, pos + node.content.size);
      const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
      const matches3 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
      matches3.forEach((match) => {
        if (match.index === void 0) {
          return;
        }
        const start3 = resolvedFrom + match.index + 1;
        const end2 = start3 + match[0].length;
        const range = {
          from: state.tr.mapping.map(start3),
          to: state.tr.mapping.map(end2)
        };
        const handler = rule.handler({
          state,
          range,
          match,
          commands: commands2,
          chain,
          can,
          pasteEvent,
          dropEvent
        });
        handlers2.push(handler);
      });
    });
    const success = handlers2.every((handler) => handler !== null);
    return success;
  }
  function pasteRulesPlugin(props) {
    const { editor, rules } = props;
    let dragSourceElement = null;
    let isPastedFromProseMirror = false;
    let isDroppedFromProseMirror = false;
    let pasteEvent = new ClipboardEvent("paste");
    let dropEvent = new DragEvent("drop");
    const plugins3 = rules.map((rule) => {
      return new Plugin({
        // we register a global drag handler to track the current drag source element
        view(view) {
          const handleDragstart = (event) => {
            var _a;
            dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
          };
          window.addEventListener("dragstart", handleDragstart);
          return {
            destroy() {
              window.removeEventListener("dragstart", handleDragstart);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (view, event) => {
              isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
              dropEvent = event;
              return false;
            },
            paste: (_view, event) => {
              var _a;
              const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
              pasteEvent = event;
              isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
              return false;
            }
          }
        },
        appendTransaction: (transactions, oldState, state) => {
          const transaction = transactions[0];
          const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
          const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
          if (!isPaste && !isDrop) {
            return;
          }
          const from3 = oldState.doc.content.findDiffStart(state.doc.content);
          const to2 = oldState.doc.content.findDiffEnd(state.doc.content);
          if (!isNumber2(from3) || !to2 || from3 === to2.b) {
            return;
          }
          const tr2 = state.tr;
          const chainableState = createChainableState({
            state,
            transaction: tr2
          });
          const handler = run({
            editor,
            state: chainableState,
            from: Math.max(from3 - 1, 0),
            to: to2.b - 1,
            rule,
            pasteEvent,
            dropEvent
          });
          if (!handler || !tr2.steps.length) {
            return;
          }
          dropEvent = new DragEvent("drop");
          pasteEvent = new ClipboardEvent("paste");
          return tr2;
        }
      });
    });
    return plugins3;
  }
  function findDuplicates(items) {
    const filtered = items.filter((el, index3) => items.indexOf(el) !== index3);
    return [...new Set(filtered)];
  }
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
  }
  function mergeDeep(target, source2) {
    const output = { ...target };
    if (isPlainObject(target) && isPlainObject(source2)) {
      Object.keys(source2).forEach((key) => {
        if (isPlainObject(source2[key])) {
          if (!(key in target)) {
            Object.assign(output, { [key]: source2[key] });
          } else {
            output[key] = mergeDeep(target[key], source2[key]);
          }
        } else {
          Object.assign(output, { [key]: source2[key] });
        }
      });
    }
    return output;
  }
  function getTextBetween(startNode, range, options) {
    const { from: from3, to: to2 } = range;
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    let text = "";
    let separated = true;
    startNode.nodesBetween(from3, to2, (node, pos, parent, index3) => {
      var _a;
      const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
      if (textSerializer) {
        if (node.isBlock && !separated) {
          text += blockSeparator;
          separated = true;
        }
        if (parent) {
          text += textSerializer({
            node,
            pos,
            parent,
            index: index3,
            range
          });
        }
      } else if (node.isText) {
        text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from3, pos) - pos, to2 - pos);
        separated = false;
      } else if (node.isBlock && !separated) {
        text += blockSeparator;
        separated = true;
      }
    });
    return text;
  }
  function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
  }
  function objectIncludes(object1, object2, options = { strict: true }) {
    const keys2 = Object.keys(object2);
    if (!keys2.length) {
      return true;
    }
    return keys2.every((key) => {
      if (options.strict) {
        return object2[key] === object1[key];
      }
      if (isRegExp(object2[key])) {
        return object2[key].test(object1[key]);
      }
      return object2[key] === object1[key];
    });
  }
  function findMarkInSet(marks, type, attributes = {}) {
    return marks.find((item) => {
      return item.type === type && objectIncludes(item.attrs, attributes);
    });
  }
  function isMarkInSet(marks, type, attributes = {}) {
    return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type, attributes = {}) {
    if (!$pos || !type) {
      return;
    }
    let start3 = $pos.parent.childAfter($pos.parentOffset);
    if ($pos.parentOffset === start3.offset && start3.offset !== 0) {
      start3 = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start3.node) {
      return;
    }
    const mark = findMarkInSet([...start3.node.marks], type, attributes);
    if (!mark) {
      return;
    }
    let startIndex = start3.index;
    let startPos = $pos.start() + start3.offset;
    let endIndex = startIndex + 1;
    let endPos = startPos + start3.node.nodeSize;
    findMarkInSet([...start3.node.marks], type, attributes);
    while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
      startIndex -= 1;
      startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
      endPos += $pos.parent.child(endIndex).nodeSize;
      endIndex += 1;
    }
    return {
      from: startPos,
      to: endPos
    };
  }
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  function isTextSelection(value) {
    return value instanceof TextSelection;
  }
  function minMax(value = 0, min2 = 0, max2 = 0) {
    return Math.min(Math.max(value, min2), max2);
  }
  function resolveFocusPosition(doc3, position = null) {
    if (!position) {
      return null;
    }
    const selectionAtStart = Selection.atStart(doc3);
    const selectionAtEnd = Selection.atEnd(doc3);
    if (position === "start" || position === true) {
      return selectionAtStart;
    }
    if (position === "end") {
      return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position === "all") {
      return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
  }
  function isiOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  function elementFromString(value) {
    const wrappedValue = `<body>${value}</body>`;
    const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
    return removeWhitespaces(html);
  }
  function createNodeFromContent(content, schema, options) {
    options = {
      slice: true,
      parseOptions: {},
      ...options
    };
    if (typeof content === "object" && content !== null) {
      try {
        if (Array.isArray(content) && content.length > 0) {
          return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
        }
        return schema.nodeFromJSON(content);
      } catch (error3) {
        console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error3);
        return createNodeFromContent("", schema, options);
      }
    }
    if (typeof content === "string") {
      const parser = DOMParser2.fromSchema(schema);
      return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
    }
    return createNodeFromContent("", schema, options);
  }
  function selectionToInsertionEnd2(tr2, startLen, bias) {
    const last = tr2.steps.length - 1;
    if (last < startLen) {
      return;
    }
    const step = tr2.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
      return;
    }
    const map4 = tr2.mapping.maps[last];
    let end2 = 0;
    map4.forEach((_from, _to, _newFrom, newTo) => {
      if (end2 === 0) {
        end2 = newTo;
      }
    });
    tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
  }
  function isMacOS() {
    return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  }
  function normalizeKeyName2(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result === "Space") {
      result = " ";
    }
    let alt;
    let ctrl;
    let shift2;
    let meta;
    for (let i = 0; i < parts.length - 1; i += 1) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift2 = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error(`Unrecognized modifier name: ${mod}`);
      }
    }
    if (alt) {
      result = `Alt-${result}`;
    }
    if (ctrl) {
      result = `Ctrl-${result}`;
    }
    if (meta) {
      result = `Meta-${result}`;
    }
    if (shift2) {
      result = `Shift-${result}`;
    }
    return result;
  }
  function isNodeActive(state, typeOrName, attributes = {}) {
    const { from: from3, to: to2, empty: empty2 } = state.selection;
    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from3, to2, (node, pos) => {
      if (node.isText) {
        return;
      }
      const relativeFrom = Math.max(from3, pos);
      const relativeTo = Math.min(to2, pos + node.nodeSize);
      nodeRanges.push({
        node,
        from: relativeFrom,
        to: relativeTo
      });
    });
    const selectionRange = to2 - from3;
    const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
      if (!type) {
        return true;
      }
      return type.name === nodeRange.node.type.name;
    }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
    if (empty2) {
      return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
    return range >= selectionRange;
  }
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce((newObj, prop) => {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  function createDocument(content, schema, parseOptions = {}) {
    return createNodeFromContent(content, schema, { slice: false, parseOptions });
  }
  function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from: from3, to: to2, empty: empty2 } = state.selection;
    const marks = [];
    if (empty2) {
      if (state.storedMarks) {
        marks.push(...state.storedMarks);
      }
      marks.push(...state.selection.$head.marks());
    } else {
      state.doc.nodesBetween(from3, to2, (node) => {
        marks.push(...node.marks);
      });
    }
    const mark = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark) {
      return {};
    }
    return { ...mark.attrs };
  }
  function combineTransactionSteps(oldDoc, transactions) {
    const transform = new Transform(oldDoc);
    transactions.forEach((transaction) => {
      transaction.steps.forEach((step) => {
        transform.step(step);
      });
    });
    return transform;
  }
  function defaultBlockAt2(match) {
    for (let i = 0; i < match.edgeCount; i += 1) {
      const { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function findChildren(node, predicate) {
    const nodesWithPos = [];
    node.descendants((child, pos) => {
      if (predicate(child)) {
        nodesWithPos.push({
          node: child,
          pos
        });
      }
    });
    return nodesWithPos;
  }
  function findChildrenInRange(node, range, predicate) {
    const nodesWithPos = [];
    node.nodesBetween(range.from, range.to, (child, pos) => {
      if (predicate(child)) {
        nodesWithPos.push({
          node: child,
          pos
        });
      }
    });
    return nodesWithPos;
  }
  function findParentNodeClosestToPos($pos, predicate) {
    for (let i = $pos.depth; i > 0; i -= 1) {
      const node = $pos.node(i);
      if (predicate(node)) {
        return {
          pos: i > 0 ? $pos.before(i) : 0,
          start: $pos.start(i),
          depth: i,
          node
        };
      }
    }
  }
  function findParentNode(predicate) {
    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
  }
  function getHTMLFromFragment(fragment, schema) {
    const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
    const temporaryDocument = document.implementation.createHTMLDocument();
    const container = temporaryDocument.createElement("div");
    container.appendChild(documentFragment);
    return container.innerHTML;
  }
  function getSchema(extensions2, editor) {
    const resolvedExtensions = ExtensionManager.resolve(extensions2);
    return getSchemaByResolvedExtensions(resolvedExtensions, editor);
  }
  function generateHTML(doc3, extensions2) {
    const schema = getSchema(extensions2);
    const contentNode = Node2.fromJSON(schema, doc3);
    return getHTMLFromFragment(contentNode.content, schema);
  }
  function generateJSON(html, extensions2) {
    const schema = getSchema(extensions2);
    const dom = elementFromString(html);
    return DOMParser2.fromSchema(schema).parse(dom).toJSON();
  }
  function getText2(node, options) {
    const range = {
      from: 0,
      to: node.content.size
    };
    return getTextBetween(node, range, options);
  }
  function generateText(doc3, extensions2, options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    const schema = getSchema(extensions2);
    const contentNode = Node2.fromJSON(schema, doc3);
    return getText2(contentNode, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(schema),
        ...textSerializers
      }
    });
  }
  function getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from: from3, to: to2 } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from3, to2, (node2) => {
      nodes.push(node2);
    });
    const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node) {
      return {};
    }
    return { ...node.attrs };
  }
  function getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (schemaType === "node") {
      return getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return getMarkAttributes(state, typeOrName);
    }
    return {};
  }
  function removeDuplicates(array, by = JSON.stringify) {
    const seen = {};
    return array.filter((item) => {
      const key = by(item);
      return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
    });
  }
  function simplifyChangedRanges(changes) {
    const uniqueChanges = removeDuplicates(changes);
    return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index3) => {
      const rest = uniqueChanges.filter((_, i) => i !== index3);
      return !rest.some((otherChange) => {
        return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
      });
    });
  }
  function getChangedRanges(transform) {
    const { mapping, steps: steps2 } = transform;
    const changes = [];
    mapping.maps.forEach((stepMap, index3) => {
      const ranges = [];
      if (!stepMap.ranges.length) {
        const { from: from3, to: to2 } = steps2[index3];
        if (from3 === void 0 || to2 === void 0) {
          return;
        }
        ranges.push({ from: from3, to: to2 });
      } else {
        stepMap.forEach((from3, to2) => {
          ranges.push({ from: from3, to: to2 });
        });
      }
      ranges.forEach(({ from: from3, to: to2 }) => {
        const newStart = mapping.slice(index3).map(from3, -1);
        const newEnd = mapping.slice(index3).map(to2);
        const oldStart = mapping.invert().map(newStart, -1);
        const oldEnd = mapping.invert().map(newEnd);
        changes.push({
          oldRange: {
            from: oldStart,
            to: oldEnd
          },
          newRange: {
            from: newStart,
            to: newEnd
          }
        });
      });
    });
    return simplifyChangedRanges(changes);
  }
  function getDebugJSON(node, startOffset = 0) {
    const isTopNode = node.type === node.type.schema.topNodeType;
    const increment = isTopNode ? 0 : 1;
    const from3 = startOffset;
    const to2 = from3 + node.nodeSize;
    const marks = node.marks.map((mark) => {
      const output2 = {
        type: mark.type.name
      };
      if (Object.keys(mark.attrs).length) {
        output2.attrs = { ...mark.attrs };
      }
      return output2;
    });
    const attrs = { ...node.attrs };
    const output = {
      type: node.type.name,
      from: from3,
      to: to2
    };
    if (Object.keys(attrs).length) {
      output.attrs = attrs;
    }
    if (marks.length) {
      output.marks = marks;
    }
    if (node.content.childCount) {
      output.content = [];
      node.forEach((child, offset2) => {
        var _a;
        (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset2 + increment));
      });
    }
    if (node.text) {
      output.text = node.text;
    }
    return output;
  }
  function getMarksBetween(from3, to2, doc3) {
    const marks = [];
    if (from3 === to2) {
      doc3.resolve(from3).marks().forEach((mark) => {
        const $pos = doc3.resolve(from3 - 1);
        const range = getMarkRange($pos, mark.type);
        if (!range) {
          return;
        }
        marks.push({
          mark,
          ...range
        });
      });
    } else {
      doc3.nodesBetween(from3, to2, (node, pos) => {
        if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
          return;
        }
        marks.push(...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        })));
      });
    }
    return marks;
  }
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    }));
  }
  function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty: empty2, ranges } = state.selection;
    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty2) {
      return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
        if (!type) {
          return true;
        }
        return type.name === mark.type.name;
      }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
      const from3 = $from.pos;
      const to2 = $to.pos;
      state.doc.nodesBetween(from3, to2, (node, pos) => {
        if (!node.isText && !node.marks.length) {
          return;
        }
        const relativeFrom = Math.max(from3, pos);
        const relativeTo = Math.min(to2, pos + node.nodeSize);
        const range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push(...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        })));
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    const matchedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return type.name === markRange.mark.type.name;
    }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const excludedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  function isActive(state, name, attributes = {}) {
    if (!name) {
      return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
    }
    const schemaType = getSchemaTypeNameByName(name, state.schema);
    if (schemaType === "node") {
      return isNodeActive(state, name, attributes);
    }
    if (schemaType === "mark") {
      return isMarkActive(state, name, attributes);
    }
    return false;
  }
  function isList(name, extensions2) {
    const { nodeExtensions } = splitExtensions(extensions2);
    const extension = nodeExtensions.find((item) => item.name === name);
    if (!extension) {
      return false;
    }
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const group = callOrReturn(getExtensionField(extension, "group", context));
    if (typeof group !== "string") {
      return false;
    }
    return group.split(" ").includes("list");
  }
  function isNodeEmpty(node) {
    var _a;
    const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
    const content = node.toJSON();
    return JSON.stringify(defaultContent) === JSON.stringify(content);
  }
  function isNodeSelection(value) {
    return value instanceof NodeSelection;
  }
  function posToDOMRect(view, from3, to2) {
    const minPos = 0;
    const maxPos = view.state.doc.content.size;
    const resolvedFrom = minMax(from3, minPos, maxPos);
    const resolvedEnd = minMax(to2, minPos, maxPos);
    const start3 = view.coordsAtPos(resolvedFrom);
    const end2 = view.coordsAtPos(resolvedEnd, -1);
    const top2 = Math.min(start3.top, end2.top);
    const bottom2 = Math.max(start3.bottom, end2.bottom);
    const left2 = Math.min(start3.left, end2.left);
    const right2 = Math.max(start3.right, end2.right);
    const width = right2 - left2;
    const height = bottom2 - top2;
    const x = left2;
    const y = top2;
    const data = {
      top: top2,
      bottom: bottom2,
      left: left2,
      right: right2,
      width,
      height,
      x,
      y
    };
    return {
      ...data,
      toJSON: () => data
    };
  }
  function canSetMark(state, tr2, newMarkType) {
    var _a;
    const { selection } = tr2;
    let cursor = null;
    if (isTextSelection(selection)) {
      cursor = selection.$cursor;
    }
    if (cursor) {
      const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
      return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
    }
    const { ranges } = selection;
    return ranges.some(({ $from, $to }) => {
      let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
      state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
        if (someNodeSupportsMark) {
          return false;
        }
        if (node.isInline) {
          const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
          const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
          someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
        }
        return !someNodeSupportsMark;
      });
      return someNodeSupportsMark;
    });
  }
  function ensureMarks(state, splittableMarks) {
    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) {
      const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
      state.tr.ensureMarks(filteredMarks);
    }
  }
  function createStyleTag(style2, nonce, suffix) {
    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
    if (tiptapStyleTag !== null) {
      return tiptapStyleTag;
    }
    const styleNode = document.createElement("style");
    if (nonce) {
      styleNode.setAttribute("nonce", nonce);
    }
    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
    styleNode.innerHTML = style2;
    document.getElementsByTagName("head")[0].appendChild(styleNode);
    return styleNode;
  }
  function markInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr: tr2 } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr2.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr2.delete(range.from + startSpaces, textStart);
          }
          const markEnd = range.from + startSpaces + captureGroup.length;
          tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
          tr2.removeStoredMark(config.type);
        }
      }
    });
  }
  function nodeInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        const { tr: tr2 } = state;
        const start3 = range.from;
        let end2 = range.to;
        const newNode2 = config.type.create(attributes);
        if (match[1]) {
          const offset2 = match[0].lastIndexOf(match[1]);
          let matchStart = start3 + offset2;
          if (matchStart > end2) {
            matchStart = end2;
          } else {
            end2 = matchStart + match[1].length;
          }
          const lastChar = match[0][match[0].length - 1];
          tr2.insertText(lastChar, start3 + match[0].length - 1);
          tr2.replaceWith(matchStart, end2, newNode2);
        } else if (match[0]) {
          tr2.insert(start3 - 1, config.type.create(attributes)).delete(tr2.mapping.map(start3), tr2.mapping.map(end2));
        }
        tr2.scrollIntoView();
      }
    });
  }
  function textblockTypeInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const $start = state.doc.resolve(range.from);
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
          return null;
        }
        state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
      }
    });
  }
  function textInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        let insert = config.replace;
        let start3 = range.from;
        const end2 = range.to;
        if (match[1]) {
          const offset2 = match[0].lastIndexOf(match[1]);
          insert += match[0].slice(offset2 + match[1].length);
          start3 += offset2;
          const cutOff = start3 - end2;
          if (cutOff > 0) {
            insert = match[0].slice(offset2 - cutOff, offset2) + insert;
            start3 = end2;
          }
        }
        state.tr.insertText(insert, start3, end2);
      }
    });
  }
  function wrappingInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match, chain }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        const tr2 = state.tr.delete(range.from, range.to);
        const $start = tr2.doc.resolve(range.from);
        const blockRange = $start.blockRange();
        const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
        if (!wrapping) {
          return null;
        }
        tr2.wrap(blockRange, wrapping);
        if (config.keepMarks && config.editor) {
          const { selection, storedMarks } = state;
          const { splittableMarks } = config.editor.extensionManager;
          const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
          if (marks) {
            const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
            tr2.ensureMarks(filteredMarks);
          }
        }
        if (config.keepAttributes) {
          const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
          chain().updateAttributes(nodeType, attributes).run();
        }
        const before = tr2.doc.resolve(range.from - 1).nodeBefore;
        if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
          tr2.join(range.from - 1);
        }
      }
    });
  }
  function isAndroid() {
    return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
  }
  function markPasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler: ({ state, range, match, pasteEvent }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr: tr2 } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        let markEnd = range.to;
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr2.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr2.delete(range.from + startSpaces, textStart);
          }
          markEnd = range.from + startSpaces + captureGroup.length;
          tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
          tr2.removeStoredMark(config.type);
        }
      }
    });
  }
  function escapeForRegEx(string) {
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function isString(value) {
    return typeof value === "string";
  }
  function nodePasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler({ match, chain, range, pasteEvent }) {
        const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
        if (attributes === false || attributes === null) {
          return null;
        }
        if (match.input) {
          chain().deleteRange(range).insertContentAt(range.from, {
            type: config.type.name,
            attrs: attributes
          });
        }
      }
    });
  }
  function textPasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        let insert = config.replace;
        let start3 = range.from;
        const end2 = range.to;
        if (match[1]) {
          const offset2 = match[0].lastIndexOf(match[1]);
          insert += match[0].slice(offset2 + match[1].length);
          start3 += offset2;
          const cutOff = start3 - end2;
          if (cutOff > 0) {
            insert = match[0].slice(offset2 - cutOff, offset2) + insert;
            start3 = end2;
          }
        }
        state.tr.insertText(insert, start3, end2);
      }
    });
  }
  var CommandManager, EventEmitter, getTextContentFromNodes, InputRule, inputRuleMatcherHandler, PasteRule, pasteRuleMatcherHandler, ExtensionManager, Extension, ClipboardTextSerializer, blur, clearContent, clearNodes, command, createParagraphNear2, cut, deleteCurrentNode, deleteNode, deleteRange2, deleteSelection2, enter, exitCode2, extendMarkRange, first, focus, forEach, insertContent, removeWhitespaces, isFragment, insertContentAt, joinUp2, joinDown2, joinBackward2, joinForward2, joinItemBackward, joinItemForward, joinTextblockBackward2, joinTextblockForward2, keyboardShortcut, lift3, liftEmptyBlock2, liftListItem2, newlineInCode2, resetAttributes, scrollIntoView, selectAll2, selectNodeBackward2, selectNodeForward2, selectParentNode2, selectTextblockEnd2, selectTextblockStart2, setContent2, getNodeAtPosition, isAtEndOfNode, isAtStartOfNode, setMark, setMeta, setNode, setNodeSelection, setTextSelection, sinkListItem2, splitBlock2, splitListItem, joinListBackwards, joinListForwards, toggleList, toggleMark, toggleNode, toggleWrap, undoInputRule, unsetAllMarks, unsetMark, updateAttributes, wrapIn2, wrapInList2, commands, Commands, Editable, FocusEvents, Keymap, Tabindex, extensions, NodePos, style, Editor, Mark2, Node3, NodeView, Tracker;
  var init_dist16 = __esm({
    "node_modules/@tiptap/core/dist/index.js"() {
      init_dist5();
      init_dist7();
      init_dist9();
      init_dist10();
      init_dist11();
      init_dist13();
      init_dist15();
      CommandManager = class {
        constructor(props) {
          this.editor = props.editor;
          this.rawCommands = this.editor.extensionManager.commands;
          this.customState = props.state;
        }
        get hasCustomState() {
          return !!this.customState;
        }
        get state() {
          return this.customState || this.editor.state;
        }
        get commands() {
          const { rawCommands, editor, state } = this;
          const { view } = editor;
          const { tr: tr2 } = state;
          const props = this.buildProps(tr2);
          return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            const method = (...args) => {
              const callback2 = command2(...args)(props);
              if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
                view.dispatch(tr2);
              }
              return callback2;
            };
            return [name, method];
          }));
        }
        get chain() {
          return () => this.createChain();
        }
        get can() {
          return () => this.createCan();
        }
        createChain(startTr, shouldDispatch = true) {
          const { rawCommands, editor, state } = this;
          const { view } = editor;
          const callbacks = [];
          const hasStartTransaction = !!startTr;
          const tr2 = startTr || state.tr;
          const run3 = () => {
            if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
              view.dispatch(tr2);
            }
            return callbacks.every((callback2) => callback2 === true);
          };
          const chain = {
            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
              const chainedCommand = (...args) => {
                const props = this.buildProps(tr2, shouldDispatch);
                const callback2 = command2(...args)(props);
                callbacks.push(callback2);
                return chain;
              };
              return [name, chainedCommand];
            })),
            run: run3
          };
          return chain;
        }
        createCan(startTr) {
          const { rawCommands, state } = this;
          const dispatch2 = false;
          const tr2 = startTr || state.tr;
          const props = this.buildProps(tr2, dispatch2);
          const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
          }));
          return {
            ...formattedCommands,
            chain: () => this.createChain(tr2, dispatch2)
          };
        }
        buildProps(tr2, shouldDispatch = true) {
          const { rawCommands, editor, state } = this;
          const { view } = editor;
          const props = {
            tr: tr2,
            editor,
            view,
            state: createChainableState({
              state,
              transaction: tr2
            }),
            dispatch: shouldDispatch ? () => void 0 : void 0,
            chain: () => this.createChain(tr2, shouldDispatch),
            can: () => this.createCan(tr2),
            get commands() {
              return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
                return [name, (...args) => command2(...args)(props)];
              }));
            }
          };
          return props;
        }
      };
      EventEmitter = class {
        constructor() {
          this.callbacks = {};
        }
        on(event, fn2) {
          if (!this.callbacks[event]) {
            this.callbacks[event] = [];
          }
          this.callbacks[event].push(fn2);
          return this;
        }
        emit(event, ...args) {
          const callbacks = this.callbacks[event];
          if (callbacks) {
            callbacks.forEach((callback2) => callback2.apply(this, args));
          }
          return this;
        }
        off(event, fn2) {
          const callbacks = this.callbacks[event];
          if (callbacks) {
            if (fn2) {
              this.callbacks[event] = callbacks.filter((callback2) => callback2 !== fn2);
            } else {
              delete this.callbacks[event];
            }
          }
          return this;
        }
        removeAllListeners() {
          this.callbacks = {};
        }
      };
      getTextContentFromNodes = ($from, maxMatch = 500) => {
        let textBefore = "";
        const sliceEndPos = $from.parentOffset;
        $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index3) => {
          var _a, _b;
          const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
            node,
            pos,
            parent,
            index: index3
          })) || node.textContent || "%leaf%";
          textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
        });
        return textBefore;
      };
      InputRule = class {
        constructor(config) {
          this.find = config.find;
          this.handler = config.handler;
        }
      };
      inputRuleMatcherHandler = (text, find3) => {
        if (isRegExp(find3)) {
          return find3.exec(text);
        }
        const inputRuleMatch = find3(text);
        if (!inputRuleMatch) {
          return null;
        }
        const result = [inputRuleMatch.text];
        result.index = inputRuleMatch.index;
        result.input = text;
        result.data = inputRuleMatch.data;
        if (inputRuleMatch.replaceWith) {
          if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
            console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
          }
          result.push(inputRuleMatch.replaceWith);
        }
        return result;
      };
      PasteRule = class {
        constructor(config) {
          this.find = config.find;
          this.handler = config.handler;
        }
      };
      pasteRuleMatcherHandler = (text, find3, event) => {
        if (isRegExp(find3)) {
          return [...text.matchAll(find3)];
        }
        const matches3 = find3(text, event);
        if (!matches3) {
          return [];
        }
        return matches3.map((pasteRuleMatch) => {
          const result = [pasteRuleMatch.text];
          result.index = pasteRuleMatch.index;
          result.input = text;
          result.data = pasteRuleMatch.data;
          if (pasteRuleMatch.replaceWith) {
            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
              console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
            }
            result.push(pasteRuleMatch.replaceWith);
          }
          return result;
        });
      };
      ExtensionManager = class _ExtensionManager {
        constructor(extensions2, editor) {
          this.splittableMarks = [];
          this.editor = editor;
          this.extensions = _ExtensionManager.resolve(extensions2);
          this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
          this.extensions.forEach((extension) => {
            var _a;
            this.editor.extensionStorage[extension.name] = extension.storage;
            const context = {
              name: extension.name,
              options: extension.options,
              storage: extension.storage,
              editor: this.editor,
              type: getSchemaTypeByName(extension.name, this.schema)
            };
            if (extension.type === "mark") {
              const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
              if (keepOnSplit) {
                this.splittableMarks.push(extension.name);
              }
            }
            const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
            if (onBeforeCreate) {
              this.editor.on("beforeCreate", onBeforeCreate);
            }
            const onCreate2 = getExtensionField(extension, "onCreate", context);
            if (onCreate2) {
              this.editor.on("create", onCreate2);
            }
            const onUpdate = getExtensionField(extension, "onUpdate", context);
            if (onUpdate) {
              this.editor.on("update", onUpdate);
            }
            const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
            if (onSelectionUpdate) {
              this.editor.on("selectionUpdate", onSelectionUpdate);
            }
            const onTransaction = getExtensionField(extension, "onTransaction", context);
            if (onTransaction) {
              this.editor.on("transaction", onTransaction);
            }
            const onFocus = getExtensionField(extension, "onFocus", context);
            if (onFocus) {
              this.editor.on("focus", onFocus);
            }
            const onBlur = getExtensionField(extension, "onBlur", context);
            if (onBlur) {
              this.editor.on("blur", onBlur);
            }
            const onDestroy2 = getExtensionField(extension, "onDestroy", context);
            if (onDestroy2) {
              this.editor.on("destroy", onDestroy2);
            }
          });
        }
        static resolve(extensions2) {
          const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions2));
          const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
          if (duplicatedNames.length) {
            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
          }
          return resolvedExtensions;
        }
        static flatten(extensions2) {
          return extensions2.map((extension) => {
            const context = {
              name: extension.name,
              options: extension.options,
              storage: extension.storage
            };
            const addExtensions = getExtensionField(extension, "addExtensions", context);
            if (addExtensions) {
              return [extension, ...this.flatten(addExtensions())];
            }
            return extension;
          }).flat(10);
        }
        static sort(extensions2) {
          const defaultPriority = 100;
          return extensions2.sort((a, b) => {
            const priorityA = getExtensionField(a, "priority") || defaultPriority;
            const priorityB = getExtensionField(b, "priority") || defaultPriority;
            if (priorityA > priorityB) {
              return -1;
            }
            if (priorityA < priorityB) {
              return 1;
            }
            return 0;
          });
        }
        get commands() {
          return this.extensions.reduce((commands2, extension) => {
            const context = {
              name: extension.name,
              options: extension.options,
              storage: extension.storage,
              editor: this.editor,
              type: getSchemaTypeByName(extension.name, this.schema)
            };
            const addCommands = getExtensionField(extension, "addCommands", context);
            if (!addCommands) {
              return commands2;
            }
            return {
              ...commands2,
              ...addCommands()
            };
          }, {});
        }
        get plugins() {
          const { editor } = this;
          const extensions2 = _ExtensionManager.sort([...this.extensions].reverse());
          const inputRules = [];
          const pasteRules = [];
          const allPlugins2 = extensions2.map((extension) => {
            const context = {
              name: extension.name,
              options: extension.options,
              storage: extension.storage,
              editor,
              type: getSchemaTypeByName(extension.name, this.schema)
            };
            const plugins3 = [];
            const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
            let defaultBindings = {};
            if (extension.type === "mark" && extension.config.exitable) {
              defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
            }
            if (addKeyboardShortcuts) {
              const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
                return [shortcut, () => method({ editor })];
              }));
              defaultBindings = { ...defaultBindings, ...bindings };
            }
            const keyMapPlugin = keymap(defaultBindings);
            plugins3.push(keyMapPlugin);
            const addInputRules = getExtensionField(extension, "addInputRules", context);
            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
              inputRules.push(...addInputRules());
            }
            const addPasteRules = getExtensionField(extension, "addPasteRules", context);
            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
              pasteRules.push(...addPasteRules());
            }
            const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
            if (addProseMirrorPlugins) {
              const proseMirrorPlugins = addProseMirrorPlugins();
              plugins3.push(...proseMirrorPlugins);
            }
            return plugins3;
          }).flat();
          return [
            inputRulesPlugin({
              editor,
              rules: inputRules
            }),
            ...pasteRulesPlugin({
              editor,
              rules: pasteRules
            }),
            ...allPlugins2
          ];
        }
        get attributes() {
          return getAttributesFromExtensions(this.extensions);
        }
        get nodeViews() {
          const { editor } = this;
          const { nodeExtensions } = splitExtensions(this.extensions);
          return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
            const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
            const context = {
              name: extension.name,
              options: extension.options,
              storage: extension.storage,
              editor,
              type: getNodeType(extension.name, this.schema)
            };
            const addNodeView = getExtensionField(extension, "addNodeView", context);
            if (!addNodeView) {
              return [];
            }
            const nodeview = (node, view, getPos, decorations) => {
              const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
              return addNodeView()({
                editor,
                node,
                getPos,
                decorations,
                HTMLAttributes,
                extension
              });
            };
            return [extension.name, nodeview];
          }));
        }
      };
      Extension = class _Extension {
        constructor(config = {}) {
          this.type = "extension";
          this.name = "extension";
          this.parent = null;
          this.child = null;
          this.config = {
            name: this.name,
            defaultOptions: {}
          };
          this.config = {
            ...this.config,
            ...config
          };
          this.name = this.config.name;
          if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
          }
          this.options = this.config.defaultOptions;
          if (this.config.addOptions) {
            this.options = callOrReturn(getExtensionField(this, "addOptions", {
              name: this.name
            }));
          }
          this.storage = callOrReturn(getExtensionField(this, "addStorage", {
            name: this.name,
            options: this.options
          })) || {};
        }
        static create(config = {}) {
          return new _Extension(config);
        }
        configure(options = {}) {
          const extension = this.extend();
          extension.options = mergeDeep(this.options, options);
          extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
            name: extension.name,
            options: extension.options
          }));
          return extension;
        }
        extend(extendedConfig = {}) {
          const extension = new _Extension({ ...this.config, ...extendedConfig });
          extension.parent = this;
          this.child = extension;
          extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
          if (extendedConfig.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
          }
          extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
            name: extension.name
          }));
          extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
            name: extension.name,
            options: extension.options
          }));
          return extension;
        }
      };
      ClipboardTextSerializer = Extension.create({
        name: "clipboardTextSerializer",
        addProseMirrorPlugins() {
          return [
            new Plugin({
              key: new PluginKey("clipboardTextSerializer"),
              props: {
                clipboardTextSerializer: () => {
                  const { editor } = this;
                  const { state, schema } = editor;
                  const { doc: doc3, selection } = state;
                  const { ranges } = selection;
                  const from3 = Math.min(...ranges.map((range2) => range2.$from.pos));
                  const to2 = Math.max(...ranges.map((range2) => range2.$to.pos));
                  const textSerializers = getTextSerializersFromSchema(schema);
                  const range = { from: from3, to: to2 };
                  return getTextBetween(doc3, range, {
                    textSerializers
                  });
                }
              }
            })
          ];
        }
      });
      blur = () => ({ editor, view }) => {
        requestAnimationFrame(() => {
          var _a;
          if (!editor.isDestroyed) {
            view.dom.blur();
            (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
          }
        });
        return true;
      };
      clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
        return commands2.setContent("", emitUpdate);
      };
      clearNodes = () => ({ state, tr: tr2, dispatch: dispatch2 }) => {
        const { selection } = tr2;
        const { ranges } = selection;
        if (!dispatch2) {
          return true;
        }
        ranges.forEach(({ $from, $to }) => {
          state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
            if (node.type.isText) {
              return;
            }
            const { doc: doc3, mapping } = tr2;
            const $mappedFrom = doc3.resolve(mapping.map(pos));
            const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
            const nodeRange = $mappedFrom.blockRange($mappedTo);
            if (!nodeRange) {
              return;
            }
            const targetLiftDepth = liftTarget(nodeRange);
            if (node.type.isTextblock) {
              const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
              tr2.setNodeMarkup(nodeRange.start, defaultType);
            }
            if (targetLiftDepth || targetLiftDepth === 0) {
              tr2.lift(nodeRange, targetLiftDepth);
            }
          });
        });
        return true;
      };
      command = (fn2) => (props) => {
        return fn2(props);
      };
      createParagraphNear2 = () => ({ state, dispatch: dispatch2 }) => {
        return createParagraphNear(state, dispatch2);
      };
      cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
        const { state } = editor;
        const contentSlice = state.doc.slice(originRange.from, originRange.to);
        tr2.deleteRange(originRange.from, originRange.to);
        const newPos = tr2.mapping.map(targetPos);
        tr2.insert(newPos, contentSlice.content);
        tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
        return true;
      };
      deleteCurrentNode = () => ({ tr: tr2, dispatch: dispatch2 }) => {
        const { selection } = tr2;
        const currentNode = selection.$anchor.node();
        if (currentNode.content.size > 0) {
          return false;
        }
        const $pos = tr2.selection.$anchor;
        for (let depth = $pos.depth; depth > 0; depth -= 1) {
          const node = $pos.node(depth);
          if (node.type === currentNode.type) {
            if (dispatch2) {
              const from3 = $pos.before(depth);
              const to2 = $pos.after(depth);
              tr2.delete(from3, to2).scrollIntoView();
            }
            return true;
          }
        }
        return false;
      };
      deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
        const type = getNodeType(typeOrName, state.schema);
        const $pos = tr2.selection.$anchor;
        for (let depth = $pos.depth; depth > 0; depth -= 1) {
          const node = $pos.node(depth);
          if (node.type === type) {
            if (dispatch2) {
              const from3 = $pos.before(depth);
              const to2 = $pos.after(depth);
              tr2.delete(from3, to2).scrollIntoView();
            }
            return true;
          }
        }
        return false;
      };
      deleteRange2 = (range) => ({ tr: tr2, dispatch: dispatch2 }) => {
        const { from: from3, to: to2 } = range;
        if (dispatch2) {
          tr2.delete(from3, to2);
        }
        return true;
      };
      deleteSelection2 = () => ({ state, dispatch: dispatch2 }) => {
        return deleteSelection(state, dispatch2);
      };
      enter = () => ({ commands: commands2 }) => {
        return commands2.keyboardShortcut("Enter");
      };
      exitCode2 = () => ({ state, dispatch: dispatch2 }) => {
        return exitCode(state, dispatch2);
      };
      extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
        const type = getMarkType(typeOrName, state.schema);
        const { doc: doc3, selection } = tr2;
        const { $from, from: from3, to: to2 } = selection;
        if (dispatch2) {
          const range = getMarkRange($from, type, attributes);
          if (range && range.from <= from3 && range.to >= to2) {
            const newSelection = TextSelection.create(doc3, range.from, range.to);
            tr2.setSelection(newSelection);
          }
        }
        return true;
      };
      first = (commands2) => (props) => {
        const items = typeof commands2 === "function" ? commands2(props) : commands2;
        for (let i = 0; i < items.length; i += 1) {
          if (items[i](props)) {
            return true;
          }
        }
        return false;
      };
      focus = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
        options = {
          scrollIntoView: true,
          ...options
        };
        const delayedFocus = () => {
          if (isiOS()) {
            view.dom.focus();
          }
          requestAnimationFrame(() => {
            if (!editor.isDestroyed) {
              view.focus();
              if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
                editor.commands.scrollIntoView();
              }
            }
          });
        };
        if (view.hasFocus() && position === null || position === false) {
          return true;
        }
        if (dispatch2 && position === null && !isTextSelection(editor.state.selection)) {
          delayedFocus();
          return true;
        }
        const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
        const isSameSelection = editor.state.selection.eq(selection);
        if (dispatch2) {
          if (!isSameSelection) {
            tr2.setSelection(selection);
          }
          if (isSameSelection && tr2.storedMarks) {
            tr2.setStoredMarks(tr2.storedMarks);
          }
          delayedFocus();
        }
        return true;
      };
      forEach = (items, fn2) => (props) => {
        return items.every((item, index3) => fn2(item, { ...props, index: index3 }));
      };
      insertContent = (value, options) => ({ tr: tr2, commands: commands2 }) => {
        return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
      };
      removeWhitespaces = (node) => {
        const children = node.childNodes;
        for (let i = children.length - 1; i >= 0; i -= 1) {
          const child = children[i];
          if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
            node.removeChild(child);
          } else if (child.nodeType === 1) {
            removeWhitespaces(child);
          }
        }
        return node;
      };
      isFragment = (nodeOrFragment) => {
        return nodeOrFragment.toString().startsWith("<");
      };
      insertContentAt = (position, value, options) => ({ tr: tr2, dispatch: dispatch2, editor }) => {
        if (dispatch2) {
          options = {
            parseOptions: {},
            updateSelection: true,
            ...options
          };
          const content = createNodeFromContent(value, editor.schema, {
            parseOptions: {
              preserveWhitespace: "full",
              ...options.parseOptions
            }
          });
          if (content.toString() === "<>") {
            return true;
          }
          let { from: from3, to: to2 } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
          let isOnlyTextContent = true;
          let isOnlyBlockContent = true;
          const nodes = isFragment(content) ? content : [content];
          nodes.forEach((node) => {
            node.check();
            isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
            isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
          });
          if (from3 === to2 && isOnlyBlockContent) {
            const { parent } = tr2.doc.resolve(from3);
            const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
            if (isEmptyTextBlock) {
              from3 -= 1;
              to2 += 1;
            }
          }
          if (isOnlyTextContent) {
            if (Array.isArray(value)) {
              tr2.insertText(value.map((v) => v.text || "").join(""), from3, to2);
            } else if (typeof value === "object" && !!value && !!value.text) {
              tr2.insertText(value.text, from3, to2);
            } else {
              tr2.insertText(value, from3, to2);
            }
          } else {
            tr2.replaceWith(from3, to2, content);
          }
          if (options.updateSelection) {
            selectionToInsertionEnd2(tr2, tr2.steps.length - 1, -1);
          }
        }
        return true;
      };
      joinUp2 = () => ({ state, dispatch: dispatch2 }) => {
        return joinUp(state, dispatch2);
      };
      joinDown2 = () => ({ state, dispatch: dispatch2 }) => {
        return joinDown(state, dispatch2);
      };
      joinBackward2 = () => ({ state, dispatch: dispatch2 }) => {
        return joinBackward(state, dispatch2);
      };
      joinForward2 = () => ({ state, dispatch: dispatch2 }) => {
        return joinForward(state, dispatch2);
      };
      joinItemBackward = () => ({ tr: tr2, state, dispatch: dispatch2 }) => {
        try {
          const point = joinPoint(state.doc, state.selection.$from.pos, -1);
          if (point === null || point === void 0) {
            return false;
          }
          tr2.join(point, 2);
          if (dispatch2) {
            dispatch2(tr2);
          }
          return true;
        } catch {
          return false;
        }
      };
      joinItemForward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
        try {
          const point = joinPoint(state.doc, state.selection.$from.pos, 1);
          if (point === null || point === void 0) {
            return false;
          }
          tr2.join(point, 2);
          if (dispatch2) {
            dispatch2(tr2);
          }
          return true;
        } catch (e) {
          return false;
        }
      };
      joinTextblockBackward2 = () => ({ state, dispatch: dispatch2 }) => {
        return joinTextblockBackward(state, dispatch2);
      };
      joinTextblockForward2 = () => ({ state, dispatch: dispatch2 }) => {
        return joinTextblockForward(state, dispatch2);
      };
      keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
        const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
        const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
        const event = new KeyboardEvent("keydown", {
          key: key === "Space" ? " " : key,
          altKey: keys2.includes("Alt"),
          ctrlKey: keys2.includes("Ctrl"),
          metaKey: keys2.includes("Meta"),
          shiftKey: keys2.includes("Shift"),
          bubbles: true,
          cancelable: true
        });
        const capturedTransaction = editor.captureTransaction(() => {
          view.someProp("handleKeyDown", (f) => f(view, event));
        });
        capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
          const newStep = step.map(tr2.mapping);
          if (newStep && dispatch2) {
            tr2.maybeStep(newStep);
          }
        });
        return true;
      };
      lift3 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
        const type = getNodeType(typeOrName, state.schema);
        const isActive2 = isNodeActive(state, type, attributes);
        if (!isActive2) {
          return false;
        }
        return lift2(state, dispatch2);
      };
      liftEmptyBlock2 = () => ({ state, dispatch: dispatch2 }) => {
        return liftEmptyBlock(state, dispatch2);
      };
      liftListItem2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
        const type = getNodeType(typeOrName, state.schema);
        return liftListItem(type)(state, dispatch2);
      };
      newlineInCode2 = () => ({ state, dispatch: dispatch2 }) => {
        return newlineInCode(state, dispatch2);
      };
      resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
        let nodeType = null;
        let markType = null;
        const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
        if (!schemaType) {
          return false;
        }
        if (schemaType === "node") {
          nodeType = getNodeType(typeOrName, state.schema);
        }
        if (schemaType === "mark") {
          markType = getMarkType(typeOrName, state.schema);
        }
        if (dispatch2) {
          tr2.selection.ranges.forEach((range) => {
            state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
              if (nodeType && nodeType === node.type) {
                tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
              }
              if (markType && node.marks.length) {
                node.marks.forEach((mark) => {
                  if (markType === mark.type) {
                    tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                  }
                });
              }
            });
          });
        }
        return true;
      };
      scrollIntoView = () => ({ tr: tr2, dispatch: dispatch2 }) => {
        if (dispatch2) {
          tr2.scrollIntoView();
        }
        return true;
      };
      selectAll2 = () => ({ tr: tr2, commands: commands2 }) => {
        return commands2.setTextSelection({
          from: 0,
          to: tr2.doc.content.size
        });
      };
      selectNodeBackward2 = () => ({ state, dispatch: dispatch2 }) => {
        return selectNodeBackward(state, dispatch2);
      };
      selectNodeForward2 = () => ({ state, dispatch: dispatch2 }) => {
        return selectNodeForward(state, dispatch2);
      };
      selectParentNode2 = () => ({ state, dispatch: dispatch2 }) => {
        return selectParentNode(state, dispatch2);
      };
      selectTextblockEnd2 = () => ({ state, dispatch: dispatch2 }) => {
        return selectTextblockEnd(state, dispatch2);
      };
      selectTextblockStart2 = () => ({ state, dispatch: dispatch2 }) => {
        return selectTextblockStart(state, dispatch2);
      };
      setContent2 = (content, emitUpdate = false, parseOptions = {}) => ({ tr: tr2, editor, dispatch: dispatch2 }) => {
        const { doc: doc3 } = tr2;
        const document2 = createDocument(content, editor.schema, parseOptions);
        if (dispatch2) {
          tr2.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
        }
        return true;
      };
      getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {
        const $pos = state.doc.resolve(pos);
        let currentDepth = maxDepth;
        let node = null;
        while (currentDepth > 0 && node === null) {
          const currentNode = $pos.node(currentDepth);
          if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {
            node = currentNode;
          } else {
            currentDepth -= 1;
          }
        }
        return [node, currentDepth];
      };
      isAtEndOfNode = (state, nodeType) => {
        const { $from, $to, $anchor } = state.selection;
        if (nodeType) {
          const parentNode2 = findParentNode((node) => node.type.name === nodeType)(state.selection);
          if (!parentNode2) {
            return false;
          }
          const $parentPos = state.doc.resolve(parentNode2.pos + 1);
          if ($anchor.pos + 1 === $parentPos.end()) {
            return true;
          }
          return false;
        }
        if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {
          return false;
        }
        return true;
      };
      isAtStartOfNode = (state) => {
        const { $from, $to } = state.selection;
        if ($from.parentOffset > 0 || $from.pos !== $to.pos) {
          return false;
        }
        return true;
      };
      setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
        const { selection } = tr2;
        const { empty: empty2, ranges } = selection;
        const type = getMarkType(typeOrName, state.schema);
        if (dispatch2) {
          if (empty2) {
            const oldAttributes = getMarkAttributes(state, type);
            tr2.addStoredMark(type.create({
              ...oldAttributes,
              ...attributes
            }));
          } else {
            ranges.forEach((range) => {
              const from3 = range.$from.pos;
              const to2 = range.$to.pos;
              state.doc.nodesBetween(from3, to2, (node, pos) => {
                const trimmedFrom = Math.max(pos, from3);
                const trimmedTo = Math.min(pos + node.nodeSize, to2);
                const someHasMark = node.marks.find((mark) => mark.type === type);
                if (someHasMark) {
                  node.marks.forEach((mark) => {
                    if (type === mark.type) {
                      tr2.addMark(trimmedFrom, trimmedTo, type.create({
                        ...mark.attrs,
                        ...attributes
                      }));
                    }
                  });
                } else {
                  tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
                }
              });
            });
          }
        }
        return canSetMark(state, tr2, type);
      };
      setMeta = (key, value) => ({ tr: tr2 }) => {
        tr2.setMeta(key, value);
        return true;
      };
      setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain }) => {
        const type = getNodeType(typeOrName, state.schema);
        if (!type.isTextblock) {
          console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
          return false;
        }
        return chain().command(({ commands: commands2 }) => {
          const canSetBlock = setBlockType2(type, attributes)(state);
          if (canSetBlock) {
            return true;
          }
          return commands2.clearNodes();
        }).command(({ state: updatedState }) => {
          return setBlockType2(type, attributes)(updatedState, dispatch2);
        }).run();
      };
      setNodeSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
        if (dispatch2) {
          const { doc: doc3 } = tr2;
          const from3 = minMax(position, 0, doc3.content.size);
          const selection = NodeSelection.create(doc3, from3);
          tr2.setSelection(selection);
        }
        return true;
      };
      setTextSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
        if (dispatch2) {
          const { doc: doc3 } = tr2;
          const { from: from3, to: to2 } = typeof position === "number" ? { from: position, to: position } : position;
          const minPos = TextSelection.atStart(doc3).from;
          const maxPos = TextSelection.atEnd(doc3).to;
          const resolvedFrom = minMax(from3, minPos, maxPos);
          const resolvedEnd = minMax(to2, minPos, maxPos);
          const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
          tr2.setSelection(selection);
        }
        return true;
      };
      sinkListItem2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
        const type = getNodeType(typeOrName, state.schema);
        return sinkListItem(type)(state, dispatch2);
      };
      splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
        const { selection, doc: doc3 } = tr2;
        const { $from, $to } = selection;
        const extensionAttributes = editor.extensionManager.attributes;
        const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
        if (selection instanceof NodeSelection && selection.node.isBlock) {
          if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
            return false;
          }
          if (dispatch2) {
            if (keepMarks) {
              ensureMarks(state, editor.extensionManager.splittableMarks);
            }
            tr2.split($from.pos).scrollIntoView();
          }
          return true;
        }
        if (!$from.parent.isBlock) {
          return false;
        }
        if (dispatch2) {
          const atEnd = $to.parentOffset === $to.parent.content.size;
          if (selection instanceof TextSelection) {
            tr2.deleteSelection();
          }
          const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
          let types = atEnd && deflt ? [
            {
              type: deflt,
              attrs: newAttributes
            }
          ] : void 0;
          let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
          if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
            can = true;
            types = deflt ? [
              {
                type: deflt,
                attrs: newAttributes
              }
            ] : void 0;
          }
          if (can) {
            tr2.split(tr2.mapping.map($from.pos), 1, types);
            if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
              const first2 = tr2.mapping.map($from.before());
              const $first = tr2.doc.resolve(first2);
              if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
                tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
              }
            }
          }
          if (keepMarks) {
            ensureMarks(state, editor.extensionManager.splittableMarks);
          }
          tr2.scrollIntoView();
        }
        return true;
      };
      splitListItem = (typeOrName) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
        var _a;
        const type = getNodeType(typeOrName, state.schema);
        const { $from, $to } = state.selection;
        const node = state.selection.node;
        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
          return false;
        }
        const grandParent = $from.node(-1);
        if (grandParent.type !== type) {
          return false;
        }
        const extensionAttributes = editor.extensionManager.attributes;
        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
          if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
            return false;
          }
          if (dispatch2) {
            let wrap2 = Fragment.empty;
            const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
            for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
              wrap2 = Fragment.from($from.node(d).copy(wrap2));
            }
            const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
            const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
            const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
            wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
            const start3 = $from.before($from.depth - (depthBefore - 1));
            tr2.replace(start3, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
            let sel = -1;
            tr2.doc.nodesBetween(start3, tr2.doc.content.size, (n, pos) => {
              if (sel > -1) {
                return false;
              }
              if (n.isTextblock && n.content.size === 0) {
                sel = pos + 1;
              }
            });
            if (sel > -1) {
              tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
            }
            tr2.scrollIntoView();
          }
          return true;
        }
        const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
        const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
        const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
        tr2.delete($from.pos, $to.pos);
        const types = nextType ? [
          { type, attrs: newTypeAttributes },
          { type: nextType, attrs: newNextTypeAttributes }
        ] : [{ type, attrs: newTypeAttributes }];
        if (!canSplit(tr2.doc, $from.pos, 2)) {
          return false;
        }
        if (dispatch2) {
          const { selection, storedMarks } = state;
          const { splittableMarks } = editor.extensionManager;
          const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
          tr2.split($from.pos, 2, types).scrollIntoView();
          if (!marks || !dispatch2) {
            return true;
          }
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
        return true;
      };
      joinListBackwards = (tr2, listType) => {
        const list = findParentNode((node) => node.type === listType)(tr2.selection);
        if (!list) {
          return true;
        }
        const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
        if (before === void 0) {
          return true;
        }
        const nodeBefore = tr2.doc.nodeAt(before);
        const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
        if (!canJoinBackwards) {
          return true;
        }
        tr2.join(list.pos);
        return true;
      };
      joinListForwards = (tr2, listType) => {
        const list = findParentNode((node) => node.type === listType)(tr2.selection);
        if (!list) {
          return true;
        }
        const after = tr2.doc.resolve(list.start).after(list.depth);
        if (after === void 0) {
          return true;
        }
        const nodeAfter = tr2.doc.nodeAt(after);
        const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
        if (!canJoinForwards) {
          return true;
        }
        tr2.join(after);
        return true;
      };
      toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch: dispatch2, chain, commands: commands2, can }) => {
        const { extensions: extensions2, splittableMarks } = editor.extensionManager;
        const listType = getNodeType(listTypeOrName, state.schema);
        const itemType = getNodeType(itemTypeOrName, state.schema);
        const { selection, storedMarks } = state;
        const { $from, $to } = selection;
        const range = $from.blockRange($to);
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (!range) {
          return false;
        }
        const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);
        if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
          if (parentList.node.type === listType) {
            return commands2.liftListItem(itemType);
          }
          if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch2) {
            return chain().command(() => {
              tr2.setNodeMarkup(parentList.pos, listType);
              return true;
            }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
          }
        }
        if (!keepMarks || !marks || !dispatch2) {
          return chain().command(() => {
            const canWrapInList = can().wrapInList(listType, attributes);
            if (canWrapInList) {
              return true;
            }
            return commands2.clearNodes();
          }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
        }
        return chain().command(() => {
          const canWrapInList = can().wrapInList(listType, attributes);
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
          if (canWrapInList) {
            return true;
          }
          return commands2.clearNodes();
        }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
      };
      toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
        const { extendEmptyMarkRange = false } = options;
        const type = getMarkType(typeOrName, state.schema);
        const isActive2 = isMarkActive(state, type, attributes);
        if (isActive2) {
          return commands2.unsetMark(type, { extendEmptyMarkRange });
        }
        return commands2.setMark(type, attributes);
      };
      toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
        const type = getNodeType(typeOrName, state.schema);
        const toggleType = getNodeType(toggleTypeOrName, state.schema);
        const isActive2 = isNodeActive(state, type, attributes);
        if (isActive2) {
          return commands2.setNode(toggleType);
        }
        return commands2.setNode(type, attributes);
      };
      toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
        const type = getNodeType(typeOrName, state.schema);
        const isActive2 = isNodeActive(state, type, attributes);
        if (isActive2) {
          return commands2.lift(type);
        }
        return commands2.wrapIn(type, attributes);
      };
      undoInputRule = () => ({ state, dispatch: dispatch2 }) => {
        const plugins3 = state.plugins;
        for (let i = 0; i < plugins3.length; i += 1) {
          const plugin = plugins3[i];
          let undoable;
          if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
            if (dispatch2) {
              const tr2 = state.tr;
              const toUndo = undoable.transform;
              for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
                tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
              }
              if (undoable.text) {
                const marks = tr2.doc.resolve(undoable.from).marks();
                tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
              } else {
                tr2.delete(undoable.from, undoable.to);
              }
            }
            return true;
          }
        }
        return false;
      };
      unsetAllMarks = () => ({ tr: tr2, dispatch: dispatch2 }) => {
        const { selection } = tr2;
        const { empty: empty2, ranges } = selection;
        if (empty2) {
          return true;
        }
        if (dispatch2) {
          ranges.forEach((range) => {
            tr2.removeMark(range.$from.pos, range.$to.pos);
          });
        }
        return true;
      };
      unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
        var _a;
        const { extendEmptyMarkRange = false } = options;
        const { selection } = tr2;
        const type = getMarkType(typeOrName, state.schema);
        const { $from, empty: empty2, ranges } = selection;
        if (!dispatch2) {
          return true;
        }
        if (empty2 && extendEmptyMarkRange) {
          let { from: from3, to: to2 } = selection;
          const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
          const range = getMarkRange($from, type, attrs);
          if (range) {
            from3 = range.from;
            to2 = range.to;
          }
          tr2.removeMark(from3, to2, type);
        } else {
          ranges.forEach((range) => {
            tr2.removeMark(range.$from.pos, range.$to.pos, type);
          });
        }
        tr2.removeStoredMark(type);
        return true;
      };
      updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
        let nodeType = null;
        let markType = null;
        const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
        if (!schemaType) {
          return false;
        }
        if (schemaType === "node") {
          nodeType = getNodeType(typeOrName, state.schema);
        }
        if (schemaType === "mark") {
          markType = getMarkType(typeOrName, state.schema);
        }
        if (dispatch2) {
          tr2.selection.ranges.forEach((range) => {
            const from3 = range.$from.pos;
            const to2 = range.$to.pos;
            state.doc.nodesBetween(from3, to2, (node, pos) => {
              if (nodeType && nodeType === node.type) {
                tr2.setNodeMarkup(pos, void 0, {
                  ...node.attrs,
                  ...attributes
                });
              }
              if (markType && node.marks.length) {
                node.marks.forEach((mark) => {
                  if (markType === mark.type) {
                    const trimmedFrom = Math.max(pos, from3);
                    const trimmedTo = Math.min(pos + node.nodeSize, to2);
                    tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                      ...mark.attrs,
                      ...attributes
                    }));
                  }
                });
              }
            });
          });
        }
        return true;
      };
      wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
        const type = getNodeType(typeOrName, state.schema);
        return wrapIn(type, attributes)(state, dispatch2);
      };
      wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
        const type = getNodeType(typeOrName, state.schema);
        return wrapInList(type, attributes)(state, dispatch2);
      };
      commands = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        blur,
        clearContent,
        clearNodes,
        command,
        createParagraphNear: createParagraphNear2,
        cut,
        deleteCurrentNode,
        deleteNode,
        deleteRange: deleteRange2,
        deleteSelection: deleteSelection2,
        enter,
        exitCode: exitCode2,
        extendMarkRange,
        first,
        focus,
        forEach,
        insertContent,
        insertContentAt,
        joinUp: joinUp2,
        joinDown: joinDown2,
        joinBackward: joinBackward2,
        joinForward: joinForward2,
        joinItemBackward,
        joinItemForward,
        joinTextblockBackward: joinTextblockBackward2,
        joinTextblockForward: joinTextblockForward2,
        keyboardShortcut,
        lift: lift3,
        liftEmptyBlock: liftEmptyBlock2,
        liftListItem: liftListItem2,
        newlineInCode: newlineInCode2,
        resetAttributes,
        scrollIntoView,
        selectAll: selectAll2,
        selectNodeBackward: selectNodeBackward2,
        selectNodeForward: selectNodeForward2,
        selectParentNode: selectParentNode2,
        selectTextblockEnd: selectTextblockEnd2,
        selectTextblockStart: selectTextblockStart2,
        setContent: setContent2,
        setMark,
        setMeta,
        setNode,
        setNodeSelection,
        setTextSelection,
        sinkListItem: sinkListItem2,
        splitBlock: splitBlock2,
        splitListItem,
        toggleList,
        toggleMark,
        toggleNode,
        toggleWrap,
        undoInputRule,
        unsetAllMarks,
        unsetMark,
        updateAttributes,
        wrapIn: wrapIn2,
        wrapInList: wrapInList2
      });
      Commands = Extension.create({
        name: "commands",
        addCommands() {
          return {
            ...commands
          };
        }
      });
      Editable = Extension.create({
        name: "editable",
        addProseMirrorPlugins() {
          return [
            new Plugin({
              key: new PluginKey("editable"),
              props: {
                editable: () => this.editor.options.editable
              }
            })
          ];
        }
      });
      FocusEvents = Extension.create({
        name: "focusEvents",
        addProseMirrorPlugins() {
          const { editor } = this;
          return [
            new Plugin({
              key: new PluginKey("focusEvents"),
              props: {
                handleDOMEvents: {
                  focus: (view, event) => {
                    editor.isFocused = true;
                    const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                    view.dispatch(transaction);
                    return false;
                  },
                  blur: (view, event) => {
                    editor.isFocused = false;
                    const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                    view.dispatch(transaction);
                    return false;
                  }
                }
              }
            })
          ];
        }
      });
      Keymap = Extension.create({
        name: "keymap",
        addKeyboardShortcuts() {
          const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
            () => commands2.undoInputRule(),
            // maybe convert first text block node to default node
            () => commands2.command(({ tr: tr2 }) => {
              const { selection, doc: doc3 } = tr2;
              const { empty: empty2, $anchor } = selection;
              const { pos, parent } = $anchor;
              const $parentPos = $anchor.parent.isTextblock ? tr2.doc.resolve(pos - 1) : $anchor;
              const parentIsIsolating = $parentPos.parent.type.spec.isolating;
              const parentPos = $anchor.pos - $anchor.parentOffset;
              const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
              if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
                return false;
              }
              return commands2.clearNodes();
            }),
            () => commands2.deleteSelection(),
            () => commands2.joinBackward(),
            () => commands2.selectNodeBackward()
          ]);
          const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
            () => commands2.deleteSelection(),
            () => commands2.deleteCurrentNode(),
            () => commands2.joinForward(),
            () => commands2.selectNodeForward()
          ]);
          const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
            () => commands2.newlineInCode(),
            () => commands2.createParagraphNear(),
            () => commands2.liftEmptyBlock(),
            () => commands2.splitBlock()
          ]);
          const baseKeymap = {
            Enter: handleEnter,
            "Mod-Enter": () => this.editor.commands.exitCode(),
            Backspace: handleBackspace,
            "Mod-Backspace": handleBackspace,
            "Shift-Backspace": handleBackspace,
            Delete: handleDelete,
            "Mod-Delete": handleDelete,
            "Mod-a": () => this.editor.commands.selectAll()
          };
          const pcKeymap = {
            ...baseKeymap
          };
          const macKeymap = {
            ...baseKeymap,
            "Ctrl-h": handleBackspace,
            "Alt-Backspace": handleBackspace,
            "Ctrl-d": handleDelete,
            "Ctrl-Alt-Backspace": handleDelete,
            "Alt-Delete": handleDelete,
            "Alt-d": handleDelete,
            "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
            "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
          };
          if (isiOS() || isMacOS()) {
            return macKeymap;
          }
          return pcKeymap;
        },
        addProseMirrorPlugins() {
          return [
            // With this plugin we check if the whole document was selected and deleted.
            // In this case we will additionally call `clearNodes()` to convert e.g. a heading
            // to a paragraph if necessary.
            // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
            // with many other commands.
            new Plugin({
              key: new PluginKey("clearDocument"),
              appendTransaction: (transactions, oldState, newState) => {
                const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
                if (!docChanges) {
                  return;
                }
                const { empty: empty2, from: from3, to: to2 } = oldState.selection;
                const allFrom = Selection.atStart(oldState.doc).from;
                const allEnd = Selection.atEnd(oldState.doc).to;
                const allWasSelected = from3 === allFrom && to2 === allEnd;
                if (empty2 || !allWasSelected) {
                  return;
                }
                const isEmpty2 = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
                if (!isEmpty2) {
                  return;
                }
                const tr2 = newState.tr;
                const state = createChainableState({
                  state: newState,
                  transaction: tr2
                });
                const { commands: commands2 } = new CommandManager({
                  editor: this.editor,
                  state
                });
                commands2.clearNodes();
                if (!tr2.steps.length) {
                  return;
                }
                return tr2;
              }
            })
          ];
        }
      });
      Tabindex = Extension.create({
        name: "tabindex",
        addProseMirrorPlugins() {
          return [
            new Plugin({
              key: new PluginKey("tabindex"),
              props: {
                attributes: this.editor.isEditable ? { tabindex: "0" } : {}
              }
            })
          ];
        }
      });
      extensions = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ClipboardTextSerializer,
        Commands,
        Editable,
        FocusEvents,
        Keymap,
        Tabindex
      });
      NodePos = class _NodePos {
        constructor(pos, editor, isBlock = false, node = null) {
          this.currentNode = null;
          this.actualDepth = null;
          this.isBlock = isBlock;
          this.resolvedPos = pos;
          this.editor = editor;
          this.currentNode = node;
        }
        get name() {
          return this.node.type.name;
        }
        get node() {
          return this.currentNode || this.resolvedPos.node();
        }
        get element() {
          return this.editor.view.domAtPos(this.pos).node;
        }
        get depth() {
          var _a;
          return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;
        }
        get pos() {
          return this.resolvedPos.pos;
        }
        get content() {
          return this.node.content;
        }
        set content(content) {
          let from3 = this.from;
          let to2 = this.to;
          if (this.isBlock) {
            if (this.content.size === 0) {
              console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
              return;
            }
            from3 = this.from + 1;
            to2 = this.to - 1;
          }
          this.editor.commands.insertContentAt({ from: from3, to: to2 }, content);
        }
        get attributes() {
          return this.node.attrs;
        }
        get textContent() {
          return this.node.textContent;
        }
        get size() {
          return this.node.nodeSize;
        }
        get from() {
          if (this.isBlock) {
            return this.pos;
          }
          return this.resolvedPos.start(this.resolvedPos.depth);
        }
        get range() {
          return {
            from: this.from,
            to: this.to
          };
        }
        get to() {
          if (this.isBlock) {
            return this.pos + this.size;
          }
          return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
        }
        get parent() {
          if (this.depth === 0) {
            return null;
          }
          const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
          const $pos = this.resolvedPos.doc.resolve(parentPos);
          return new _NodePos($pos, this.editor);
        }
        get before() {
          let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
          if ($pos.depth !== this.depth) {
            $pos = this.resolvedPos.doc.resolve(this.from - 3);
          }
          return new _NodePos($pos, this.editor);
        }
        get after() {
          let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
          if ($pos.depth !== this.depth) {
            $pos = this.resolvedPos.doc.resolve(this.to + 3);
          }
          return new _NodePos($pos, this.editor);
        }
        get children() {
          const children = [];
          this.node.content.forEach((node, offset2) => {
            const isBlock = node.isBlock && !node.isTextblock;
            const targetPos = this.pos + offset2 + (isBlock ? 0 : 1);
            const $pos = this.resolvedPos.doc.resolve(targetPos);
            if (!isBlock && $pos.depth <= this.depth) {
              return;
            }
            const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
            if (isBlock) {
              childNodePos.actualDepth = this.depth + 1;
            }
            children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
          });
          return children;
        }
        get firstChild() {
          return this.children[0] || null;
        }
        get lastChild() {
          const children = this.children;
          return children[children.length - 1] || null;
        }
        closest(selector, attributes = {}) {
          let node = null;
          let currentNode = this.parent;
          while (currentNode && !node) {
            if (currentNode.node.type.name === selector) {
              if (Object.keys(attributes).length > 0) {
                const nodeAttributes = currentNode.node.attrs;
                const attrKeys = Object.keys(attributes);
                for (let index3 = 0; index3 < attrKeys.length; index3 += 1) {
                  const key = attrKeys[index3];
                  if (nodeAttributes[key] !== attributes[key]) {
                    break;
                  }
                }
              } else {
                node = currentNode;
              }
            }
            currentNode = currentNode.parent;
          }
          return node;
        }
        querySelector(selector, attributes = {}) {
          return this.querySelectorAll(selector, attributes, true)[0] || null;
        }
        querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
          let nodes = [];
          if (this.isBlock || !this.children || this.children.length === 0) {
            return nodes;
          }
          this.children.forEach((childPos) => {
            if (childPos.node.type.name === selector) {
              if (Object.keys(attributes).length > 0) {
                const nodeAttributes = childPos.node.attrs;
                const attrKeys = Object.keys(attributes);
                for (let index3 = 0; index3 < attrKeys.length; index3 += 1) {
                  const key = attrKeys[index3];
                  if (nodeAttributes[key] !== attributes[key]) {
                    return;
                  }
                }
              }
              nodes.push(childPos);
              if (firstItemOnly) {
                return;
              }
            }
            nodes = nodes.concat(childPos.querySelectorAll(selector));
          });
          return nodes;
        }
        setAttribute(attributes) {
          const oldSelection = this.editor.state.selection;
          this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, attributes).setTextSelection(oldSelection.from).run();
        }
      };
      style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
      Editor = class extends EventEmitter {
        constructor(options = {}) {
          super();
          this.isFocused = false;
          this.extensionStorage = {};
          this.options = {
            element: document.createElement("div"),
            content: "",
            injectCSS: true,
            injectNonce: void 0,
            extensions: [],
            autofocus: false,
            editable: true,
            editorProps: {},
            parseOptions: {},
            enableInputRules: true,
            enablePasteRules: true,
            enableCoreExtensions: true,
            onBeforeCreate: () => null,
            onCreate: () => null,
            onUpdate: () => null,
            onSelectionUpdate: () => null,
            onTransaction: () => null,
            onFocus: () => null,
            onBlur: () => null,
            onDestroy: () => null
          };
          this.isCapturingTransaction = false;
          this.capturedTransaction = null;
          this.setOptions(options);
          this.createExtensionManager();
          this.createCommandManager();
          this.createSchema();
          this.on("beforeCreate", this.options.onBeforeCreate);
          this.emit("beforeCreate", { editor: this });
          this.createView();
          this.injectCSS();
          this.on("create", this.options.onCreate);
          this.on("update", this.options.onUpdate);
          this.on("selectionUpdate", this.options.onSelectionUpdate);
          this.on("transaction", this.options.onTransaction);
          this.on("focus", this.options.onFocus);
          this.on("blur", this.options.onBlur);
          this.on("destroy", this.options.onDestroy);
          window.setTimeout(() => {
            if (this.isDestroyed) {
              return;
            }
            this.commands.focus(this.options.autofocus);
            this.emit("create", { editor: this });
          }, 0);
        }
        /**
         * Returns the editor storage.
         */
        get storage() {
          return this.extensionStorage;
        }
        /**
         * An object of all registered commands.
         */
        get commands() {
          return this.commandManager.commands;
        }
        /**
         * Create a command chain to call multiple commands at once.
         */
        chain() {
          return this.commandManager.chain();
        }
        /**
         * Check if a command or a command chain can be executed. Without executing it.
         */
        can() {
          return this.commandManager.can();
        }
        /**
         * Inject CSS styles.
         */
        injectCSS() {
          if (this.options.injectCSS && document) {
            this.css = createStyleTag(style, this.options.injectNonce);
          }
        }
        /**
         * Update editor options.
         *
         * @param options A list of options
         */
        setOptions(options = {}) {
          this.options = {
            ...this.options,
            ...options
          };
          if (!this.view || !this.state || this.isDestroyed) {
            return;
          }
          if (this.options.editorProps) {
            this.view.setProps(this.options.editorProps);
          }
          this.view.updateState(this.state);
        }
        /**
         * Update editable state of the editor.
         */
        setEditable(editable, emitUpdate = true) {
          this.setOptions({ editable });
          if (emitUpdate) {
            this.emit("update", { editor: this, transaction: this.state.tr });
          }
        }
        /**
         * Returns whether the editor is editable.
         */
        get isEditable() {
          return this.options.editable && this.view && this.view.editable;
        }
        /**
         * Returns the editor state.
         */
        get state() {
          return this.view.state;
        }
        /**
         * Register a ProseMirror plugin.
         *
         * @param plugin A ProseMirror plugin
         * @param handlePlugins Control how to merge the plugin into the existing plugins.
         */
        registerPlugin(plugin, handlePlugins) {
          const plugins3 = isFunction2(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
          const state = this.state.reconfigure({ plugins: plugins3 });
          this.view.updateState(state);
        }
        /**
         * Unregister a ProseMirror plugin.
         *
         * @param nameOrPluginKey The plugins name
         */
        unregisterPlugin(nameOrPluginKey) {
          if (this.isDestroyed) {
            return;
          }
          const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
          const state = this.state.reconfigure({
            // @ts-ignore
            plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
          });
          this.view.updateState(state);
        }
        /**
         * Creates an extension manager.
         */
        createExtensionManager() {
          const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
          const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
            return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
          });
          this.extensionManager = new ExtensionManager(allExtensions, this);
        }
        /**
         * Creates an command manager.
         */
        createCommandManager() {
          this.commandManager = new CommandManager({
            editor: this
          });
        }
        /**
         * Creates a ProseMirror schema.
         */
        createSchema() {
          this.schema = this.extensionManager.schema;
        }
        /**
         * Creates a ProseMirror view.
         */
        createView() {
          const doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions);
          const selection = resolveFocusPosition(doc3, this.options.autofocus);
          this.view = new EditorView(this.options.element, {
            ...this.options.editorProps,
            dispatchTransaction: this.dispatchTransaction.bind(this),
            state: EditorState.create({
              doc: doc3,
              selection: selection || void 0
            })
          });
          const newState = this.state.reconfigure({
            plugins: this.extensionManager.plugins
          });
          this.view.updateState(newState);
          this.createNodeViews();
          this.prependClass();
          const dom = this.view.dom;
          dom.editor = this;
        }
        /**
         * Creates all node views.
         */
        createNodeViews() {
          this.view.setProps({
            nodeViews: this.extensionManager.nodeViews
          });
        }
        /**
         * Prepend class name to element.
         */
        prependClass() {
          this.view.dom.className = `tiptap ${this.view.dom.className}`;
        }
        captureTransaction(fn2) {
          this.isCapturingTransaction = true;
          fn2();
          this.isCapturingTransaction = false;
          const tr2 = this.capturedTransaction;
          this.capturedTransaction = null;
          return tr2;
        }
        /**
         * The callback over which to send transactions (state updates) produced by the view.
         *
         * @param transaction An editor state transaction
         */
        dispatchTransaction(transaction) {
          if (this.view.isDestroyed) {
            return;
          }
          if (this.isCapturingTransaction) {
            if (!this.capturedTransaction) {
              this.capturedTransaction = transaction;
              return;
            }
            transaction.steps.forEach((step) => {
              var _a;
              return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
            });
            return;
          }
          const state = this.state.apply(transaction);
          const selectionHasChanged = !this.state.selection.eq(state.selection);
          this.view.updateState(state);
          this.emit("transaction", {
            editor: this,
            transaction
          });
          if (selectionHasChanged) {
            this.emit("selectionUpdate", {
              editor: this,
              transaction
            });
          }
          const focus2 = transaction.getMeta("focus");
          const blur2 = transaction.getMeta("blur");
          if (focus2) {
            this.emit("focus", {
              editor: this,
              event: focus2.event,
              transaction
            });
          }
          if (blur2) {
            this.emit("blur", {
              editor: this,
              event: blur2.event,
              transaction
            });
          }
          if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
            return;
          }
          this.emit("update", {
            editor: this,
            transaction
          });
        }
        /**
         * Get attributes of the currently selected node or mark.
         */
        getAttributes(nameOrType) {
          return getAttributes(this.state, nameOrType);
        }
        isActive(nameOrAttributes, attributesOrUndefined) {
          const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
          const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
          return isActive(this.state, name, attributes);
        }
        /**
         * Get the document as JSON.
         */
        getJSON() {
          return this.state.doc.toJSON();
        }
        /**
         * Get the document as HTML.
         */
        getHTML() {
          return getHTMLFromFragment(this.state.doc.content, this.schema);
        }
        /**
         * Get the document as text.
         */
        getText(options) {
          const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
          return getText2(this.state.doc, {
            blockSeparator,
            textSerializers: {
              ...getTextSerializersFromSchema(this.schema),
              ...textSerializers
            }
          });
        }
        /**
         * Check if there is no content.
         */
        get isEmpty() {
          return isNodeEmpty(this.state.doc);
        }
        /**
         * Get the number of characters for the current document.
         *
         * @deprecated
         */
        getCharacterCount() {
          console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
          return this.state.doc.content.size - 2;
        }
        /**
         * Destroy the editor.
         */
        destroy() {
          this.emit("destroy");
          if (this.view) {
            this.view.destroy();
          }
          this.removeAllListeners();
        }
        /**
         * Check if the editor is already destroyed.
         */
        get isDestroyed() {
          var _a;
          return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
        }
        $node(selector, attributes) {
          var _a;
          return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;
        }
        $nodes(selector, attributes) {
          var _a;
          return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
        }
        $pos(pos) {
          const $pos = this.state.doc.resolve(pos);
          return new NodePos($pos, this);
        }
        get $doc() {
          return this.$pos(0);
        }
      };
      Mark2 = class _Mark {
        constructor(config = {}) {
          this.type = "mark";
          this.name = "mark";
          this.parent = null;
          this.child = null;
          this.config = {
            name: this.name,
            defaultOptions: {}
          };
          this.config = {
            ...this.config,
            ...config
          };
          this.name = this.config.name;
          if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
          }
          this.options = this.config.defaultOptions;
          if (this.config.addOptions) {
            this.options = callOrReturn(getExtensionField(this, "addOptions", {
              name: this.name
            }));
          }
          this.storage = callOrReturn(getExtensionField(this, "addStorage", {
            name: this.name,
            options: this.options
          })) || {};
        }
        static create(config = {}) {
          return new _Mark(config);
        }
        configure(options = {}) {
          const extension = this.extend();
          extension.options = mergeDeep(this.options, options);
          extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
            name: extension.name,
            options: extension.options
          }));
          return extension;
        }
        extend(extendedConfig = {}) {
          const extension = new _Mark({ ...this.config, ...extendedConfig });
          extension.parent = this;
          this.child = extension;
          extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
          if (extendedConfig.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
          }
          extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
            name: extension.name
          }));
          extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
            name: extension.name,
            options: extension.options
          }));
          return extension;
        }
        static handleExit({ editor, mark }) {
          const { tr: tr2 } = editor.state;
          const currentPos = editor.state.selection.$from;
          const isAtEnd = currentPos.pos === currentPos.end();
          if (isAtEnd) {
            const currentMarks = currentPos.marks();
            const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
            if (!isInMark) {
              return false;
            }
            const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
            if (removeMark2) {
              tr2.removeStoredMark(removeMark2);
            }
            tr2.insertText(" ", currentPos.pos);
            editor.view.dispatch(tr2);
            return true;
          }
          return false;
        }
      };
      Node3 = class _Node {
        constructor(config = {}) {
          this.type = "node";
          this.name = "node";
          this.parent = null;
          this.child = null;
          this.config = {
            name: this.name,
            defaultOptions: {}
          };
          this.config = {
            ...this.config,
            ...config
          };
          this.name = this.config.name;
          if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
          }
          this.options = this.config.defaultOptions;
          if (this.config.addOptions) {
            this.options = callOrReturn(getExtensionField(this, "addOptions", {
              name: this.name
            }));
          }
          this.storage = callOrReturn(getExtensionField(this, "addStorage", {
            name: this.name,
            options: this.options
          })) || {};
        }
        static create(config = {}) {
          return new _Node(config);
        }
        configure(options = {}) {
          const extension = this.extend();
          extension.options = mergeDeep(this.options, options);
          extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
            name: extension.name,
            options: extension.options
          }));
          return extension;
        }
        extend(extendedConfig = {}) {
          const extension = new _Node({ ...this.config, ...extendedConfig });
          extension.parent = this;
          this.child = extension;
          extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
          if (extendedConfig.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
          }
          extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
            name: extension.name
          }));
          extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
            name: extension.name,
            options: extension.options
          }));
          return extension;
        }
      };
      NodeView = class {
        constructor(component, props, options) {
          this.isDragging = false;
          this.component = component;
          this.editor = props.editor;
          this.options = {
            stopEvent: null,
            ignoreMutation: null,
            ...options
          };
          this.extension = props.extension;
          this.node = props.node;
          this.decorations = props.decorations;
          this.getPos = props.getPos;
          this.mount();
        }
        mount() {
          return;
        }
        get dom() {
          return this.editor.view.dom;
        }
        get contentDOM() {
          return null;
        }
        onDragStart(event) {
          var _a, _b, _c, _d, _e, _f, _g;
          const { view } = this.editor;
          const target = event.target;
          const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
          if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
            return;
          }
          let x = 0;
          let y = 0;
          if (this.dom !== dragHandle) {
            const domBox = this.dom.getBoundingClientRect();
            const handleBox = dragHandle.getBoundingClientRect();
            const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;
            const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;
            x = handleBox.x - domBox.x + offsetX;
            y = handleBox.y - domBox.y + offsetY;
          }
          (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);
          const selection = NodeSelection.create(view.state.doc, this.getPos());
          const transaction = view.state.tr.setSelection(selection);
          view.dispatch(transaction);
        }
        stopEvent(event) {
          var _a;
          if (!this.dom) {
            return false;
          }
          if (typeof this.options.stopEvent === "function") {
            return this.options.stopEvent({ event });
          }
          const target = event.target;
          const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));
          if (!isInElement) {
            return false;
          }
          const isDragEvent = event.type.startsWith("drag");
          const isDropEvent = event.type === "drop";
          const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
          if (isInput && !isDropEvent && !isDragEvent) {
            return true;
          }
          const { isEditable } = this.editor;
          const { isDragging } = this;
          const isDraggable = !!this.node.type.spec.draggable;
          const isSelectable = NodeSelection.isSelectable(this.node);
          const isCopyEvent = event.type === "copy";
          const isPasteEvent = event.type === "paste";
          const isCutEvent = event.type === "cut";
          const isClickEvent = event.type === "mousedown";
          if (!isDraggable && isSelectable && isDragEvent) {
            event.preventDefault();
          }
          if (isDraggable && isDragEvent && !isDragging) {
            event.preventDefault();
            return false;
          }
          if (isDraggable && isEditable && !isDragging && isClickEvent) {
            const dragHandle = target.closest("[data-drag-handle]");
            const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
            if (isValidDragHandle) {
              this.isDragging = true;
              document.addEventListener("dragend", () => {
                this.isDragging = false;
              }, { once: true });
              document.addEventListener("drop", () => {
                this.isDragging = false;
              }, { once: true });
              document.addEventListener("mouseup", () => {
                this.isDragging = false;
              }, { once: true });
            }
          }
          if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
            return false;
          }
          return true;
        }
        ignoreMutation(mutation) {
          if (!this.dom || !this.contentDOM) {
            return true;
          }
          if (typeof this.options.ignoreMutation === "function") {
            return this.options.ignoreMutation({ mutation });
          }
          if (this.node.isLeaf || this.node.isAtom) {
            return true;
          }
          if (mutation.type === "selection") {
            return false;
          }
          if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
            const changedNodes = [
              ...Array.from(mutation.addedNodes),
              ...Array.from(mutation.removedNodes)
            ];
            if (changedNodes.every((node) => node.isContentEditable)) {
              return false;
            }
          }
          if (this.contentDOM === mutation.target && mutation.type === "attributes") {
            return true;
          }
          if (this.contentDOM.contains(mutation.target)) {
            return false;
          }
          return true;
        }
        updateAttributes(attributes) {
          this.editor.commands.command(({ tr: tr2 }) => {
            const pos = this.getPos();
            tr2.setNodeMarkup(pos, void 0, {
              ...this.node.attrs,
              ...attributes
            });
            return true;
          });
        }
        deleteNode() {
          const from3 = this.getPos();
          const to2 = from3 + this.node.nodeSize;
          this.editor.commands.deleteRange({ from: from3, to: to2 });
        }
      };
      Tracker = class {
        constructor(transaction) {
          this.transaction = transaction;
          this.currentStep = this.transaction.steps.length;
        }
        map(position) {
          let deleted = false;
          const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {
            const mapResult = step.getMap().mapResult(newPosition);
            if (mapResult.deleted) {
              deleted = true;
            }
            return mapResult.pos;
          }, position);
          return {
            position: mappedPosition,
            deleted
          };
        }
      };
    }
  });

  // node_modules/@tiptap/extension-document/dist/index.js
  var dist_exports2 = {};
  __export(dist_exports2, {
    Document: () => Document,
    default: () => Document
  });
  var Document;
  var init_dist17 = __esm({
    "node_modules/@tiptap/extension-document/dist/index.js"() {
      init_dist16();
      Document = Node3.create({
        name: "doc",
        topNode: true,
        content: "block+"
      });
    }
  });

  // node_modules/prosemirror-dropcursor/dist/index.js
  function dropCursor(options = {}) {
    return new Plugin({
      view(editorView) {
        return new DropCursorView(editorView, options);
      }
    });
  }
  var DropCursorView;
  var init_dist18 = __esm({
    "node_modules/prosemirror-dropcursor/dist/index.js"() {
      init_dist4();
      init_dist3();
      DropCursorView = class {
        constructor(editorView, options) {
          var _a;
          this.editorView = editorView;
          this.cursorPos = null;
          this.element = null;
          this.timeout = -1;
          this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
          this.color = options.color === false ? void 0 : options.color || "black";
          this.class = options.class;
          this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
            let handler = (e) => {
              this[name](e);
            };
            editorView.dom.addEventListener(name, handler);
            return { name, handler };
          });
        }
        destroy() {
          this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
        }
        update(editorView, prevState) {
          if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
            if (this.cursorPos > editorView.state.doc.content.size)
              this.setCursor(null);
            else
              this.updateOverlay();
          }
        }
        setCursor(pos) {
          if (pos == this.cursorPos)
            return;
          this.cursorPos = pos;
          if (pos == null) {
            this.element.parentNode.removeChild(this.element);
            this.element = null;
          } else {
            this.updateOverlay();
          }
        }
        updateOverlay() {
          let $pos = this.editorView.state.doc.resolve(this.cursorPos);
          let isBlock = !$pos.parent.inlineContent, rect;
          if (isBlock) {
            let before = $pos.nodeBefore, after = $pos.nodeAfter;
            if (before || after) {
              let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
              if (node) {
                let nodeRect = node.getBoundingClientRect();
                let top2 = before ? nodeRect.bottom : nodeRect.top;
                if (before && after)
                  top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
                rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
              }
            }
          }
          if (!rect) {
            let coords = this.editorView.coordsAtPos(this.cursorPos);
            rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
          }
          let parent = this.editorView.dom.offsetParent;
          if (!this.element) {
            this.element = parent.appendChild(document.createElement("div"));
            if (this.class)
              this.element.className = this.class;
            this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
            if (this.color) {
              this.element.style.backgroundColor = this.color;
            }
          }
          this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
          this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
          let parentLeft, parentTop;
          if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
            parentLeft = -pageXOffset;
            parentTop = -pageYOffset;
          } else {
            let rect2 = parent.getBoundingClientRect();
            parentLeft = rect2.left - parent.scrollLeft;
            parentTop = rect2.top - parent.scrollTop;
          }
          this.element.style.left = rect.left - parentLeft + "px";
          this.element.style.top = rect.top - parentTop + "px";
          this.element.style.width = rect.right - rect.left + "px";
          this.element.style.height = rect.bottom - rect.top + "px";
        }
        scheduleRemoval(timeout) {
          clearTimeout(this.timeout);
          this.timeout = setTimeout(() => this.setCursor(null), timeout);
        }
        dragover(event) {
          if (!this.editorView.editable)
            return;
          let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
          let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
          let disableDropCursor = node && node.type.spec.disableDropCursor;
          let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
          if (pos && !disabled) {
            let target = pos.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
              let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
              if (point != null)
                target = point;
            }
            this.setCursor(target);
            this.scheduleRemoval(5e3);
          }
        }
        dragend() {
          this.scheduleRemoval(20);
        }
        drop() {
          this.scheduleRemoval(20);
        }
        dragleave(event) {
          if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
            this.setCursor(null);
        }
      };
    }
  });

  // node_modules/@tiptap/pm/dropcursor/dist/index.js
  var init_dist19 = __esm({
    "node_modules/@tiptap/pm/dropcursor/dist/index.js"() {
      init_dist18();
    }
  });

  // node_modules/@tiptap/extension-dropcursor/dist/index.js
  var dist_exports3 = {};
  __export(dist_exports3, {
    Dropcursor: () => Dropcursor,
    default: () => Dropcursor
  });
  var Dropcursor;
  var init_dist20 = __esm({
    "node_modules/@tiptap/extension-dropcursor/dist/index.js"() {
      init_dist16();
      init_dist19();
      Dropcursor = Extension.create({
        name: "dropCursor",
        addOptions() {
          return {
            color: "currentColor",
            width: 1,
            class: void 0
          };
        },
        addProseMirrorPlugins() {
          return [
            dropCursor(this.options)
          ];
        }
      });
    }
  });

  // node_modules/prosemirror-gapcursor/dist/index.js
  function closedBefore($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index3 = $pos.index(d), parent = $pos.node(d);
      if (index3 == 0) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let before = parent.child(index3 - 1); ; before = before.lastChild) {
        if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
          return true;
        if (before.inlineContent)
          return false;
      }
    }
    return true;
  }
  function closedAfter($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index3 = $pos.indexAfter(d), parent = $pos.node(d);
      if (index3 == parent.childCount) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let after = parent.child(index3); ; after = after.firstChild) {
        if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
          return true;
        if (after.inlineContent)
          return false;
      }
    }
    return true;
  }
  function gapCursor() {
    return new Plugin({
      props: {
        decorations: drawGapCursor,
        createSelectionBetween(_view, $anchor, $head) {
          return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
        },
        handleClick,
        handleKeyDown,
        handleDOMEvents: { beforeinput }
      }
    });
  }
  function arrow2(axis, dir) {
    const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
    return function(state, dispatch2, view) {
      let sel = state.selection;
      let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
      if (sel instanceof TextSelection) {
        if (!view.endOfTextblock(dirStr) || $start.depth == 0)
          return false;
        mustMove = false;
        $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
      }
      let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
      if (!$found)
        return false;
      if (dispatch2)
        dispatch2(state.tr.setSelection(new GapCursor($found)));
      return true;
    };
  }
  function handleClick(view, pos, event) {
    if (!view || !view.editable)
      return false;
    let $pos = view.state.doc.resolve(pos);
    if (!GapCursor.valid($pos))
      return false;
    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
      return false;
    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
    return true;
  }
  function beforeinput(view, event) {
    if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
      return false;
    let { $from } = view.state.selection;
    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
    if (!insert)
      return false;
    let frag = Fragment.empty;
    for (let i = insert.length - 1; i >= 0; i--)
      frag = Fragment.from(insert[i].createAndFill(null, frag));
    let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
    tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
    view.dispatch(tr2);
    return false;
  }
  function drawGapCursor(state) {
    if (!(state.selection instanceof GapCursor))
      return null;
    let node = document.createElement("div");
    node.className = "ProseMirror-gapcursor";
    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
  }
  var GapCursor, GapBookmark, handleKeyDown;
  var init_dist21 = __esm({
    "node_modules/prosemirror-gapcursor/dist/index.js"() {
      init_dist8();
      init_dist4();
      init_dist2();
      init_dist6();
      GapCursor = class _GapCursor extends Selection {
        /**
        Create a gap cursor.
        */
        constructor($pos) {
          super($pos, $pos);
        }
        map(doc3, mapping) {
          let $pos = doc3.resolve(mapping.map(this.head));
          return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
        }
        content() {
          return Slice.empty;
        }
        eq(other) {
          return other instanceof _GapCursor && other.head == this.head;
        }
        toJSON() {
          return { type: "gapcursor", pos: this.head };
        }
        /**
        @internal
        */
        static fromJSON(doc3, json2) {
          if (typeof json2.pos != "number")
            throw new RangeError("Invalid input for GapCursor.fromJSON");
          return new _GapCursor(doc3.resolve(json2.pos));
        }
        /**
        @internal
        */
        getBookmark() {
          return new GapBookmark(this.anchor);
        }
        /**
        @internal
        */
        static valid($pos) {
          let parent = $pos.parent;
          if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
            return false;
          let override = parent.type.spec.allowGapCursor;
          if (override != null)
            return override;
          let deflt = parent.contentMatchAt($pos.index()).defaultType;
          return deflt && deflt.isTextblock;
        }
        /**
        @internal
        */
        static findGapCursorFrom($pos, dir, mustMove = false) {
          search:
            for (; ; ) {
              if (!mustMove && _GapCursor.valid($pos))
                return $pos;
              let pos = $pos.pos, next = null;
              for (let d = $pos.depth; ; d--) {
                let parent = $pos.node(d);
                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
                  next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
                  break;
                } else if (d == 0) {
                  return null;
                }
                pos += dir;
                let $cur = $pos.doc.resolve(pos);
                if (_GapCursor.valid($cur))
                  return $cur;
              }
              for (; ; ) {
                let inside = dir > 0 ? next.firstChild : next.lastChild;
                if (!inside) {
                  if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                    $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                    mustMove = false;
                    continue search;
                  }
                  break;
                }
                next = inside;
                pos += dir;
                let $cur = $pos.doc.resolve(pos);
                if (_GapCursor.valid($cur))
                  return $cur;
              }
              return null;
            }
        }
      };
      GapCursor.prototype.visible = false;
      GapCursor.findFrom = GapCursor.findGapCursorFrom;
      Selection.jsonID("gapcursor", GapCursor);
      GapBookmark = class _GapBookmark {
        constructor(pos) {
          this.pos = pos;
        }
        map(mapping) {
          return new _GapBookmark(mapping.map(this.pos));
        }
        resolve(doc3) {
          let $pos = doc3.resolve(this.pos);
          return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
        }
      };
      handleKeyDown = keydownHandler({
        "ArrowLeft": arrow2("horiz", -1),
        "ArrowRight": arrow2("horiz", 1),
        "ArrowUp": arrow2("vert", -1),
        "ArrowDown": arrow2("vert", 1)
      });
    }
  });

  // node_modules/@tiptap/pm/gapcursor/dist/index.js
  var init_dist22 = __esm({
    "node_modules/@tiptap/pm/gapcursor/dist/index.js"() {
      init_dist21();
    }
  });

  // node_modules/@tiptap/extension-gapcursor/dist/index.js
  var dist_exports4 = {};
  __export(dist_exports4, {
    Gapcursor: () => Gapcursor,
    default: () => Gapcursor
  });
  var Gapcursor;
  var init_dist23 = __esm({
    "node_modules/@tiptap/extension-gapcursor/dist/index.js"() {
      init_dist16();
      init_dist22();
      Gapcursor = Extension.create({
        name: "gapCursor",
        addProseMirrorPlugins() {
          return [
            gapCursor()
          ];
        },
        extendNodeSchema(extension) {
          var _a;
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage
          };
          return {
            allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
          };
        }
      });
    }
  });

  // node_modules/rope-sequence/dist/index.js
  var GOOD_LEAF_SIZE, RopeSequence, Leaf, Append, dist_default2;
  var init_dist24 = __esm({
    "node_modules/rope-sequence/dist/index.js"() {
      GOOD_LEAF_SIZE = 200;
      RopeSequence = function RopeSequence2() {
      };
      RopeSequence.prototype.append = function append(other) {
        if (!other.length) {
          return this;
        }
        other = RopeSequence.from(other);
        return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
      };
      RopeSequence.prototype.prepend = function prepend(other) {
        if (!other.length) {
          return this;
        }
        return RopeSequence.from(other).append(this);
      };
      RopeSequence.prototype.appendInner = function appendInner(other) {
        return new Append(this, other);
      };
      RopeSequence.prototype.slice = function slice(from3, to2) {
        if (from3 === void 0)
          from3 = 0;
        if (to2 === void 0)
          to2 = this.length;
        if (from3 >= to2) {
          return RopeSequence.empty;
        }
        return this.sliceInner(Math.max(0, from3), Math.min(this.length, to2));
      };
      RopeSequence.prototype.get = function get2(i) {
        if (i < 0 || i >= this.length) {
          return void 0;
        }
        return this.getInner(i);
      };
      RopeSequence.prototype.forEach = function forEach2(f, from3, to2) {
        if (from3 === void 0)
          from3 = 0;
        if (to2 === void 0)
          to2 = this.length;
        if (from3 <= to2) {
          this.forEachInner(f, from3, to2, 0);
        } else {
          this.forEachInvertedInner(f, from3, to2, 0);
        }
      };
      RopeSequence.prototype.map = function map3(f, from3, to2) {
        if (from3 === void 0)
          from3 = 0;
        if (to2 === void 0)
          to2 = this.length;
        var result = [];
        this.forEach(function(elt, i) {
          return result.push(f(elt, i));
        }, from3, to2);
        return result;
      };
      RopeSequence.from = function from2(values) {
        if (values instanceof RopeSequence) {
          return values;
        }
        return values && values.length ? new Leaf(values) : RopeSequence.empty;
      };
      Leaf = /* @__PURE__ */ function(RopeSequence3) {
        function Leaf2(values) {
          RopeSequence3.call(this);
          this.values = values;
        }
        if (RopeSequence3)
          Leaf2.__proto__ = RopeSequence3;
        Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
        Leaf2.prototype.constructor = Leaf2;
        var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
        Leaf2.prototype.flatten = function flatten() {
          return this.values;
        };
        Leaf2.prototype.sliceInner = function sliceInner(from3, to2) {
          if (from3 == 0 && to2 == this.length) {
            return this;
          }
          return new Leaf2(this.values.slice(from3, to2));
        };
        Leaf2.prototype.getInner = function getInner(i) {
          return this.values[i];
        };
        Leaf2.prototype.forEachInner = function forEachInner(f, from3, to2, start3) {
          for (var i = from3; i < to2; i++) {
            if (f(this.values[i], start3 + i) === false) {
              return false;
            }
          }
        };
        Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from3, to2, start3) {
          for (var i = from3 - 1; i >= to2; i--) {
            if (f(this.values[i], start3 + i) === false) {
              return false;
            }
          }
        };
        Leaf2.prototype.leafAppend = function leafAppend(other) {
          if (this.length + other.length <= GOOD_LEAF_SIZE) {
            return new Leaf2(this.values.concat(other.flatten()));
          }
        };
        Leaf2.prototype.leafPrepend = function leafPrepend(other) {
          if (this.length + other.length <= GOOD_LEAF_SIZE) {
            return new Leaf2(other.flatten().concat(this.values));
          }
        };
        prototypeAccessors.length.get = function() {
          return this.values.length;
        };
        prototypeAccessors.depth.get = function() {
          return 0;
        };
        Object.defineProperties(Leaf2.prototype, prototypeAccessors);
        return Leaf2;
      }(RopeSequence);
      RopeSequence.empty = new Leaf([]);
      Append = /* @__PURE__ */ function(RopeSequence3) {
        function Append2(left2, right2) {
          RopeSequence3.call(this);
          this.left = left2;
          this.right = right2;
          this.length = left2.length + right2.length;
          this.depth = Math.max(left2.depth, right2.depth) + 1;
        }
        if (RopeSequence3)
          Append2.__proto__ = RopeSequence3;
        Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
        Append2.prototype.constructor = Append2;
        Append2.prototype.flatten = function flatten() {
          return this.left.flatten().concat(this.right.flatten());
        };
        Append2.prototype.getInner = function getInner(i) {
          return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
        };
        Append2.prototype.forEachInner = function forEachInner(f, from3, to2, start3) {
          var leftLen = this.left.length;
          if (from3 < leftLen && this.left.forEachInner(f, from3, Math.min(to2, leftLen), start3) === false) {
            return false;
          }
          if (to2 > leftLen && this.right.forEachInner(f, Math.max(from3 - leftLen, 0), Math.min(this.length, to2) - leftLen, start3 + leftLen) === false) {
            return false;
          }
        };
        Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from3, to2, start3) {
          var leftLen = this.left.length;
          if (from3 > leftLen && this.right.forEachInvertedInner(f, from3 - leftLen, Math.max(to2, leftLen) - leftLen, start3 + leftLen) === false) {
            return false;
          }
          if (to2 < leftLen && this.left.forEachInvertedInner(f, Math.min(from3, leftLen), to2, start3) === false) {
            return false;
          }
        };
        Append2.prototype.sliceInner = function sliceInner(from3, to2) {
          if (from3 == 0 && to2 == this.length) {
            return this;
          }
          var leftLen = this.left.length;
          if (to2 <= leftLen) {
            return this.left.slice(from3, to2);
          }
          if (from3 >= leftLen) {
            return this.right.slice(from3 - leftLen, to2 - leftLen);
          }
          return this.left.slice(from3, leftLen).append(this.right.slice(0, to2 - leftLen));
        };
        Append2.prototype.leafAppend = function leafAppend(other) {
          var inner = this.right.leafAppend(other);
          if (inner) {
            return new Append2(this.left, inner);
          }
        };
        Append2.prototype.leafPrepend = function leafPrepend(other) {
          var inner = this.left.leafPrepend(other);
          if (inner) {
            return new Append2(inner, this.right);
          }
        };
        Append2.prototype.appendInner = function appendInner2(other) {
          if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
            return new Append2(this.left, new Append2(this.right, other));
          }
          return new Append2(this, other);
        };
        return Append2;
      }(RopeSequence);
      dist_default2 = RopeSequence;
    }
  });

  // node_modules/prosemirror-history/dist/index.js
  function cutOffEvents(items, n) {
    let cutPoint;
    items.forEach((item, i) => {
      if (item.selection && n-- == 0) {
        cutPoint = i;
        return false;
      }
    });
    return items.slice(cutPoint);
  }
  function applyTransaction(history3, state, tr2, options) {
    let historyTr = tr2.getMeta(historyKey), rebased;
    if (historyTr)
      return historyTr.historyState;
    if (tr2.getMeta(closeHistoryKey))
      history3 = new HistoryState(history3.done, history3.undone, null, 0, -1);
    let appended = tr2.getMeta("appendedTransaction");
    if (tr2.steps.length == 0) {
      return history3;
    } else if (appended && appended.getMeta(historyKey)) {
      if (appended.getMeta(historyKey).redo)
        return new HistoryState(history3.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history3.undone, rangesFor(tr2.mapping.maps[tr2.steps.length - 1]), history3.prevTime, history3.prevComposition);
      else
        return new HistoryState(history3.done, history3.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history3.prevTime, history3.prevComposition);
    } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
      let composition = tr2.getMeta("composition");
      let newGroup = history3.prevTime == 0 || !appended && history3.prevComposition != composition && (history3.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history3.prevRanges));
      let prevRanges = appended ? mapRanges(history3.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps[tr2.steps.length - 1]);
      return new HistoryState(history3.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history3.prevComposition : composition);
    } else if (rebased = tr2.getMeta("rebased")) {
      return new HistoryState(history3.done.rebased(tr2, rebased), history3.undone.rebased(tr2, rebased), mapRanges(history3.prevRanges, tr2.mapping), history3.prevTime, history3.prevComposition);
    } else {
      return new HistoryState(history3.done.addMaps(tr2.mapping.maps), history3.undone.addMaps(tr2.mapping.maps), mapRanges(history3.prevRanges, tr2.mapping), history3.prevTime, history3.prevComposition);
    }
  }
  function isAdjacentTo(transform, prevRanges) {
    if (!prevRanges)
      return false;
    if (!transform.docChanged)
      return true;
    let adjacent = false;
    transform.mapping.maps[0].forEach((start3, end2) => {
      for (let i = 0; i < prevRanges.length; i += 2)
        if (start3 <= prevRanges[i + 1] && end2 >= prevRanges[i])
          adjacent = true;
    });
    return adjacent;
  }
  function rangesFor(map4) {
    let result = [];
    map4.forEach((_from, _to, from3, to2) => result.push(from3, to2));
    return result;
  }
  function mapRanges(ranges, mapping) {
    if (!ranges)
      return null;
    let result = [];
    for (let i = 0; i < ranges.length; i += 2) {
      let from3 = mapping.map(ranges[i], 1), to2 = mapping.map(ranges[i + 1], -1);
      if (from3 <= to2)
        result.push(from3, to2);
    }
    return result;
  }
  function histTransaction(history3, state, dispatch2, redo2) {
    let preserveItems = mustPreserveItems(state);
    let histOptions = historyKey.get(state).spec.config;
    let pop = (redo2 ? history3.undone : history3.done).popEvent(state, preserveItems);
    if (!pop)
      return;
    let selection = pop.selection.resolve(pop.transform.doc);
    let added = (redo2 ? history3.done : history3.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
    dispatch2(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
  }
  function mustPreserveItems(state) {
    let plugins3 = state.plugins;
    if (cachedPreserveItemsPlugins != plugins3) {
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = plugins3;
      for (let i = 0; i < plugins3.length; i++)
        if (plugins3[i].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break;
        }
    }
    return cachedPreserveItems;
  }
  function history2(config = {}) {
    config = {
      depth: config.depth || 100,
      newGroupDelay: config.newGroupDelay || 500
    };
    return new Plugin({
      key: historyKey,
      state: {
        init() {
          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
        },
        apply(tr2, hist, state) {
          return applyTransaction(hist, state, tr2, config);
        }
      },
      config,
      props: {
        handleDOMEvents: {
          beforeinput(view, e) {
            let inputType = e.inputType;
            let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
            if (!command2)
              return false;
            e.preventDefault();
            return command2(view.state, view.dispatch);
          }
        }
      }
    });
  }
  var max_empty_items, Branch, Item, HistoryState, DEPTH_OVERFLOW, cachedPreserveItems, cachedPreserveItemsPlugins, historyKey, closeHistoryKey, undo, redo;
  var init_dist25 = __esm({
    "node_modules/prosemirror-history/dist/index.js"() {
      init_dist24();
      init_dist3();
      init_dist4();
      max_empty_items = 500;
      Branch = class _Branch {
        constructor(items, eventCount) {
          this.items = items;
          this.eventCount = eventCount;
        }
        // Pop the latest event off the branch's history and apply it
        // to a document transform.
        popEvent(state, preserveItems) {
          if (this.eventCount == 0)
            return null;
          let end2 = this.items.length;
          for (; ; end2--) {
            let next = this.items.get(end2 - 1);
            if (next.selection) {
              --end2;
              break;
            }
          }
          let remap, mapFrom;
          if (preserveItems) {
            remap = this.remapping(end2, this.items.length);
            mapFrom = remap.maps.length;
          }
          let transform = state.tr;
          let selection, remaining;
          let addAfter = [], addBefore = [];
          this.items.forEach((item, i) => {
            if (!item.step) {
              if (!remap) {
                remap = this.remapping(end2, i + 1);
                mapFrom = remap.maps.length;
              }
              mapFrom--;
              addBefore.push(item);
              return;
            }
            if (remap) {
              addBefore.push(new Item(item.map));
              let step = item.step.map(remap.slice(mapFrom)), map4;
              if (step && transform.maybeStep(step).doc) {
                map4 = transform.mapping.maps[transform.mapping.maps.length - 1];
                addAfter.push(new Item(map4, void 0, void 0, addAfter.length + addBefore.length));
              }
              mapFrom--;
              if (map4)
                remap.appendMap(map4, mapFrom);
            } else {
              transform.maybeStep(item.step);
            }
            if (item.selection) {
              selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
              remaining = new _Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
              return false;
            }
          }, this.items.length, 0);
          return { remaining, transform, selection };
        }
        // Create a new branch with the given transform added.
        addTransform(transform, selection, histOptions, preserveItems) {
          let newItems = [], eventCount = this.eventCount;
          let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
          for (let i = 0; i < transform.steps.length; i++) {
            let step = transform.steps[i].invert(transform.docs[i]);
            let item = new Item(transform.mapping.maps[i], step, selection), merged;
            if (merged = lastItem && lastItem.merge(item)) {
              item = merged;
              if (i)
                newItems.pop();
              else
                oldItems = oldItems.slice(0, oldItems.length - 1);
            }
            newItems.push(item);
            if (selection) {
              eventCount++;
              selection = void 0;
            }
            if (!preserveItems)
              lastItem = item;
          }
          let overflow = eventCount - histOptions.depth;
          if (overflow > DEPTH_OVERFLOW) {
            oldItems = cutOffEvents(oldItems, overflow);
            eventCount -= overflow;
          }
          return new _Branch(oldItems.append(newItems), eventCount);
        }
        remapping(from3, to2) {
          let maps = new Mapping();
          this.items.forEach((item, i) => {
            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from3 ? maps.maps.length - item.mirrorOffset : void 0;
            maps.appendMap(item.map, mirrorPos);
          }, from3, to2);
          return maps;
        }
        addMaps(array) {
          if (this.eventCount == 0)
            return this;
          return new _Branch(this.items.append(array.map((map4) => new Item(map4))), this.eventCount);
        }
        // When the collab module receives remote changes, the history has
        // to know about those, so that it can adjust the steps that were
        // rebased on top of the remote changes, and include the position
        // maps for the remote changes in its array of items.
        rebased(rebasedTransform, rebasedCount) {
          if (!this.eventCount)
            return this;
          let rebasedItems = [], start3 = Math.max(0, this.items.length - rebasedCount);
          let mapping = rebasedTransform.mapping;
          let newUntil = rebasedTransform.steps.length;
          let eventCount = this.eventCount;
          this.items.forEach((item) => {
            if (item.selection)
              eventCount--;
          }, start3);
          let iRebased = rebasedCount;
          this.items.forEach((item) => {
            let pos = mapping.getMirror(--iRebased);
            if (pos == null)
              return;
            newUntil = Math.min(newUntil, pos);
            let map4 = mapping.maps[pos];
            if (item.step) {
              let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
              let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
              if (selection)
                eventCount++;
              rebasedItems.push(new Item(map4, step, selection));
            } else {
              rebasedItems.push(new Item(map4));
            }
          }, start3);
          let newMaps = [];
          for (let i = rebasedCount; i < newUntil; i++)
            newMaps.push(new Item(mapping.maps[i]));
          let items = this.items.slice(0, start3).append(newMaps).append(rebasedItems);
          let branch = new _Branch(items, eventCount);
          if (branch.emptyItemCount() > max_empty_items)
            branch = branch.compress(this.items.length - rebasedItems.length);
          return branch;
        }
        emptyItemCount() {
          let count = 0;
          this.items.forEach((item) => {
            if (!item.step)
              count++;
          });
          return count;
        }
        // Compressing a branch means rewriting it to push the air (map-only
        // items) out. During collaboration, these naturally accumulate
        // because each remote change adds one. The `upto` argument is used
        // to ensure that only the items below a given level are compressed,
        // because `rebased` relies on a clean, untouched set of items in
        // order to associate old items with rebased steps.
        compress(upto = this.items.length) {
          let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
          let items = [], events = 0;
          this.items.forEach((item, i) => {
            if (i >= upto) {
              items.push(item);
              if (item.selection)
                events++;
            } else if (item.step) {
              let step = item.step.map(remap.slice(mapFrom)), map4 = step && step.getMap();
              mapFrom--;
              if (map4)
                remap.appendMap(map4, mapFrom);
              if (step) {
                let selection = item.selection && item.selection.map(remap.slice(mapFrom));
                if (selection)
                  events++;
                let newItem = new Item(map4.invert(), step, selection), merged, last = items.length - 1;
                if (merged = items.length && items[last].merge(newItem))
                  items[last] = merged;
                else
                  items.push(newItem);
              }
            } else if (item.map) {
              mapFrom--;
            }
          }, this.items.length, 0);
          return new _Branch(dist_default2.from(items.reverse()), events);
        }
      };
      Branch.empty = new Branch(dist_default2.empty, 0);
      Item = class _Item {
        constructor(map4, step, selection, mirrorOffset) {
          this.map = map4;
          this.step = step;
          this.selection = selection;
          this.mirrorOffset = mirrorOffset;
        }
        merge(other) {
          if (this.step && other.step && !other.selection) {
            let step = other.step.merge(this.step);
            if (step)
              return new _Item(step.getMap().invert(), step, this.selection);
          }
        }
      };
      HistoryState = class {
        constructor(done, undone, prevRanges, prevTime, prevComposition) {
          this.done = done;
          this.undone = undone;
          this.prevRanges = prevRanges;
          this.prevTime = prevTime;
          this.prevComposition = prevComposition;
        }
      };
      DEPTH_OVERFLOW = 20;
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = null;
      historyKey = new PluginKey("history");
      closeHistoryKey = new PluginKey("closeHistory");
      undo = (state, dispatch2) => {
        let hist = historyKey.getState(state);
        if (!hist || hist.done.eventCount == 0)
          return false;
        if (dispatch2)
          histTransaction(hist, state, dispatch2, false);
        return true;
      };
      redo = (state, dispatch2) => {
        let hist = historyKey.getState(state);
        if (!hist || hist.undone.eventCount == 0)
          return false;
        if (dispatch2)
          histTransaction(hist, state, dispatch2, true);
        return true;
      };
    }
  });

  // node_modules/@tiptap/pm/history/dist/index.js
  var init_dist26 = __esm({
    "node_modules/@tiptap/pm/history/dist/index.js"() {
      init_dist25();
    }
  });

  // node_modules/@tiptap/extension-history/dist/index.js
  var dist_exports5 = {};
  __export(dist_exports5, {
    History: () => History2,
    default: () => History2
  });
  var History2;
  var init_dist27 = __esm({
    "node_modules/@tiptap/extension-history/dist/index.js"() {
      init_dist16();
      init_dist26();
      History2 = Extension.create({
        name: "history",
        addOptions() {
          return {
            depth: 100,
            newGroupDelay: 500
          };
        },
        addCommands() {
          return {
            undo: () => ({ state, dispatch: dispatch2 }) => {
              return undo(state, dispatch2);
            },
            redo: () => ({ state, dispatch: dispatch2 }) => {
              return redo(state, dispatch2);
            }
          };
        },
        addProseMirrorPlugins() {
          return [
            history2(this.options)
          ];
        },
        addKeyboardShortcuts() {
          return {
            "Mod-z": () => this.editor.commands.undo(),
            "Shift-Mod-z": () => this.editor.commands.redo(),
            "Mod-y": () => this.editor.commands.redo(),
            // Russian keyboard layouts
            "Mod-\u044F": () => this.editor.commands.undo(),
            "Shift-Mod-\u044F": () => this.editor.commands.redo()
          };
        }
      });
    }
  });

  // node_modules/@tiptap/extension-placeholder/dist/index.js
  var dist_exports6 = {};
  __export(dist_exports6, {
    Placeholder: () => Placeholder,
    default: () => Placeholder
  });
  var Placeholder;
  var init_dist28 = __esm({
    "node_modules/@tiptap/extension-placeholder/dist/index.js"() {
      init_dist16();
      init_dist5();
      init_dist7();
      Placeholder = Extension.create({
        name: "placeholder",
        addOptions() {
          return {
            emptyEditorClass: "is-editor-empty",
            emptyNodeClass: "is-empty",
            placeholder: "Write something \u2026",
            showOnlyWhenEditable: true,
            considerAnyAsEmpty: false,
            showOnlyCurrent: true,
            includeChildren: false
          };
        },
        addProseMirrorPlugins() {
          return [
            new Plugin({
              key: new PluginKey("placeholder"),
              props: {
                decorations: ({ doc: doc3, selection }) => {
                  var _a;
                  const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
                  const { anchor } = selection;
                  const decorations = [];
                  if (!active) {
                    return null;
                  }
                  const { firstChild } = doc3.content;
                  const isLeaf = firstChild && firstChild.type.isLeaf;
                  const isAtom = firstChild && firstChild.isAtom;
                  const isValidNode = this.options.considerAnyAsEmpty ? true : firstChild && firstChild.type.name === ((_a = doc3.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.name);
                  const isEmptyDoc = doc3.content.childCount <= 1 && firstChild && isValidNode && (firstChild.nodeSize <= 2 && (!isLeaf || !isAtom));
                  doc3.descendants((node, pos) => {
                    const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
                    const isEmpty2 = !node.isLeaf && !node.childCount;
                    if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty2) {
                      const classes = [this.options.emptyNodeClass];
                      if (isEmptyDoc) {
                        classes.push(this.options.emptyEditorClass);
                      }
                      const decoration = Decoration.node(pos, pos + node.nodeSize, {
                        class: classes.join(" "),
                        "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                          editor: this.editor,
                          node,
                          pos,
                          hasAnchor
                        }) : this.options.placeholder
                      });
                      decorations.push(decoration);
                    }
                    return this.options.includeChildren;
                  });
                  return DecorationSet.create(doc3, decorations);
                }
              }
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-bubble-menu/dist/index.js
  var dist_exports7 = {};
  __export(dist_exports7, {
    BubbleMenu: () => BubbleMenu,
    BubbleMenuPlugin: () => BubbleMenuPlugin,
    BubbleMenuView: () => BubbleMenuView,
    default: () => BubbleMenu
  });
  var BubbleMenuView, BubbleMenuPlugin, BubbleMenu;
  var init_dist29 = __esm({
    "node_modules/@tiptap/extension-bubble-menu/dist/index.js"() {
      init_dist16();
      init_dist5();
      init_tippy_esm();
      BubbleMenuView = class {
        constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
          this.preventHide = false;
          this.shouldShow = ({ view: view2, state, from: from3, to: to2 }) => {
            const { doc: doc3, selection } = state;
            const { empty: empty2 } = selection;
            const isEmptyTextBlock = !doc3.textBetween(from3, to2).length && isTextSelection(state.selection);
            const isChildOfMenu = this.element.contains(document.activeElement);
            const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
            if (!hasEditorFocus || empty2 || isEmptyTextBlock || !this.editor.isEditable) {
              return false;
            }
            return true;
          };
          this.mousedownHandler = () => {
            this.preventHide = true;
          };
          this.dragstartHandler = () => {
            this.hide();
          };
          this.focusHandler = () => {
            setTimeout(() => this.update(this.editor.view));
          };
          this.blurHandler = ({ event }) => {
            var _a;
            if (this.preventHide) {
              this.preventHide = false;
              return;
            }
            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
              return;
            }
            this.hide();
          };
          this.tippyBlurHandler = (event) => {
            this.blurHandler({ event });
          };
          this.handleDebouncedUpdate = (view2, oldState) => {
            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
            if (!selectionChanged && !docChanged) {
              return;
            }
            if (this.updateDebounceTimer) {
              clearTimeout(this.updateDebounceTimer);
            }
            this.updateDebounceTimer = window.setTimeout(() => {
              this.updateHandler(view2, selectionChanged, docChanged, oldState);
            }, this.updateDelay);
          };
          this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
            var _a, _b, _c;
            const { state, composing } = view2;
            const { selection } = state;
            const isSame = !selectionChanged && !docChanged;
            if (composing || isSame) {
              return;
            }
            this.createTooltip();
            const { ranges } = selection;
            const from3 = Math.min(...ranges.map((range) => range.$from.pos));
            const to2 = Math.max(...ranges.map((range) => range.$to.pos));
            const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
              editor: this.editor,
              view: view2,
              state,
              oldState,
              from: from3,
              to: to2
            });
            if (!shouldShow2) {
              this.hide();
              return;
            }
            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
              getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
                if (isNodeSelection(state.selection)) {
                  let node = view2.nodeDOM(from3);
                  const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
                  if (nodeViewWrapper) {
                    node = nodeViewWrapper.firstChild;
                  }
                  if (node) {
                    return node.getBoundingClientRect();
                  }
                }
                return posToDOMRect(view2, from3, to2);
              })
            });
            this.show();
          };
          this.editor = editor;
          this.element = element;
          this.view = view;
          this.updateDelay = updateDelay;
          if (shouldShow) {
            this.shouldShow = shouldShow;
          }
          this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
          this.view.dom.addEventListener("dragstart", this.dragstartHandler);
          this.editor.on("focus", this.focusHandler);
          this.editor.on("blur", this.blurHandler);
          this.tippyOptions = tippyOptions;
          this.element.remove();
          this.element.style.visibility = "visible";
        }
        createTooltip() {
          const { element: editorElement } = this.editor.options;
          const editorIsAttached = !!editorElement.parentElement;
          if (this.tippy || !editorIsAttached) {
            return;
          }
          this.tippy = tippy_esm_default(editorElement, {
            duration: 0,
            getReferenceClientRect: null,
            content: this.element,
            interactive: true,
            trigger: "manual",
            placement: "top",
            hideOnClick: "toggle",
            ...this.tippyOptions
          });
          if (this.tippy.popper.firstChild) {
            this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
          }
        }
        update(view, oldState) {
          const { state } = view;
          const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;
          if (this.updateDelay > 0 && hasValidSelection) {
            this.handleDebouncedUpdate(view, oldState);
            return;
          }
          const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
          const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
          this.updateHandler(view, selectionChanged, docChanged, oldState);
        }
        show() {
          var _a;
          (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
        }
        hide() {
          var _a;
          (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
        }
        destroy() {
          var _a, _b;
          if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
            this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
          }
          (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
          this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
          this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
          this.editor.off("focus", this.focusHandler);
          this.editor.off("blur", this.blurHandler);
        }
      };
      BubbleMenuPlugin = (options) => {
        return new Plugin({
          key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
          view: (view) => new BubbleMenuView({ view, ...options })
        });
      };
      BubbleMenu = Extension.create({
        name: "bubbleMenu",
        addOptions() {
          return {
            element: null,
            tippyOptions: {},
            pluginKey: "bubbleMenu",
            updateDelay: void 0,
            shouldShow: null
          };
        },
        addProseMirrorPlugins() {
          if (!this.options.element) {
            return [];
          }
          return [
            BubbleMenuPlugin({
              pluginKey: this.options.pluginKey,
              editor: this.editor,
              element: this.options.element,
              tippyOptions: this.options.tippyOptions,
              updateDelay: this.options.updateDelay,
              shouldShow: this.options.shouldShow
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-text-align/dist/index.js
  var dist_exports8 = {};
  __export(dist_exports8, {
    TextAlign: () => TextAlign,
    default: () => TextAlign
  });
  var TextAlign;
  var init_dist30 = __esm({
    "node_modules/@tiptap/extension-text-align/dist/index.js"() {
      init_dist16();
      TextAlign = Extension.create({
        name: "textAlign",
        addOptions() {
          return {
            types: [],
            alignments: ["left", "center", "right", "justify"],
            defaultAlignment: "left"
          };
        },
        addGlobalAttributes() {
          return [
            {
              types: this.options.types,
              attributes: {
                textAlign: {
                  default: this.options.defaultAlignment,
                  parseHTML: (element) => element.style.textAlign || this.options.defaultAlignment,
                  renderHTML: (attributes) => {
                    if (attributes.textAlign === this.options.defaultAlignment) {
                      return {};
                    }
                    return { style: `text-align: ${attributes.textAlign}` };
                  }
                }
              }
            }
          ];
        },
        addCommands() {
          return {
            setTextAlign: (alignment) => ({ commands: commands2 }) => {
              if (!this.options.alignments.includes(alignment)) {
                return false;
              }
              return this.options.types.every((type) => commands2.updateAttributes(type, { textAlign: alignment }));
            },
            unsetTextAlign: () => ({ commands: commands2 }) => {
              return this.options.types.every((type) => commands2.resetAttributes(type, "textAlign"));
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
            "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
            "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
            "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
          };
        }
      });
    }
  });

  // node_modules/@tiptap/extension-text-style/dist/index.js
  var dist_exports9 = {};
  __export(dist_exports9, {
    TextStyle: () => TextStyle,
    default: () => TextStyle
  });
  var TextStyle;
  var init_dist31 = __esm({
    "node_modules/@tiptap/extension-text-style/dist/index.js"() {
      init_dist16();
      TextStyle = Mark2.create({
        name: "textStyle",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        parseHTML() {
          return [
            {
              tag: "span",
              getAttrs: (element) => {
                const hasStyles = element.hasAttribute("style");
                if (!hasStyles) {
                  return false;
                }
                return {};
              }
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
              const attributes = getMarkAttributes(state, this.type);
              const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
              if (hasStyles) {
                return true;
              }
              return commands2.unsetMark(this.name);
            }
          };
        }
      });
    }
  });

  // node_modules/@tiptap/extension-color/dist/index.js
  var dist_exports10 = {};
  __export(dist_exports10, {
    Color: () => Color2,
    default: () => Color2
  });
  var Color2;
  var init_dist32 = __esm({
    "node_modules/@tiptap/extension-color/dist/index.js"() {
      init_dist31();
      init_dist16();
      Color2 = Extension.create({
        name: "color",
        addOptions() {
          return {
            types: ["textStyle"]
          };
        },
        addGlobalAttributes() {
          return [
            {
              types: this.options.types,
              attributes: {
                color: {
                  default: null,
                  parseHTML: (element) => {
                    var _a;
                    return (_a = element.style.color) === null || _a === void 0 ? void 0 : _a.replace(/['"]+/g, "");
                  },
                  renderHTML: (attributes) => {
                    if (!attributes.color) {
                      return {};
                    }
                    return {
                      style: `color: ${attributes.color}`
                    };
                  }
                }
              }
            }
          ];
        },
        addCommands() {
          return {
            setColor: (color2) => ({ chain }) => {
              return chain().setMark("textStyle", { color: color2 }).run();
            },
            unsetColor: () => ({ chain }) => {
              return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
            }
          };
        }
      });
    }
  });

  // node_modules/@tiptap/extension-bold/dist/index.js
  var dist_exports11 = {};
  __export(dist_exports11, {
    Bold: () => Bold,
    default: () => Bold,
    starInputRegex: () => starInputRegex,
    starPasteRegex: () => starPasteRegex,
    underscoreInputRegex: () => underscoreInputRegex,
    underscorePasteRegex: () => underscorePasteRegex
  });
  var starInputRegex, starPasteRegex, underscoreInputRegex, underscorePasteRegex, Bold;
  var init_dist33 = __esm({
    "node_modules/@tiptap/extension-bold/dist/index.js"() {
      init_dist16();
      starInputRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
      starPasteRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
      underscoreInputRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
      underscorePasteRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
      Bold = Mark2.create({
        name: "bold",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        parseHTML() {
          return [
            {
              tag: "strong"
            },
            {
              tag: "b",
              getAttrs: (node) => node.style.fontWeight !== "normal" && null
            },
            {
              style: "font-weight",
              getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setBold: () => ({ commands: commands2 }) => {
              return commands2.setMark(this.name);
            },
            toggleBold: () => ({ commands: commands2 }) => {
              return commands2.toggleMark(this.name);
            },
            unsetBold: () => ({ commands: commands2 }) => {
              return commands2.unsetMark(this.name);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-b": () => this.editor.commands.toggleBold(),
            "Mod-B": () => this.editor.commands.toggleBold()
          };
        },
        addInputRules() {
          return [
            markInputRule({
              find: starInputRegex,
              type: this.type
            }),
            markInputRule({
              find: underscoreInputRegex,
              type: this.type
            })
          ];
        },
        addPasteRules() {
          return [
            markPasteRule({
              find: starPasteRegex,
              type: this.type
            }),
            markPasteRule({
              find: underscorePasteRegex,
              type: this.type
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-code/dist/index.js
  var dist_exports12 = {};
  __export(dist_exports12, {
    Code: () => Code,
    default: () => Code,
    inputRegex: () => inputRegex,
    pasteRegex: () => pasteRegex
  });
  var inputRegex, pasteRegex, Code;
  var init_dist34 = __esm({
    "node_modules/@tiptap/extension-code/dist/index.js"() {
      init_dist16();
      inputRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
      pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
      Code = Mark2.create({
        name: "code",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        excludes: "_",
        code: true,
        exitable: true,
        parseHTML() {
          return [
            { tag: "code" }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setCode: () => ({ commands: commands2 }) => {
              return commands2.setMark(this.name);
            },
            toggleCode: () => ({ commands: commands2 }) => {
              return commands2.toggleMark(this.name);
            },
            unsetCode: () => ({ commands: commands2 }) => {
              return commands2.unsetMark(this.name);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-e": () => this.editor.commands.toggleCode()
          };
        },
        addInputRules() {
          return [
            markInputRule({
              find: inputRegex,
              type: this.type
            })
          ];
        },
        addPasteRules() {
          return [
            markPasteRule({
              find: pasteRegex,
              type: this.type
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-italic/dist/index.js
  var dist_exports13 = {};
  __export(dist_exports13, {
    Italic: () => Italic,
    default: () => Italic,
    starInputRegex: () => starInputRegex2,
    starPasteRegex: () => starPasteRegex2,
    underscoreInputRegex: () => underscoreInputRegex2,
    underscorePasteRegex: () => underscorePasteRegex2
  });
  var starInputRegex2, starPasteRegex2, underscoreInputRegex2, underscorePasteRegex2, Italic;
  var init_dist35 = __esm({
    "node_modules/@tiptap/extension-italic/dist/index.js"() {
      init_dist16();
      starInputRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
      starPasteRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
      underscoreInputRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
      underscorePasteRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
      Italic = Mark2.create({
        name: "italic",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        parseHTML() {
          return [
            {
              tag: "em"
            },
            {
              tag: "i",
              getAttrs: (node) => node.style.fontStyle !== "normal" && null
            },
            {
              style: "font-style=italic"
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setItalic: () => ({ commands: commands2 }) => {
              return commands2.setMark(this.name);
            },
            toggleItalic: () => ({ commands: commands2 }) => {
              return commands2.toggleMark(this.name);
            },
            unsetItalic: () => ({ commands: commands2 }) => {
              return commands2.unsetMark(this.name);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-i": () => this.editor.commands.toggleItalic(),
            "Mod-I": () => this.editor.commands.toggleItalic()
          };
        },
        addInputRules() {
          return [
            markInputRule({
              find: starInputRegex2,
              type: this.type
            }),
            markInputRule({
              find: underscoreInputRegex2,
              type: this.type
            })
          ];
        },
        addPasteRules() {
          return [
            markPasteRule({
              find: starPasteRegex2,
              type: this.type
            }),
            markPasteRule({
              find: underscorePasteRegex2,
              type: this.type
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-strike/dist/index.js
  var dist_exports14 = {};
  __export(dist_exports14, {
    Strike: () => Strike,
    default: () => Strike,
    inputRegex: () => inputRegex2,
    pasteRegex: () => pasteRegex2
  });
  var inputRegex2, pasteRegex2, Strike;
  var init_dist36 = __esm({
    "node_modules/@tiptap/extension-strike/dist/index.js"() {
      init_dist16();
      inputRegex2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
      pasteRegex2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
      Strike = Mark2.create({
        name: "strike",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        parseHTML() {
          return [
            {
              tag: "s"
            },
            {
              tag: "del"
            },
            {
              tag: "strike"
            },
            {
              style: "text-decoration",
              consuming: false,
              getAttrs: (style2) => style2.includes("line-through") ? {} : false
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setStrike: () => ({ commands: commands2 }) => {
              return commands2.setMark(this.name);
            },
            toggleStrike: () => ({ commands: commands2 }) => {
              return commands2.toggleMark(this.name);
            },
            unsetStrike: () => ({ commands: commands2 }) => {
              return commands2.unsetMark(this.name);
            }
          };
        },
        addKeyboardShortcuts() {
          const shortcuts = {};
          if (isMacOS()) {
            shortcuts["Mod-Shift-s"] = () => this.editor.commands.toggleStrike();
          } else {
            shortcuts["Ctrl-Shift-s"] = () => this.editor.commands.toggleStrike();
          }
          return shortcuts;
        },
        addInputRules() {
          return [
            markInputRule({
              find: inputRegex2,
              type: this.type
            })
          ];
        },
        addPasteRules() {
          return [
            markPasteRule({
              find: pasteRegex2,
              type: this.type
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-underline/dist/index.js
  var dist_exports15 = {};
  __export(dist_exports15, {
    Underline: () => Underline,
    default: () => Underline
  });
  var Underline;
  var init_dist37 = __esm({
    "node_modules/@tiptap/extension-underline/dist/index.js"() {
      init_dist16();
      Underline = Mark2.create({
        name: "underline",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        parseHTML() {
          return [
            {
              tag: "u"
            },
            {
              style: "text-decoration",
              consuming: false,
              getAttrs: (style2) => style2.includes("underline") ? {} : false
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setUnderline: () => ({ commands: commands2 }) => {
              return commands2.setMark(this.name);
            },
            toggleUnderline: () => ({ commands: commands2 }) => {
              return commands2.toggleMark(this.name);
            },
            unsetUnderline: () => ({ commands: commands2 }) => {
              return commands2.unsetMark(this.name);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-u": () => this.editor.commands.toggleUnderline(),
            "Mod-U": () => this.editor.commands.toggleUnderline()
          };
        }
      });
    }
  });

  // node_modules/prosemirror-tables/dist/index.js
  function computeMap(table) {
    if (table.type.spec.tableRole != "table")
      throw new RangeError("Not a table node: " + table.type.name);
    const width = findWidth(table), height = table.childCount;
    const map4 = [];
    let mapPos = 0;
    let problems = null;
    const colWidths = [];
    for (let i = 0, e = width * height; i < e; i++)
      map4[i] = 0;
    for (let row = 0, pos = 0; row < height; row++) {
      const rowNode = table.child(row);
      pos++;
      for (let i = 0; ; i++) {
        while (mapPos < map4.length && map4[mapPos] != 0)
          mapPos++;
        if (i == rowNode.childCount)
          break;
        const cellNode = rowNode.child(i);
        const { colspan, rowspan, colwidth } = cellNode.attrs;
        for (let h = 0; h < rowspan; h++) {
          if (h + row >= height) {
            (problems || (problems = [])).push({
              type: "overlong_rowspan",
              pos,
              n: rowspan - h
            });
            break;
          }
          const start3 = mapPos + h * width;
          for (let w = 0; w < colspan; w++) {
            if (map4[start3 + w] == 0)
              map4[start3 + w] = pos;
            else
              (problems || (problems = [])).push({
                type: "collision",
                row,
                pos,
                n: colspan - w
              });
            const colW = colwidth && colwidth[w];
            if (colW) {
              const widthIndex = (start3 + w) % width * 2, prev = colWidths[widthIndex];
              if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
                colWidths[widthIndex] = colW;
                colWidths[widthIndex + 1] = 1;
              } else if (prev == colW) {
                colWidths[widthIndex + 1]++;
              }
            }
          }
        }
        mapPos += colspan;
        pos += cellNode.nodeSize;
      }
      const expectedPos = (row + 1) * width;
      let missing = 0;
      while (mapPos < expectedPos)
        if (map4[mapPos++] == 0)
          missing++;
      if (missing)
        (problems || (problems = [])).push({ type: "missing", row, n: missing });
      pos++;
    }
    const tableMap = new TableMap(width, height, map4, problems);
    let badWidths = false;
    for (let i = 0; !badWidths && i < colWidths.length; i += 2)
      if (colWidths[i] != null && colWidths[i + 1] < height)
        badWidths = true;
    if (badWidths)
      findBadColWidths(tableMap, colWidths, table);
    return tableMap;
  }
  function findWidth(table) {
    let width = -1;
    let hasRowSpan = false;
    for (let row = 0; row < table.childCount; row++) {
      const rowNode = table.child(row);
      let rowWidth = 0;
      if (hasRowSpan)
        for (let j = 0; j < row; j++) {
          const prevRow = table.child(j);
          for (let i = 0; i < prevRow.childCount; i++) {
            const cell = prevRow.child(i);
            if (j + cell.attrs.rowspan > row)
              rowWidth += cell.attrs.colspan;
          }
        }
      for (let i = 0; i < rowNode.childCount; i++) {
        const cell = rowNode.child(i);
        rowWidth += cell.attrs.colspan;
        if (cell.attrs.rowspan > 1)
          hasRowSpan = true;
      }
      if (width == -1)
        width = rowWidth;
      else if (width != rowWidth)
        width = Math.max(width, rowWidth);
    }
    return width;
  }
  function findBadColWidths(map4, colWidths, table) {
    if (!map4.problems)
      map4.problems = [];
    const seen = {};
    for (let i = 0; i < map4.map.length; i++) {
      const pos = map4.map[i];
      if (seen[pos])
        continue;
      seen[pos] = true;
      const node = table.nodeAt(pos);
      if (!node) {
        throw new RangeError(`No cell with offset ${pos} found`);
      }
      let updated = null;
      const attrs = node.attrs;
      for (let j = 0; j < attrs.colspan; j++) {
        const col = (i + j) % map4.width;
        const colWidth = colWidths[col * 2];
        if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))
          (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
      }
      if (updated)
        map4.problems.unshift({
          type: "colwidth mismatch",
          pos,
          colwidth: updated
        });
    }
  }
  function freshColWidth(attrs) {
    if (attrs.colwidth)
      return attrs.colwidth.slice();
    const result = [];
    for (let i = 0; i < attrs.colspan; i++)
      result.push(0);
    return result;
  }
  function tableNodeTypes(schema) {
    let result = schema.cached.tableNodeTypes;
    if (!result) {
      result = schema.cached.tableNodeTypes = {};
      for (const name in schema.nodes) {
        const type = schema.nodes[name], role = type.spec.tableRole;
        if (role)
          result[role] = type;
      }
    }
    return result;
  }
  function cellAround($pos) {
    for (let d = $pos.depth - 1; d > 0; d--)
      if ($pos.node(d).type.spec.tableRole == "row")
        return $pos.node(0).resolve($pos.before(d + 1));
    return null;
  }
  function cellWrapping($pos) {
    for (let d = $pos.depth; d > 0; d--) {
      const role = $pos.node(d).type.spec.tableRole;
      if (role === "cell" || role === "header_cell")
        return $pos.node(d);
    }
    return null;
  }
  function isInTable(state) {
    const $head = state.selection.$head;
    for (let d = $head.depth; d > 0; d--)
      if ($head.node(d).type.spec.tableRole == "row")
        return true;
    return false;
  }
  function selectionCell(state) {
    const sel = state.selection;
    if ("$anchorCell" in sel && sel.$anchorCell) {
      return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
    } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
      return sel.$anchor;
    }
    const $cell = cellAround(sel.$head) || cellNear(sel.$head);
    if ($cell) {
      return $cell;
    }
    throw new RangeError(`No cell found around position ${sel.head}`);
  }
  function cellNear($pos) {
    for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
      const role = after.type.spec.tableRole;
      if (role == "cell" || role == "header_cell")
        return $pos.doc.resolve(pos);
    }
    for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
      const role = before.type.spec.tableRole;
      if (role == "cell" || role == "header_cell")
        return $pos.doc.resolve(pos - before.nodeSize);
    }
  }
  function pointsAtCell($pos) {
    return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
  }
  function moveCellForward($pos) {
    return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
  }
  function inSameTable($cellA, $cellB) {
    return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
  }
  function nextCell($pos, axis, dir) {
    const table = $pos.node(-1);
    const map4 = TableMap.get(table);
    const tableStart = $pos.start(-1);
    const moved2 = map4.nextCell($pos.pos - tableStart, axis, dir);
    return moved2 == null ? null : $pos.node(0).resolve(tableStart + moved2);
  }
  function removeColSpan(attrs, pos, n = 1) {
    const result = { ...attrs, colspan: attrs.colspan - n };
    if (result.colwidth) {
      result.colwidth = result.colwidth.slice();
      result.colwidth.splice(pos, n);
      if (!result.colwidth.some((w) => w > 0))
        result.colwidth = null;
    }
    return result;
  }
  function addColSpan(attrs, pos, n = 1) {
    const result = { ...attrs, colspan: attrs.colspan + n };
    if (result.colwidth) {
      result.colwidth = result.colwidth.slice();
      for (let i = 0; i < n; i++)
        result.colwidth.splice(pos, 0, 0);
    }
    return result;
  }
  function columnIsHeader(map4, table, col) {
    const headerCell = tableNodeTypes(table.type.schema).header_cell;
    for (let row = 0; row < map4.height; row++)
      if (table.nodeAt(map4.map[col + row * map4.width]).type != headerCell)
        return false;
    return true;
  }
  function drawCellSelection(state) {
    if (!(state.selection instanceof CellSelection))
      return null;
    const cells = [];
    state.selection.forEachCell((node, pos) => {
      cells.push(
        Decoration.node(pos, pos + node.nodeSize, { class: "selectedCell" })
      );
    });
    return DecorationSet.create(state.doc, cells);
  }
  function isCellBoundarySelection({ $from, $to }) {
    if ($from.pos == $to.pos || $from.pos < $from.pos - 6)
      return false;
    let afterFrom = $from.pos;
    let beforeTo = $to.pos;
    let depth = $from.depth;
    for (; depth >= 0; depth--, afterFrom++)
      if ($from.after(depth + 1) < $from.end(depth))
        break;
    for (let d = $to.depth; d >= 0; d--, beforeTo--)
      if ($to.before(d + 1) > $to.start(d))
        break;
    return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
  }
  function isTextSelectionAcrossCells({ $from, $to }) {
    let fromCellBoundaryNode;
    let toCellBoundaryNode;
    for (let i = $from.depth; i > 0; i--) {
      const node = $from.node(i);
      if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
        fromCellBoundaryNode = node;
        break;
      }
    }
    for (let i = $to.depth; i > 0; i--) {
      const node = $to.node(i);
      if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
        toCellBoundaryNode = node;
        break;
      }
    }
    return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
  }
  function normalizeSelection(state, tr2, allowTableNodeSelection) {
    const sel = (tr2 || state).selection;
    const doc3 = (tr2 || state).doc;
    let normalize2;
    let role;
    if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
      if (role == "cell" || role == "header_cell") {
        normalize2 = CellSelection.create(doc3, sel.from);
      } else if (role == "row") {
        const $cell = doc3.resolve(sel.from + 1);
        normalize2 = CellSelection.rowSelection($cell, $cell);
      } else if (!allowTableNodeSelection) {
        const map4 = TableMap.get(sel.node);
        const start3 = sel.from + 1;
        const lastCell = start3 + map4.map[map4.width * map4.height - 1];
        normalize2 = CellSelection.create(doc3, start3 + 1, lastCell);
      }
    } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
      normalize2 = TextSelection.create(doc3, sel.from);
    } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
      normalize2 = TextSelection.create(doc3, sel.$from.start(), sel.$from.end());
    }
    if (normalize2)
      (tr2 || (tr2 = state.tr)).setSelection(normalize2);
    return tr2;
  }
  function changedDescendants(old, cur, offset2, f) {
    const oldSize = old.childCount, curSize = cur.childCount;
    outer:
      for (let i = 0, j = 0; i < curSize; i++) {
        const child = cur.child(i);
        for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
          if (old.child(scan) == child) {
            j = scan + 1;
            offset2 += child.nodeSize;
            continue outer;
          }
        }
        f(child, offset2);
        if (j < oldSize && old.child(j).sameMarkup(child))
          changedDescendants(old.child(j), child, offset2 + 1, f);
        else
          child.nodesBetween(0, child.content.size, f, offset2 + 1);
        offset2 += child.nodeSize;
      }
  }
  function fixTables(state, oldState) {
    let tr2;
    const check = (node, pos) => {
      if (node.type.spec.tableRole == "table")
        tr2 = fixTable(state, node, pos, tr2);
    };
    if (!oldState)
      state.doc.descendants(check);
    else if (oldState.doc != state.doc)
      changedDescendants(oldState.doc, state.doc, 0, check);
    return tr2;
  }
  function fixTable(state, table, tablePos, tr2) {
    const map4 = TableMap.get(table);
    if (!map4.problems)
      return tr2;
    if (!tr2)
      tr2 = state.tr;
    const mustAdd = [];
    for (let i = 0; i < map4.height; i++)
      mustAdd.push(0);
    for (let i = 0; i < map4.problems.length; i++) {
      const prob = map4.problems[i];
      if (prob.type == "collision") {
        const cell = table.nodeAt(prob.pos);
        if (!cell)
          continue;
        const attrs = cell.attrs;
        for (let j = 0; j < attrs.rowspan; j++)
          mustAdd[prob.row + j] += prob.n;
        tr2.setNodeMarkup(
          tr2.mapping.map(tablePos + 1 + prob.pos),
          null,
          removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
        );
      } else if (prob.type == "missing") {
        mustAdd[prob.row] += prob.n;
      } else if (prob.type == "overlong_rowspan") {
        const cell = table.nodeAt(prob.pos);
        if (!cell)
          continue;
        tr2.setNodeMarkup(tr2.mapping.map(tablePos + 1 + prob.pos), null, {
          ...cell.attrs,
          rowspan: cell.attrs.rowspan - prob.n
        });
      } else if (prob.type == "colwidth mismatch") {
        const cell = table.nodeAt(prob.pos);
        if (!cell)
          continue;
        tr2.setNodeMarkup(tr2.mapping.map(tablePos + 1 + prob.pos), null, {
          ...cell.attrs,
          colwidth: prob.colwidth
        });
      }
    }
    let first2, last;
    for (let i = 0; i < mustAdd.length; i++)
      if (mustAdd[i]) {
        if (first2 == null)
          first2 = i;
        last = i;
      }
    for (let i = 0, pos = tablePos + 1; i < map4.height; i++) {
      const row = table.child(i);
      const end2 = pos + row.nodeSize;
      const add2 = mustAdd[i];
      if (add2 > 0) {
        let role = "cell";
        if (row.firstChild) {
          role = row.firstChild.type.spec.tableRole;
        }
        const nodes = [];
        for (let j = 0; j < add2; j++) {
          const node = tableNodeTypes(state.schema)[role].createAndFill();
          if (node)
            nodes.push(node);
        }
        const side = (i == 0 || first2 == i - 1) && last == i ? pos + 1 : end2 - 1;
        tr2.insert(tr2.mapping.map(side), nodes);
      }
      pos = end2;
    }
    return tr2.setMeta(fixTablesKey, { fixTables: true });
  }
  function pastedCells(slice2) {
    if (!slice2.size)
      return null;
    let { content, openStart, openEnd } = slice2;
    while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == "table")) {
      openStart--;
      openEnd--;
      content = content.child(0).content;
    }
    const first2 = content.child(0);
    const role = first2.type.spec.tableRole;
    const schema = first2.type.schema, rows = [];
    if (role == "row") {
      for (let i = 0; i < content.childCount; i++) {
        let cells = content.child(i).content;
        const left2 = i ? 0 : Math.max(0, openStart - 1);
        const right2 = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
        if (left2 || right2)
          cells = fitSlice(
            tableNodeTypes(schema).row,
            new Slice(cells, left2, right2)
          ).content;
        rows.push(cells);
      }
    } else if (role == "cell" || role == "header_cell") {
      rows.push(
        openStart || openEnd ? fitSlice(
          tableNodeTypes(schema).row,
          new Slice(content, openStart, openEnd)
        ).content : content
      );
    } else {
      return null;
    }
    return ensureRectangular(schema, rows);
  }
  function ensureRectangular(schema, rows) {
    const widths = [];
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      for (let j = row.childCount - 1; j >= 0; j--) {
        const { rowspan, colspan } = row.child(j).attrs;
        for (let r = i; r < i + rowspan; r++)
          widths[r] = (widths[r] || 0) + colspan;
      }
    }
    let width = 0;
    for (let r = 0; r < widths.length; r++)
      width = Math.max(width, widths[r]);
    for (let r = 0; r < widths.length; r++) {
      if (r >= rows.length)
        rows.push(Fragment.empty);
      if (widths[r] < width) {
        const empty2 = tableNodeTypes(schema).cell.createAndFill();
        const cells = [];
        for (let i = widths[r]; i < width; i++) {
          cells.push(empty2);
        }
        rows[r] = rows[r].append(Fragment.from(cells));
      }
    }
    return { height: rows.length, width, rows };
  }
  function fitSlice(nodeType, slice2) {
    const node = nodeType.createAndFill();
    const tr2 = new Transform(node).replace(0, node.content.size, slice2);
    return tr2.doc;
  }
  function clipCells({ width, height, rows }, newWidth, newHeight) {
    if (width != newWidth) {
      const added = [];
      const newRows = [];
      for (let row = 0; row < rows.length; row++) {
        const frag = rows[row], cells = [];
        for (let col = added[row] || 0, i = 0; col < newWidth; i++) {
          let cell = frag.child(i % frag.childCount);
          if (col + cell.attrs.colspan > newWidth)
            cell = cell.type.createChecked(
              removeColSpan(
                cell.attrs,
                cell.attrs.colspan,
                col + cell.attrs.colspan - newWidth
              ),
              cell.content
            );
          cells.push(cell);
          col += cell.attrs.colspan;
          for (let j = 1; j < cell.attrs.rowspan; j++)
            added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
        }
        newRows.push(Fragment.from(cells));
      }
      rows = newRows;
      width = newWidth;
    }
    if (height != newHeight) {
      const newRows = [];
      for (let row = 0, i = 0; row < newHeight; row++, i++) {
        const cells = [], source2 = rows[i % height];
        for (let j = 0; j < source2.childCount; j++) {
          let cell = source2.child(j);
          if (row + cell.attrs.rowspan > newHeight)
            cell = cell.type.create(
              {
                ...cell.attrs,
                rowspan: Math.max(1, newHeight - cell.attrs.rowspan)
              },
              cell.content
            );
          cells.push(cell);
        }
        newRows.push(Fragment.from(cells));
      }
      rows = newRows;
      height = newHeight;
    }
    return { width, height, rows };
  }
  function growTable(tr2, map4, table, start3, width, height, mapFrom) {
    const schema = tr2.doc.type.schema;
    const types = tableNodeTypes(schema);
    let empty2;
    let emptyHead;
    if (width > map4.width) {
      for (let row = 0, rowEnd = 0; row < map4.height; row++) {
        const rowNode = table.child(row);
        rowEnd += rowNode.nodeSize;
        const cells = [];
        let add2;
        if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
          add2 = empty2 || (empty2 = types.cell.createAndFill());
        else
          add2 = emptyHead || (emptyHead = types.header_cell.createAndFill());
        for (let i = map4.width; i < width; i++)
          cells.push(add2);
        tr2.insert(tr2.mapping.slice(mapFrom).map(rowEnd - 1 + start3), cells);
      }
    }
    if (height > map4.height) {
      const cells = [];
      for (let i = 0, start22 = (map4.height - 1) * map4.width; i < Math.max(map4.width, width); i++) {
        const header = i >= map4.width ? false : table.nodeAt(map4.map[start22 + i]).type == types.header_cell;
        cells.push(
          header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill())
        );
      }
      const emptyRow = types.row.create(null, Fragment.from(cells)), rows = [];
      for (let i = map4.height; i < height; i++)
        rows.push(emptyRow);
      tr2.insert(tr2.mapping.slice(mapFrom).map(start3 + table.nodeSize - 2), rows);
    }
    return !!(empty2 || emptyHead);
  }
  function isolateHorizontal(tr2, map4, table, start3, left2, right2, top2, mapFrom) {
    if (top2 == 0 || top2 == map4.height)
      return false;
    let found2 = false;
    for (let col = left2; col < right2; col++) {
      const index3 = top2 * map4.width + col, pos = map4.map[index3];
      if (map4.map[index3 - map4.width] == pos) {
        found2 = true;
        const cell = table.nodeAt(pos);
        const { top: cellTop, left: cellLeft } = map4.findCell(pos);
        tr2.setNodeMarkup(tr2.mapping.slice(mapFrom).map(pos + start3), null, {
          ...cell.attrs,
          rowspan: top2 - cellTop
        });
        tr2.insert(
          tr2.mapping.slice(mapFrom).map(map4.positionAt(top2, cellLeft, table)),
          cell.type.createAndFill({
            ...cell.attrs,
            rowspan: cellTop + cell.attrs.rowspan - top2
          })
        );
        col += cell.attrs.colspan - 1;
      }
    }
    return found2;
  }
  function isolateVertical(tr2, map4, table, start3, top2, bottom2, left2, mapFrom) {
    if (left2 == 0 || left2 == map4.width)
      return false;
    let found2 = false;
    for (let row = top2; row < bottom2; row++) {
      const index3 = row * map4.width + left2, pos = map4.map[index3];
      if (map4.map[index3 - 1] == pos) {
        found2 = true;
        const cell = table.nodeAt(pos);
        const cellLeft = map4.colCount(pos);
        const updatePos = tr2.mapping.slice(mapFrom).map(pos + start3);
        tr2.setNodeMarkup(
          updatePos,
          null,
          removeColSpan(
            cell.attrs,
            left2 - cellLeft,
            cell.attrs.colspan - (left2 - cellLeft)
          )
        );
        tr2.insert(
          updatePos + cell.nodeSize,
          cell.type.createAndFill(
            removeColSpan(cell.attrs, 0, left2 - cellLeft)
          )
        );
        row += cell.attrs.rowspan - 1;
      }
    }
    return found2;
  }
  function insertCells(state, dispatch2, tableStart, rect, cells) {
    let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
    if (!table) {
      throw new Error("No table found");
    }
    let map4 = TableMap.get(table);
    const { top: top2, left: left2 } = rect;
    const right2 = left2 + cells.width, bottom2 = top2 + cells.height;
    const tr2 = state.tr;
    let mapFrom = 0;
    function recomp() {
      table = tableStart ? tr2.doc.nodeAt(tableStart - 1) : tr2.doc;
      if (!table) {
        throw new Error("No table found");
      }
      map4 = TableMap.get(table);
      mapFrom = tr2.mapping.maps.length;
    }
    if (growTable(tr2, map4, table, tableStart, right2, bottom2, mapFrom))
      recomp();
    if (isolateHorizontal(tr2, map4, table, tableStart, left2, right2, top2, mapFrom))
      recomp();
    if (isolateHorizontal(tr2, map4, table, tableStart, left2, right2, bottom2, mapFrom))
      recomp();
    if (isolateVertical(tr2, map4, table, tableStart, top2, bottom2, left2, mapFrom))
      recomp();
    if (isolateVertical(tr2, map4, table, tableStart, top2, bottom2, right2, mapFrom))
      recomp();
    for (let row = top2; row < bottom2; row++) {
      const from3 = map4.positionAt(row, left2, table), to2 = map4.positionAt(row, right2, table);
      tr2.replace(
        tr2.mapping.slice(mapFrom).map(from3 + tableStart),
        tr2.mapping.slice(mapFrom).map(to2 + tableStart),
        new Slice(cells.rows[row - top2], 0, 0)
      );
    }
    recomp();
    tr2.setSelection(
      new CellSelection(
        tr2.doc.resolve(tableStart + map4.positionAt(top2, left2, table)),
        tr2.doc.resolve(tableStart + map4.positionAt(bottom2 - 1, right2 - 1, table))
      )
    );
    dispatch2(tr2);
  }
  function maybeSetSelection(state, dispatch2, selection) {
    if (selection.eq(state.selection))
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(selection).scrollIntoView());
    return true;
  }
  function arrow3(axis, dir) {
    return (state, dispatch2, view) => {
      if (!view)
        return false;
      const sel = state.selection;
      if (sel instanceof CellSelection) {
        return maybeSetSelection(
          state,
          dispatch2,
          Selection.near(sel.$headCell, dir)
        );
      }
      if (axis != "horiz" && !sel.empty)
        return false;
      const end2 = atEndOfCell(view, axis, dir);
      if (end2 == null)
        return false;
      if (axis == "horiz") {
        return maybeSetSelection(
          state,
          dispatch2,
          Selection.near(state.doc.resolve(sel.head + dir), dir)
        );
      } else {
        const $cell = state.doc.resolve(end2);
        const $next = nextCell($cell, axis, dir);
        let newSel;
        if ($next)
          newSel = Selection.near($next, 1);
        else if (dir < 0)
          newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
        else
          newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
        return maybeSetSelection(state, dispatch2, newSel);
      }
    };
  }
  function shiftArrow(axis, dir) {
    return (state, dispatch2, view) => {
      if (!view)
        return false;
      const sel = state.selection;
      let cellSel;
      if (sel instanceof CellSelection) {
        cellSel = sel;
      } else {
        const end2 = atEndOfCell(view, axis, dir);
        if (end2 == null)
          return false;
        cellSel = new CellSelection(state.doc.resolve(end2));
      }
      const $head = nextCell(cellSel.$headCell, axis, dir);
      if (!$head)
        return false;
      return maybeSetSelection(
        state,
        dispatch2,
        new CellSelection(cellSel.$anchorCell, $head)
      );
    };
  }
  function deleteCellSelection(state, dispatch2) {
    const sel = state.selection;
    if (!(sel instanceof CellSelection))
      return false;
    if (dispatch2) {
      const tr2 = state.tr;
      const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
      sel.forEachCell((cell, pos) => {
        if (!cell.content.eq(baseContent))
          tr2.replace(
            tr2.mapping.map(pos + 1),
            tr2.mapping.map(pos + cell.nodeSize - 1),
            new Slice(baseContent, 0, 0)
          );
      });
      if (tr2.docChanged)
        dispatch2(tr2);
    }
    return true;
  }
  function handleTripleClick2(view, pos) {
    const doc3 = view.state.doc, $cell = cellAround(doc3.resolve(pos));
    if (!$cell)
      return false;
    view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
    return true;
  }
  function handlePaste(view, _, slice2) {
    if (!isInTable(view.state))
      return false;
    let cells = pastedCells(slice2);
    const sel = view.state.selection;
    if (sel instanceof CellSelection) {
      if (!cells)
        cells = {
          width: 1,
          height: 1,
          rows: [
            Fragment.from(
              fitSlice(tableNodeTypes(view.state.schema).cell, slice2)
            )
          ]
        };
      const table = sel.$anchorCell.node(-1);
      const start3 = sel.$anchorCell.start(-1);
      const rect = TableMap.get(table).rectBetween(
        sel.$anchorCell.pos - start3,
        sel.$headCell.pos - start3
      );
      cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
      insertCells(view.state, view.dispatch, start3, rect, cells);
      return true;
    } else if (cells) {
      const $cell = selectionCell(view.state);
      const start3 = $cell.start(-1);
      insertCells(
        view.state,
        view.dispatch,
        start3,
        TableMap.get($cell.node(-1)).findCell($cell.pos - start3),
        cells
      );
      return true;
    } else {
      return false;
    }
  }
  function handleMouseDown(view, startEvent) {
    var _a;
    if (startEvent.ctrlKey || startEvent.metaKey)
      return;
    const startDOMCell = domInCell(view, startEvent.target);
    let $anchor;
    if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
      setCellSelection(view.state.selection.$anchorCell, startEvent);
      startEvent.preventDefault();
    } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {
      setCellSelection($anchor, startEvent);
      startEvent.preventDefault();
    } else if (!startDOMCell) {
      return;
    }
    function setCellSelection($anchor2, event) {
      let $head = cellUnderMouse(view, event);
      const starting = tableEditingKey.getState(view.state) == null;
      if (!$head || !inSameTable($anchor2, $head)) {
        if (starting)
          $head = $anchor2;
        else
          return;
      }
      const selection = new CellSelection($anchor2, $head);
      if (starting || !view.state.selection.eq(selection)) {
        const tr2 = view.state.tr.setSelection(selection);
        if (starting)
          tr2.setMeta(tableEditingKey, $anchor2.pos);
        view.dispatch(tr2);
      }
    }
    function stop() {
      view.root.removeEventListener("mouseup", stop);
      view.root.removeEventListener("dragstart", stop);
      view.root.removeEventListener("mousemove", move);
      if (tableEditingKey.getState(view.state) != null)
        view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
    }
    function move(_event) {
      const event = _event;
      const anchor = tableEditingKey.getState(view.state);
      let $anchor2;
      if (anchor != null) {
        $anchor2 = view.state.doc.resolve(anchor);
      } else if (domInCell(view, event.target) != startDOMCell) {
        $anchor2 = cellUnderMouse(view, startEvent);
        if (!$anchor2)
          return stop();
      }
      if ($anchor2)
        setCellSelection($anchor2, event);
    }
    view.root.addEventListener("mouseup", stop);
    view.root.addEventListener("dragstart", stop);
    view.root.addEventListener("mousemove", move);
  }
  function atEndOfCell(view, axis, dir) {
    if (!(view.state.selection instanceof TextSelection))
      return null;
    const { $head } = view.state.selection;
    for (let d = $head.depth - 1; d >= 0; d--) {
      const parent = $head.node(d), index3 = dir < 0 ? $head.index(d) : $head.indexAfter(d);
      if (index3 != (dir < 0 ? 0 : parent.childCount))
        return null;
      if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
        const cellPos = $head.before(d);
        const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
        return view.endOfTextblock(dirStr) ? cellPos : null;
      }
    }
    return null;
  }
  function domInCell(view, dom) {
    for (; dom && dom != view.dom; dom = dom.parentNode) {
      if (dom.nodeName == "TD" || dom.nodeName == "TH") {
        return dom;
      }
    }
    return null;
  }
  function cellUnderMouse(view, event) {
    const mousePos = view.posAtCoords({
      left: event.clientX,
      top: event.clientY
    });
    if (!mousePos)
      return null;
    return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
  }
  function updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
    var _a;
    let totalWidth = 0;
    let fixedWidth = true;
    let nextDOM = colgroup.firstChild;
    const row = node.firstChild;
    if (!row)
      return;
    for (let i = 0, col = 0; i < row.childCount; i++) {
      const { colspan, colwidth } = row.child(i).attrs;
      for (let j = 0; j < colspan; j++, col++) {
        const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? hasWidth + "px" : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth)
          fixedWidth = false;
        if (!nextDOM) {
          colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
        } else {
          if (nextDOM.style.width != cssWidth)
            nextDOM.style.width = cssWidth;
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
    while (nextDOM) {
      const after = nextDOM.nextSibling;
      (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
      nextDOM = after;
    }
    if (fixedWidth) {
      table.style.width = totalWidth + "px";
      table.style.minWidth = "";
    } else {
      table.style.width = "";
      table.style.minWidth = totalWidth + "px";
    }
  }
  function columnResizing({
    handleWidth = 5,
    cellMinWidth = 25,
    View: View2 = TableView,
    lastColumnResizable = true
  } = {}) {
    const plugin = new Plugin({
      key: columnResizingPluginKey,
      state: {
        init(_, state) {
          plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View2(node, cellMinWidth, view);
          return new ResizeState(-1, false);
        },
        apply(tr2, prev) {
          return prev.apply(tr2);
        }
      },
      props: {
        attributes: (state) => {
          const pluginState = columnResizingPluginKey.getState(state);
          return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
        },
        handleDOMEvents: {
          mousemove: (view, event) => {
            handleMouseMove(
              view,
              event,
              handleWidth,
              cellMinWidth,
              lastColumnResizable
            );
          },
          mouseleave: (view) => {
            handleMouseLeave(view);
          },
          mousedown: (view, event) => {
            handleMouseDown2(view, event, cellMinWidth);
          }
        },
        decorations: (state) => {
          const pluginState = columnResizingPluginKey.getState(state);
          if (pluginState && pluginState.activeHandle > -1) {
            return handleDecorations(state, pluginState.activeHandle);
          }
        },
        nodeViews: {}
      }
    });
    return plugin;
  }
  function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (!pluginState)
      return;
    if (!pluginState.dragging) {
      const target = domCellAround(event.target);
      let cell = -1;
      if (target) {
        const { left: left2, right: right2 } = target.getBoundingClientRect();
        if (event.clientX - left2 <= handleWidth)
          cell = edgeCell(view, event, "left", handleWidth);
        else if (right2 - event.clientX <= handleWidth)
          cell = edgeCell(view, event, "right", handleWidth);
      }
      if (cell != pluginState.activeHandle) {
        if (!lastColumnResizable && cell !== -1) {
          const $cell = view.state.doc.resolve(cell);
          const table = $cell.node(-1);
          const map4 = TableMap.get(table);
          const tableStart = $cell.start(-1);
          const col = map4.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
          if (col == map4.width - 1) {
            return;
          }
        }
        updateHandle(view, cell);
      }
    }
  }
  function handleMouseLeave(view) {
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
      updateHandle(view, -1);
  }
  function handleMouseDown2(view, event, cellMinWidth) {
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
      return false;
    const cell = view.state.doc.nodeAt(pluginState.activeHandle);
    const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
    view.dispatch(
      view.state.tr.setMeta(columnResizingPluginKey, {
        setDragging: { startX: event.clientX, startWidth: width }
      })
    );
    function finish(event2) {
      window.removeEventListener("mouseup", finish);
      window.removeEventListener("mousemove", move);
      const pluginState2 = columnResizingPluginKey.getState(view.state);
      if (pluginState2 == null ? void 0 : pluginState2.dragging) {
        updateColumnWidth(
          view,
          pluginState2.activeHandle,
          draggedWidth(pluginState2.dragging, event2, cellMinWidth)
        );
        view.dispatch(
          view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
        );
      }
    }
    function move(event2) {
      if (!event2.which)
        return finish(event2);
      const pluginState2 = columnResizingPluginKey.getState(view.state);
      if (!pluginState2)
        return;
      if (pluginState2.dragging) {
        const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
        displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);
      }
    }
    window.addEventListener("mouseup", finish);
    window.addEventListener("mousemove", move);
    event.preventDefault();
    return true;
  }
  function currentColWidth(view, cellPos, { colspan, colwidth }) {
    const width = colwidth && colwidth[colwidth.length - 1];
    if (width)
      return width;
    const dom = view.domAtPos(cellPos);
    const node = dom.node.childNodes[dom.offset];
    let domWidth = node.offsetWidth, parts = colspan;
    if (colwidth) {
      for (let i = 0; i < colspan; i++)
        if (colwidth[i]) {
          domWidth -= colwidth[i];
          parts--;
        }
    }
    return domWidth / parts;
  }
  function domCellAround(target) {
    while (target && target.nodeName != "TD" && target.nodeName != "TH")
      target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
    return target;
  }
  function edgeCell(view, event, side, handleWidth) {
    const offset2 = side == "right" ? -handleWidth : handleWidth;
    const found2 = view.posAtCoords({
      left: event.clientX + offset2,
      top: event.clientY
    });
    if (!found2)
      return -1;
    const { pos } = found2;
    const $cell = cellAround(view.state.doc.resolve(pos));
    if (!$cell)
      return -1;
    if (side == "right")
      return $cell.pos;
    const map4 = TableMap.get($cell.node(-1)), start3 = $cell.start(-1);
    const index3 = map4.map.indexOf($cell.pos - start3);
    return index3 % map4.width == 0 ? -1 : start3 + map4.map[index3 - 1];
  }
  function draggedWidth(dragging, event, cellMinWidth) {
    const offset2 = event.clientX - dragging.startX;
    return Math.max(cellMinWidth, dragging.startWidth + offset2);
  }
  function updateHandle(view, value) {
    view.dispatch(
      view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
    );
  }
  function updateColumnWidth(view, cell, width) {
    const $cell = view.state.doc.resolve(cell);
    const table = $cell.node(-1), map4 = TableMap.get(table), start3 = $cell.start(-1);
    const col = map4.colCount($cell.pos - start3) + $cell.nodeAfter.attrs.colspan - 1;
    const tr2 = view.state.tr;
    for (let row = 0; row < map4.height; row++) {
      const mapIndex = row * map4.width + col;
      if (row && map4.map[mapIndex] == map4.map[mapIndex - map4.width])
        continue;
      const pos = map4.map[mapIndex];
      const attrs = table.nodeAt(pos).attrs;
      const index3 = attrs.colspan == 1 ? 0 : col - map4.colCount(pos);
      if (attrs.colwidth && attrs.colwidth[index3] == width)
        continue;
      const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
      colwidth[index3] = width;
      tr2.setNodeMarkup(start3 + pos, null, { ...attrs, colwidth });
    }
    if (tr2.docChanged)
      view.dispatch(tr2);
  }
  function displayColumnWidth(view, cell, width, cellMinWidth) {
    const $cell = view.state.doc.resolve(cell);
    const table = $cell.node(-1), start3 = $cell.start(-1);
    const col = TableMap.get(table).colCount($cell.pos - start3) + $cell.nodeAfter.attrs.colspan - 1;
    let dom = view.domAtPos($cell.start(-1)).node;
    while (dom && dom.nodeName != "TABLE") {
      dom = dom.parentNode;
    }
    if (!dom)
      return;
    updateColumnsOnResize(
      table,
      dom.firstChild,
      dom,
      cellMinWidth,
      col,
      width
    );
  }
  function zeroes(n) {
    return Array(n).fill(0);
  }
  function handleDecorations(state, cell) {
    const decorations = [];
    const $cell = state.doc.resolve(cell);
    const table = $cell.node(-1);
    if (!table) {
      return DecorationSet.empty;
    }
    const map4 = TableMap.get(table);
    const start3 = $cell.start(-1);
    const col = map4.colCount($cell.pos - start3) + $cell.nodeAfter.attrs.colspan;
    for (let row = 0; row < map4.height; row++) {
      const index3 = col + row * map4.width - 1;
      if ((col == map4.width || map4.map[index3] != map4.map[index3 + 1]) && (row == 0 || map4.map[index3] != map4.map[index3 - map4.width])) {
        const cellPos = map4.map[index3];
        const pos = start3 + cellPos + table.nodeAt(cellPos).nodeSize - 1;
        const dom = document.createElement("div");
        dom.className = "column-resize-handle";
        decorations.push(Decoration.widget(pos, dom));
      }
    }
    return DecorationSet.create(state.doc, decorations);
  }
  function selectedRect(state) {
    const sel = state.selection;
    const $pos = selectionCell(state);
    const table = $pos.node(-1);
    const tableStart = $pos.start(-1);
    const map4 = TableMap.get(table);
    const rect = sel instanceof CellSelection ? map4.rectBetween(
      sel.$anchorCell.pos - tableStart,
      sel.$headCell.pos - tableStart
    ) : map4.findCell($pos.pos - tableStart);
    return { ...rect, tableStart, map: map4, table };
  }
  function addColumn(tr2, { map: map4, tableStart, table }, col) {
    let refColumn = col > 0 ? -1 : 0;
    if (columnIsHeader(map4, table, col + refColumn)) {
      refColumn = col == 0 || col == map4.width ? null : 0;
    }
    for (let row = 0; row < map4.height; row++) {
      const index3 = row * map4.width + col;
      if (col > 0 && col < map4.width && map4.map[index3 - 1] == map4.map[index3]) {
        const pos = map4.map[index3];
        const cell = table.nodeAt(pos);
        tr2.setNodeMarkup(
          tr2.mapping.map(tableStart + pos),
          null,
          addColSpan(cell.attrs, col - map4.colCount(pos))
        );
        row += cell.attrs.rowspan - 1;
      } else {
        const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map4.map[index3 + refColumn]).type;
        const pos = map4.positionAt(row, col, table);
        tr2.insert(tr2.mapping.map(tableStart + pos), type.createAndFill());
      }
    }
    return tr2;
  }
  function addColumnBefore(state, dispatch2) {
    if (!isInTable(state))
      return false;
    if (dispatch2) {
      const rect = selectedRect(state);
      dispatch2(addColumn(state.tr, rect, rect.left));
    }
    return true;
  }
  function addColumnAfter(state, dispatch2) {
    if (!isInTable(state))
      return false;
    if (dispatch2) {
      const rect = selectedRect(state);
      dispatch2(addColumn(state.tr, rect, rect.right));
    }
    return true;
  }
  function removeColumn(tr2, { map: map4, table, tableStart }, col) {
    const mapStart = tr2.mapping.maps.length;
    for (let row = 0; row < map4.height; ) {
      const index3 = row * map4.width + col;
      const pos = map4.map[index3];
      const cell = table.nodeAt(pos);
      const attrs = cell.attrs;
      if (col > 0 && map4.map[index3 - 1] == pos || col < map4.width - 1 && map4.map[index3 + 1] == pos) {
        tr2.setNodeMarkup(
          tr2.mapping.slice(mapStart).map(tableStart + pos),
          null,
          removeColSpan(attrs, col - map4.colCount(pos))
        );
      } else {
        const start3 = tr2.mapping.slice(mapStart).map(tableStart + pos);
        tr2.delete(start3, start3 + cell.nodeSize);
      }
      row += attrs.rowspan;
    }
  }
  function deleteColumn(state, dispatch2) {
    if (!isInTable(state))
      return false;
    if (dispatch2) {
      const rect = selectedRect(state);
      const tr2 = state.tr;
      if (rect.left == 0 && rect.right == rect.map.width)
        return false;
      for (let i = rect.right - 1; ; i--) {
        removeColumn(tr2, rect, i);
        if (i == rect.left)
          break;
        const table = rect.tableStart ? tr2.doc.nodeAt(rect.tableStart - 1) : tr2.doc;
        if (!table) {
          throw RangeError("No table found");
        }
        rect.table = table;
        rect.map = TableMap.get(table);
      }
      dispatch2(tr2);
    }
    return true;
  }
  function rowIsHeader(map4, table, row) {
    var _a;
    const headerCell = tableNodeTypes(table.type.schema).header_cell;
    for (let col = 0; col < map4.width; col++)
      if (((_a = table.nodeAt(map4.map[col + row * map4.width])) == null ? void 0 : _a.type) != headerCell)
        return false;
    return true;
  }
  function addRow(tr2, { map: map4, tableStart, table }, row) {
    var _a;
    let rowPos = tableStart;
    for (let i = 0; i < row; i++)
      rowPos += table.child(i).nodeSize;
    const cells = [];
    let refRow = row > 0 ? -1 : 0;
    if (rowIsHeader(map4, table, row + refRow))
      refRow = row == 0 || row == map4.height ? null : 0;
    for (let col = 0, index3 = map4.width * row; col < map4.width; col++, index3++) {
      if (row > 0 && row < map4.height && map4.map[index3] == map4.map[index3 - map4.width]) {
        const pos = map4.map[index3];
        const attrs = table.nodeAt(pos).attrs;
        tr2.setNodeMarkup(tableStart + pos, null, {
          ...attrs,
          rowspan: attrs.rowspan + 1
        });
        col += attrs.colspan - 1;
      } else {
        const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map4.map[index3 + refRow * map4.width])) == null ? void 0 : _a.type;
        const node = type == null ? void 0 : type.createAndFill();
        if (node)
          cells.push(node);
      }
    }
    tr2.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
    return tr2;
  }
  function addRowBefore(state, dispatch2) {
    if (!isInTable(state))
      return false;
    if (dispatch2) {
      const rect = selectedRect(state);
      dispatch2(addRow(state.tr, rect, rect.top));
    }
    return true;
  }
  function addRowAfter(state, dispatch2) {
    if (!isInTable(state))
      return false;
    if (dispatch2) {
      const rect = selectedRect(state);
      dispatch2(addRow(state.tr, rect, rect.bottom));
    }
    return true;
  }
  function removeRow(tr2, { map: map4, table, tableStart }, row) {
    let rowPos = 0;
    for (let i = 0; i < row; i++)
      rowPos += table.child(i).nodeSize;
    const nextRow = rowPos + table.child(row).nodeSize;
    const mapFrom = tr2.mapping.maps.length;
    tr2.delete(rowPos + tableStart, nextRow + tableStart);
    const seen = /* @__PURE__ */ new Set();
    for (let col = 0, index3 = row * map4.width; col < map4.width; col++, index3++) {
      const pos = map4.map[index3];
      if (seen.has(pos))
        continue;
      seen.add(pos);
      if (row > 0 && pos == map4.map[index3 - map4.width]) {
        const attrs = table.nodeAt(pos).attrs;
        tr2.setNodeMarkup(tr2.mapping.slice(mapFrom).map(pos + tableStart), null, {
          ...attrs,
          rowspan: attrs.rowspan - 1
        });
        col += attrs.colspan - 1;
      } else if (row < map4.height && pos == map4.map[index3 + map4.width]) {
        const cell = table.nodeAt(pos);
        const attrs = cell.attrs;
        const copy2 = cell.type.create(
          { ...attrs, rowspan: cell.attrs.rowspan - 1 },
          cell.content
        );
        const newPos = map4.positionAt(row + 1, col, table);
        tr2.insert(tr2.mapping.slice(mapFrom).map(tableStart + newPos), copy2);
        col += attrs.colspan - 1;
      }
    }
  }
  function deleteRow(state, dispatch2) {
    if (!isInTable(state))
      return false;
    if (dispatch2) {
      const rect = selectedRect(state), tr2 = state.tr;
      if (rect.top == 0 && rect.bottom == rect.map.height)
        return false;
      for (let i = rect.bottom - 1; ; i--) {
        removeRow(tr2, rect, i);
        if (i == rect.top)
          break;
        const table = rect.tableStart ? tr2.doc.nodeAt(rect.tableStart - 1) : tr2.doc;
        if (!table) {
          throw RangeError("No table found");
        }
        rect.table = table;
        rect.map = TableMap.get(rect.table);
      }
      dispatch2(tr2);
    }
    return true;
  }
  function isEmpty(cell) {
    const c = cell.content;
    return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;
  }
  function cellsOverlapRectangle({ width, height, map: map4 }, rect) {
    let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
    let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
    for (let i = rect.top; i < rect.bottom; i++) {
      if (rect.left > 0 && map4[indexLeft] == map4[indexLeft - 1] || rect.right < width && map4[indexRight] == map4[indexRight + 1])
        return true;
      indexLeft += width;
      indexRight += width;
    }
    for (let i = rect.left; i < rect.right; i++) {
      if (rect.top > 0 && map4[indexTop] == map4[indexTop - width] || rect.bottom < height && map4[indexBottom] == map4[indexBottom + width])
        return true;
      indexTop++;
      indexBottom++;
    }
    return false;
  }
  function mergeCells(state, dispatch2) {
    const sel = state.selection;
    if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
      return false;
    const rect = selectedRect(state), { map: map4 } = rect;
    if (cellsOverlapRectangle(map4, rect))
      return false;
    if (dispatch2) {
      const tr2 = state.tr;
      const seen = {};
      let content = Fragment.empty;
      let mergedPos;
      let mergedCell;
      for (let row = rect.top; row < rect.bottom; row++) {
        for (let col = rect.left; col < rect.right; col++) {
          const cellPos = map4.map[row * map4.width + col];
          const cell = rect.table.nodeAt(cellPos);
          if (seen[cellPos] || !cell)
            continue;
          seen[cellPos] = true;
          if (mergedPos == null) {
            mergedPos = cellPos;
            mergedCell = cell;
          } else {
            if (!isEmpty(cell))
              content = content.append(cell.content);
            const mapped = tr2.mapping.map(cellPos + rect.tableStart);
            tr2.delete(mapped, mapped + cell.nodeSize);
          }
        }
      }
      if (mergedPos == null || mergedCell == null) {
        return true;
      }
      tr2.setNodeMarkup(mergedPos + rect.tableStart, null, {
        ...addColSpan(
          mergedCell.attrs,
          mergedCell.attrs.colspan,
          rect.right - rect.left - mergedCell.attrs.colspan
        ),
        rowspan: rect.bottom - rect.top
      });
      if (content.size) {
        const end2 = mergedPos + 1 + mergedCell.content.size;
        const start3 = isEmpty(mergedCell) ? mergedPos + 1 : end2;
        tr2.replaceWith(start3 + rect.tableStart, end2 + rect.tableStart, content);
      }
      tr2.setSelection(
        new CellSelection(tr2.doc.resolve(mergedPos + rect.tableStart))
      );
      dispatch2(tr2);
    }
    return true;
  }
  function splitCell(state, dispatch2) {
    const nodeTypes = tableNodeTypes(state.schema);
    return splitCellWithType(({ node }) => {
      return nodeTypes[node.type.spec.tableRole];
    })(state, dispatch2);
  }
  function splitCellWithType(getCellType) {
    return (state, dispatch2) => {
      var _a;
      const sel = state.selection;
      let cellNode;
      let cellPos;
      if (!(sel instanceof CellSelection)) {
        cellNode = cellWrapping(sel.$from);
        if (!cellNode)
          return false;
        cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;
      } else {
        if (sel.$anchorCell.pos != sel.$headCell.pos)
          return false;
        cellNode = sel.$anchorCell.nodeAfter;
        cellPos = sel.$anchorCell.pos;
      }
      if (cellNode == null || cellPos == null) {
        return false;
      }
      if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
        return false;
      }
      if (dispatch2) {
        let baseAttrs = cellNode.attrs;
        const attrs = [];
        const colwidth = baseAttrs.colwidth;
        if (baseAttrs.rowspan > 1)
          baseAttrs = { ...baseAttrs, rowspan: 1 };
        if (baseAttrs.colspan > 1)
          baseAttrs = { ...baseAttrs, colspan: 1 };
        const rect = selectedRect(state), tr2 = state.tr;
        for (let i = 0; i < rect.right - rect.left; i++)
          attrs.push(
            colwidth ? {
              ...baseAttrs,
              colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
            } : baseAttrs
          );
        let lastCell;
        for (let row = rect.top; row < rect.bottom; row++) {
          let pos = rect.map.positionAt(row, rect.left, rect.table);
          if (row == rect.top)
            pos += cellNode.nodeSize;
          for (let col = rect.left, i = 0; col < rect.right; col++, i++) {
            if (col == rect.left && row == rect.top)
              continue;
            tr2.insert(
              lastCell = tr2.mapping.map(pos + rect.tableStart, 1),
              getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])
            );
          }
        }
        tr2.setNodeMarkup(
          cellPos,
          getCellType({ node: cellNode, row: rect.top, col: rect.left }),
          attrs[0]
        );
        if (sel instanceof CellSelection)
          tr2.setSelection(
            new CellSelection(
              tr2.doc.resolve(sel.$anchorCell.pos),
              lastCell ? tr2.doc.resolve(lastCell) : void 0
            )
          );
        dispatch2(tr2);
      }
      return true;
    };
  }
  function setCellAttr(name, value) {
    return function(state, dispatch2) {
      if (!isInTable(state))
        return false;
      const $cell = selectionCell(state);
      if ($cell.nodeAfter.attrs[name] === value)
        return false;
      if (dispatch2) {
        const tr2 = state.tr;
        if (state.selection instanceof CellSelection)
          state.selection.forEachCell((node, pos) => {
            if (node.attrs[name] !== value)
              tr2.setNodeMarkup(pos, null, {
                ...node.attrs,
                [name]: value
              });
          });
        else
          tr2.setNodeMarkup($cell.pos, null, {
            ...$cell.nodeAfter.attrs,
            [name]: value
          });
        dispatch2(tr2);
      }
      return true;
    };
  }
  function deprecated_toggleHeader(type) {
    return function(state, dispatch2) {
      if (!isInTable(state))
        return false;
      if (dispatch2) {
        const types = tableNodeTypes(state.schema);
        const rect = selectedRect(state), tr2 = state.tr;
        const cells = rect.map.cellsInRect(
          type == "column" ? {
            left: rect.left,
            top: 0,
            right: rect.right,
            bottom: rect.map.height
          } : type == "row" ? {
            left: 0,
            top: rect.top,
            right: rect.map.width,
            bottom: rect.bottom
          } : rect
        );
        const nodes = cells.map((pos) => rect.table.nodeAt(pos));
        for (let i = 0; i < cells.length; i++)
          if (nodes[i].type == types.header_cell)
            tr2.setNodeMarkup(
              rect.tableStart + cells[i],
              types.cell,
              nodes[i].attrs
            );
        if (tr2.steps.length == 0)
          for (let i = 0; i < cells.length; i++)
            tr2.setNodeMarkup(
              rect.tableStart + cells[i],
              types.header_cell,
              nodes[i].attrs
            );
        dispatch2(tr2);
      }
      return true;
    };
  }
  function isHeaderEnabledByType(type, rect, types) {
    const cellPositions = rect.map.cellsInRect({
      left: 0,
      top: 0,
      right: type == "row" ? rect.map.width : 1,
      bottom: type == "column" ? rect.map.height : 1
    });
    for (let i = 0; i < cellPositions.length; i++) {
      const cell = rect.table.nodeAt(cellPositions[i]);
      if (cell && cell.type !== types.header_cell) {
        return false;
      }
    }
    return true;
  }
  function toggleHeader(type, options) {
    options = options || { useDeprecatedLogic: false };
    if (options.useDeprecatedLogic)
      return deprecated_toggleHeader(type);
    return function(state, dispatch2) {
      if (!isInTable(state))
        return false;
      if (dispatch2) {
        const types = tableNodeTypes(state.schema);
        const rect = selectedRect(state), tr2 = state.tr;
        const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
        const isHeaderColumnEnabled = isHeaderEnabledByType(
          "column",
          rect,
          types
        );
        const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
        const selectionStartsAt = isHeaderEnabled ? 1 : 0;
        const cellsRect = type == "column" ? {
          left: 0,
          top: selectionStartsAt,
          right: 1,
          bottom: rect.map.height
        } : type == "row" ? {
          left: selectionStartsAt,
          top: 0,
          right: rect.map.width,
          bottom: 1
        } : rect;
        const newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
        rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
          const cellPos = relativeCellPos + rect.tableStart;
          const cell = tr2.doc.nodeAt(cellPos);
          if (cell) {
            tr2.setNodeMarkup(cellPos, newType, cell.attrs);
          }
        });
        dispatch2(tr2);
      }
      return true;
    };
  }
  function findNextCell($cell, dir) {
    if (dir < 0) {
      const before = $cell.nodeBefore;
      if (before)
        return $cell.pos - before.nodeSize;
      for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
        const rowNode = $cell.node(-1).child(row);
        const lastChild2 = rowNode.lastChild;
        if (lastChild2) {
          return rowEnd - 1 - lastChild2.nodeSize;
        }
        rowEnd -= rowNode.nodeSize;
      }
    } else {
      if ($cell.index() < $cell.parent.childCount - 1) {
        return $cell.pos + $cell.nodeAfter.nodeSize;
      }
      const table = $cell.node(-1);
      for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {
        const rowNode = table.child(row);
        if (rowNode.childCount)
          return rowStart + 1;
        rowStart += rowNode.nodeSize;
      }
    }
    return null;
  }
  function goToNextCell(direction) {
    return function(state, dispatch2) {
      if (!isInTable(state))
        return false;
      const cell = findNextCell(selectionCell(state), direction);
      if (cell == null)
        return false;
      if (dispatch2) {
        const $cell = state.doc.resolve(cell);
        dispatch2(
          state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
        );
      }
      return true;
    };
  }
  function deleteTable(state, dispatch2) {
    const $pos = state.selection.$anchor;
    for (let d = $pos.depth; d > 0; d--) {
      const node = $pos.node(d);
      if (node.type.spec.tableRole == "table") {
        if (dispatch2)
          dispatch2(
            state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()
          );
        return true;
      }
    }
    return false;
  }
  function tableEditing({
    allowTableNodeSelection = false
  } = {}) {
    return new Plugin({
      key: tableEditingKey,
      // This piece of state is used to remember when a mouse-drag
      // cell-selection is happening, so that it can continue even as
      // transactions (which might move its anchor cell) come in.
      state: {
        init() {
          return null;
        },
        apply(tr2, cur) {
          const set2 = tr2.getMeta(tableEditingKey);
          if (set2 != null)
            return set2 == -1 ? null : set2;
          if (cur == null || !tr2.docChanged)
            return cur;
          const { deleted, pos } = tr2.mapping.mapResult(cur);
          return deleted ? null : pos;
        }
      },
      props: {
        decorations: drawCellSelection,
        handleDOMEvents: {
          mousedown: handleMouseDown
        },
        createSelectionBetween(view) {
          return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
        },
        handleTripleClick: handleTripleClick2,
        handleKeyDown: handleKeyDown2,
        handlePaste
      },
      appendTransaction(_, oldState, state) {
        return normalizeSelection(
          state,
          fixTables(state, oldState),
          allowTableNodeSelection
        );
      }
    });
  }
  var readFromCache, addToCache, TableMap, tableEditingKey, CellSelection, CellBookmark, fixTablesKey, handleKeyDown2, TableView, columnResizingPluginKey, ResizeState, toggleHeaderRow, toggleHeaderColumn, toggleHeaderCell;
  var init_dist38 = __esm({
    "node_modules/prosemirror-tables/dist/index.js"() {
      init_dist4();
      init_dist2();
      init_dist4();
      init_dist6();
      init_dist4();
      init_dist4();
      init_dist2();
      init_dist4();
      init_dist8();
      init_dist2();
      init_dist3();
      init_dist4();
      init_dist6();
      init_dist2();
      init_dist4();
      if (typeof WeakMap != "undefined") {
        let cache2 = /* @__PURE__ */ new WeakMap();
        readFromCache = (key) => cache2.get(key);
        addToCache = (key, value) => {
          cache2.set(key, value);
          return value;
        };
      } else {
        const cache2 = [];
        const cacheSize = 10;
        let cachePos = 0;
        readFromCache = (key) => {
          for (let i = 0; i < cache2.length; i += 2)
            if (cache2[i] == key)
              return cache2[i + 1];
        };
        addToCache = (key, value) => {
          if (cachePos == cacheSize)
            cachePos = 0;
          cache2[cachePos++] = key;
          return cache2[cachePos++] = value;
        };
      }
      TableMap = class {
        constructor(width, height, map4, problems) {
          this.width = width;
          this.height = height;
          this.map = map4;
          this.problems = problems;
        }
        // Find the dimensions of the cell at the given position.
        findCell(pos) {
          for (let i = 0; i < this.map.length; i++) {
            const curPos = this.map[i];
            if (curPos != pos)
              continue;
            const left2 = i % this.width;
            const top2 = i / this.width | 0;
            let right2 = left2 + 1;
            let bottom2 = top2 + 1;
            for (let j = 1; right2 < this.width && this.map[i + j] == curPos; j++) {
              right2++;
            }
            for (let j = 1; bottom2 < this.height && this.map[i + this.width * j] == curPos; j++) {
              bottom2++;
            }
            return { left: left2, top: top2, right: right2, bottom: bottom2 };
          }
          throw new RangeError(`No cell with offset ${pos} found`);
        }
        // Find the left side of the cell at the given position.
        colCount(pos) {
          for (let i = 0; i < this.map.length; i++) {
            if (this.map[i] == pos) {
              return i % this.width;
            }
          }
          throw new RangeError(`No cell with offset ${pos} found`);
        }
        // Find the next cell in the given direction, starting from the cell
        // at `pos`, if any.
        nextCell(pos, axis, dir) {
          const { left: left2, right: right2, top: top2, bottom: bottom2 } = this.findCell(pos);
          if (axis == "horiz") {
            if (dir < 0 ? left2 == 0 : right2 == this.width)
              return null;
            return this.map[top2 * this.width + (dir < 0 ? left2 - 1 : right2)];
          } else {
            if (dir < 0 ? top2 == 0 : bottom2 == this.height)
              return null;
            return this.map[left2 + this.width * (dir < 0 ? top2 - 1 : bottom2)];
          }
        }
        // Get the rectangle spanning the two given cells.
        rectBetween(a, b) {
          const {
            left: leftA,
            right: rightA,
            top: topA,
            bottom: bottomA
          } = this.findCell(a);
          const {
            left: leftB,
            right: rightB,
            top: topB,
            bottom: bottomB
          } = this.findCell(b);
          return {
            left: Math.min(leftA, leftB),
            top: Math.min(topA, topB),
            right: Math.max(rightA, rightB),
            bottom: Math.max(bottomA, bottomB)
          };
        }
        // Return the position of all cells that have the top left corner in
        // the given rectangle.
        cellsInRect(rect) {
          const result = [];
          const seen = {};
          for (let row = rect.top; row < rect.bottom; row++) {
            for (let col = rect.left; col < rect.right; col++) {
              const index3 = row * this.width + col;
              const pos = this.map[index3];
              if (seen[pos])
                continue;
              seen[pos] = true;
              if (col == rect.left && col && this.map[index3 - 1] == pos || row == rect.top && row && this.map[index3 - this.width] == pos) {
                continue;
              }
              result.push(pos);
            }
          }
          return result;
        }
        // Return the position at which the cell at the given row and column
        // starts, or would start, if a cell started there.
        positionAt(row, col, table) {
          for (let i = 0, rowStart = 0; ; i++) {
            const rowEnd = rowStart + table.child(i).nodeSize;
            if (i == row) {
              let index3 = col + row * this.width;
              const rowEndIndex = (row + 1) * this.width;
              while (index3 < rowEndIndex && this.map[index3] < rowStart)
                index3++;
              return index3 == rowEndIndex ? rowEnd - 1 : this.map[index3];
            }
            rowStart = rowEnd;
          }
        }
        // Find the table map for the given table node.
        static get(table) {
          return readFromCache(table) || addToCache(table, computeMap(table));
        }
      };
      tableEditingKey = new PluginKey("selectingCells");
      CellSelection = class _CellSelection extends Selection {
        // A table selection is identified by its anchor and head cells. The
        // positions given to this constructor should point _before_ two
        // cells in the same table. They may be the same, to select a single
        // cell.
        constructor($anchorCell, $headCell = $anchorCell) {
          const table = $anchorCell.node(-1);
          const map4 = TableMap.get(table);
          const tableStart = $anchorCell.start(-1);
          const rect = map4.rectBetween(
            $anchorCell.pos - tableStart,
            $headCell.pos - tableStart
          );
          const doc3 = $anchorCell.node(0);
          const cells = map4.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);
          cells.unshift($headCell.pos - tableStart);
          const ranges = cells.map((pos) => {
            const cell = table.nodeAt(pos);
            if (!cell) {
              throw RangeError(`No cell with offset ${pos} found`);
            }
            const from3 = tableStart + pos + 1;
            return new SelectionRange(
              doc3.resolve(from3),
              doc3.resolve(from3 + cell.content.size)
            );
          });
          super(ranges[0].$from, ranges[0].$to, ranges);
          this.$anchorCell = $anchorCell;
          this.$headCell = $headCell;
        }
        map(doc3, mapping) {
          const $anchorCell = doc3.resolve(mapping.map(this.$anchorCell.pos));
          const $headCell = doc3.resolve(mapping.map(this.$headCell.pos));
          if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
            const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
            if (tableChanged && this.isRowSelection())
              return _CellSelection.rowSelection($anchorCell, $headCell);
            else if (tableChanged && this.isColSelection())
              return _CellSelection.colSelection($anchorCell, $headCell);
            else
              return new _CellSelection($anchorCell, $headCell);
          }
          return TextSelection.between($anchorCell, $headCell);
        }
        // Returns a rectangular slice of table rows containing the selected
        // cells.
        content() {
          const table = this.$anchorCell.node(-1);
          const map4 = TableMap.get(table);
          const tableStart = this.$anchorCell.start(-1);
          const rect = map4.rectBetween(
            this.$anchorCell.pos - tableStart,
            this.$headCell.pos - tableStart
          );
          const seen = {};
          const rows = [];
          for (let row = rect.top; row < rect.bottom; row++) {
            const rowContent = [];
            for (let index3 = row * map4.width + rect.left, col = rect.left; col < rect.right; col++, index3++) {
              const pos = map4.map[index3];
              if (seen[pos])
                continue;
              seen[pos] = true;
              const cellRect = map4.findCell(pos);
              let cell = table.nodeAt(pos);
              if (!cell) {
                throw RangeError(`No cell with offset ${pos} found`);
              }
              const extraLeft = rect.left - cellRect.left;
              const extraRight = cellRect.right - rect.right;
              if (extraLeft > 0 || extraRight > 0) {
                let attrs = cell.attrs;
                if (extraLeft > 0) {
                  attrs = removeColSpan(attrs, 0, extraLeft);
                }
                if (extraRight > 0) {
                  attrs = removeColSpan(
                    attrs,
                    attrs.colspan - extraRight,
                    extraRight
                  );
                }
                if (cellRect.left < rect.left) {
                  cell = cell.type.createAndFill(attrs);
                  if (!cell) {
                    throw RangeError(
                      `Could not create cell with attrs ${JSON.stringify(attrs)}`
                    );
                  }
                } else {
                  cell = cell.type.create(attrs, cell.content);
                }
              }
              if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
                const attrs = {
                  ...cell.attrs,
                  rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
                };
                if (cellRect.top < rect.top) {
                  cell = cell.type.createAndFill(attrs);
                } else {
                  cell = cell.type.create(attrs, cell.content);
                }
              }
              rowContent.push(cell);
            }
            rows.push(table.child(row).copy(Fragment.from(rowContent)));
          }
          const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
          return new Slice(Fragment.from(fragment), 1, 1);
        }
        replace(tr2, content = Slice.empty) {
          const mapFrom = tr2.steps.length, ranges = this.ranges;
          for (let i = 0; i < ranges.length; i++) {
            const { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
            tr2.replace(
              mapping.map($from.pos),
              mapping.map($to.pos),
              i ? Slice.empty : content
            );
          }
          const sel = Selection.findFrom(
            tr2.doc.resolve(tr2.mapping.slice(mapFrom).map(this.to)),
            -1
          );
          if (sel)
            tr2.setSelection(sel);
        }
        replaceWith(tr2, node) {
          this.replace(tr2, new Slice(Fragment.from(node), 0, 0));
        }
        forEachCell(f) {
          const table = this.$anchorCell.node(-1);
          const map4 = TableMap.get(table);
          const tableStart = this.$anchorCell.start(-1);
          const cells = map4.cellsInRect(
            map4.rectBetween(
              this.$anchorCell.pos - tableStart,
              this.$headCell.pos - tableStart
            )
          );
          for (let i = 0; i < cells.length; i++) {
            f(table.nodeAt(cells[i]), tableStart + cells[i]);
          }
        }
        // True if this selection goes all the way from the top to the
        // bottom of the table.
        isColSelection() {
          const anchorTop = this.$anchorCell.index(-1);
          const headTop = this.$headCell.index(-1);
          if (Math.min(anchorTop, headTop) > 0)
            return false;
          const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
          const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
          return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
        }
        // Returns the smallest column selection that covers the given anchor
        // and head cell.
        static colSelection($anchorCell, $headCell = $anchorCell) {
          const table = $anchorCell.node(-1);
          const map4 = TableMap.get(table);
          const tableStart = $anchorCell.start(-1);
          const anchorRect = map4.findCell($anchorCell.pos - tableStart);
          const headRect = map4.findCell($headCell.pos - tableStart);
          const doc3 = $anchorCell.node(0);
          if (anchorRect.top <= headRect.top) {
            if (anchorRect.top > 0)
              $anchorCell = doc3.resolve(tableStart + map4.map[anchorRect.left]);
            if (headRect.bottom < map4.height)
              $headCell = doc3.resolve(
                tableStart + map4.map[map4.width * (map4.height - 1) + headRect.right - 1]
              );
          } else {
            if (headRect.top > 0)
              $headCell = doc3.resolve(tableStart + map4.map[headRect.left]);
            if (anchorRect.bottom < map4.height)
              $anchorCell = doc3.resolve(
                tableStart + map4.map[map4.width * (map4.height - 1) + anchorRect.right - 1]
              );
          }
          return new _CellSelection($anchorCell, $headCell);
        }
        // True if this selection goes all the way from the left to the
        // right of the table.
        isRowSelection() {
          const table = this.$anchorCell.node(-1);
          const map4 = TableMap.get(table);
          const tableStart = this.$anchorCell.start(-1);
          const anchorLeft = map4.colCount(this.$anchorCell.pos - tableStart);
          const headLeft = map4.colCount(this.$headCell.pos - tableStart);
          if (Math.min(anchorLeft, headLeft) > 0)
            return false;
          const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
          const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
          return Math.max(anchorRight, headRight) == map4.width;
        }
        eq(other) {
          return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
        }
        // Returns the smallest row selection that covers the given anchor
        // and head cell.
        static rowSelection($anchorCell, $headCell = $anchorCell) {
          const table = $anchorCell.node(-1);
          const map4 = TableMap.get(table);
          const tableStart = $anchorCell.start(-1);
          const anchorRect = map4.findCell($anchorCell.pos - tableStart);
          const headRect = map4.findCell($headCell.pos - tableStart);
          const doc3 = $anchorCell.node(0);
          if (anchorRect.left <= headRect.left) {
            if (anchorRect.left > 0)
              $anchorCell = doc3.resolve(
                tableStart + map4.map[anchorRect.top * map4.width]
              );
            if (headRect.right < map4.width)
              $headCell = doc3.resolve(
                tableStart + map4.map[map4.width * (headRect.top + 1) - 1]
              );
          } else {
            if (headRect.left > 0)
              $headCell = doc3.resolve(tableStart + map4.map[headRect.top * map4.width]);
            if (anchorRect.right < map4.width)
              $anchorCell = doc3.resolve(
                tableStart + map4.map[map4.width * (anchorRect.top + 1) - 1]
              );
          }
          return new _CellSelection($anchorCell, $headCell);
        }
        toJSON() {
          return {
            type: "cell",
            anchor: this.$anchorCell.pos,
            head: this.$headCell.pos
          };
        }
        static fromJSON(doc3, json2) {
          return new _CellSelection(doc3.resolve(json2.anchor), doc3.resolve(json2.head));
        }
        static create(doc3, anchorCell, headCell = anchorCell) {
          return new _CellSelection(doc3.resolve(anchorCell), doc3.resolve(headCell));
        }
        getBookmark() {
          return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
        }
      };
      CellSelection.prototype.visible = false;
      Selection.jsonID("cell", CellSelection);
      CellBookmark = class _CellBookmark {
        constructor(anchor, head) {
          this.anchor = anchor;
          this.head = head;
        }
        map(mapping) {
          return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
        }
        resolve(doc3) {
          const $anchorCell = doc3.resolve(this.anchor), $headCell = doc3.resolve(this.head);
          if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
            return new CellSelection($anchorCell, $headCell);
          else
            return Selection.near($headCell, 1);
        }
      };
      fixTablesKey = new PluginKey("fix-tables");
      handleKeyDown2 = keydownHandler({
        ArrowLeft: arrow3("horiz", -1),
        ArrowRight: arrow3("horiz", 1),
        ArrowUp: arrow3("vert", -1),
        ArrowDown: arrow3("vert", 1),
        "Shift-ArrowLeft": shiftArrow("horiz", -1),
        "Shift-ArrowRight": shiftArrow("horiz", 1),
        "Shift-ArrowUp": shiftArrow("vert", -1),
        "Shift-ArrowDown": shiftArrow("vert", 1),
        Backspace: deleteCellSelection,
        "Mod-Backspace": deleteCellSelection,
        Delete: deleteCellSelection,
        "Mod-Delete": deleteCellSelection
      });
      TableView = class {
        constructor(node, cellMinWidth) {
          this.node = node;
          this.cellMinWidth = cellMinWidth;
          this.dom = document.createElement("div");
          this.dom.className = "tableWrapper";
          this.table = this.dom.appendChild(document.createElement("table"));
          this.colgroup = this.table.appendChild(document.createElement("colgroup"));
          updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);
          this.contentDOM = this.table.appendChild(document.createElement("tbody"));
        }
        update(node) {
          if (node.type != this.node.type)
            return false;
          this.node = node;
          updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);
          return true;
        }
        ignoreMutation(record) {
          return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
        }
      };
      columnResizingPluginKey = new PluginKey(
        "tableColumnResizing"
      );
      ResizeState = class _ResizeState {
        constructor(activeHandle, dragging) {
          this.activeHandle = activeHandle;
          this.dragging = dragging;
        }
        apply(tr2) {
          const state = this;
          const action = tr2.getMeta(columnResizingPluginKey);
          if (action && action.setHandle != null)
            return new _ResizeState(action.setHandle, false);
          if (action && action.setDragging !== void 0)
            return new _ResizeState(state.activeHandle, action.setDragging);
          if (state.activeHandle > -1 && tr2.docChanged) {
            let handle = tr2.mapping.map(state.activeHandle, -1);
            if (!pointsAtCell(tr2.doc.resolve(handle))) {
              handle = -1;
            }
            return new _ResizeState(handle, state.dragging);
          }
          return state;
        }
      };
      toggleHeaderRow = toggleHeader("row", {
        useDeprecatedLogic: true
      });
      toggleHeaderColumn = toggleHeader("column", {
        useDeprecatedLogic: true
      });
      toggleHeaderCell = toggleHeader("cell", {
        useDeprecatedLogic: true
      });
    }
  });

  // node_modules/@tiptap/pm/tables/dist/index.js
  var init_dist39 = __esm({
    "node_modules/@tiptap/pm/tables/dist/index.js"() {
      init_dist38();
    }
  });

  // node_modules/@tiptap/extension-table/dist/index.js
  var dist_exports16 = {};
  __export(dist_exports16, {
    Table: () => Table,
    createColGroup: () => createColGroup,
    createTable: () => createTable,
    default: () => Table
  });
  function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
    let totalWidth = 0;
    let fixedWidth = true;
    let nextDOM = colgroup.firstChild;
    const row = node.firstChild;
    for (let i = 0, col = 0; i < row.childCount; i += 1) {
      const { colspan, colwidth } = row.child(i).attrs;
      for (let j = 0; j < colspan; j += 1, col += 1) {
        const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? `${hasWidth}px` : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) {
          fixedWidth = false;
        }
        if (!nextDOM) {
          colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
        } else {
          if (nextDOM.style.width !== cssWidth) {
            nextDOM.style.width = cssWidth;
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
    while (nextDOM) {
      const after = nextDOM.nextSibling;
      nextDOM.parentNode.removeChild(nextDOM);
      nextDOM = after;
    }
    if (fixedWidth) {
      table.style.width = `${totalWidth}px`;
      table.style.minWidth = "";
    } else {
      table.style.width = "";
      table.style.minWidth = `${totalWidth}px`;
    }
  }
  function createColGroup(node, cellMinWidth, overrideCol, overrideValue) {
    let totalWidth = 0;
    let fixedWidth = true;
    const cols = [];
    const row = node.firstChild;
    if (!row) {
      return {};
    }
    for (let i = 0, col = 0; i < row.childCount; i += 1) {
      const { colspan, colwidth } = row.child(i).attrs;
      for (let j = 0; j < colspan; j += 1, col += 1) {
        const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? `${hasWidth}px` : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) {
          fixedWidth = false;
        }
        cols.push(["col", cssWidth ? { style: `width: ${cssWidth}` } : {}]);
      }
    }
    const tableWidth = fixedWidth ? `${totalWidth}px` : "";
    const tableMinWidth = fixedWidth ? "" : `${totalWidth}px`;
    const colgroup = ["colgroup", {}, ...cols];
    return { colgroup, tableWidth, tableMinWidth };
  }
  function createCell(cellType, cellContent) {
    if (cellContent) {
      return cellType.createChecked(null, cellContent);
    }
    return cellType.createAndFill();
  }
  function getTableNodeTypes(schema) {
    if (schema.cached.tableNodeTypes) {
      return schema.cached.tableNodeTypes;
    }
    const roles = {};
    Object.keys(schema.nodes).forEach((type) => {
      const nodeType = schema.nodes[type];
      if (nodeType.spec.tableRole) {
        roles[nodeType.spec.tableRole] = nodeType;
      }
    });
    schema.cached.tableNodeTypes = roles;
    return roles;
  }
  function createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {
    const types = getTableNodeTypes(schema);
    const headerCells = [];
    const cells = [];
    for (let index3 = 0; index3 < colsCount; index3 += 1) {
      const cell = createCell(types.cell, cellContent);
      if (cell) {
        cells.push(cell);
      }
      if (withHeaderRow) {
        const headerCell = createCell(types.header_cell, cellContent);
        if (headerCell) {
          headerCells.push(headerCell);
        }
      }
    }
    const rows = [];
    for (let index3 = 0; index3 < rowsCount; index3 += 1) {
      rows.push(types.row.createChecked(null, withHeaderRow && index3 === 0 ? headerCells : cells));
    }
    return types.table.createChecked(null, rows);
  }
  function isCellSelection(value) {
    return value instanceof CellSelection;
  }
  var TableView2, deleteTableWhenAllCellsSelected, Table;
  var init_dist40 = __esm({
    "node_modules/@tiptap/extension-table/dist/index.js"() {
      init_dist16();
      init_dist5();
      init_dist39();
      TableView2 = class {
        constructor(node, cellMinWidth) {
          this.node = node;
          this.cellMinWidth = cellMinWidth;
          this.dom = document.createElement("div");
          this.dom.className = "tableWrapper";
          this.table = this.dom.appendChild(document.createElement("table"));
          this.colgroup = this.table.appendChild(document.createElement("colgroup"));
          updateColumns(node, this.colgroup, this.table, cellMinWidth);
          this.contentDOM = this.table.appendChild(document.createElement("tbody"));
        }
        update(node) {
          if (node.type !== this.node.type) {
            return false;
          }
          this.node = node;
          updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
          return true;
        }
        ignoreMutation(mutation) {
          return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
        }
      };
      deleteTableWhenAllCellsSelected = ({ editor }) => {
        const { selection } = editor.state;
        if (!isCellSelection(selection)) {
          return false;
        }
        let cellCount = 0;
        const table = findParentNodeClosestToPos(selection.ranges[0].$from, (node) => {
          return node.type.name === "table";
        });
        table === null || table === void 0 ? void 0 : table.node.descendants((node) => {
          if (node.type.name === "table") {
            return false;
          }
          if (["tableCell", "tableHeader"].includes(node.type.name)) {
            cellCount += 1;
          }
        });
        const allCellsSelected = cellCount === selection.ranges.length;
        if (!allCellsSelected) {
          return false;
        }
        editor.commands.deleteTable();
        return true;
      };
      Table = Node3.create({
        name: "table",
        // @ts-ignore
        addOptions() {
          return {
            HTMLAttributes: {},
            resizable: false,
            handleWidth: 5,
            cellMinWidth: 25,
            // TODO: fix
            View: TableView2,
            lastColumnResizable: true,
            allowTableNodeSelection: false
          };
        },
        content: "tableRow+",
        tableRole: "table",
        isolating: true,
        group: "block",
        parseHTML() {
          return [{ tag: "table" }];
        },
        renderHTML({ node, HTMLAttributes }) {
          const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);
          const table = [
            "table",
            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
              style: tableWidth ? `width: ${tableWidth}` : `minWidth: ${tableMinWidth}`
            }),
            colgroup,
            ["tbody", 0]
          ];
          return table;
        },
        addCommands() {
          return {
            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr: tr2, dispatch: dispatch2, editor }) => {
              const node = createTable(editor.schema, rows, cols, withHeaderRow);
              if (dispatch2) {
                const offset2 = tr2.selection.anchor + 1;
                tr2.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr2.doc.resolve(offset2)));
              }
              return true;
            },
            addColumnBefore: () => ({ state, dispatch: dispatch2 }) => {
              return addColumnBefore(state, dispatch2);
            },
            addColumnAfter: () => ({ state, dispatch: dispatch2 }) => {
              return addColumnAfter(state, dispatch2);
            },
            deleteColumn: () => ({ state, dispatch: dispatch2 }) => {
              return deleteColumn(state, dispatch2);
            },
            addRowBefore: () => ({ state, dispatch: dispatch2 }) => {
              return addRowBefore(state, dispatch2);
            },
            addRowAfter: () => ({ state, dispatch: dispatch2 }) => {
              return addRowAfter(state, dispatch2);
            },
            deleteRow: () => ({ state, dispatch: dispatch2 }) => {
              return deleteRow(state, dispatch2);
            },
            deleteTable: () => ({ state, dispatch: dispatch2 }) => {
              return deleteTable(state, dispatch2);
            },
            mergeCells: () => ({ state, dispatch: dispatch2 }) => {
              return mergeCells(state, dispatch2);
            },
            splitCell: () => ({ state, dispatch: dispatch2 }) => {
              return splitCell(state, dispatch2);
            },
            toggleHeaderColumn: () => ({ state, dispatch: dispatch2 }) => {
              return toggleHeader("column")(state, dispatch2);
            },
            toggleHeaderRow: () => ({ state, dispatch: dispatch2 }) => {
              return toggleHeader("row")(state, dispatch2);
            },
            toggleHeaderCell: () => ({ state, dispatch: dispatch2 }) => {
              return toggleHeaderCell(state, dispatch2);
            },
            mergeOrSplit: () => ({ state, dispatch: dispatch2 }) => {
              if (mergeCells(state, dispatch2)) {
                return true;
              }
              return splitCell(state, dispatch2);
            },
            setCellAttribute: (name, value) => ({ state, dispatch: dispatch2 }) => {
              return setCellAttr(name, value)(state, dispatch2);
            },
            goToNextCell: () => ({ state, dispatch: dispatch2 }) => {
              return goToNextCell(1)(state, dispatch2);
            },
            goToPreviousCell: () => ({ state, dispatch: dispatch2 }) => {
              return goToNextCell(-1)(state, dispatch2);
            },
            fixTables: () => ({ state, dispatch: dispatch2 }) => {
              if (dispatch2) {
                fixTables(state);
              }
              return true;
            },
            setCellSelection: (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
              if (dispatch2) {
                const selection = CellSelection.create(tr2.doc, position.anchorCell, position.headCell);
                tr2.setSelection(selection);
              }
              return true;
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            Tab: () => {
              if (this.editor.commands.goToNextCell()) {
                return true;
              }
              if (!this.editor.can().addRowAfter()) {
                return false;
              }
              return this.editor.chain().addRowAfter().goToNextCell().run();
            },
            "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
            Backspace: deleteTableWhenAllCellsSelected,
            "Mod-Backspace": deleteTableWhenAllCellsSelected,
            Delete: deleteTableWhenAllCellsSelected,
            "Mod-Delete": deleteTableWhenAllCellsSelected
          };
        },
        addProseMirrorPlugins() {
          const isResizable = this.options.resizable && this.editor.isEditable;
          return [
            ...isResizable ? [
              columnResizing({
                handleWidth: this.options.handleWidth,
                cellMinWidth: this.options.cellMinWidth,
                // @ts-ignore (incorrect type)
                View: this.options.View,
                // TODO: PR for @types/prosemirror-tables
                // @ts-ignore (incorrect type)
                lastColumnResizable: this.options.lastColumnResizable
              })
            ] : [],
            tableEditing({
              allowTableNodeSelection: this.options.allowTableNodeSelection
            })
          ];
        },
        extendNodeSchema(extension) {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage
          };
          return {
            tableRole: callOrReturn(getExtensionField(extension, "tableRole", context))
          };
        }
      });
    }
  });

  // node_modules/@tiptap/extension-table-row/dist/index.js
  var dist_exports17 = {};
  __export(dist_exports17, {
    TableRow: () => TableRow,
    default: () => TableRow
  });
  var TableRow;
  var init_dist41 = __esm({
    "node_modules/@tiptap/extension-table-row/dist/index.js"() {
      init_dist16();
      TableRow = Node3.create({
        name: "tableRow",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        content: "(tableCell | tableHeader)*",
        tableRole: "row",
        parseHTML() {
          return [
            { tag: "tr" }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["tr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-table-cell/dist/index.js
  var dist_exports18 = {};
  __export(dist_exports18, {
    TableCell: () => TableCell,
    default: () => TableCell
  });
  var TableCell;
  var init_dist42 = __esm({
    "node_modules/@tiptap/extension-table-cell/dist/index.js"() {
      init_dist16();
      TableCell = Node3.create({
        name: "tableCell",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        content: "block+",
        addAttributes() {
          return {
            colspan: {
              default: 1
            },
            rowspan: {
              default: 1
            },
            colwidth: {
              default: null,
              parseHTML: (element) => {
                const colwidth = element.getAttribute("colwidth");
                const value = colwidth ? [parseInt(colwidth, 10)] : null;
                return value;
              }
            }
          };
        },
        tableRole: "cell",
        isolating: true,
        parseHTML() {
          return [
            { tag: "td" }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-table-header/dist/index.js
  var dist_exports19 = {};
  __export(dist_exports19, {
    TableHeader: () => TableHeader,
    default: () => TableHeader
  });
  var TableHeader;
  var init_dist43 = __esm({
    "node_modules/@tiptap/extension-table-header/dist/index.js"() {
      init_dist16();
      TableHeader = Node3.create({
        name: "tableHeader",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        content: "block+",
        addAttributes() {
          return {
            colspan: {
              default: 1
            },
            rowspan: {
              default: 1
            },
            colwidth: {
              default: null,
              parseHTML: (element) => {
                const colwidth = element.getAttribute("colwidth");
                const value = colwidth ? [parseInt(colwidth, 10)] : null;
                return value;
              }
            }
          };
        },
        tableRole: "header_cell",
        isolating: true,
        parseHTML() {
          return [
            { tag: "th" }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        }
      });
    }
  });

  // node_modules/linkifyjs/dist/linkify.es.js
  function registerGroup(name, groups) {
    if (!(name in groups)) {
      groups[name] = [];
    }
    return groups[name];
  }
  function addToGroups(t, flags, groups) {
    if (flags[numeric]) {
      flags[asciinumeric] = true;
      flags[alphanumeric] = true;
    }
    if (flags[ascii]) {
      flags[asciinumeric] = true;
      flags[alpha2] = true;
    }
    if (flags[asciinumeric]) {
      flags[alphanumeric] = true;
    }
    if (flags[alpha2]) {
      flags[alphanumeric] = true;
    }
    if (flags[alphanumeric]) {
      flags[domain] = true;
    }
    if (flags[emoji]) {
      flags[domain] = true;
    }
    for (const k in flags) {
      const group = registerGroup(k, groups);
      if (group.indexOf(t) < 0) {
        group.push(t);
      }
    }
  }
  function flagsForToken(t, groups) {
    const result = {};
    for (const c in groups) {
      if (groups[c].indexOf(t) >= 0) {
        result[c] = true;
      }
    }
    return result;
  }
  function State(token) {
    if (token === void 0) {
      token = null;
    }
    this.j = {};
    this.jr = [];
    this.jd = null;
    this.t = token;
  }
  function init$2(customSchemes) {
    if (customSchemes === void 0) {
      customSchemes = [];
    }
    const groups = {};
    State.groups = groups;
    const Start = new State();
    if (tlds == null) {
      tlds = decodeTlds(encodedTlds);
    }
    if (utlds == null) {
      utlds = decodeTlds(encodedUtlds);
    }
    tt(Start, "'", APOSTROPHE);
    tt(Start, "{", OPENBRACE);
    tt(Start, "}", CLOSEBRACE);
    tt(Start, "[", OPENBRACKET);
    tt(Start, "]", CLOSEBRACKET);
    tt(Start, "(", OPENPAREN);
    tt(Start, ")", CLOSEPAREN);
    tt(Start, "<", OPENANGLEBRACKET);
    tt(Start, ">", CLOSEANGLEBRACKET);
    tt(Start, "\uFF08", FULLWIDTHLEFTPAREN);
    tt(Start, "\uFF09", FULLWIDTHRIGHTPAREN);
    tt(Start, "\u300C", LEFTCORNERBRACKET);
    tt(Start, "\u300D", RIGHTCORNERBRACKET);
    tt(Start, "\u300E", LEFTWHITECORNERBRACKET);
    tt(Start, "\u300F", RIGHTWHITECORNERBRACKET);
    tt(Start, "\uFF1C", FULLWIDTHLESSTHAN);
    tt(Start, "\uFF1E", FULLWIDTHGREATERTHAN);
    tt(Start, "&", AMPERSAND);
    tt(Start, "*", ASTERISK);
    tt(Start, "@", AT);
    tt(Start, "`", BACKTICK);
    tt(Start, "^", CARET);
    tt(Start, ":", COLON);
    tt(Start, ",", COMMA);
    tt(Start, "$", DOLLAR);
    tt(Start, ".", DOT);
    tt(Start, "=", EQUALS);
    tt(Start, "!", EXCLAMATION);
    tt(Start, "-", HYPHEN);
    tt(Start, "%", PERCENT);
    tt(Start, "|", PIPE);
    tt(Start, "+", PLUS);
    tt(Start, "#", POUND);
    tt(Start, "?", QUERY);
    tt(Start, '"', QUOTE);
    tt(Start, "/", SLASH);
    tt(Start, ";", SEMI);
    tt(Start, "~", TILDE);
    tt(Start, "_", UNDERSCORE);
    tt(Start, "\\", BACKSLASH);
    const Num = tr(Start, DIGIT, NUM, {
      [numeric]: true
    });
    tr(Num, DIGIT, Num);
    const Word = tr(Start, ASCII_LETTER, WORD, {
      [ascii]: true
    });
    tr(Word, ASCII_LETTER, Word);
    const UWord = tr(Start, LETTER, UWORD, {
      [alpha2]: true
    });
    tr(UWord, ASCII_LETTER);
    tr(UWord, LETTER, UWord);
    const Ws = tr(Start, SPACE, WS, {
      [whitespace]: true
    });
    tt(Start, NL, NL$1, {
      [whitespace]: true
    });
    tt(Ws, NL);
    tr(Ws, SPACE, Ws);
    const Emoji = tr(Start, EMOJI, EMOJI$1, {
      [emoji]: true
    });
    tr(Emoji, EMOJI, Emoji);
    tt(Emoji, EMOJI_VARIATION, Emoji);
    const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
    tr(EmojiJoiner, EMOJI, Emoji);
    const wordjr = [[ASCII_LETTER, Word]];
    const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
    for (let i = 0; i < tlds.length; i++) {
      fastts(Start, tlds[i], TLD, WORD, wordjr);
    }
    for (let i = 0; i < utlds.length; i++) {
      fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
    }
    addToGroups(TLD, {
      tld: true,
      ascii: true
    }, groups);
    addToGroups(UTLD, {
      utld: true,
      alpha: true
    }, groups);
    fastts(Start, "file", SCHEME, WORD, wordjr);
    fastts(Start, "mailto", SCHEME, WORD, wordjr);
    fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
    addToGroups(SCHEME, {
      scheme: true,
      ascii: true
    }, groups);
    addToGroups(SLASH_SCHEME, {
      slashscheme: true,
      ascii: true
    }, groups);
    customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
    for (let i = 0; i < customSchemes.length; i++) {
      const sch = customSchemes[i][0];
      const optionalSlashSlash = customSchemes[i][1];
      const flags = optionalSlashSlash ? {
        [scheme]: true
      } : {
        [slashscheme]: true
      };
      if (sch.indexOf("-") >= 0) {
        flags[domain] = true;
      } else if (!ASCII_LETTER.test(sch)) {
        flags[numeric] = true;
      } else if (DIGIT.test(sch)) {
        flags[asciinumeric] = true;
      } else {
        flags[ascii] = true;
      }
      ts(Start, sch, sch, flags);
    }
    ts(Start, "localhost", LOCALHOST, {
      ascii: true
    });
    Start.jd = new State(SYM);
    return {
      start: Start,
      tokens: assign({
        groups
      }, tk)
    };
  }
  function run$12(start3, str) {
    const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
    const charCount = iterable.length;
    const tokens = [];
    let cursor = 0;
    let charCursor = 0;
    while (charCursor < charCount) {
      let state = start3;
      let nextState = null;
      let tokenLength = 0;
      let latestAccepting = null;
      let sinceAccepts = -1;
      let charsSinceAccepts = -1;
      while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
        state = nextState;
        if (state.accepts()) {
          sinceAccepts = 0;
          charsSinceAccepts = 0;
          latestAccepting = state;
        } else if (sinceAccepts >= 0) {
          sinceAccepts += iterable[charCursor].length;
          charsSinceAccepts++;
        }
        tokenLength += iterable[charCursor].length;
        cursor += iterable[charCursor].length;
        charCursor++;
      }
      cursor -= sinceAccepts;
      charCursor -= charsSinceAccepts;
      tokenLength -= sinceAccepts;
      tokens.push({
        t: latestAccepting.t,
        // token type/name
        v: str.slice(cursor - tokenLength, cursor),
        // string value
        s: cursor - tokenLength,
        // start index
        e: cursor
        // end index (excluding)
      });
    }
    return tokens;
  }
  function stringToArray(str) {
    const result = [];
    const len = str.length;
    let index3 = 0;
    while (index3 < len) {
      let first2 = str.charCodeAt(index3);
      let second;
      let char = first2 < 55296 || first2 > 56319 || index3 + 1 === len || (second = str.charCodeAt(index3 + 1)) < 56320 || second > 57343 ? str[index3] : str.slice(index3, index3 + 2);
      result.push(char);
      index3 += char.length;
    }
    return result;
  }
  function fastts(state, input, t, defaultt, jr) {
    let next;
    const len = input.length;
    for (let i = 0; i < len - 1; i++) {
      const char = input[i];
      if (state.j[char]) {
        next = state.j[char];
      } else {
        next = new State(defaultt);
        next.jr = jr.slice();
        state.j[char] = next;
      }
      state = next;
    }
    next = new State(t);
    next.jr = jr.slice();
    state.j[input[len - 1]] = next;
    return next;
  }
  function decodeTlds(encoded) {
    const words = [];
    const stack = [];
    let i = 0;
    let digits = "0123456789";
    while (i < encoded.length) {
      let popDigitCount = 0;
      while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
        popDigitCount++;
      }
      if (popDigitCount > 0) {
        words.push(stack.join(""));
        for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
          stack.pop();
        }
        i += popDigitCount;
      } else {
        stack.push(encoded[i]);
        i++;
      }
    }
    return words;
  }
  function Options(opts, defaultRender) {
    if (defaultRender === void 0) {
      defaultRender = null;
    }
    let o = assign({}, defaults3);
    if (opts) {
      o = assign(o, opts instanceof Options ? opts.o : opts);
    }
    const ignoredTags = o.ignoreTags;
    const uppercaseIgnoredTags = [];
    for (let i = 0; i < ignoredTags.length; i++) {
      uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
    }
    this.o = o;
    if (defaultRender) {
      this.defaultRender = defaultRender;
    }
    this.ignoreTags = uppercaseIgnoredTags;
  }
  function noop2(val) {
    return val;
  }
  function MultiToken(value, tokens) {
    this.t = "token";
    this.v = value;
    this.tk = tokens;
  }
  function createTokenClass(type, props) {
    class Token extends MultiToken {
      constructor(value, tokens) {
        super(value, tokens);
        this.t = type;
      }
    }
    for (const p in props) {
      Token.prototype[p] = props[p];
    }
    Token.t = type;
    return Token;
  }
  function init$1(_ref) {
    let {
      groups
    } = _ref;
    const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
    const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
    const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
    const Start = makeState();
    const Localpart = tt(Start, TILDE);
    ta(Localpart, localpartAccepting, Localpart);
    ta(Localpart, groups.domain, Localpart);
    const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
    ta(Start, groups.domain, Domain);
    ta(Start, groups.scheme, Scheme);
    ta(Start, groups.slashscheme, SlashScheme);
    ta(Domain, localpartAccepting, Localpart);
    ta(Domain, groups.domain, Domain);
    const LocalpartAt = tt(Domain, AT);
    tt(Localpart, AT, LocalpartAt);
    tt(Scheme, AT, LocalpartAt);
    tt(SlashScheme, AT, LocalpartAt);
    const LocalpartDot = tt(Localpart, DOT);
    ta(LocalpartDot, localpartAccepting, Localpart);
    ta(LocalpartDot, groups.domain, Localpart);
    const EmailDomain = makeState();
    ta(LocalpartAt, groups.domain, EmailDomain);
    ta(EmailDomain, groups.domain, EmailDomain);
    const EmailDomainDot = tt(EmailDomain, DOT);
    ta(EmailDomainDot, groups.domain, EmailDomain);
    const Email$1 = makeState(Email);
    ta(EmailDomainDot, groups.tld, Email$1);
    ta(EmailDomainDot, groups.utld, Email$1);
    tt(LocalpartAt, LOCALHOST, Email$1);
    const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
    ta(EmailDomainHyphen, groups.domain, EmailDomain);
    ta(Email$1, groups.domain, EmailDomain);
    tt(Email$1, DOT, EmailDomainDot);
    tt(Email$1, HYPHEN, EmailDomainHyphen);
    const EmailColon = tt(Email$1, COLON);
    ta(EmailColon, groups.numeric, Email);
    const DomainHyphen = tt(Domain, HYPHEN);
    const DomainDot = tt(Domain, DOT);
    ta(DomainHyphen, groups.domain, Domain);
    ta(DomainDot, localpartAccepting, Localpart);
    ta(DomainDot, groups.domain, Domain);
    const DomainDotTld = makeState(Url);
    ta(DomainDot, groups.tld, DomainDotTld);
    ta(DomainDot, groups.utld, DomainDotTld);
    ta(DomainDotTld, groups.domain, Domain);
    ta(DomainDotTld, localpartAccepting, Localpart);
    tt(DomainDotTld, DOT, DomainDot);
    tt(DomainDotTld, HYPHEN, DomainHyphen);
    tt(DomainDotTld, AT, LocalpartAt);
    const DomainDotTldColon = tt(DomainDotTld, COLON);
    const DomainDotTldColonPort = makeState(Url);
    ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
    const Url$1 = makeState(Url);
    const UrlNonaccept = makeState();
    ta(Url$1, qsAccepting, Url$1);
    ta(Url$1, qsNonAccepting, UrlNonaccept);
    ta(UrlNonaccept, qsAccepting, Url$1);
    ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
    tt(DomainDotTld, SLASH, Url$1);
    tt(DomainDotTldColonPort, SLASH, Url$1);
    const SchemeColon = tt(Scheme, COLON);
    const SlashSchemeColon = tt(SlashScheme, COLON);
    const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
    const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
    ta(Scheme, groups.domain, Domain);
    tt(Scheme, DOT, DomainDot);
    tt(Scheme, HYPHEN, DomainHyphen);
    ta(SlashScheme, groups.domain, Domain);
    tt(SlashScheme, DOT, DomainDot);
    tt(SlashScheme, HYPHEN, DomainHyphen);
    ta(SchemeColon, groups.domain, Url$1);
    tt(SchemeColon, SLASH, Url$1);
    ta(UriPrefix, groups.domain, Url$1);
    ta(UriPrefix, qsAccepting, Url$1);
    tt(UriPrefix, SLASH, Url$1);
    const bracketPairs = [
      [OPENBRACE, CLOSEBRACE],
      // {}
      [OPENBRACKET, CLOSEBRACKET],
      // []
      [OPENPAREN, CLOSEPAREN],
      // ()
      [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
      // <>
      [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
      // 
      [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
      // 
      [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
      // 
      [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
      // 
    ];
    for (let i = 0; i < bracketPairs.length; i++) {
      const [OPEN, CLOSE] = bracketPairs[i];
      const UrlOpen = tt(Url$1, OPEN);
      tt(UrlNonaccept, OPEN, UrlOpen);
      tt(UrlOpen, CLOSE, Url$1);
      const UrlOpenQ = makeState(Url);
      ta(UrlOpen, qsAccepting, UrlOpenQ);
      const UrlOpenSyms = makeState();
      ta(UrlOpen, qsNonAccepting);
      ta(UrlOpenQ, qsAccepting, UrlOpenQ);
      ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
      ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
      ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
      tt(UrlOpenQ, CLOSE, Url$1);
      tt(UrlOpenSyms, CLOSE, Url$1);
    }
    tt(Start, LOCALHOST, DomainDotTld);
    tt(Start, NL$1, Nl);
    return {
      start: Start,
      tokens: tk
    };
  }
  function run2(start3, input, tokens) {
    let len = tokens.length;
    let cursor = 0;
    let multis = [];
    let textTokens = [];
    while (cursor < len) {
      let state = start3;
      let secondState = null;
      let nextState = null;
      let multiLength = 0;
      let latestAccepting = null;
      let sinceAccepts = -1;
      while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
        textTokens.push(tokens[cursor++]);
      }
      while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
        secondState = null;
        state = nextState;
        if (state.accepts()) {
          sinceAccepts = 0;
          latestAccepting = state;
        } else if (sinceAccepts >= 0) {
          sinceAccepts++;
        }
        cursor++;
        multiLength++;
      }
      if (sinceAccepts < 0) {
        cursor -= multiLength;
        if (cursor < len) {
          textTokens.push(tokens[cursor]);
          cursor++;
        }
      } else {
        if (textTokens.length > 0) {
          multis.push(initMultiToken(Text, input, textTokens));
          textTokens = [];
        }
        cursor -= sinceAccepts;
        multiLength -= sinceAccepts;
        const Multi = latestAccepting.t;
        const subtokens = tokens.slice(cursor - multiLength, cursor);
        multis.push(initMultiToken(Multi, input, subtokens));
      }
    }
    if (textTokens.length > 0) {
      multis.push(initMultiToken(Text, input, textTokens));
    }
    return multis;
  }
  function initMultiToken(Multi, input, tokens) {
    const startIdx = tokens[0].s;
    const endIdx = tokens[tokens.length - 1].e;
    const value = input.slice(startIdx, endIdx);
    return new Multi(value, tokens);
  }
  function reset() {
    State.groups = {};
    INIT.scanner = null;
    INIT.parser = null;
    INIT.tokenQueue = [];
    INIT.pluginQueue = [];
    INIT.customSchemes = [];
    INIT.initialized = false;
  }
  function registerCustomProtocol(scheme2, optionalSlashSlash) {
    if (optionalSlashSlash === void 0) {
      optionalSlashSlash = false;
    }
    if (INIT.initialized) {
      warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
    }
    if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
      throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
    }
    INIT.customSchemes.push([scheme2, optionalSlashSlash]);
  }
  function init() {
    INIT.scanner = init$2(INIT.customSchemes);
    for (let i = 0; i < INIT.tokenQueue.length; i++) {
      INIT.tokenQueue[i][1]({
        scanner: INIT.scanner
      });
    }
    INIT.parser = init$1(INIT.scanner.tokens);
    for (let i = 0; i < INIT.pluginQueue.length; i++) {
      INIT.pluginQueue[i][1]({
        scanner: INIT.scanner,
        parser: INIT.parser
      });
    }
    INIT.initialized = true;
  }
  function tokenize2(str) {
    if (!INIT.initialized) {
      init();
    }
    return run2(INIT.parser.start, str, run$12(INIT.scanner.start, str));
  }
  function find2(str, type, opts) {
    if (type === void 0) {
      type = null;
    }
    if (opts === void 0) {
      opts = null;
    }
    if (type && typeof type === "object") {
      if (opts) {
        throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
      }
      opts = type;
      type = null;
    }
    const options = new Options(opts);
    const tokens = tokenize2(str);
    const filtered = [];
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token.isLink && (!type || token.t === type) && options.check(token)) {
        filtered.push(token.toFormattedObject(options));
      }
    }
    return filtered;
  }
  var encodedTlds, encodedUtlds, assign, numeric, ascii, alpha2, asciinumeric, alphanumeric, domain, emoji, scheme, slashscheme, whitespace, ta, tr, ts, tt, WORD, UWORD, LOCALHOST, TLD, UTLD, SCHEME, SLASH_SCHEME, NUM, WS, NL$1, OPENBRACE, CLOSEBRACE, OPENBRACKET, CLOSEBRACKET, OPENPAREN, CLOSEPAREN, OPENANGLEBRACKET, CLOSEANGLEBRACKET, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN, AMPERSAND, APOSTROPHE, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, COLON, COMMA, DOLLAR, DOT, EQUALS, EXCLAMATION, HYPHEN, PERCENT, PIPE, PLUS, POUND, QUERY, QUOTE, SEMI, SLASH, TILDE, UNDERSCORE, EMOJI$1, SYM, tk, ASCII_LETTER, LETTER, EMOJI, DIGIT, SPACE, NL, EMOJI_VARIATION, EMOJI_JOINER, tlds, utlds, defaults3, Email, Text, Nl, Url, makeState, warn, warnAdvice, INIT;
  var init_linkify_es = __esm({
    "node_modules/linkifyjs/dist/linkify.es.js"() {
      encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
      encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
      assign = (target, properties) => {
        for (const key in properties) {
          target[key] = properties[key];
        }
        return target;
      };
      numeric = "numeric";
      ascii = "ascii";
      alpha2 = "alpha";
      asciinumeric = "asciinumeric";
      alphanumeric = "alphanumeric";
      domain = "domain";
      emoji = "emoji";
      scheme = "scheme";
      slashscheme = "slashscheme";
      whitespace = "whitespace";
      State.groups = {};
      State.prototype = {
        accepts() {
          return !!this.t;
        },
        /**
         * Follow an existing transition from the given input to the next state.
         * Does not mutate.
         * @param {string} input character or token type to transition on
         * @returns {?State<T>} the next state, if any
         */
        go(input) {
          const state = this;
          const nextState = state.j[input];
          if (nextState) {
            return nextState;
          }
          for (let i = 0; i < state.jr.length; i++) {
            const regex = state.jr[i][0];
            const nextState2 = state.jr[i][1];
            if (nextState2 && regex.test(input)) {
              return nextState2;
            }
          }
          return state.jd;
        },
        /**
         * Whether the state has a transition for the given input. Set the second
         * argument to true to only look for an exact match (and not a default or
         * regular-expression-based transition)
         * @param {string} input
         * @param {boolean} exactOnly
         */
        has(input, exactOnly) {
          if (exactOnly === void 0) {
            exactOnly = false;
          }
          return exactOnly ? input in this.j : !!this.go(input);
        },
        /**
         * Short for "transition all"; create a transition from the array of items
         * in the given list to the same final resulting state.
         * @param {string | string[]} inputs Group of inputs to transition on
         * @param {Transition<T> | State<T>} [next] Transition options
         * @param {Flags} [flags] Collections flags to add token to
         * @param {Collections<T>} [groups] Master list of token groups
         */
        ta(inputs, next, flags, groups) {
          for (let i = 0; i < inputs.length; i++) {
            this.tt(inputs[i], next, flags, groups);
          }
        },
        /**
         * Short for "take regexp transition"; defines a transition for this state
         * when it encounters a token which matches the given regular expression
         * @param {RegExp} regexp Regular expression transition (populate first)
         * @param {T | State<T>} [next] Transition options
         * @param {Flags} [flags] Collections flags to add token to
         * @param {Collections<T>} [groups] Master list of token groups
         * @returns {State<T>} taken after the given input
         */
        tr(regexp, next, flags, groups) {
          groups = groups || State.groups;
          let nextState;
          if (next && next.j) {
            nextState = next;
          } else {
            nextState = new State(next);
            if (flags && groups) {
              addToGroups(next, flags, groups);
            }
          }
          this.jr.push([regexp, nextState]);
          return nextState;
        },
        /**
         * Short for "take transitions", will take as many sequential transitions as
         * the length of the given input and returns the
         * resulting final state.
         * @param {string | string[]} input
         * @param {T | State<T>} [next] Transition options
         * @param {Flags} [flags] Collections flags to add token to
         * @param {Collections<T>} [groups] Master list of token groups
         * @returns {State<T>} taken after the given input
         */
        ts(input, next, flags, groups) {
          let state = this;
          const len = input.length;
          if (!len) {
            return state;
          }
          for (let i = 0; i < len - 1; i++) {
            state = state.tt(input[i]);
          }
          return state.tt(input[len - 1], next, flags, groups);
        },
        /**
         * Short for "take transition", this is a method for building/working with
         * state machines.
         *
         * If a state already exists for the given input, returns it.
         *
         * If a token is specified, that state will emit that token when reached by
         * the linkify engine.
         *
         * If no state exists, it will be initialized with some default transitions
         * that resemble existing default transitions.
         *
         * If a state is given for the second argument, that state will be
         * transitioned to on the given input regardless of what that input
         * previously did.
         *
         * Specify a token group flags to define groups that this token belongs to.
         * The token will be added to corresponding entires in the given groups
         * object.
         *
         * @param {string} input character, token type to transition on
         * @param {T | State<T>} [next] Transition options
         * @param {Flags} [flags] Collections flags to add token to
         * @param {Collections<T>} [groups] Master list of groups
         * @returns {State<T>} taken after the given input
         */
        tt(input, next, flags, groups) {
          groups = groups || State.groups;
          const state = this;
          if (next && next.j) {
            state.j[input] = next;
            return next;
          }
          const t = next;
          let nextState, templateState = state.go(input);
          if (templateState) {
            nextState = new State();
            assign(nextState.j, templateState.j);
            nextState.jr.push.apply(nextState.jr, templateState.jr);
            nextState.jd = templateState.jd;
            nextState.t = templateState.t;
          } else {
            nextState = new State();
          }
          if (t) {
            if (groups) {
              if (nextState.t && typeof nextState.t === "string") {
                const allFlags = assign(flagsForToken(nextState.t, groups), flags);
                addToGroups(t, allFlags, groups);
              } else if (flags) {
                addToGroups(t, flags, groups);
              }
            }
            nextState.t = t;
          }
          state.j[input] = nextState;
          return nextState;
        }
      };
      ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
      tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
      ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
      tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
      WORD = "WORD";
      UWORD = "UWORD";
      LOCALHOST = "LOCALHOST";
      TLD = "TLD";
      UTLD = "UTLD";
      SCHEME = "SCHEME";
      SLASH_SCHEME = "SLASH_SCHEME";
      NUM = "NUM";
      WS = "WS";
      NL$1 = "NL";
      OPENBRACE = "OPENBRACE";
      CLOSEBRACE = "CLOSEBRACE";
      OPENBRACKET = "OPENBRACKET";
      CLOSEBRACKET = "CLOSEBRACKET";
      OPENPAREN = "OPENPAREN";
      CLOSEPAREN = "CLOSEPAREN";
      OPENANGLEBRACKET = "OPENANGLEBRACKET";
      CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
      FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
      FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
      LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
      RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
      LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
      RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
      FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
      FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
      AMPERSAND = "AMPERSAND";
      APOSTROPHE = "APOSTROPHE";
      ASTERISK = "ASTERISK";
      AT = "AT";
      BACKSLASH = "BACKSLASH";
      BACKTICK = "BACKTICK";
      CARET = "CARET";
      COLON = "COLON";
      COMMA = "COMMA";
      DOLLAR = "DOLLAR";
      DOT = "DOT";
      EQUALS = "EQUALS";
      EXCLAMATION = "EXCLAMATION";
      HYPHEN = "HYPHEN";
      PERCENT = "PERCENT";
      PIPE = "PIPE";
      PLUS = "PLUS";
      POUND = "POUND";
      QUERY = "QUERY";
      QUOTE = "QUOTE";
      SEMI = "SEMI";
      SLASH = "SLASH";
      TILDE = "TILDE";
      UNDERSCORE = "UNDERSCORE";
      EMOJI$1 = "EMOJI";
      SYM = "SYM";
      tk = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        WORD,
        UWORD,
        LOCALHOST,
        TLD,
        UTLD,
        SCHEME,
        SLASH_SCHEME,
        NUM,
        WS,
        NL: NL$1,
        OPENBRACE,
        CLOSEBRACE,
        OPENBRACKET,
        CLOSEBRACKET,
        OPENPAREN,
        CLOSEPAREN,
        OPENANGLEBRACKET,
        CLOSEANGLEBRACKET,
        FULLWIDTHLEFTPAREN,
        FULLWIDTHRIGHTPAREN,
        LEFTCORNERBRACKET,
        RIGHTCORNERBRACKET,
        LEFTWHITECORNERBRACKET,
        RIGHTWHITECORNERBRACKET,
        FULLWIDTHLESSTHAN,
        FULLWIDTHGREATERTHAN,
        AMPERSAND,
        APOSTROPHE,
        ASTERISK,
        AT,
        BACKSLASH,
        BACKTICK,
        CARET,
        COLON,
        COMMA,
        DOLLAR,
        DOT,
        EQUALS,
        EXCLAMATION,
        HYPHEN,
        PERCENT,
        PIPE,
        PLUS,
        POUND,
        QUERY,
        QUOTE,
        SEMI,
        SLASH,
        TILDE,
        UNDERSCORE,
        EMOJI: EMOJI$1,
        SYM
      });
      ASCII_LETTER = /[a-z]/;
      LETTER = /\p{L}/u;
      EMOJI = /\p{Emoji}/u;
      DIGIT = /\d/;
      SPACE = /\s/;
      NL = "\n";
      EMOJI_VARIATION = "\uFE0F";
      EMOJI_JOINER = "\u200D";
      tlds = null;
      utlds = null;
      defaults3 = {
        defaultProtocol: "http",
        events: null,
        format: noop2,
        formatHref: noop2,
        nl2br: false,
        tagName: "a",
        target: null,
        rel: null,
        validate: true,
        truncate: Infinity,
        className: null,
        attributes: null,
        ignoreTags: [],
        render: null
      };
      Options.prototype = {
        o: defaults3,
        /**
         * @type string[]
         */
        ignoreTags: [],
        /**
         * @param {IntermediateRepresentation} ir
         * @returns {any}
         */
        defaultRender(ir) {
          return ir;
        },
        /**
         * Returns true or false based on whether a token should be displayed as a
         * link based on the user options.
         * @param {MultiToken} token
         * @returns {boolean}
         */
        check(token) {
          return this.get("validate", token.toString(), token);
        },
        // Private methods
        /**
         * Resolve an option's value based on the value of the option and the given
         * params. If operator and token are specified and the target option is
         * callable, automatically calls the function with the given argument.
         * @template {keyof Opts} K
         * @param {K} key Name of option to use
         * @param {string} [operator] will be passed to the target option if it's a
         * function. If not specified, RAW function value gets returned
         * @param {MultiToken} [token] The token from linkify.tokenize
         * @returns {Opts[K] | any}
         */
        get(key, operator, token) {
          const isCallable = operator != null;
          let option2 = this.o[key];
          if (!option2) {
            return option2;
          }
          if (typeof option2 === "object") {
            option2 = token.t in option2 ? option2[token.t] : defaults3[key];
            if (typeof option2 === "function" && isCallable) {
              option2 = option2(operator, token);
            }
          } else if (typeof option2 === "function" && isCallable) {
            option2 = option2(operator, token.t, token);
          }
          return option2;
        },
        /**
         * @template {keyof Opts} L
         * @param {L} key Name of options object to use
         * @param {string} [operator]
         * @param {MultiToken} [token]
         * @returns {Opts[L] | any}
         */
        getObj(key, operator, token) {
          let obj = this.o[key];
          if (typeof obj === "function" && operator != null) {
            obj = obj(operator, token.t, token);
          }
          return obj;
        },
        /**
         * Convert the given token to a rendered element that may be added to the
         * calling-interface's DOM
         * @param {MultiToken} token Token to render to an HTML element
         * @returns {any} Render result; e.g., HTML string, DOM element, React
         *   Component, etc.
         */
        render(token) {
          const ir = token.render(this);
          const renderFn = this.get("render", null, token) || this.defaultRender;
          return renderFn(ir, token.t, token);
        }
      };
      MultiToken.prototype = {
        isLink: false,
        /**
         * Return the string this token represents.
         * @return {string}
         */
        toString() {
          return this.v;
        },
        /**
         * What should the value for this token be in the `href` HTML attribute?
         * Returns the `.toString` value by default.
         * @param {string} [scheme]
         * @return {string}
        */
        toHref(scheme2) {
          return this.toString();
        },
        /**
         * @param {Options} options Formatting options
         * @returns {string}
         */
        toFormattedString(options) {
          const val = this.toString();
          const truncate = options.get("truncate", val, this);
          const formatted = options.get("format", val, this);
          return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
        },
        /**
         *
         * @param {Options} options
         * @returns {string}
         */
        toFormattedHref(options) {
          return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
        },
        /**
         * The start index of this token in the original input string
         * @returns {number}
         */
        startIndex() {
          return this.tk[0].s;
        },
        /**
         * The end index of this token in the original input string (up to this
         * index but not including it)
         * @returns {number}
         */
        endIndex() {
          return this.tk[this.tk.length - 1].e;
        },
        /**
        	Returns an object  of relevant values for this token, which includes keys
        	* type - Kind of token ('url', 'email', etc.)
        	* value - Original text
        	* href - The value that should be added to the anchor tag's href
        		attribute
        		@method toObject
        	@param {string} [protocol] `'http'` by default
        */
        toObject(protocol) {
          if (protocol === void 0) {
            protocol = defaults3.defaultProtocol;
          }
          return {
            type: this.t,
            value: this.toString(),
            isLink: this.isLink,
            href: this.toHref(protocol),
            start: this.startIndex(),
            end: this.endIndex()
          };
        },
        /**
         *
         * @param {Options} options Formatting option
         */
        toFormattedObject(options) {
          return {
            type: this.t,
            value: this.toFormattedString(options),
            isLink: this.isLink,
            href: this.toFormattedHref(options),
            start: this.startIndex(),
            end: this.endIndex()
          };
        },
        /**
         * Whether this token should be rendered as a link according to the given options
         * @param {Options} options
         * @returns {boolean}
         */
        validate(options) {
          return options.get("validate", this.toString(), this);
        },
        /**
         * Return an object that represents how this link should be rendered.
         * @param {Options} options Formattinng options
         */
        render(options) {
          const token = this;
          const href = this.toHref(options.get("defaultProtocol"));
          const formattedHref = options.get("formatHref", href, this);
          const tagName = options.get("tagName", href, token);
          const content = this.toFormattedString(options);
          const attributes = {};
          const className = options.get("className", href, token);
          const target = options.get("target", href, token);
          const rel = options.get("rel", href, token);
          const attrs = options.getObj("attributes", href, token);
          const eventListeners = options.getObj("events", href, token);
          attributes.href = formattedHref;
          if (className) {
            attributes.class = className;
          }
          if (target) {
            attributes.target = target;
          }
          if (rel) {
            attributes.rel = rel;
          }
          if (attrs) {
            assign(attributes, attrs);
          }
          return {
            tagName,
            attributes,
            content,
            eventListeners
          };
        }
      };
      Email = createTokenClass("email", {
        isLink: true,
        toHref() {
          return "mailto:" + this.toString();
        }
      });
      Text = createTokenClass("text");
      Nl = createTokenClass("nl");
      Url = createTokenClass("url", {
        isLink: true,
        /**
        	Lowercases relevant parts of the domain and adds the protocol if
        	required. Note that this will not escape unsafe HTML characters in the
        	URL.
        		@param {string} [scheme] default scheme (e.g., 'https')
        	@return {string} the full href
        */
        toHref(scheme2) {
          if (scheme2 === void 0) {
            scheme2 = defaults3.defaultProtocol;
          }
          return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
        },
        /**
         * Check whether this URL token has a protocol
         * @return {boolean}
         */
        hasProtocol() {
          const tokens = this.tk;
          return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
        }
      });
      makeState = (arg) => new State(arg);
      warn = typeof console !== "undefined" && console && console.warn || (() => {
      });
      warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
      INIT = {
        scanner: null,
        parser: null,
        tokenQueue: [],
        pluginQueue: [],
        customSchemes: [],
        initialized: false
      };
    }
  });

  // node_modules/@tiptap/extension-link/dist/index.js
  var dist_exports20 = {};
  __export(dist_exports20, {
    Link: () => Link,
    default: () => Link,
    pasteRegex: () => pasteRegex3
  });
  function autolink(options) {
    return new Plugin({
      key: new PluginKey("autolink"),
      appendTransaction: (transactions, oldState, newState) => {
        const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
        const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
        if (!docChanges || preventAutolink) {
          return;
        }
        const { tr: tr2 } = newState;
        const transform = combineTransactionSteps(oldState.doc, [...transactions]);
        const changes = getChangedRanges(transform);
        changes.forEach(({ newRange }) => {
          const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
          let textBlock;
          let textBeforeWhitespace;
          if (nodesInChangedRanges.length > 1) {
            textBlock = nodesInChangedRanges[0];
            textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
          } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
            textBlock = nodesInChangedRanges[0];
            textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
          }
          if (textBlock && textBeforeWhitespace) {
            const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s) => s !== "");
            if (wordsBeforeWhitespace.length <= 0) {
              return false;
            }
            const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
            const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
            if (!lastWordBeforeSpace) {
              return false;
            }
            find2(lastWordBeforeSpace).filter((link) => link.isLink).map((link) => ({
              ...link,
              from: lastWordAndBlockOffset + link.start + 1,
              to: lastWordAndBlockOffset + link.end + 1
            })).filter((link) => {
              if (!newState.schema.marks.code) {
                return true;
              }
              return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
            }).filter((link) => {
              if (options.validate) {
                return options.validate(link.value);
              }
              return true;
            }).forEach((link) => {
              if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
                return;
              }
              tr2.addMark(link.from, link.to, options.type.create({
                href: link.href
              }));
            });
          }
        });
        if (!tr2.steps.length) {
          return;
        }
        return tr2;
      }
    });
  }
  function clickHandler(options) {
    return new Plugin({
      key: new PluginKey("handleClickLink"),
      props: {
        handleClick: (view, pos, event) => {
          var _a, _b;
          if (event.button !== 0) {
            return false;
          }
          let a = event.target;
          const els = [];
          while (a.nodeName !== "DIV") {
            els.push(a);
            a = a.parentNode;
          }
          if (!els.find((value) => value.nodeName === "A")) {
            return false;
          }
          const attrs = getAttributes(view.state, options.type.name);
          const link = event.target;
          const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;
          const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;
          if (link && href) {
            window.open(href, target);
            return true;
          }
          return false;
        }
      }
    });
  }
  function pasteHandler(options) {
    return new Plugin({
      key: new PluginKey("handlePasteLink"),
      props: {
        handlePaste: (view, event, slice2) => {
          const { state } = view;
          const { selection } = state;
          const { empty: empty2 } = selection;
          if (empty2) {
            return false;
          }
          let textContent = "";
          slice2.content.forEach((node) => {
            textContent += node.textContent;
          });
          const link = find2(textContent).find((item) => item.isLink && item.value === textContent);
          if (!textContent || !link) {
            return false;
          }
          options.editor.commands.setMark(options.type, {
            href: link.href
          });
          return true;
        }
      }
    });
  }
  var pasteRegex3, Link;
  var init_dist44 = __esm({
    "node_modules/@tiptap/extension-link/dist/index.js"() {
      init_dist16();
      init_linkify_es();
      init_dist5();
      pasteRegex3 = /https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z]{2,}\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;
      Link = Mark2.create({
        name: "link",
        priority: 1e3,
        keepOnSplit: false,
        onCreate() {
          this.options.protocols.forEach((protocol) => {
            if (typeof protocol === "string") {
              registerCustomProtocol(protocol);
              return;
            }
            registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
          });
        },
        onDestroy() {
          reset();
        },
        inclusive() {
          return this.options.autolink;
        },
        addOptions() {
          return {
            openOnClick: true,
            linkOnPaste: true,
            autolink: true,
            protocols: [],
            HTMLAttributes: {
              target: "_blank",
              rel: "noopener noreferrer nofollow",
              class: null
            },
            validate: void 0
          };
        },
        addAttributes() {
          return {
            href: {
              default: null
            },
            target: {
              default: this.options.HTMLAttributes.target
            },
            rel: {
              default: this.options.HTMLAttributes.rel
            },
            class: {
              default: this.options.HTMLAttributes.class
            }
          };
        },
        parseHTML() {
          return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
        },
        renderHTML({ HTMLAttributes }) {
          var _a;
          if ((_a = HTMLAttributes.href) === null || _a === void 0 ? void 0 : _a.startsWith("javascript:")) {
            return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
          }
          return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setLink: (attributes) => ({ chain }) => {
              return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
            },
            toggleLink: (attributes) => ({ chain }) => {
              return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
            },
            unsetLink: () => ({ chain }) => {
              return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
            }
          };
        },
        addPasteRules() {
          return [
            markPasteRule({
              find: (text, event) => {
                var _a;
                const html = (_a = event === null || event === void 0 ? void 0 : event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
                const foundLinks = [];
                if (html) {
                  const dom = new DOMParser().parseFromString(html, "text/html");
                  const anchors = dom.querySelectorAll("a");
                  if (anchors.length) {
                    [...anchors].forEach((anchor) => foundLinks.push({
                      text: anchor.innerText,
                      data: {
                        href: anchor.getAttribute("href")
                      },
                      // get the index of the anchor inside the text
                      // and add the length of the anchor text
                      index: dom.body.innerText.indexOf(anchor.innerText) + anchor.innerText.length
                    }));
                  }
                }
                if (text) {
                  const links = find2(text).filter((item) => item.isLink);
                  if (links.length) {
                    links.forEach((link) => foundLinks.push({
                      text: link.value,
                      data: {
                        href: link.href
                      },
                      index: link.start
                    }));
                  }
                }
                return foundLinks;
              },
              type: this.type,
              getAttributes: (match) => {
                var _a;
                return {
                  href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href
                };
              }
            })
          ];
        },
        addProseMirrorPlugins() {
          const plugins3 = [];
          if (this.options.autolink) {
            plugins3.push(autolink({
              type: this.type,
              validate: this.options.validate
            }));
          }
          if (this.options.openOnClick) {
            plugins3.push(clickHandler({
              type: this.type
            }));
          }
          if (this.options.linkOnPaste) {
            plugins3.push(pasteHandler({
              editor: this.editor,
              type: this.type
            }));
          }
          return plugins3;
        }
      });
    }
  });

  // node_modules/@tiptap/suggestion/dist/index.js
  function findSuggestionMatch(config) {
    var _a;
    const { char, allowSpaces, allowedPrefixes, startOfLine, $position } = config;
    const escapedChar = escapeForRegEx(char);
    const suffix = new RegExp(`\\s${escapedChar}$`);
    const prefix = startOfLine ? "^" : "";
    const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${escapedChar}|$)`, "gm") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${escapedChar}]*`, "gm");
    const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;
    if (!text) {
      return null;
    }
    const textFrom = $position.pos - text.length;
    const match = Array.from(text.matchAll(regexp)).pop();
    if (!match || match.input === void 0 || match.index === void 0) {
      return null;
    }
    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
    const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
    if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
      return null;
    }
    const from3 = textFrom + match.index;
    let to2 = from3 + match[0].length;
    if (allowSpaces && suffix.test(text.slice(to2 - 1, to2 + 1))) {
      match[0] += " ";
      to2 += 1;
    }
    if (from3 < $position.pos && to2 >= $position.pos) {
      return {
        range: {
          from: from3,
          to: to2
        },
        query: match[0].slice(char.length),
        text: match[0]
      };
    }
    return null;
  }
  function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, allowedPrefixes = [" "], startOfLine = false, decorationTag = "span", decorationClass = "suggestion", command: command2 = () => null, items = () => [], render: render2 = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch }) {
    let props;
    const renderer = render2 === null || render2 === void 0 ? void 0 : render2();
    const plugin = new Plugin({
      key: pluginKey,
      view() {
        return {
          update: async (view, prevState) => {
            var _a, _b, _c, _d, _e, _f, _g;
            const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
            const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
            const moved2 = prev.active && next.active && prev.range.from !== next.range.from;
            const started = !prev.active && next.active;
            const stopped = prev.active && !next.active;
            const changed = !started && !stopped && prev.query !== next.query;
            const handleStart = started || moved2;
            const handleChange = changed && !moved2;
            const handleExit = stopped || moved2;
            if (!handleStart && !handleChange && !handleExit) {
              return;
            }
            const state = handleExit && !handleStart ? prev : next;
            const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
            props = {
              editor,
              range: state.range,
              query: state.query,
              text: state.text,
              items: [],
              command: (commandProps) => {
                command2({
                  editor,
                  range: state.range,
                  props: commandProps
                });
              },
              decorationNode,
              // virtual node for popper.js or tippy.js
              // this can be used for building popups without a DOM node
              clientRect: decorationNode ? () => {
                var _a2;
                const { decorationId } = (_a2 = this.key) === null || _a2 === void 0 ? void 0 : _a2.getState(editor.state);
                const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
                return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
              } : null
            };
            if (handleStart) {
              (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
            }
            if (handleChange) {
              (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
            }
            if (handleChange || handleStart) {
              props.items = await items({
                editor,
                query: state.query
              });
            }
            if (handleExit) {
              (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
            }
            if (handleChange) {
              (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);
            }
            if (handleStart) {
              (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
            }
          },
          destroy: () => {
            var _a;
            if (!props) {
              return;
            }
            (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);
          }
        };
      },
      state: {
        // Initialize the plugin's internal state.
        init() {
          const state = {
            active: false,
            range: {
              from: 0,
              to: 0
            },
            query: null,
            text: null,
            composing: false
          };
          return state;
        },
        // Apply changes to the plugin state from a view transaction.
        apply(transaction, prev, oldState, state) {
          const { isEditable } = editor;
          const { composing } = editor.view;
          const { selection } = transaction;
          const { empty: empty2, from: from3 } = selection;
          const next = { ...prev };
          next.composing = composing;
          if (isEditable && (empty2 || editor.view.composing)) {
            if ((from3 < prev.range.from || from3 > prev.range.to) && !composing && !prev.composing) {
              next.active = false;
            }
            const match = findSuggestionMatch$1({
              char,
              allowSpaces,
              allowedPrefixes,
              startOfLine,
              $position: selection.$from
            });
            const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
            if (match && allow({ editor, state, range: match.range })) {
              next.active = true;
              next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
              next.range = match.range;
              next.query = match.query;
              next.text = match.text;
            } else {
              next.active = false;
            }
          } else {
            next.active = false;
          }
          if (!next.active) {
            next.decorationId = null;
            next.range = { from: 0, to: 0 };
            next.query = null;
            next.text = null;
          }
          return next;
        }
      },
      props: {
        // Call the keydown hook if suggestion is active.
        handleKeyDown(view, event) {
          var _a;
          const { active, range } = plugin.getState(view.state);
          if (!active) {
            return false;
          }
          return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;
        },
        // Setup decorator on the currently active suggestion.
        decorations(state) {
          const { active, range, decorationId } = plugin.getState(state);
          if (!active) {
            return null;
          }
          return DecorationSet.create(state.doc, [
            Decoration.inline(range.from, range.to, {
              nodeName: decorationTag,
              class: decorationClass,
              "data-decoration-id": decorationId
            })
          ]);
        }
      }
    });
    return plugin;
  }
  var SuggestionPluginKey;
  var init_dist45 = __esm({
    "node_modules/@tiptap/suggestion/dist/index.js"() {
      init_dist5();
      init_dist7();
      init_dist16();
      SuggestionPluginKey = new PluginKey("suggestion");
    }
  });

  // node_modules/@tiptap/extension-mention/dist/index.js
  var dist_exports21 = {};
  __export(dist_exports21, {
    Mention: () => Mention,
    MentionPluginKey: () => MentionPluginKey,
    default: () => Mention
  });
  var MentionPluginKey, Mention;
  var init_dist46 = __esm({
    "node_modules/@tiptap/extension-mention/dist/index.js"() {
      init_dist16();
      init_dist5();
      init_dist45();
      MentionPluginKey = new PluginKey("mention");
      Mention = Node3.create({
        name: "mention",
        addOptions() {
          return {
            HTMLAttributes: {},
            renderText({ options, node }) {
              var _a;
              return `${options.suggestion.char}${(_a = node.attrs.label) !== null && _a !== void 0 ? _a : node.attrs.id}`;
            },
            renderHTML({ options, node }) {
              var _a;
              return [
                "span",
                this.HTMLAttributes,
                `${options.suggestion.char}${(_a = node.attrs.label) !== null && _a !== void 0 ? _a : node.attrs.id}`
              ];
            },
            suggestion: {
              char: "@",
              pluginKey: MentionPluginKey,
              command: ({ editor, range, props }) => {
                var _a, _b;
                const nodeAfter = editor.view.state.selection.$to.nodeAfter;
                const overrideSpace = (_a = nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.text) === null || _a === void 0 ? void 0 : _a.startsWith(" ");
                if (overrideSpace) {
                  range.to += 1;
                }
                editor.chain().focus().insertContentAt(range, [
                  {
                    type: this.name,
                    attrs: props
                  },
                  {
                    type: "text",
                    text: " "
                  }
                ]).run();
                (_b = window.getSelection()) === null || _b === void 0 ? void 0 : _b.collapseToEnd();
              },
              allow: ({ state, range }) => {
                const $from = state.doc.resolve(range.from);
                const type = state.schema.nodes[this.name];
                const allow = !!$from.parent.type.contentMatch.matchType(type);
                return allow;
              }
            }
          };
        },
        group: "inline",
        inline: true,
        selectable: false,
        atom: true,
        addAttributes() {
          return {
            id: {
              default: null,
              parseHTML: (element) => element.getAttribute("data-id"),
              renderHTML: (attributes) => {
                if (!attributes.id) {
                  return {};
                }
                return {
                  "data-id": attributes.id
                };
              }
            },
            label: {
              default: null,
              parseHTML: (element) => element.getAttribute("data-label"),
              renderHTML: (attributes) => {
                if (!attributes.label) {
                  return {};
                }
                return {
                  "data-label": attributes.label
                };
              }
            }
          };
        },
        parseHTML() {
          return [
            {
              tag: `span[data-type="${this.name}"]`
            }
          ];
        },
        renderHTML({ node, HTMLAttributes }) {
          if (this.options.renderLabel !== void 0) {
            console.warn("renderLabel is deprecated use renderText and renderHTML instead");
            return [
              "span",
              mergeAttributes({ "data-type": this.name }, this.options.HTMLAttributes, HTMLAttributes),
              this.options.renderLabel({
                options: this.options,
                node
              })
            ];
          }
          const html = this.options.renderHTML({
            options: this.options,
            node
          });
          if (typeof html === "string") {
            return [
              "span",
              mergeAttributes({ "data-type": this.name }, this.options.HTMLAttributes, HTMLAttributes),
              html
            ];
          }
          return html;
        },
        renderText({ node }) {
          if (this.options.renderLabel !== void 0) {
            console.warn("renderLabel is deprecated use renderText and renderHTML instead");
            return this.options.renderLabel({
              options: this.options,
              node
            });
          }
          return this.options.renderText({
            options: this.options,
            node
          });
        },
        addKeyboardShortcuts() {
          return {
            Backspace: () => this.editor.commands.command(({ tr: tr2, state }) => {
              let isMention = false;
              const { selection } = state;
              const { empty: empty2, anchor } = selection;
              if (!empty2) {
                return false;
              }
              state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {
                if (node.type.name === this.name) {
                  isMention = true;
                  tr2.insertText(this.options.suggestion.char || "", pos, pos + node.nodeSize);
                  return false;
                }
              });
              return isMention;
            })
          };
        },
        addProseMirrorPlugins() {
          return [
            Suggestion({
              editor: this.editor,
              ...this.options.suggestion
            })
          ];
        }
      });
    }
  });

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/suggestions/popup_list_component.js
  var import_lodash3, createRoot, createItem, PopUpListComponent;
  var init_popup_list_component = __esm({
    "node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/suggestions/popup_list_component.js"() {
      import_lodash3 = __toESM(require_lodash());
      createRoot = ({ className } = {}) => {
        const div2 = document.createElement("div");
        div2.classList.add("dropdown-content", className);
        return div2;
      };
      createItem = (list, index3, item, classNames = "") => {
        const div2 = document.createElement("div");
        div2.classList.add("dropdown-item", classNames);
        if (item.icon) {
          div2.innerHTML = `<span class='icon'>${item.icon}</span><span>${item.title}</span>`;
        } else {
          div2.innerHTML = item.title;
        }
        div2.addEventListener("mousemove", () => list.throttledUpdateActiveItem(index3));
        div2.addEventListener("mousedown", () => list.selectItem(index3));
        return div2;
      };
      PopUpListComponent = class {
        constructor({ rootOptions } = {}) {
          this.selectedIndex = 0;
          this.items = [];
          this.command = () => {
          };
          this.element = createRoot(rootOptions);
        }
        render() {
          this.element.innerHTML = "";
          this.items.forEach((item, index3) => {
            const classNames = index3 === this.selectedIndex ? "is-active" : "inactive";
            this.element.appendChild(createItem(this, index3, item, classNames));
          });
          return this.element;
        }
        updateProps({ items, command: command2 }) {
          this.items = items;
          this.command = command2;
        }
        throttledUpdateActiveItem = (0, import_lodash3.default)(this.updateActiveItem, 100);
        selectItem(index3) {
          const { url, title, command: command2 } = this.items[index3];
          this.command({ id: url, url, label: title, command: command2 });
        }
        selectActiveItem() {
          this.selectItem(this.selectedIndex);
        }
        updateActiveItem(index3) {
          this.selectedIndex = index3;
          this.render();
        }
        goUp() {
          const newSelectedIndex = (this.selectedIndex + this.items.length - 1) % this.items.length;
          this.updateActiveItem(newSelectedIndex);
        }
        goDown() {
          const newSelectedIndex = (this.selectedIndex + 1) % this.items.length;
          this.updateActiveItem(newSelectedIndex);
        }
        destroy() {
          this.element.remove();
        }
      };
    }
  });

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/suggestions/renderer.js
  var renderer_default;
  var init_renderer = __esm({
    "node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/suggestions/renderer.js"() {
      init_tippy_esm();
      init_popup_list_component();
      renderer_default = ({ popUpOptions } = {}) => {
        return () => {
          const component = new PopUpListComponent(popUpOptions);
          let popup;
          return {
            onStart: function({ items, command: command2, clientRect: clientRect2 }) {
              popup = tippy_esm_default("body", {
                getReferenceClientRect: clientRect2,
                appendTo: () => document.body,
                allowHTML: true,
                content: component.render(),
                showOnCreate: true,
                interactive: true,
                trigger: "manual",
                placement: "bottom-start",
                arrow: false
              });
              this.onUpdate({ items, command: command2, clientRect: clientRect2 });
            },
            onUpdate({ items, command: command2, clientRect: clientRect2 }) {
              component.updateProps({ items, command: command2 });
              component.render();
              popup[0].setProps({ getReferenceClientRect: clientRect2 });
            },
            onKeyDown({ event }) {
              if (event.key === "Escape") {
                popup[0].hide();
                return true;
              } else if (event.key === "Enter") {
                component.selectActiveItem();
                return true;
              } else if (event.key === "ArrowUp") {
                component.goUp();
                return true;
              } else if (event.key === "ArrowDown") {
                component.goDown();
                return true;
              }
            },
            onExit() {
              popup[0].destroy();
              component.destroy();
            }
          };
        };
      };
    }
  });

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/suggestions/pages_options.js
  var pages_options_exports = {};
  __export(pages_options_exports, {
    default: () => pages_options_default
  });
  var pages_options_default;
  var init_pages_options = __esm({
    "node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/suggestions/pages_options.js"() {
      init_src2();
      init_renderer();
      pages_options_default = {
        items: async ({ query }) => {
          const response = await get("/documentation/pages", {
            query: { title: query },
            responseKind: "json"
          });
          if (!response.ok)
            return [];
          return await response.json;
        },
        render: renderer_default()
      };
    }
  });

  // node_modules/@tiptap/extension-blockquote/dist/index.js
  var dist_exports22 = {};
  __export(dist_exports22, {
    Blockquote: () => Blockquote,
    default: () => Blockquote,
    inputRegex: () => inputRegex3
  });
  var inputRegex3, Blockquote;
  var init_dist47 = __esm({
    "node_modules/@tiptap/extension-blockquote/dist/index.js"() {
      init_dist16();
      inputRegex3 = /^\s*>\s$/;
      Blockquote = Node3.create({
        name: "blockquote",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        content: "block+",
        group: "block",
        defining: true,
        parseHTML() {
          return [
            { tag: "blockquote" }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setBlockquote: () => ({ commands: commands2 }) => {
              return commands2.wrapIn(this.name);
            },
            toggleBlockquote: () => ({ commands: commands2 }) => {
              return commands2.toggleWrap(this.name);
            },
            unsetBlockquote: () => ({ commands: commands2 }) => {
              return commands2.lift(this.name);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
          };
        },
        addInputRules() {
          return [
            wrappingInputRule({
              find: inputRegex3,
              type: this.type
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-bullet-list/dist/index.js
  var dist_exports23 = {};
  __export(dist_exports23, {
    BulletList: () => BulletList,
    default: () => BulletList,
    inputRegex: () => inputRegex4
  });
  var ListItem, TextStyle2, inputRegex4, BulletList;
  var init_dist48 = __esm({
    "node_modules/@tiptap/extension-bullet-list/dist/index.js"() {
      init_dist16();
      ListItem = Node3.create({
        name: "listItem",
        addOptions() {
          return {
            HTMLAttributes: {},
            bulletListTypeName: "bulletList",
            orderedListTypeName: "orderedList"
          };
        },
        content: "paragraph block*",
        defining: true,
        parseHTML() {
          return [
            {
              tag: "li"
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addKeyboardShortcuts() {
          return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
          };
        }
      });
      TextStyle2 = Mark2.create({
        name: "textStyle",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        parseHTML() {
          return [
            {
              tag: "span",
              getAttrs: (element) => {
                const hasStyles = element.hasAttribute("style");
                if (!hasStyles) {
                  return false;
                }
                return {};
              }
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
              const attributes = getMarkAttributes(state, this.type);
              const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
              if (hasStyles) {
                return true;
              }
              return commands2.unsetMark(this.name);
            }
          };
        }
      });
      inputRegex4 = /^\s*([-+*])\s$/;
      BulletList = Node3.create({
        name: "bulletList",
        addOptions() {
          return {
            itemTypeName: "listItem",
            HTMLAttributes: {},
            keepMarks: false,
            keepAttributes: false
          };
        },
        group: "block list",
        content() {
          return `${this.options.itemTypeName}+`;
        },
        parseHTML() {
          return [
            { tag: "ul" }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            toggleBulletList: () => ({ commands: commands2, chain }) => {
              if (this.options.keepAttributes) {
                return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle2.name)).run();
              }
              return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
          };
        },
        addInputRules() {
          let inputRule = wrappingInputRule({
            find: inputRegex4,
            type: this.type
          });
          if (this.options.keepMarks || this.options.keepAttributes) {
            inputRule = wrappingInputRule({
              find: inputRegex4,
              type: this.type,
              keepMarks: this.options.keepMarks,
              keepAttributes: this.options.keepAttributes,
              getAttributes: () => {
                return this.editor.getAttributes(TextStyle2.name);
              },
              editor: this.editor
            });
          }
          return [
            inputRule
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-code-block/dist/index.js
  var dist_exports24 = {};
  __export(dist_exports24, {
    CodeBlock: () => CodeBlock,
    backtickInputRegex: () => backtickInputRegex,
    default: () => CodeBlock,
    tildeInputRegex: () => tildeInputRegex
  });
  var backtickInputRegex, tildeInputRegex, CodeBlock;
  var init_dist49 = __esm({
    "node_modules/@tiptap/extension-code-block/dist/index.js"() {
      init_dist16();
      init_dist5();
      backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
      tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
      CodeBlock = Node3.create({
        name: "codeBlock",
        addOptions() {
          return {
            languageClassPrefix: "language-",
            exitOnTripleEnter: true,
            exitOnArrowDown: true,
            HTMLAttributes: {}
          };
        },
        content: "text*",
        marks: "",
        group: "block",
        code: true,
        defining: true,
        addAttributes() {
          return {
            language: {
              default: null,
              parseHTML: (element) => {
                var _a;
                const { languageClassPrefix } = this.options;
                const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
                const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
                const language = languages[0];
                if (!language) {
                  return null;
                }
                return language;
              },
              rendered: false
            }
          };
        },
        parseHTML() {
          return [
            {
              tag: "pre",
              preserveWhitespace: "full"
            }
          ];
        },
        renderHTML({ node, HTMLAttributes }) {
          return [
            "pre",
            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
            [
              "code",
              {
                class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
              },
              0
            ]
          ];
        },
        addCommands() {
          return {
            setCodeBlock: (attributes) => ({ commands: commands2 }) => {
              return commands2.setNode(this.name, attributes);
            },
            toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
              return commands2.toggleNode(this.name, "paragraph", attributes);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
            // remove code block when at start of document or code block is empty
            Backspace: () => {
              const { empty: empty2, $anchor } = this.editor.state.selection;
              const isAtStart = $anchor.pos === 1;
              if (!empty2 || $anchor.parent.type.name !== this.name) {
                return false;
              }
              if (isAtStart || !$anchor.parent.textContent.length) {
                return this.editor.commands.clearNodes();
              }
              return false;
            },
            // exit node on triple enter
            Enter: ({ editor }) => {
              if (!this.options.exitOnTripleEnter) {
                return false;
              }
              const { state } = editor;
              const { selection } = state;
              const { $from, empty: empty2 } = selection;
              if (!empty2 || $from.parent.type !== this.type) {
                return false;
              }
              const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
              const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
              if (!isAtEnd || !endsWithDoubleNewline) {
                return false;
              }
              return editor.chain().command(({ tr: tr2 }) => {
                tr2.delete($from.pos - 2, $from.pos);
                return true;
              }).exitCode().run();
            },
            // exit node on arrow down
            ArrowDown: ({ editor }) => {
              if (!this.options.exitOnArrowDown) {
                return false;
              }
              const { state } = editor;
              const { selection, doc: doc3 } = state;
              const { $from, empty: empty2 } = selection;
              if (!empty2 || $from.parent.type !== this.type) {
                return false;
              }
              const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
              if (!isAtEnd) {
                return false;
              }
              const after = $from.after();
              if (after === void 0) {
                return false;
              }
              const nodeAfter = doc3.nodeAt(after);
              if (nodeAfter) {
                return false;
              }
              return editor.commands.exitCode();
            }
          };
        },
        addInputRules() {
          return [
            textblockTypeInputRule({
              find: backtickInputRegex,
              type: this.type,
              getAttributes: (match) => ({
                language: match[1]
              })
            }),
            textblockTypeInputRule({
              find: tildeInputRegex,
              type: this.type,
              getAttributes: (match) => ({
                language: match[1]
              })
            })
          ];
        },
        addProseMirrorPlugins() {
          return [
            // this plugin creates a code block for pasted content from VS Code
            // we can also detect the copied code language
            new Plugin({
              key: new PluginKey("codeBlockVSCodeHandler"),
              props: {
                handlePaste: (view, event) => {
                  if (!event.clipboardData) {
                    return false;
                  }
                  if (this.editor.isActive(this.type.name)) {
                    return false;
                  }
                  const text = event.clipboardData.getData("text/plain");
                  const vscode = event.clipboardData.getData("vscode-editor-data");
                  const vscodeData = vscode ? JSON.parse(vscode) : void 0;
                  const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
                  if (!text || !language) {
                    return false;
                  }
                  const { tr: tr2 } = view.state;
                  tr2.replaceSelectionWith(this.type.create({ language }));
                  tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
                  tr2.insertText(text.replace(/\r\n?/g, "\n"));
                  tr2.setMeta("paste", true);
                  view.dispatch(tr2);
                  return true;
                }
              }
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-code-block-lowlight/dist/index.js
  var dist_exports25 = {};
  __export(dist_exports25, {
    CodeBlockLowlight: () => CodeBlockLowlight,
    default: () => CodeBlockLowlight
  });
  function deepFreeze(obj) {
    if (obj instanceof Map) {
      obj.clear = obj.delete = obj.set = function() {
        throw new Error("map is read-only");
      };
    } else if (obj instanceof Set) {
      obj.add = obj.clear = obj.delete = function() {
        throw new Error("set is read-only");
      };
    }
    Object.freeze(obj);
    Object.getOwnPropertyNames(obj).forEach(function(name) {
      var prop = obj[name];
      if (typeof prop == "object" && !Object.isFrozen(prop)) {
        deepFreeze(prop);
      }
    });
    return obj;
  }
  function escapeHTML(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function inherit$1(original, ...objects) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const key in original) {
      result[key] = original[key];
    }
    objects.forEach(function(obj) {
      for (const key in obj) {
        result[key] = obj[key];
      }
    });
    return (
      /** @type {T} */
      result
    );
  }
  function source(re) {
    if (!re)
      return null;
    if (typeof re === "string")
      return re;
    return re.source;
  }
  function lookahead(re) {
    return concat("(?=", re, ")");
  }
  function anyNumberOfTimes(re) {
    return concat("(?:", re, ")*");
  }
  function optional(re) {
    return concat("(?:", re, ")?");
  }
  function concat(...args) {
    const joined = args.map((x) => source(x)).join("");
    return joined;
  }
  function stripOptionsFromArgs(args) {
    const opts = args[args.length - 1];
    if (typeof opts === "object" && opts.constructor === Object) {
      args.splice(args.length - 1, 1);
      return opts;
    } else {
      return {};
    }
  }
  function either(...args) {
    const opts = stripOptionsFromArgs(args);
    const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
    return joined;
  }
  function countMatchGroups(re) {
    return new RegExp(re.toString() + "|").exec("").length - 1;
  }
  function startsWith(re, lexeme) {
    const match = re && re.exec(lexeme);
    return match && match.index === 0;
  }
  function _rewriteBackreferences(regexps, { joinWith }) {
    let numCaptures = 0;
    return regexps.map((regex) => {
      numCaptures += 1;
      const offset2 = numCaptures;
      let re = source(regex);
      let out = "";
      while (re.length > 0) {
        const match = BACKREF_RE.exec(re);
        if (!match) {
          out += re;
          break;
        }
        out += re.substring(0, match.index);
        re = re.substring(match.index + match[0].length);
        if (match[0][0] === "\\" && match[1]) {
          out += "\\" + String(Number(match[1]) + offset2);
        } else {
          out += match[0];
          if (match[0] === "(") {
            numCaptures++;
          }
        }
      }
      return out;
    }).map((re) => `(${re})`).join(joinWith);
  }
  function skipIfHasPrecedingDot(match, response) {
    const before = match.input[match.index - 1];
    if (before === ".") {
      response.ignoreMatch();
    }
  }
  function scopeClassName(mode, _parent) {
    if (mode.className !== void 0) {
      mode.scope = mode.className;
      delete mode.className;
    }
  }
  function beginKeywords(mode, parent) {
    if (!parent)
      return;
    if (!mode.beginKeywords)
      return;
    mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
    mode.__beforeBegin = skipIfHasPrecedingDot;
    mode.keywords = mode.keywords || mode.beginKeywords;
    delete mode.beginKeywords;
    if (mode.relevance === void 0)
      mode.relevance = 0;
  }
  function compileIllegal(mode, _parent) {
    if (!Array.isArray(mode.illegal))
      return;
    mode.illegal = either(...mode.illegal);
  }
  function compileMatch(mode, _parent) {
    if (!mode.match)
      return;
    if (mode.begin || mode.end)
      throw new Error("begin & end are not supported with match");
    mode.begin = mode.match;
    delete mode.match;
  }
  function compileRelevance(mode, _parent) {
    if (mode.relevance === void 0)
      mode.relevance = 1;
  }
  function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
    const compiledKeywords = /* @__PURE__ */ Object.create(null);
    if (typeof rawKeywords === "string") {
      compileList(scopeName, rawKeywords.split(" "));
    } else if (Array.isArray(rawKeywords)) {
      compileList(scopeName, rawKeywords);
    } else {
      Object.keys(rawKeywords).forEach(function(scopeName2) {
        Object.assign(
          compiledKeywords,
          compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
        );
      });
    }
    return compiledKeywords;
    function compileList(scopeName2, keywordList) {
      if (caseInsensitive) {
        keywordList = keywordList.map((x) => x.toLowerCase());
      }
      keywordList.forEach(function(keyword) {
        const pair = keyword.split("|");
        compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
      });
    }
  }
  function scoreForKeyword(keyword, providedScore) {
    if (providedScore) {
      return Number(providedScore);
    }
    return commonKeyword(keyword) ? 0 : 1;
  }
  function commonKeyword(keyword) {
    return COMMON_KEYWORDS.includes(keyword.toLowerCase());
  }
  function remapScopeNames(mode, regexes, { key }) {
    let offset2 = 0;
    const scopeNames = mode[key];
    const emit = {};
    const positions2 = {};
    for (let i = 1; i <= regexes.length; i++) {
      positions2[i + offset2] = scopeNames[i];
      emit[i + offset2] = true;
      offset2 += countMatchGroups(regexes[i - 1]);
    }
    mode[key] = positions2;
    mode[key]._emit = emit;
    mode[key]._multi = true;
  }
  function beginMultiClass(mode) {
    if (!Array.isArray(mode.begin))
      return;
    if (mode.skip || mode.excludeBegin || mode.returnBegin) {
      error2("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
      throw MultiClassError;
    }
    if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
      error2("beginScope must be object");
      throw MultiClassError;
    }
    remapScopeNames(mode, mode.begin, { key: "beginScope" });
    mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
  }
  function endMultiClass(mode) {
    if (!Array.isArray(mode.end))
      return;
    if (mode.skip || mode.excludeEnd || mode.returnEnd) {
      error2("skip, excludeEnd, returnEnd not compatible with endScope: {}");
      throw MultiClassError;
    }
    if (typeof mode.endScope !== "object" || mode.endScope === null) {
      error2("endScope must be object");
      throw MultiClassError;
    }
    remapScopeNames(mode, mode.end, { key: "endScope" });
    mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
  }
  function scopeSugar(mode) {
    if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
      mode.beginScope = mode.scope;
      delete mode.scope;
    }
  }
  function MultiClass(mode) {
    scopeSugar(mode);
    if (typeof mode.beginScope === "string") {
      mode.beginScope = { _wrap: mode.beginScope };
    }
    if (typeof mode.endScope === "string") {
      mode.endScope = { _wrap: mode.endScope };
    }
    beginMultiClass(mode);
    endMultiClass(mode);
  }
  function compileLanguage(language) {
    function langRe(value, global2) {
      return new RegExp(
        source(value),
        "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
      );
    }
    class MultiRegex {
      constructor() {
        this.matchIndexes = {};
        this.regexes = [];
        this.matchAt = 1;
        this.position = 0;
      }
      // @ts-ignore
      addRule(re, opts) {
        opts.position = this.position++;
        this.matchIndexes[this.matchAt] = opts;
        this.regexes.push([opts, re]);
        this.matchAt += countMatchGroups(re) + 1;
      }
      compile() {
        if (this.regexes.length === 0) {
          this.exec = () => null;
        }
        const terminators = this.regexes.map((el) => el[1]);
        this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
        this.lastIndex = 0;
      }
      /** @param {string} s */
      exec(s) {
        this.matcherRe.lastIndex = this.lastIndex;
        const match = this.matcherRe.exec(s);
        if (!match) {
          return null;
        }
        const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
        const matchData = this.matchIndexes[i];
        match.splice(0, i);
        return Object.assign(match, matchData);
      }
    }
    class ResumableMultiRegex {
      constructor() {
        this.rules = [];
        this.multiRegexes = [];
        this.count = 0;
        this.lastIndex = 0;
        this.regexIndex = 0;
      }
      // @ts-ignore
      getMatcher(index3) {
        if (this.multiRegexes[index3])
          return this.multiRegexes[index3];
        const matcher = new MultiRegex();
        this.rules.slice(index3).forEach(([re, opts]) => matcher.addRule(re, opts));
        matcher.compile();
        this.multiRegexes[index3] = matcher;
        return matcher;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      // @ts-ignore
      addRule(re, opts) {
        this.rules.push([re, opts]);
        if (opts.type === "begin")
          this.count++;
      }
      /** @param {string} s */
      exec(s) {
        const m = this.getMatcher(this.regexIndex);
        m.lastIndex = this.lastIndex;
        let result = m.exec(s);
        if (this.resumingScanAtSamePosition()) {
          if (result && result.index === this.lastIndex)
            ;
          else {
            const m2 = this.getMatcher(0);
            m2.lastIndex = this.lastIndex + 1;
            result = m2.exec(s);
          }
        }
        if (result) {
          this.regexIndex += result.position + 1;
          if (this.regexIndex === this.count) {
            this.considerAll();
          }
        }
        return result;
      }
    }
    function buildModeRegex(mode) {
      const mm = new ResumableMultiRegex();
      mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
      if (mode.terminatorEnd) {
        mm.addRule(mode.terminatorEnd, { type: "end" });
      }
      if (mode.illegal) {
        mm.addRule(mode.illegal, { type: "illegal" });
      }
      return mm;
    }
    function compileMode(mode, parent) {
      const cmode = (
        /** @type CompiledMode */
        mode
      );
      if (mode.isCompiled)
        return cmode;
      [
        scopeClassName,
        // do this early so compiler extensions generally don't have to worry about
        // the distinction between match/begin
        compileMatch,
        MultiClass,
        beforeMatchExt
      ].forEach((ext) => ext(mode, parent));
      language.compilerExtensions.forEach((ext) => ext(mode, parent));
      mode.__beforeBegin = null;
      [
        beginKeywords,
        // do this later so compiler extensions that come earlier have access to the
        // raw array if they wanted to perhaps manipulate it, etc.
        compileIllegal,
        // default to 1 relevance if not specified
        compileRelevance
      ].forEach((ext) => ext(mode, parent));
      mode.isCompiled = true;
      let keywordPattern = null;
      if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
        mode.keywords = Object.assign({}, mode.keywords);
        keywordPattern = mode.keywords.$pattern;
        delete mode.keywords.$pattern;
      }
      keywordPattern = keywordPattern || /\w+/;
      if (mode.keywords) {
        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
      }
      cmode.keywordPatternRe = langRe(keywordPattern, true);
      if (parent) {
        if (!mode.begin)
          mode.begin = /\B|\b/;
        cmode.beginRe = langRe(cmode.begin);
        if (!mode.end && !mode.endsWithParent)
          mode.end = /\B|\b/;
        if (mode.end)
          cmode.endRe = langRe(cmode.end);
        cmode.terminatorEnd = source(cmode.end) || "";
        if (mode.endsWithParent && parent.terminatorEnd) {
          cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
        }
      }
      if (mode.illegal)
        cmode.illegalRe = langRe(
          /** @type {RegExp | string} */
          mode.illegal
        );
      if (!mode.contains)
        mode.contains = [];
      mode.contains = [].concat(...mode.contains.map(function(c) {
        return expandOrCloneMode(c === "self" ? mode : c);
      }));
      mode.contains.forEach(function(c) {
        compileMode(
          /** @type Mode */
          c,
          cmode
        );
      });
      if (mode.starts) {
        compileMode(mode.starts, parent);
      }
      cmode.matcher = buildModeRegex(cmode);
      return cmode;
    }
    if (!language.compilerExtensions)
      language.compilerExtensions = [];
    if (language.contains && language.contains.includes("self")) {
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    }
    language.classNameAliases = inherit$1(language.classNameAliases || {});
    return compileMode(
      /** @type Mode */
      language
    );
  }
  function dependencyOnParent(mode) {
    if (!mode)
      return false;
    return mode.endsWithParent || dependencyOnParent(mode.starts);
  }
  function expandOrCloneMode(mode) {
    if (mode.variants && !mode.cachedVariants) {
      mode.cachedVariants = mode.variants.map(function(variant) {
        return inherit$1(mode, { variants: null }, variant);
      });
    }
    if (mode.cachedVariants) {
      return mode.cachedVariants;
    }
    if (dependencyOnParent(mode)) {
      return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
    }
    if (Object.isFrozen(mode)) {
      return inherit$1(mode);
    }
    return mode;
  }
  function parseNodes(nodes, className = []) {
    return nodes.map((node) => {
      const classes = [...className, ...node.properties ? node.properties.className : []];
      if (node.children) {
        return parseNodes(node.children, classes);
      }
      return {
        text: node.value,
        classes
      };
    }).flat();
  }
  function getHighlightNodes(result) {
    return result.value || result.children || [];
  }
  function registered(aliasOrLanguage) {
    return Boolean(HighlightJS.getLanguage(aliasOrLanguage));
  }
  function getDecorations({ doc: doc3, name, lowlight: lowlight2, defaultLanguage }) {
    const decorations = [];
    findChildren(doc3, (node) => node.type.name === name).forEach((block) => {
      let from3 = block.pos + 1;
      const language = block.node.attrs.language || defaultLanguage;
      const languages = lowlight2.listLanguages();
      const nodes = language && (languages.includes(language) || registered(language)) ? getHighlightNodes(lowlight2.highlight(language, block.node.textContent)) : getHighlightNodes(lowlight2.highlightAuto(block.node.textContent));
      parseNodes(nodes).forEach((node) => {
        const to2 = from3 + node.text.length;
        if (node.classes.length) {
          const decoration = Decoration.inline(from3, to2, {
            class: node.classes.join(" ")
          });
          decorations.push(decoration);
        }
        from3 = to2;
      });
    });
    return DecorationSet.create(doc3, decorations);
  }
  function isFunction3(param) {
    return typeof param === "function";
  }
  function LowlightPlugin({ name, lowlight: lowlight2, defaultLanguage }) {
    if (!["highlight", "highlightAuto", "listLanguages"].every((api) => isFunction3(lowlight2[api]))) {
      throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
    }
    const lowlightPlugin = new Plugin({
      key: new PluginKey("lowlight"),
      state: {
        init: (_, { doc: doc3 }) => getDecorations({
          doc: doc3,
          name,
          lowlight: lowlight2,
          defaultLanguage
        }),
        apply: (transaction, decorationSet, oldState, newState) => {
          const oldNodeName = oldState.selection.$head.parent.type.name;
          const newNodeName = newState.selection.$head.parent.type.name;
          const oldNodes = findChildren(oldState.doc, (node) => node.type.name === name);
          const newNodes = findChildren(newState.doc, (node) => node.type.name === name);
          if (transaction.docChanged && ([oldNodeName, newNodeName].includes(name) || newNodes.length !== oldNodes.length || transaction.steps.some((step) => {
            return (
              // @ts-ignore
              step.from !== void 0 && step.to !== void 0 && oldNodes.some((node) => {
                return (
                  // @ts-ignore
                  node.pos >= step.from && node.pos + node.node.nodeSize <= step.to
                );
              })
            );
          }))) {
            return getDecorations({
              doc: transaction.doc,
              name,
              lowlight: lowlight2,
              defaultLanguage
            });
          }
          return decorationSet.map(transaction.mapping, transaction.doc);
        }
      },
      props: {
        decorations(state) {
          return lowlightPlugin.getState(state);
        }
      }
    });
    return lowlightPlugin;
  }
  var deepFreezeEs6, Response2, SPAN_CLOSE, emitsWrappingTags, scopeToCSSClass, HTMLRenderer, newNode, TokenTree, TokenTreeEmitter, BACKREF_RE, MATCH_NOTHING_RE, IDENT_RE, UNDERSCORE_IDENT_RE, NUMBER_RE, C_NUMBER_RE, BINARY_NUMBER_RE, RE_STARTERS_RE, SHEBANG, BACKSLASH_ESCAPE, APOS_STRING_MODE, QUOTE_STRING_MODE, PHRASAL_WORDS_MODE, COMMENT, C_LINE_COMMENT_MODE, C_BLOCK_COMMENT_MODE, HASH_COMMENT_MODE, NUMBER_MODE, C_NUMBER_MODE, BINARY_NUMBER_MODE, REGEXP_MODE, TITLE_MODE, UNDERSCORE_TITLE_MODE, METHOD_GUARD, END_SAME_AS_BEGIN, MODES, beforeMatchExt, COMMON_KEYWORDS, DEFAULT_KEYWORD_SCOPE, seenDeprecations, error2, warn2, deprecated, MultiClassError, version3, HTMLInjectionError, escape, inherit, NO_MATCH, MAX_KEYWORD_HITS, HLJS, highlight, core, HighlightJS, CodeBlockLowlight;
  var init_dist50 = __esm({
    "node_modules/@tiptap/extension-code-block-lowlight/dist/index.js"() {
      init_dist49();
      init_dist16();
      init_dist5();
      init_dist7();
      deepFreezeEs6 = { exports: {} };
      deepFreezeEs6.exports = deepFreeze;
      deepFreezeEs6.exports.default = deepFreeze;
      Response2 = class {
        /**
         * @param {CompiledMode} mode
         */
        constructor(mode) {
          if (mode.data === void 0)
            mode.data = {};
          this.data = mode.data;
          this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      };
      SPAN_CLOSE = "</span>";
      emitsWrappingTags = (node) => {
        return !!node.scope || node.sublanguage && node.language;
      };
      scopeToCSSClass = (name, { prefix }) => {
        if (name.includes(".")) {
          const pieces = name.split(".");
          return [
            `${prefix}${pieces.shift()}`,
            ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
          ].join(" ");
        }
        return `${prefix}${name}`;
      };
      HTMLRenderer = class {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(parseTree, options) {
          this.buffer = "";
          this.classPrefix = options.classPrefix;
          parseTree.walk(this);
        }
        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(text) {
          this.buffer += escapeHTML(text);
        }
        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(node) {
          if (!emitsWrappingTags(node))
            return;
          let className = "";
          if (node.sublanguage) {
            className = `language-${node.language}`;
          } else {
            className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });
          }
          this.span(className);
        }
        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(node) {
          if (!emitsWrappingTags(node))
            return;
          this.buffer += SPAN_CLOSE;
        }
        /**
         * returns the accumulated buffer
        */
        value() {
          return this.buffer;
        }
        // helpers
        /**
         * Builds a span element
         *
         * @param {string} className */
        span(className) {
          this.buffer += `<span class="${className}">`;
        }
      };
      newNode = (opts = {}) => {
        const result = { children: [] };
        Object.assign(result, opts);
        return result;
      };
      TokenTree = class _TokenTree {
        constructor() {
          this.rootNode = newNode();
          this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        /** @param {Node} node */
        add(node) {
          this.top.children.push(node);
        }
        /** @param {string} scope */
        openNode(scope) {
          const node = newNode({ scope });
          this.add(node);
          this.stack.push(node);
        }
        closeNode() {
          if (this.stack.length > 1) {
            return this.stack.pop();
          }
          return void 0;
        }
        closeAllNodes() {
          while (this.closeNode())
            ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(builder) {
          return this.constructor._walk(builder, this.rootNode);
        }
        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(builder, node) {
          if (typeof node === "string") {
            builder.addText(node);
          } else if (node.children) {
            builder.openNode(node);
            node.children.forEach((child) => this._walk(builder, child));
            builder.closeNode(node);
          }
          return builder;
        }
        /**
         * @param {Node} node
         */
        static _collapse(node) {
          if (typeof node === "string")
            return;
          if (!node.children)
            return;
          if (node.children.every((el) => typeof el === "string")) {
            node.children = [node.children.join("")];
          } else {
            node.children.forEach((child) => {
              _TokenTree._collapse(child);
            });
          }
        }
      };
      TokenTreeEmitter = class extends TokenTree {
        /**
         * @param {*} options
         */
        constructor(options) {
          super();
          this.options = options;
        }
        /**
         * @param {string} text
         * @param {string} scope
         */
        addKeyword(text, scope) {
          if (text === "") {
            return;
          }
          this.openNode(scope);
          this.addText(text);
          this.closeNode();
        }
        /**
         * @param {string} text
         */
        addText(text) {
          if (text === "") {
            return;
          }
          this.add(text);
        }
        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        addSublanguage(emitter, name) {
          const node = emitter.root;
          node.sublanguage = true;
          node.language = name;
          this.add(node);
        }
        toHTML() {
          const renderer = new HTMLRenderer(this, this.options);
          return renderer.value();
        }
        finalize() {
          return true;
        }
      };
      BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      MATCH_NOTHING_RE = /\b\B/;
      IDENT_RE = "[a-zA-Z]\\w*";
      UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
      NUMBER_RE = "\\b\\d+(\\.\\d+)?";
      C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
      BINARY_NUMBER_RE = "\\b(0b[01]+)";
      RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
      SHEBANG = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
          opts.begin = concat(
            beginShebang,
            /.*\b/,
            opts.binary,
            /\b.*/
          );
        }
        return inherit$1({
          scope: "meta",
          begin: beginShebang,
          end: /$/,
          relevance: 0,
          /** @type {ModeCallback} */
          "on:begin": (m, resp) => {
            if (m.index !== 0)
              resp.ignoreMatch();
          }
        }, opts);
      };
      BACKSLASH_ESCAPE = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      };
      APOS_STRING_MODE = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      QUOTE_STRING_MODE = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      PHRASAL_WORDS_MODE = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      };
      COMMENT = function(begin, end2, modeOptions = {}) {
        const mode = inherit$1(
          {
            scope: "comment",
            begin,
            end: end2,
            contains: []
          },
          modeOptions
        );
        mode.contains.push({
          scope: "doctag",
          // hack to avoid the space from being included. the space is necessary to
          // match here to prevent the plain text rule below from gobbling up doctags
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const ENGLISH_WORD = either(
          // list of common 1 and 2 letter words in English
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          // note: this is not an exhaustive list of contractions, just popular ones
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          // contractions - can't we'd they're let's, etc
          /[A-Za-z]+[-][a-z]+/,
          // `no-way`, etc.
          /[A-Za-z][a-z]{2,}/
          // allow capitalized words at beginning of sentences
        );
        mode.contains.push(
          {
            // TODO: how to include ", (, ) without breaking grammars that use these for
            // comment delimiters?
            // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
            // ---
            // this tries to find sequences of 3 english words in a row (without any
            // "programming" type syntax) this gives us a strong signal that we've
            // TRULY found a comment - vs perhaps scanning with the wrong language.
            // It's possible to find something that LOOKS like the start of the
            // comment - but then if there is no readable text - good chance it is a
            // false match and not a comment.
            //
            // for a visual example please see:
            // https://github.com/highlightjs/highlight.js/issues/2827
            begin: concat(
              /[ ]+/,
              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
              "(",
              ENGLISH_WORD,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
            // look for 3 words in a row
          }
        );
        return mode;
      };
      C_LINE_COMMENT_MODE = COMMENT("//", "$");
      C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
      HASH_COMMENT_MODE = COMMENT("#", "$");
      NUMBER_MODE = {
        scope: "number",
        begin: NUMBER_RE,
        relevance: 0
      };
      C_NUMBER_MODE = {
        scope: "number",
        begin: C_NUMBER_RE,
        relevance: 0
      };
      BINARY_NUMBER_MODE = {
        scope: "number",
        begin: BINARY_NUMBER_RE,
        relevance: 0
      };
      REGEXP_MODE = {
        // this outer rule makes sure we actually have a WHOLE regex and not simply
        // an expression such as:
        //
        //     3 / something
        //
        // (which will then blow up when regex's `illegal` sees the newline)
        begin: /(?=\/[^/\n]*\/)/,
        contains: [{
          scope: "regexp",
          begin: /\//,
          end: /\/[gimuy]*/,
          illegal: /\n/,
          contains: [
            BACKSLASH_ESCAPE,
            {
              begin: /\[/,
              end: /\]/,
              relevance: 0,
              contains: [BACKSLASH_ESCAPE]
            }
          ]
        }]
      };
      TITLE_MODE = {
        scope: "title",
        begin: IDENT_RE,
        relevance: 0
      };
      UNDERSCORE_TITLE_MODE = {
        scope: "title",
        begin: UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      METHOD_GUARD = {
        // excludes method names from keyword processing
        begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      END_SAME_AS_BEGIN = function(mode) {
        return Object.assign(
          mode,
          {
            /** @type {ModeCallback} */
            "on:begin": (m, resp) => {
              resp.data._beginMatch = m[1];
            },
            /** @type {ModeCallback} */
            "on:end": (m, resp) => {
              if (resp.data._beginMatch !== m[1])
                resp.ignoreMatch();
            }
          }
        );
      };
      MODES = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE,
        IDENT_RE,
        UNDERSCORE_IDENT_RE,
        NUMBER_RE,
        C_NUMBER_RE,
        BINARY_NUMBER_RE,
        RE_STARTERS_RE,
        SHEBANG,
        BACKSLASH_ESCAPE,
        APOS_STRING_MODE,
        QUOTE_STRING_MODE,
        PHRASAL_WORDS_MODE,
        COMMENT,
        C_LINE_COMMENT_MODE,
        C_BLOCK_COMMENT_MODE,
        HASH_COMMENT_MODE,
        NUMBER_MODE,
        C_NUMBER_MODE,
        BINARY_NUMBER_MODE,
        REGEXP_MODE,
        TITLE_MODE,
        UNDERSCORE_TITLE_MODE,
        METHOD_GUARD,
        END_SAME_AS_BEGIN
      });
      beforeMatchExt = (mode, parent) => {
        if (!mode.beforeMatch)
          return;
        if (mode.starts)
          throw new Error("beforeMatch cannot be used with starts");
        const originalMode = Object.assign({}, mode);
        Object.keys(mode).forEach((key) => {
          delete mode[key];
        });
        mode.keywords = originalMode.keywords;
        mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
        mode.starts = {
          relevance: 0,
          contains: [
            Object.assign(originalMode, { endsParent: true })
          ]
        };
        mode.relevance = 0;
        delete originalMode.beforeMatch;
      };
      COMMON_KEYWORDS = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        // common variable name
        "list",
        // common variable name
        "value"
        // common variable name
      ];
      DEFAULT_KEYWORD_SCOPE = "keyword";
      seenDeprecations = {};
      error2 = (message) => {
        console.error(message);
      };
      warn2 = (message, ...args) => {
        console.log(`WARN: ${message}`, ...args);
      };
      deprecated = (version4, message) => {
        if (seenDeprecations[`${version4}/${message}`])
          return;
        console.log(`Deprecated as of ${version4}. ${message}`);
        seenDeprecations[`${version4}/${message}`] = true;
      };
      MultiClassError = new Error();
      version3 = "11.6.0";
      HTMLInjectionError = class extends Error {
        constructor(reason, html) {
          super(reason);
          this.name = "HTMLInjectionError";
          this.html = html;
        }
      };
      escape = escapeHTML;
      inherit = inherit$1;
      NO_MATCH = Symbol("nomatch");
      MAX_KEYWORD_HITS = 7;
      HLJS = function(hljs) {
        const languages = /* @__PURE__ */ Object.create(null);
        const aliases = /* @__PURE__ */ Object.create(null);
        const plugins3 = [];
        let SAFE_MODE = true;
        const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
        let options = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          // beta configuration options, subject to change, welcome to discuss
          // https://github.com/highlightjs/highlight.js/issues/1086
          __emitter: TokenTreeEmitter
        };
        function shouldNotHighlight(languageName) {
          return options.noHighlightRe.test(languageName);
        }
        function blockLanguage(block) {
          let classes = block.className + " ";
          classes += block.parentNode ? block.parentNode.className : "";
          const match = options.languageDetectRe.exec(classes);
          if (match) {
            const language = getLanguage(match[1]);
            if (!language) {
              warn2(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
              warn2("Falling back to no-highlight mode for this block.", block);
            }
            return language ? match[1] : "no-highlight";
          }
          return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
        }
        function highlight3(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
          let code = "";
          let languageName = "";
          if (typeof optionsOrCode === "object") {
            code = codeOrLanguageName;
            ignoreIllegals = optionsOrCode.ignoreIllegals;
            languageName = optionsOrCode.language;
          } else {
            deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
            deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
            languageName = codeOrLanguageName;
            code = optionsOrCode;
          }
          if (ignoreIllegals === void 0) {
            ignoreIllegals = true;
          }
          const context = {
            code,
            language: languageName
          };
          fire("before:highlight", context);
          const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
          result.code = context.code;
          fire("after:highlight", result);
          return result;
        }
        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
          const keywordHits = /* @__PURE__ */ Object.create(null);
          function keywordData(mode, matchText) {
            return mode.keywords[matchText];
          }
          function processKeywords() {
            if (!top2.keywords) {
              emitter.addText(modeBuffer);
              return;
            }
            let lastIndex = 0;
            top2.keywordPatternRe.lastIndex = 0;
            let match = top2.keywordPatternRe.exec(modeBuffer);
            let buf = "";
            while (match) {
              buf += modeBuffer.substring(lastIndex, match.index);
              const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
              const data = keywordData(top2, word);
              if (data) {
                const [kind, keywordRelevance] = data;
                emitter.addText(buf);
                buf = "";
                keywordHits[word] = (keywordHits[word] || 0) + 1;
                if (keywordHits[word] <= MAX_KEYWORD_HITS)
                  relevance += keywordRelevance;
                if (kind.startsWith("_")) {
                  buf += match[0];
                } else {
                  const cssClass = language.classNameAliases[kind] || kind;
                  emitter.addKeyword(match[0], cssClass);
                }
              } else {
                buf += match[0];
              }
              lastIndex = top2.keywordPatternRe.lastIndex;
              match = top2.keywordPatternRe.exec(modeBuffer);
            }
            buf += modeBuffer.substring(lastIndex);
            emitter.addText(buf);
          }
          function processSubLanguage() {
            if (modeBuffer === "")
              return;
            let result2 = null;
            if (typeof top2.subLanguage === "string") {
              if (!languages[top2.subLanguage]) {
                emitter.addText(modeBuffer);
                return;
              }
              result2 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
              continuations[top2.subLanguage] = /** @type {CompiledMode} */
              result2._top;
            } else {
              result2 = highlightAuto2(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
            }
            if (top2.relevance > 0) {
              relevance += result2.relevance;
            }
            emitter.addSublanguage(result2._emitter, result2.language);
          }
          function processBuffer() {
            if (top2.subLanguage != null) {
              processSubLanguage();
            } else {
              processKeywords();
            }
            modeBuffer = "";
          }
          function emitMultiClass(scope, match) {
            let i = 1;
            const max2 = match.length - 1;
            while (i <= max2) {
              if (!scope._emit[i]) {
                i++;
                continue;
              }
              const klass = language.classNameAliases[scope[i]] || scope[i];
              const text = match[i];
              if (klass) {
                emitter.addKeyword(text, klass);
              } else {
                modeBuffer = text;
                processKeywords();
                modeBuffer = "";
              }
              i++;
            }
          }
          function startNewMode(mode, match) {
            if (mode.scope && typeof mode.scope === "string") {
              emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
            }
            if (mode.beginScope) {
              if (mode.beginScope._wrap) {
                emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
                modeBuffer = "";
              } else if (mode.beginScope._multi) {
                emitMultiClass(mode.beginScope, match);
                modeBuffer = "";
              }
            }
            top2 = Object.create(mode, { parent: { value: top2 } });
            return top2;
          }
          function endOfMode(mode, match, matchPlusRemainder) {
            let matched = startsWith(mode.endRe, matchPlusRemainder);
            if (matched) {
              if (mode["on:end"]) {
                const resp = new Response2(mode);
                mode["on:end"](match, resp);
                if (resp.isMatchIgnored)
                  matched = false;
              }
              if (matched) {
                while (mode.endsParent && mode.parent) {
                  mode = mode.parent;
                }
                return mode;
              }
            }
            if (mode.endsWithParent) {
              return endOfMode(mode.parent, match, matchPlusRemainder);
            }
          }
          function doIgnore(lexeme) {
            if (top2.matcher.regexIndex === 0) {
              modeBuffer += lexeme[0];
              return 1;
            } else {
              resumeScanAtSamePosition = true;
              return 0;
            }
          }
          function doBeginMatch(match) {
            const lexeme = match[0];
            const newMode = match.rule;
            const resp = new Response2(newMode);
            const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
            for (const cb of beforeCallbacks) {
              if (!cb)
                continue;
              cb(match, resp);
              if (resp.isMatchIgnored)
                return doIgnore(lexeme);
            }
            if (newMode.skip) {
              modeBuffer += lexeme;
            } else {
              if (newMode.excludeBegin) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (!newMode.returnBegin && !newMode.excludeBegin) {
                modeBuffer = lexeme;
              }
            }
            startNewMode(newMode, match);
            return newMode.returnBegin ? 0 : lexeme.length;
          }
          function doEndMatch(match) {
            const lexeme = match[0];
            const matchPlusRemainder = codeToHighlight.substring(match.index);
            const endMode = endOfMode(top2, match, matchPlusRemainder);
            if (!endMode) {
              return NO_MATCH;
            }
            const origin = top2;
            if (top2.endScope && top2.endScope._wrap) {
              processBuffer();
              emitter.addKeyword(lexeme, top2.endScope._wrap);
            } else if (top2.endScope && top2.endScope._multi) {
              processBuffer();
              emitMultiClass(top2.endScope, match);
            } else if (origin.skip) {
              modeBuffer += lexeme;
            } else {
              if (!(origin.returnEnd || origin.excludeEnd)) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (origin.excludeEnd) {
                modeBuffer = lexeme;
              }
            }
            do {
              if (top2.scope) {
                emitter.closeNode();
              }
              if (!top2.skip && !top2.subLanguage) {
                relevance += top2.relevance;
              }
              top2 = top2.parent;
            } while (top2 !== endMode.parent);
            if (endMode.starts) {
              startNewMode(endMode.starts, match);
            }
            return origin.returnEnd ? 0 : lexeme.length;
          }
          function processContinuations() {
            const list = [];
            for (let current = top2; current !== language; current = current.parent) {
              if (current.scope) {
                list.unshift(current.scope);
              }
            }
            list.forEach((item) => emitter.openNode(item));
          }
          let lastMatch = {};
          function processLexeme(textBeforeMatch, match) {
            const lexeme = match && match[0];
            modeBuffer += textBeforeMatch;
            if (lexeme == null) {
              processBuffer();
              return 0;
            }
            if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
              modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
              if (!SAFE_MODE) {
                const err = new Error(`0 width match regex (${languageName})`);
                err.languageName = languageName;
                err.badRule = lastMatch.rule;
                throw err;
              }
              return 1;
            }
            lastMatch = match;
            if (match.type === "begin") {
              return doBeginMatch(match);
            } else if (match.type === "illegal" && !ignoreIllegals) {
              const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.scope || "<unnamed>") + '"');
              err.mode = top2;
              throw err;
            } else if (match.type === "end") {
              const processed = doEndMatch(match);
              if (processed !== NO_MATCH) {
                return processed;
              }
            }
            if (match.type === "illegal" && lexeme === "") {
              return 1;
            }
            if (iterations > 1e5 && iterations > match.index * 3) {
              const err = new Error("potential infinite loop, way more iterations than matches");
              throw err;
            }
            modeBuffer += lexeme;
            return lexeme.length;
          }
          const language = getLanguage(languageName);
          if (!language) {
            error2(LANGUAGE_NOT_FOUND.replace("{}", languageName));
            throw new Error('Unknown language: "' + languageName + '"');
          }
          const md = compileLanguage(language);
          let result = "";
          let top2 = continuation || md;
          const continuations = {};
          const emitter = new options.__emitter(options);
          processContinuations();
          let modeBuffer = "";
          let relevance = 0;
          let index3 = 0;
          let iterations = 0;
          let resumeScanAtSamePosition = false;
          try {
            top2.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top2.matcher.considerAll();
              }
              top2.matcher.lastIndex = index3;
              const match = top2.matcher.exec(codeToHighlight);
              if (!match)
                break;
              const beforeMatch = codeToHighlight.substring(index3, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index3 = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substring(index3));
            emitter.closeAllNodes();
            emitter.finalize();
            result = emitter.toHTML();
            return {
              language: languageName,
              value: result,
              relevance,
              illegal: false,
              _emitter: emitter,
              _top: top2
            };
          } catch (err) {
            if (err.message && err.message.includes("Illegal")) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: err.message,
                  index: index3,
                  context: codeToHighlight.slice(index3 - 100, index3 + 100),
                  mode: err.mode,
                  resultSoFar: result
                },
                _emitter: emitter
              };
            } else if (SAFE_MODE) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: false,
                relevance: 0,
                errorRaised: err,
                _emitter: emitter,
                _top: top2
              };
            } else {
              throw err;
            }
          }
        }
        function justTextHighlightResult(code) {
          const result = {
            value: escape(code),
            illegal: false,
            relevance: 0,
            _top: PLAINTEXT_LANGUAGE,
            _emitter: new options.__emitter(options)
          };
          result._emitter.addText(code);
          return result;
        }
        function highlightAuto2(code, languageSubset) {
          languageSubset = languageSubset || options.languages || Object.keys(languages);
          const plaintext = justTextHighlightResult(code);
          const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
            (name) => _highlight(name, code, false)
          );
          results.unshift(plaintext);
          const sorted = results.sort((a, b) => {
            if (a.relevance !== b.relevance)
              return b.relevance - a.relevance;
            if (a.language && b.language) {
              if (getLanguage(a.language).supersetOf === b.language) {
                return 1;
              } else if (getLanguage(b.language).supersetOf === a.language) {
                return -1;
              }
            }
            return 0;
          });
          const [best, secondBest] = sorted;
          const result = best;
          result.secondBest = secondBest;
          return result;
        }
        function updateClassName(element, currentLang, resultLang) {
          const language = currentLang && aliases[currentLang] || resultLang;
          element.classList.add("hljs");
          element.classList.add(`language-${language}`);
        }
        function highlightElement(element) {
          let node = null;
          const language = blockLanguage(element);
          if (shouldNotHighlight(language))
            return;
          fire(
            "before:highlightElement",
            { el: element, language }
          );
          if (element.children.length > 0) {
            if (!options.ignoreUnescapedHTML) {
              console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
              console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
              console.warn("The element with unescaped HTML:");
              console.warn(element);
            }
            if (options.throwUnescapedHTML) {
              const err = new HTMLInjectionError(
                "One of your code blocks includes unescaped HTML.",
                element.innerHTML
              );
              throw err;
            }
          }
          node = element;
          const text = node.textContent;
          const result = language ? highlight3(text, { language, ignoreIllegals: true }) : highlightAuto2(text);
          element.innerHTML = result.value;
          updateClassName(element, language, result.language);
          element.result = {
            language: result.language,
            // TODO: remove with version 11.0
            re: result.relevance,
            relevance: result.relevance
          };
          if (result.secondBest) {
            element.secondBest = {
              language: result.secondBest.language,
              relevance: result.secondBest.relevance
            };
          }
          fire("after:highlightElement", { el: element, result, text });
        }
        function configure(userOptions) {
          options = inherit(options, userOptions);
        }
        const initHighlighting = () => {
          highlightAll();
          deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function initHighlightingOnLoad() {
          highlightAll();
          deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let wantsHighlight = false;
        function highlightAll() {
          if (document.readyState === "loading") {
            wantsHighlight = true;
            return;
          }
          const blocks = document.querySelectorAll(options.cssSelector);
          blocks.forEach(highlightElement);
        }
        function boot() {
          if (wantsHighlight)
            highlightAll();
        }
        if (typeof window !== "undefined" && window.addEventListener) {
          window.addEventListener("DOMContentLoaded", boot, false);
        }
        function registerLanguage2(languageName, languageDefinition) {
          let lang = null;
          try {
            lang = languageDefinition(hljs);
          } catch (error$1) {
            error2("Language definition for '{}' could not be registered.".replace("{}", languageName));
            if (!SAFE_MODE) {
              throw error$1;
            } else {
              error2(error$1);
            }
            lang = PLAINTEXT_LANGUAGE;
          }
          if (!lang.name)
            lang.name = languageName;
          languages[languageName] = lang;
          lang.rawDefinition = languageDefinition.bind(null, hljs);
          if (lang.aliases) {
            registerAliases(lang.aliases, { languageName });
          }
        }
        function unregisterLanguage(languageName) {
          delete languages[languageName];
          for (const alias of Object.keys(aliases)) {
            if (aliases[alias] === languageName) {
              delete aliases[alias];
            }
          }
        }
        function listLanguages2() {
          return Object.keys(languages);
        }
        function getLanguage(name) {
          name = (name || "").toLowerCase();
          return languages[name] || languages[aliases[name]];
        }
        function registerAliases(aliasList, { languageName }) {
          if (typeof aliasList === "string") {
            aliasList = [aliasList];
          }
          aliasList.forEach((alias) => {
            aliases[alias.toLowerCase()] = languageName;
          });
        }
        function autoDetection(name) {
          const lang = getLanguage(name);
          return lang && !lang.disableAutodetect;
        }
        function upgradePluginAPI(plugin) {
          if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
            plugin["before:highlightElement"] = (data) => {
              plugin["before:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
          if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
            plugin["after:highlightElement"] = (data) => {
              plugin["after:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
        }
        function addPlugin(plugin) {
          upgradePluginAPI(plugin);
          plugins3.push(plugin);
        }
        function fire(event, args) {
          const cb = event;
          plugins3.forEach(function(plugin) {
            if (plugin[cb]) {
              plugin[cb](args);
            }
          });
        }
        function deprecateHighlightBlock(el) {
          deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
          deprecated("10.7.0", "Please use highlightElement now.");
          return highlightElement(el);
        }
        Object.assign(hljs, {
          highlight: highlight3,
          highlightAuto: highlightAuto2,
          highlightAll,
          highlightElement,
          // TODO: Remove with v12 API
          highlightBlock: deprecateHighlightBlock,
          configure,
          initHighlighting,
          initHighlightingOnLoad,
          registerLanguage: registerLanguage2,
          unregisterLanguage,
          listLanguages: listLanguages2,
          getLanguage,
          registerAliases,
          autoDetection,
          inherit,
          addPlugin
        });
        hljs.debugMode = function() {
          SAFE_MODE = false;
        };
        hljs.safeMode = function() {
          SAFE_MODE = true;
        };
        hljs.versionString = version3;
        hljs.regex = {
          concat,
          lookahead,
          either,
          optional,
          anyNumberOfTimes
        };
        for (const key in MODES) {
          if (typeof MODES[key] === "object") {
            deepFreezeEs6.exports(MODES[key]);
          }
        }
        Object.assign(hljs, MODES);
        return hljs;
      };
      highlight = HLJS({});
      core = highlight;
      highlight.HighlightJS = highlight;
      highlight.default = highlight;
      HighlightJS = core;
      CodeBlockLowlight = CodeBlock.extend({
        addOptions() {
          var _a;
          return {
            ...(_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this),
            lowlight: {},
            defaultLanguage: null
          };
        },
        addProseMirrorPlugins() {
          var _a;
          return [
            ...((_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this)) || [],
            LowlightPlugin({
              name: this.name,
              lowlight: this.options.lowlight,
              defaultLanguage: this.options.defaultLanguage
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-hard-break/dist/index.js
  var dist_exports26 = {};
  __export(dist_exports26, {
    HardBreak: () => HardBreak,
    default: () => HardBreak
  });
  var HardBreak;
  var init_dist51 = __esm({
    "node_modules/@tiptap/extension-hard-break/dist/index.js"() {
      init_dist16();
      HardBreak = Node3.create({
        name: "hardBreak",
        addOptions() {
          return {
            keepMarks: true,
            HTMLAttributes: {}
          };
        },
        inline: true,
        group: "inline",
        selectable: false,
        parseHTML() {
          return [
            { tag: "br" }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
        },
        renderText() {
          return "\n";
        },
        addCommands() {
          return {
            setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
              return commands2.first([
                () => commands2.exitCode(),
                () => commands2.command(() => {
                  const { selection, storedMarks } = state;
                  if (selection.$from.parent.type.spec.isolating) {
                    return false;
                  }
                  const { keepMarks } = this.options;
                  const { splittableMarks } = editor.extensionManager;
                  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
                  return chain().insertContent({ type: this.name }).command(({ tr: tr2, dispatch: dispatch2 }) => {
                    if (dispatch2 && marks && keepMarks) {
                      const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                      tr2.ensureMarks(filteredMarks);
                    }
                    return true;
                  }).run();
                })
              ]);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Enter": () => this.editor.commands.setHardBreak(),
            "Shift-Enter": () => this.editor.commands.setHardBreak()
          };
        }
      });
    }
  });

  // node_modules/@tiptap/extension-heading/dist/index.js
  var dist_exports27 = {};
  __export(dist_exports27, {
    Heading: () => Heading,
    default: () => Heading
  });
  var Heading;
  var init_dist52 = __esm({
    "node_modules/@tiptap/extension-heading/dist/index.js"() {
      init_dist16();
      Heading = Node3.create({
        name: "heading",
        addOptions() {
          return {
            levels: [1, 2, 3, 4, 5, 6],
            HTMLAttributes: {}
          };
        },
        content: "inline*",
        group: "block",
        defining: true,
        addAttributes() {
          return {
            level: {
              default: 1,
              rendered: false
            }
          };
        },
        parseHTML() {
          return this.options.levels.map((level) => ({
            tag: `h${level}`,
            attrs: { level }
          }));
        },
        renderHTML({ node, HTMLAttributes }) {
          const hasLevel = this.options.levels.includes(node.attrs.level);
          const level = hasLevel ? node.attrs.level : this.options.levels[0];
          return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setHeading: (attributes) => ({ commands: commands2 }) => {
              if (!this.options.levels.includes(attributes.level)) {
                return false;
              }
              return commands2.setNode(this.name, attributes);
            },
            toggleHeading: (attributes) => ({ commands: commands2 }) => {
              if (!this.options.levels.includes(attributes.level)) {
                return false;
              }
              return commands2.toggleNode(this.name, "paragraph", attributes);
            }
          };
        },
        addKeyboardShortcuts() {
          return this.options.levels.reduce((items, level) => ({
            ...items,
            ...{
              [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
            }
          }), {});
        },
        addInputRules() {
          return this.options.levels.map((level) => {
            return textblockTypeInputRule({
              find: new RegExp(`^(#{1,${level}})\\s$`),
              type: this.type,
              getAttributes: {
                level
              }
            });
          });
        }
      });
    }
  });

  // node_modules/@tiptap/extension-horizontal-rule/dist/index.js
  var dist_exports28 = {};
  __export(dist_exports28, {
    HorizontalRule: () => HorizontalRule,
    default: () => HorizontalRule
  });
  var HorizontalRule;
  var init_dist53 = __esm({
    "node_modules/@tiptap/extension-horizontal-rule/dist/index.js"() {
      init_dist16();
      init_dist5();
      HorizontalRule = Node3.create({
        name: "horizontalRule",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        group: "block",
        parseHTML() {
          return [{ tag: "hr" }];
        },
        renderHTML({ HTMLAttributes }) {
          return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
        },
        addCommands() {
          return {
            setHorizontalRule: () => ({ chain, state }) => {
              const { $to: $originTo } = state.selection;
              const currentChain = chain();
              if ($originTo.parentOffset === 0) {
                currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: this.name });
              } else {
                currentChain.insertContent({ type: this.name });
              }
              return currentChain.command(({ tr: tr2, dispatch: dispatch2 }) => {
                var _a;
                if (dispatch2) {
                  const { $to } = tr2.selection;
                  const posAfter = $to.end();
                  if ($to.nodeAfter) {
                    if ($to.nodeAfter.isTextblock) {
                      tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
                    } else if ($to.nodeAfter.isBlock) {
                      tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
                    } else {
                      tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
                    }
                  } else {
                    const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                    if (node) {
                      tr2.insert(posAfter, node);
                      tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
                    }
                  }
                  tr2.scrollIntoView();
                }
                return true;
              }).run();
            }
          };
        },
        addInputRules() {
          return [
            nodeInputRule({
              find: /^(?:---|-|___\s|\*\*\*\s)$/,
              type: this.type
            })
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-list-item/dist/index.js
  var dist_exports29 = {};
  __export(dist_exports29, {
    ListItem: () => ListItem2,
    default: () => ListItem2
  });
  var ListItem2;
  var init_dist54 = __esm({
    "node_modules/@tiptap/extension-list-item/dist/index.js"() {
      init_dist16();
      ListItem2 = Node3.create({
        name: "listItem",
        addOptions() {
          return {
            HTMLAttributes: {},
            bulletListTypeName: "bulletList",
            orderedListTypeName: "orderedList"
          };
        },
        content: "paragraph block*",
        defining: true,
        parseHTML() {
          return [
            {
              tag: "li"
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addKeyboardShortcuts() {
          return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
          };
        }
      });
    }
  });

  // node_modules/@tiptap/extension-ordered-list/dist/index.js
  var dist_exports30 = {};
  __export(dist_exports30, {
    OrderedList: () => OrderedList,
    default: () => OrderedList,
    inputRegex: () => inputRegex5
  });
  var ListItem3, TextStyle3, inputRegex5, OrderedList;
  var init_dist55 = __esm({
    "node_modules/@tiptap/extension-ordered-list/dist/index.js"() {
      init_dist16();
      ListItem3 = Node3.create({
        name: "listItem",
        addOptions() {
          return {
            HTMLAttributes: {},
            bulletListTypeName: "bulletList",
            orderedListTypeName: "orderedList"
          };
        },
        content: "paragraph block*",
        defining: true,
        parseHTML() {
          return [
            {
              tag: "li"
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addKeyboardShortcuts() {
          return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
          };
        }
      });
      TextStyle3 = Mark2.create({
        name: "textStyle",
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        parseHTML() {
          return [
            {
              tag: "span",
              getAttrs: (element) => {
                const hasStyles = element.hasAttribute("style");
                if (!hasStyles) {
                  return false;
                }
                return {};
              }
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
              const attributes = getMarkAttributes(state, this.type);
              const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
              if (hasStyles) {
                return true;
              }
              return commands2.unsetMark(this.name);
            }
          };
        }
      });
      inputRegex5 = /^(\d+)\.\s$/;
      OrderedList = Node3.create({
        name: "orderedList",
        addOptions() {
          return {
            itemTypeName: "listItem",
            HTMLAttributes: {},
            keepMarks: false,
            keepAttributes: false
          };
        },
        group: "block list",
        content() {
          return `${this.options.itemTypeName}+`;
        },
        addAttributes() {
          return {
            start: {
              default: 1,
              parseHTML: (element) => {
                return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
              }
            }
          };
        },
        parseHTML() {
          return [
            {
              tag: "ol"
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          const { start: start3, ...attributesWithoutStart } = HTMLAttributes;
          return start3 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            toggleOrderedList: () => ({ commands: commands2, chain }) => {
              if (this.options.keepAttributes) {
                return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem3.name, this.editor.getAttributes(TextStyle3.name)).run();
              }
              return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
          };
        },
        addInputRules() {
          let inputRule = wrappingInputRule({
            find: inputRegex5,
            type: this.type,
            getAttributes: (match) => ({ start: +match[1] }),
            joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
          });
          if (this.options.keepMarks || this.options.keepAttributes) {
            inputRule = wrappingInputRule({
              find: inputRegex5,
              type: this.type,
              keepMarks: this.options.keepMarks,
              keepAttributes: this.options.keepAttributes,
              getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyle3.name) }),
              joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
              editor: this.editor
            });
          }
          return [
            inputRule
          ];
        }
      });
    }
  });

  // node_modules/@tiptap/extension-paragraph/dist/index.js
  var dist_exports31 = {};
  __export(dist_exports31, {
    Paragraph: () => Paragraph,
    default: () => Paragraph
  });
  var Paragraph;
  var init_dist56 = __esm({
    "node_modules/@tiptap/extension-paragraph/dist/index.js"() {
      init_dist16();
      Paragraph = Node3.create({
        name: "paragraph",
        priority: 1e3,
        addOptions() {
          return {
            HTMLAttributes: {}
          };
        },
        group: "block",
        content: "inline*",
        parseHTML() {
          return [
            { tag: "p" }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
        },
        addCommands() {
          return {
            setParagraph: () => ({ commands: commands2 }) => {
              return commands2.setNode(this.name);
            }
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Alt-0": () => this.editor.commands.setParagraph()
          };
        }
      });
    }
  });

  // node_modules/@tiptap/extension-text/dist/index.js
  var dist_exports32 = {};
  __export(dist_exports32, {
    Text: () => Text2,
    default: () => Text2
  });
  var Text2;
  var init_dist57 = __esm({
    "node_modules/@tiptap/extension-text/dist/index.js"() {
      init_dist16();
      Text2 = Node3.create({
        name: "text",
        group: "inline"
      });
    }
  });

  // node_modules/highlight.js/lib/core.js
  var require_core = __commonJS({
    "node_modules/highlight.js/lib/core.js"(exports, module) {
      function deepFreeze2(obj) {
        if (obj instanceof Map) {
          obj.clear = obj.delete = obj.set = function() {
            throw new Error("map is read-only");
          };
        } else if (obj instanceof Set) {
          obj.add = obj.clear = obj.delete = function() {
            throw new Error("set is read-only");
          };
        }
        Object.freeze(obj);
        Object.getOwnPropertyNames(obj).forEach((name) => {
          const prop = obj[name];
          const type = typeof prop;
          if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
            deepFreeze2(prop);
          }
        });
        return obj;
      }
      var Response3 = class {
        /**
         * @param {CompiledMode} mode
         */
        constructor(mode) {
          if (mode.data === void 0)
            mode.data = {};
          this.data = mode.data;
          this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      };
      function escapeHTML2(value) {
        return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function inherit$12(original, ...objects) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key in original) {
          result[key] = original[key];
        }
        objects.forEach(function(obj) {
          for (const key in obj) {
            result[key] = obj[key];
          }
        });
        return (
          /** @type {T} */
          result
        );
      }
      var SPAN_CLOSE2 = "</span>";
      var emitsWrappingTags2 = (node) => {
        return !!node.scope;
      };
      var scopeToCSSClass2 = (name, { prefix }) => {
        if (name.startsWith("language:")) {
          return name.replace("language:", "language-");
        }
        if (name.includes(".")) {
          const pieces = name.split(".");
          return [
            `${prefix}${pieces.shift()}`,
            ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
          ].join(" ");
        }
        return `${prefix}${name}`;
      };
      var HTMLRenderer2 = class {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(parseTree, options) {
          this.buffer = "";
          this.classPrefix = options.classPrefix;
          parseTree.walk(this);
        }
        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(text) {
          this.buffer += escapeHTML2(text);
        }
        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(node) {
          if (!emitsWrappingTags2(node))
            return;
          const className = scopeToCSSClass2(
            node.scope,
            { prefix: this.classPrefix }
          );
          this.span(className);
        }
        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(node) {
          if (!emitsWrappingTags2(node))
            return;
          this.buffer += SPAN_CLOSE2;
        }
        /**
         * returns the accumulated buffer
        */
        value() {
          return this.buffer;
        }
        // helpers
        /**
         * Builds a span element
         *
         * @param {string} className */
        span(className) {
          this.buffer += `<span class="${className}">`;
        }
      };
      var newNode2 = (opts = {}) => {
        const result = { children: [] };
        Object.assign(result, opts);
        return result;
      };
      var TokenTree2 = class _TokenTree {
        constructor() {
          this.rootNode = newNode2();
          this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        /** @param {Node} node */
        add(node) {
          this.top.children.push(node);
        }
        /** @param {string} scope */
        openNode(scope) {
          const node = newNode2({ scope });
          this.add(node);
          this.stack.push(node);
        }
        closeNode() {
          if (this.stack.length > 1) {
            return this.stack.pop();
          }
          return void 0;
        }
        closeAllNodes() {
          while (this.closeNode())
            ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(builder) {
          return this.constructor._walk(builder, this.rootNode);
        }
        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(builder, node) {
          if (typeof node === "string") {
            builder.addText(node);
          } else if (node.children) {
            builder.openNode(node);
            node.children.forEach((child) => this._walk(builder, child));
            builder.closeNode(node);
          }
          return builder;
        }
        /**
         * @param {Node} node
         */
        static _collapse(node) {
          if (typeof node === "string")
            return;
          if (!node.children)
            return;
          if (node.children.every((el) => typeof el === "string")) {
            node.children = [node.children.join("")];
          } else {
            node.children.forEach((child) => {
              _TokenTree._collapse(child);
            });
          }
        }
      };
      var TokenTreeEmitter2 = class extends TokenTree2 {
        /**
         * @param {*} options
         */
        constructor(options) {
          super();
          this.options = options;
        }
        /**
         * @param {string} text
         */
        addText(text) {
          if (text === "") {
            return;
          }
          this.add(text);
        }
        /** @param {string} scope */
        startScope(scope) {
          this.openNode(scope);
        }
        endScope() {
          this.closeNode();
        }
        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        __addSublanguage(emitter, name) {
          const node = emitter.root;
          if (name)
            node.scope = `language:${name}`;
          this.add(node);
        }
        toHTML() {
          const renderer = new HTMLRenderer2(this, this.options);
          return renderer.value();
        }
        finalize() {
          this.closeAllNodes();
          return true;
        }
      };
      function source2(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function lookahead2(re) {
        return concat2("(?=", re, ")");
      }
      function anyNumberOfTimes2(re) {
        return concat2("(?:", re, ")*");
      }
      function optional2(re) {
        return concat2("(?:", re, ")?");
      }
      function concat2(...args) {
        const joined = args.map((x) => source2(x)).join("");
        return joined;
      }
      function stripOptionsFromArgs2(args) {
        const opts = args[args.length - 1];
        if (typeof opts === "object" && opts.constructor === Object) {
          args.splice(args.length - 1, 1);
          return opts;
        } else {
          return {};
        }
      }
      function either2(...args) {
        const opts = stripOptionsFromArgs2(args);
        const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source2(x)).join("|") + ")";
        return joined;
      }
      function countMatchGroups2(re) {
        return new RegExp(re.toString() + "|").exec("").length - 1;
      }
      function startsWith2(re, lexeme) {
        const match = re && re.exec(lexeme);
        return match && match.index === 0;
      }
      var BACKREF_RE2 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function _rewriteBackreferences2(regexps, { joinWith }) {
        let numCaptures = 0;
        return regexps.map((regex) => {
          numCaptures += 1;
          const offset2 = numCaptures;
          let re = source2(regex);
          let out = "";
          while (re.length > 0) {
            const match = BACKREF_RE2.exec(re);
            if (!match) {
              out += re;
              break;
            }
            out += re.substring(0, match.index);
            re = re.substring(match.index + match[0].length);
            if (match[0][0] === "\\" && match[1]) {
              out += "\\" + String(Number(match[1]) + offset2);
            } else {
              out += match[0];
              if (match[0] === "(") {
                numCaptures++;
              }
            }
          }
          return out;
        }).map((re) => `(${re})`).join(joinWith);
      }
      var MATCH_NOTHING_RE2 = /\b\B/;
      var IDENT_RE3 = "[a-zA-Z]\\w*";
      var UNDERSCORE_IDENT_RE2 = "[a-zA-Z_]\\w*";
      var NUMBER_RE2 = "\\b\\d+(\\.\\d+)?";
      var C_NUMBER_RE2 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
      var BINARY_NUMBER_RE2 = "\\b(0b[01]+)";
      var RE_STARTERS_RE2 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
      var SHEBANG2 = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
          opts.begin = concat2(
            beginShebang,
            /.*\b/,
            opts.binary,
            /\b.*/
          );
        }
        return inherit$12({
          scope: "meta",
          begin: beginShebang,
          end: /$/,
          relevance: 0,
          /** @type {ModeCallback} */
          "on:begin": (m, resp) => {
            if (m.index !== 0)
              resp.ignoreMatch();
          }
        }, opts);
      };
      var BACKSLASH_ESCAPE2 = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      };
      var APOS_STRING_MODE2 = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE2]
      };
      var QUOTE_STRING_MODE2 = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE2]
      };
      var PHRASAL_WORDS_MODE2 = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      };
      var COMMENT2 = function(begin, end2, modeOptions = {}) {
        const mode = inherit$12(
          {
            scope: "comment",
            begin,
            end: end2,
            contains: []
          },
          modeOptions
        );
        mode.contains.push({
          scope: "doctag",
          // hack to avoid the space from being included. the space is necessary to
          // match here to prevent the plain text rule below from gobbling up doctags
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const ENGLISH_WORD = either2(
          // list of common 1 and 2 letter words in English
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          // note: this is not an exhaustive list of contractions, just popular ones
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          // contractions - can't we'd they're let's, etc
          /[A-Za-z]+[-][a-z]+/,
          // `no-way`, etc.
          /[A-Za-z][a-z]{2,}/
          // allow capitalized words at beginning of sentences
        );
        mode.contains.push(
          {
            // TODO: how to include ", (, ) without breaking grammars that use these for
            // comment delimiters?
            // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
            // ---
            // this tries to find sequences of 3 english words in a row (without any
            // "programming" type syntax) this gives us a strong signal that we've
            // TRULY found a comment - vs perhaps scanning with the wrong language.
            // It's possible to find something that LOOKS like the start of the
            // comment - but then if there is no readable text - good chance it is a
            // false match and not a comment.
            //
            // for a visual example please see:
            // https://github.com/highlightjs/highlight.js/issues/2827
            begin: concat2(
              /[ ]+/,
              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
              "(",
              ENGLISH_WORD,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
            // look for 3 words in a row
          }
        );
        return mode;
      };
      var C_LINE_COMMENT_MODE2 = COMMENT2("//", "$");
      var C_BLOCK_COMMENT_MODE2 = COMMENT2("/\\*", "\\*/");
      var HASH_COMMENT_MODE2 = COMMENT2("#", "$");
      var NUMBER_MODE2 = {
        scope: "number",
        begin: NUMBER_RE2,
        relevance: 0
      };
      var C_NUMBER_MODE2 = {
        scope: "number",
        begin: C_NUMBER_RE2,
        relevance: 0
      };
      var BINARY_NUMBER_MODE2 = {
        scope: "number",
        begin: BINARY_NUMBER_RE2,
        relevance: 0
      };
      var REGEXP_MODE2 = {
        // this outer rule makes sure we actually have a WHOLE regex and not simply
        // an expression such as:
        //
        //     3 / something
        //
        // (which will then blow up when regex's `illegal` sees the newline)
        begin: /(?=\/[^/\n]*\/)/,
        contains: [{
          scope: "regexp",
          begin: /\//,
          end: /\/[gimuy]*/,
          illegal: /\n/,
          contains: [
            BACKSLASH_ESCAPE2,
            {
              begin: /\[/,
              end: /\]/,
              relevance: 0,
              contains: [BACKSLASH_ESCAPE2]
            }
          ]
        }]
      };
      var TITLE_MODE2 = {
        scope: "title",
        begin: IDENT_RE3,
        relevance: 0
      };
      var UNDERSCORE_TITLE_MODE2 = {
        scope: "title",
        begin: UNDERSCORE_IDENT_RE2,
        relevance: 0
      };
      var METHOD_GUARD2 = {
        // excludes method names from keyword processing
        begin: "\\.\\s*" + UNDERSCORE_IDENT_RE2,
        relevance: 0
      };
      var END_SAME_AS_BEGIN2 = function(mode) {
        return Object.assign(
          mode,
          {
            /** @type {ModeCallback} */
            "on:begin": (m, resp) => {
              resp.data._beginMatch = m[1];
            },
            /** @type {ModeCallback} */
            "on:end": (m, resp) => {
              if (resp.data._beginMatch !== m[1])
                resp.ignoreMatch();
            }
          }
        );
      };
      var MODES4 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE: MATCH_NOTHING_RE2,
        IDENT_RE: IDENT_RE3,
        UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE2,
        NUMBER_RE: NUMBER_RE2,
        C_NUMBER_RE: C_NUMBER_RE2,
        BINARY_NUMBER_RE: BINARY_NUMBER_RE2,
        RE_STARTERS_RE: RE_STARTERS_RE2,
        SHEBANG: SHEBANG2,
        BACKSLASH_ESCAPE: BACKSLASH_ESCAPE2,
        APOS_STRING_MODE: APOS_STRING_MODE2,
        QUOTE_STRING_MODE: QUOTE_STRING_MODE2,
        PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE2,
        COMMENT: COMMENT2,
        C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE2,
        C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE2,
        HASH_COMMENT_MODE: HASH_COMMENT_MODE2,
        NUMBER_MODE: NUMBER_MODE2,
        C_NUMBER_MODE: C_NUMBER_MODE2,
        BINARY_NUMBER_MODE: BINARY_NUMBER_MODE2,
        REGEXP_MODE: REGEXP_MODE2,
        TITLE_MODE: TITLE_MODE2,
        UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE2,
        METHOD_GUARD: METHOD_GUARD2,
        END_SAME_AS_BEGIN: END_SAME_AS_BEGIN2
      });
      function skipIfHasPrecedingDot2(match, response) {
        const before = match.input[match.index - 1];
        if (before === ".") {
          response.ignoreMatch();
        }
      }
      function scopeClassName2(mode, _parent) {
        if (mode.className !== void 0) {
          mode.scope = mode.className;
          delete mode.className;
        }
      }
      function beginKeywords2(mode, parent) {
        if (!parent)
          return;
        if (!mode.beginKeywords)
          return;
        mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
        mode.__beforeBegin = skipIfHasPrecedingDot2;
        mode.keywords = mode.keywords || mode.beginKeywords;
        delete mode.beginKeywords;
        if (mode.relevance === void 0)
          mode.relevance = 0;
      }
      function compileIllegal2(mode, _parent) {
        if (!Array.isArray(mode.illegal))
          return;
        mode.illegal = either2(...mode.illegal);
      }
      function compileMatch2(mode, _parent) {
        if (!mode.match)
          return;
        if (mode.begin || mode.end)
          throw new Error("begin & end are not supported with match");
        mode.begin = mode.match;
        delete mode.match;
      }
      function compileRelevance2(mode, _parent) {
        if (mode.relevance === void 0)
          mode.relevance = 1;
      }
      var beforeMatchExt2 = (mode, parent) => {
        if (!mode.beforeMatch)
          return;
        if (mode.starts)
          throw new Error("beforeMatch cannot be used with starts");
        const originalMode = Object.assign({}, mode);
        Object.keys(mode).forEach((key) => {
          delete mode[key];
        });
        mode.keywords = originalMode.keywords;
        mode.begin = concat2(originalMode.beforeMatch, lookahead2(originalMode.begin));
        mode.starts = {
          relevance: 0,
          contains: [
            Object.assign(originalMode, { endsParent: true })
          ]
        };
        mode.relevance = 0;
        delete originalMode.beforeMatch;
      };
      var COMMON_KEYWORDS2 = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        // common variable name
        "list",
        // common variable name
        "value"
        // common variable name
      ];
      var DEFAULT_KEYWORD_SCOPE2 = "keyword";
      function compileKeywords2(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE2) {
        const compiledKeywords = /* @__PURE__ */ Object.create(null);
        if (typeof rawKeywords === "string") {
          compileList(scopeName, rawKeywords.split(" "));
        } else if (Array.isArray(rawKeywords)) {
          compileList(scopeName, rawKeywords);
        } else {
          Object.keys(rawKeywords).forEach(function(scopeName2) {
            Object.assign(
              compiledKeywords,
              compileKeywords2(rawKeywords[scopeName2], caseInsensitive, scopeName2)
            );
          });
        }
        return compiledKeywords;
        function compileList(scopeName2, keywordList) {
          if (caseInsensitive) {
            keywordList = keywordList.map((x) => x.toLowerCase());
          }
          keywordList.forEach(function(keyword) {
            const pair = keyword.split("|");
            compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword2(pair[0], pair[1])];
          });
        }
      }
      function scoreForKeyword2(keyword, providedScore) {
        if (providedScore) {
          return Number(providedScore);
        }
        return commonKeyword2(keyword) ? 0 : 1;
      }
      function commonKeyword2(keyword) {
        return COMMON_KEYWORDS2.includes(keyword.toLowerCase());
      }
      var seenDeprecations2 = {};
      var error3 = (message) => {
        console.error(message);
      };
      var warn3 = (message, ...args) => {
        console.log(`WARN: ${message}`, ...args);
      };
      var deprecated2 = (version5, message) => {
        if (seenDeprecations2[`${version5}/${message}`])
          return;
        console.log(`Deprecated as of ${version5}. ${message}`);
        seenDeprecations2[`${version5}/${message}`] = true;
      };
      var MultiClassError2 = new Error();
      function remapScopeNames2(mode, regexes, { key }) {
        let offset2 = 0;
        const scopeNames = mode[key];
        const emit = {};
        const positions2 = {};
        for (let i = 1; i <= regexes.length; i++) {
          positions2[i + offset2] = scopeNames[i];
          emit[i + offset2] = true;
          offset2 += countMatchGroups2(regexes[i - 1]);
        }
        mode[key] = positions2;
        mode[key]._emit = emit;
        mode[key]._multi = true;
      }
      function beginMultiClass2(mode) {
        if (!Array.isArray(mode.begin))
          return;
        if (mode.skip || mode.excludeBegin || mode.returnBegin) {
          error3("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
          throw MultiClassError2;
        }
        if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
          error3("beginScope must be object");
          throw MultiClassError2;
        }
        remapScopeNames2(mode, mode.begin, { key: "beginScope" });
        mode.begin = _rewriteBackreferences2(mode.begin, { joinWith: "" });
      }
      function endMultiClass2(mode) {
        if (!Array.isArray(mode.end))
          return;
        if (mode.skip || mode.excludeEnd || mode.returnEnd) {
          error3("skip, excludeEnd, returnEnd not compatible with endScope: {}");
          throw MultiClassError2;
        }
        if (typeof mode.endScope !== "object" || mode.endScope === null) {
          error3("endScope must be object");
          throw MultiClassError2;
        }
        remapScopeNames2(mode, mode.end, { key: "endScope" });
        mode.end = _rewriteBackreferences2(mode.end, { joinWith: "" });
      }
      function scopeSugar2(mode) {
        if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
          mode.beginScope = mode.scope;
          delete mode.scope;
        }
      }
      function MultiClass2(mode) {
        scopeSugar2(mode);
        if (typeof mode.beginScope === "string") {
          mode.beginScope = { _wrap: mode.beginScope };
        }
        if (typeof mode.endScope === "string") {
          mode.endScope = { _wrap: mode.endScope };
        }
        beginMultiClass2(mode);
        endMultiClass2(mode);
      }
      function compileLanguage2(language) {
        function langRe(value, global2) {
          return new RegExp(
            source2(value),
            "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
          );
        }
        class MultiRegex {
          constructor() {
            this.matchIndexes = {};
            this.regexes = [];
            this.matchAt = 1;
            this.position = 0;
          }
          // @ts-ignore
          addRule(re, opts) {
            opts.position = this.position++;
            this.matchIndexes[this.matchAt] = opts;
            this.regexes.push([opts, re]);
            this.matchAt += countMatchGroups2(re) + 1;
          }
          compile() {
            if (this.regexes.length === 0) {
              this.exec = () => null;
            }
            const terminators = this.regexes.map((el) => el[1]);
            this.matcherRe = langRe(_rewriteBackreferences2(terminators, { joinWith: "|" }), true);
            this.lastIndex = 0;
          }
          /** @param {string} s */
          exec(s) {
            this.matcherRe.lastIndex = this.lastIndex;
            const match = this.matcherRe.exec(s);
            if (!match) {
              return null;
            }
            const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
            const matchData = this.matchIndexes[i];
            match.splice(0, i);
            return Object.assign(match, matchData);
          }
        }
        class ResumableMultiRegex {
          constructor() {
            this.rules = [];
            this.multiRegexes = [];
            this.count = 0;
            this.lastIndex = 0;
            this.regexIndex = 0;
          }
          // @ts-ignore
          getMatcher(index3) {
            if (this.multiRegexes[index3])
              return this.multiRegexes[index3];
            const matcher = new MultiRegex();
            this.rules.slice(index3).forEach(([re, opts]) => matcher.addRule(re, opts));
            matcher.compile();
            this.multiRegexes[index3] = matcher;
            return matcher;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          // @ts-ignore
          addRule(re, opts) {
            this.rules.push([re, opts]);
            if (opts.type === "begin")
              this.count++;
          }
          /** @param {string} s */
          exec(s) {
            const m = this.getMatcher(this.regexIndex);
            m.lastIndex = this.lastIndex;
            let result = m.exec(s);
            if (this.resumingScanAtSamePosition()) {
              if (result && result.index === this.lastIndex)
                ;
              else {
                const m2 = this.getMatcher(0);
                m2.lastIndex = this.lastIndex + 1;
                result = m2.exec(s);
              }
            }
            if (result) {
              this.regexIndex += result.position + 1;
              if (this.regexIndex === this.count) {
                this.considerAll();
              }
            }
            return result;
          }
        }
        function buildModeRegex(mode) {
          const mm = new ResumableMultiRegex();
          mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
          if (mode.terminatorEnd) {
            mm.addRule(mode.terminatorEnd, { type: "end" });
          }
          if (mode.illegal) {
            mm.addRule(mode.illegal, { type: "illegal" });
          }
          return mm;
        }
        function compileMode(mode, parent) {
          const cmode = (
            /** @type CompiledMode */
            mode
          );
          if (mode.isCompiled)
            return cmode;
          [
            scopeClassName2,
            // do this early so compiler extensions generally don't have to worry about
            // the distinction between match/begin
            compileMatch2,
            MultiClass2,
            beforeMatchExt2
          ].forEach((ext) => ext(mode, parent));
          language.compilerExtensions.forEach((ext) => ext(mode, parent));
          mode.__beforeBegin = null;
          [
            beginKeywords2,
            // do this later so compiler extensions that come earlier have access to the
            // raw array if they wanted to perhaps manipulate it, etc.
            compileIllegal2,
            // default to 1 relevance if not specified
            compileRelevance2
          ].forEach((ext) => ext(mode, parent));
          mode.isCompiled = true;
          let keywordPattern = null;
          if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
            mode.keywords = Object.assign({}, mode.keywords);
            keywordPattern = mode.keywords.$pattern;
            delete mode.keywords.$pattern;
          }
          keywordPattern = keywordPattern || /\w+/;
          if (mode.keywords) {
            mode.keywords = compileKeywords2(mode.keywords, language.case_insensitive);
          }
          cmode.keywordPatternRe = langRe(keywordPattern, true);
          if (parent) {
            if (!mode.begin)
              mode.begin = /\B|\b/;
            cmode.beginRe = langRe(cmode.begin);
            if (!mode.end && !mode.endsWithParent)
              mode.end = /\B|\b/;
            if (mode.end)
              cmode.endRe = langRe(cmode.end);
            cmode.terminatorEnd = source2(cmode.end) || "";
            if (mode.endsWithParent && parent.terminatorEnd) {
              cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
            }
          }
          if (mode.illegal)
            cmode.illegalRe = langRe(
              /** @type {RegExp | string} */
              mode.illegal
            );
          if (!mode.contains)
            mode.contains = [];
          mode.contains = [].concat(...mode.contains.map(function(c) {
            return expandOrCloneMode2(c === "self" ? mode : c);
          }));
          mode.contains.forEach(function(c) {
            compileMode(
              /** @type Mode */
              c,
              cmode
            );
          });
          if (mode.starts) {
            compileMode(mode.starts, parent);
          }
          cmode.matcher = buildModeRegex(cmode);
          return cmode;
        }
        if (!language.compilerExtensions)
          language.compilerExtensions = [];
        if (language.contains && language.contains.includes("self")) {
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        }
        language.classNameAliases = inherit$12(language.classNameAliases || {});
        return compileMode(
          /** @type Mode */
          language
        );
      }
      function dependencyOnParent2(mode) {
        if (!mode)
          return false;
        return mode.endsWithParent || dependencyOnParent2(mode.starts);
      }
      function expandOrCloneMode2(mode) {
        if (mode.variants && !mode.cachedVariants) {
          mode.cachedVariants = mode.variants.map(function(variant) {
            return inherit$12(mode, { variants: null }, variant);
          });
        }
        if (mode.cachedVariants) {
          return mode.cachedVariants;
        }
        if (dependencyOnParent2(mode)) {
          return inherit$12(mode, { starts: mode.starts ? inherit$12(mode.starts) : null });
        }
        if (Object.isFrozen(mode)) {
          return inherit$12(mode);
        }
        return mode;
      }
      var version4 = "11.8.0";
      var HTMLInjectionError2 = class extends Error {
        constructor(reason, html) {
          super(reason);
          this.name = "HTMLInjectionError";
          this.html = html;
        }
      };
      var escape2 = escapeHTML2;
      var inherit2 = inherit$12;
      var NO_MATCH2 = Symbol("nomatch");
      var MAX_KEYWORD_HITS2 = 7;
      var HLJS2 = function(hljs) {
        const languages = /* @__PURE__ */ Object.create(null);
        const aliases = /* @__PURE__ */ Object.create(null);
        const plugins3 = [];
        let SAFE_MODE = true;
        const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
        let options = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          // beta configuration options, subject to change, welcome to discuss
          // https://github.com/highlightjs/highlight.js/issues/1086
          __emitter: TokenTreeEmitter2
        };
        function shouldNotHighlight(languageName) {
          return options.noHighlightRe.test(languageName);
        }
        function blockLanguage(block) {
          let classes = block.className + " ";
          classes += block.parentNode ? block.parentNode.className : "";
          const match = options.languageDetectRe.exec(classes);
          if (match) {
            const language = getLanguage(match[1]);
            if (!language) {
              warn3(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
              warn3("Falling back to no-highlight mode for this block.", block);
            }
            return language ? match[1] : "no-highlight";
          }
          return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
        }
        function highlight4(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
          let code = "";
          let languageName = "";
          if (typeof optionsOrCode === "object") {
            code = codeOrLanguageName;
            ignoreIllegals = optionsOrCode.ignoreIllegals;
            languageName = optionsOrCode.language;
          } else {
            deprecated2("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
            deprecated2("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
            languageName = codeOrLanguageName;
            code = optionsOrCode;
          }
          if (ignoreIllegals === void 0) {
            ignoreIllegals = true;
          }
          const context = {
            code,
            language: languageName
          };
          fire("before:highlight", context);
          const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
          result.code = context.code;
          fire("after:highlight", result);
          return result;
        }
        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
          const keywordHits = /* @__PURE__ */ Object.create(null);
          function keywordData(mode, matchText) {
            return mode.keywords[matchText];
          }
          function processKeywords() {
            if (!top2.keywords) {
              emitter.addText(modeBuffer);
              return;
            }
            let lastIndex = 0;
            top2.keywordPatternRe.lastIndex = 0;
            let match = top2.keywordPatternRe.exec(modeBuffer);
            let buf = "";
            while (match) {
              buf += modeBuffer.substring(lastIndex, match.index);
              const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
              const data = keywordData(top2, word);
              if (data) {
                const [kind, keywordRelevance] = data;
                emitter.addText(buf);
                buf = "";
                keywordHits[word] = (keywordHits[word] || 0) + 1;
                if (keywordHits[word] <= MAX_KEYWORD_HITS2)
                  relevance += keywordRelevance;
                if (kind.startsWith("_")) {
                  buf += match[0];
                } else {
                  const cssClass = language.classNameAliases[kind] || kind;
                  emitKeyword(match[0], cssClass);
                }
              } else {
                buf += match[0];
              }
              lastIndex = top2.keywordPatternRe.lastIndex;
              match = top2.keywordPatternRe.exec(modeBuffer);
            }
            buf += modeBuffer.substring(lastIndex);
            emitter.addText(buf);
          }
          function processSubLanguage() {
            if (modeBuffer === "")
              return;
            let result2 = null;
            if (typeof top2.subLanguage === "string") {
              if (!languages[top2.subLanguage]) {
                emitter.addText(modeBuffer);
                return;
              }
              result2 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
              continuations[top2.subLanguage] = /** @type {CompiledMode} */
              result2._top;
            } else {
              result2 = highlightAuto2(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
            }
            if (top2.relevance > 0) {
              relevance += result2.relevance;
            }
            emitter.__addSublanguage(result2._emitter, result2.language);
          }
          function processBuffer() {
            if (top2.subLanguage != null) {
              processSubLanguage();
            } else {
              processKeywords();
            }
            modeBuffer = "";
          }
          function emitKeyword(keyword, scope) {
            if (keyword === "")
              return;
            emitter.startScope(scope);
            emitter.addText(keyword);
            emitter.endScope();
          }
          function emitMultiClass(scope, match) {
            let i = 1;
            const max2 = match.length - 1;
            while (i <= max2) {
              if (!scope._emit[i]) {
                i++;
                continue;
              }
              const klass = language.classNameAliases[scope[i]] || scope[i];
              const text = match[i];
              if (klass) {
                emitKeyword(text, klass);
              } else {
                modeBuffer = text;
                processKeywords();
                modeBuffer = "";
              }
              i++;
            }
          }
          function startNewMode(mode, match) {
            if (mode.scope && typeof mode.scope === "string") {
              emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
            }
            if (mode.beginScope) {
              if (mode.beginScope._wrap) {
                emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
                modeBuffer = "";
              } else if (mode.beginScope._multi) {
                emitMultiClass(mode.beginScope, match);
                modeBuffer = "";
              }
            }
            top2 = Object.create(mode, { parent: { value: top2 } });
            return top2;
          }
          function endOfMode(mode, match, matchPlusRemainder) {
            let matched = startsWith2(mode.endRe, matchPlusRemainder);
            if (matched) {
              if (mode["on:end"]) {
                const resp = new Response3(mode);
                mode["on:end"](match, resp);
                if (resp.isMatchIgnored)
                  matched = false;
              }
              if (matched) {
                while (mode.endsParent && mode.parent) {
                  mode = mode.parent;
                }
                return mode;
              }
            }
            if (mode.endsWithParent) {
              return endOfMode(mode.parent, match, matchPlusRemainder);
            }
          }
          function doIgnore(lexeme) {
            if (top2.matcher.regexIndex === 0) {
              modeBuffer += lexeme[0];
              return 1;
            } else {
              resumeScanAtSamePosition = true;
              return 0;
            }
          }
          function doBeginMatch(match) {
            const lexeme = match[0];
            const newMode = match.rule;
            const resp = new Response3(newMode);
            const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
            for (const cb of beforeCallbacks) {
              if (!cb)
                continue;
              cb(match, resp);
              if (resp.isMatchIgnored)
                return doIgnore(lexeme);
            }
            if (newMode.skip) {
              modeBuffer += lexeme;
            } else {
              if (newMode.excludeBegin) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (!newMode.returnBegin && !newMode.excludeBegin) {
                modeBuffer = lexeme;
              }
            }
            startNewMode(newMode, match);
            return newMode.returnBegin ? 0 : lexeme.length;
          }
          function doEndMatch(match) {
            const lexeme = match[0];
            const matchPlusRemainder = codeToHighlight.substring(match.index);
            const endMode = endOfMode(top2, match, matchPlusRemainder);
            if (!endMode) {
              return NO_MATCH2;
            }
            const origin = top2;
            if (top2.endScope && top2.endScope._wrap) {
              processBuffer();
              emitKeyword(lexeme, top2.endScope._wrap);
            } else if (top2.endScope && top2.endScope._multi) {
              processBuffer();
              emitMultiClass(top2.endScope, match);
            } else if (origin.skip) {
              modeBuffer += lexeme;
            } else {
              if (!(origin.returnEnd || origin.excludeEnd)) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (origin.excludeEnd) {
                modeBuffer = lexeme;
              }
            }
            do {
              if (top2.scope) {
                emitter.closeNode();
              }
              if (!top2.skip && !top2.subLanguage) {
                relevance += top2.relevance;
              }
              top2 = top2.parent;
            } while (top2 !== endMode.parent);
            if (endMode.starts) {
              startNewMode(endMode.starts, match);
            }
            return origin.returnEnd ? 0 : lexeme.length;
          }
          function processContinuations() {
            const list = [];
            for (let current = top2; current !== language; current = current.parent) {
              if (current.scope) {
                list.unshift(current.scope);
              }
            }
            list.forEach((item) => emitter.openNode(item));
          }
          let lastMatch = {};
          function processLexeme(textBeforeMatch, match) {
            const lexeme = match && match[0];
            modeBuffer += textBeforeMatch;
            if (lexeme == null) {
              processBuffer();
              return 0;
            }
            if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
              modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
              if (!SAFE_MODE) {
                const err = new Error(`0 width match regex (${languageName})`);
                err.languageName = languageName;
                err.badRule = lastMatch.rule;
                throw err;
              }
              return 1;
            }
            lastMatch = match;
            if (match.type === "begin") {
              return doBeginMatch(match);
            } else if (match.type === "illegal" && !ignoreIllegals) {
              const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.scope || "<unnamed>") + '"');
              err.mode = top2;
              throw err;
            } else if (match.type === "end") {
              const processed = doEndMatch(match);
              if (processed !== NO_MATCH2) {
                return processed;
              }
            }
            if (match.type === "illegal" && lexeme === "") {
              return 1;
            }
            if (iterations > 1e5 && iterations > match.index * 3) {
              const err = new Error("potential infinite loop, way more iterations than matches");
              throw err;
            }
            modeBuffer += lexeme;
            return lexeme.length;
          }
          const language = getLanguage(languageName);
          if (!language) {
            error3(LANGUAGE_NOT_FOUND.replace("{}", languageName));
            throw new Error('Unknown language: "' + languageName + '"');
          }
          const md = compileLanguage2(language);
          let result = "";
          let top2 = continuation || md;
          const continuations = {};
          const emitter = new options.__emitter(options);
          processContinuations();
          let modeBuffer = "";
          let relevance = 0;
          let index3 = 0;
          let iterations = 0;
          let resumeScanAtSamePosition = false;
          try {
            if (!language.__emitTokens) {
              top2.matcher.considerAll();
              for (; ; ) {
                iterations++;
                if (resumeScanAtSamePosition) {
                  resumeScanAtSamePosition = false;
                } else {
                  top2.matcher.considerAll();
                }
                top2.matcher.lastIndex = index3;
                const match = top2.matcher.exec(codeToHighlight);
                if (!match)
                  break;
                const beforeMatch = codeToHighlight.substring(index3, match.index);
                const processedCount = processLexeme(beforeMatch, match);
                index3 = match.index + processedCount;
              }
              processLexeme(codeToHighlight.substring(index3));
            } else {
              language.__emitTokens(codeToHighlight, emitter);
            }
            emitter.finalize();
            result = emitter.toHTML();
            return {
              language: languageName,
              value: result,
              relevance,
              illegal: false,
              _emitter: emitter,
              _top: top2
            };
          } catch (err) {
            if (err.message && err.message.includes("Illegal")) {
              return {
                language: languageName,
                value: escape2(codeToHighlight),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: err.message,
                  index: index3,
                  context: codeToHighlight.slice(index3 - 100, index3 + 100),
                  mode: err.mode,
                  resultSoFar: result
                },
                _emitter: emitter
              };
            } else if (SAFE_MODE) {
              return {
                language: languageName,
                value: escape2(codeToHighlight),
                illegal: false,
                relevance: 0,
                errorRaised: err,
                _emitter: emitter,
                _top: top2
              };
            } else {
              throw err;
            }
          }
        }
        function justTextHighlightResult(code) {
          const result = {
            value: escape2(code),
            illegal: false,
            relevance: 0,
            _top: PLAINTEXT_LANGUAGE,
            _emitter: new options.__emitter(options)
          };
          result._emitter.addText(code);
          return result;
        }
        function highlightAuto2(code, languageSubset) {
          languageSubset = languageSubset || options.languages || Object.keys(languages);
          const plaintext = justTextHighlightResult(code);
          const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
            (name) => _highlight(name, code, false)
          );
          results.unshift(plaintext);
          const sorted = results.sort((a, b) => {
            if (a.relevance !== b.relevance)
              return b.relevance - a.relevance;
            if (a.language && b.language) {
              if (getLanguage(a.language).supersetOf === b.language) {
                return 1;
              } else if (getLanguage(b.language).supersetOf === a.language) {
                return -1;
              }
            }
            return 0;
          });
          const [best, secondBest] = sorted;
          const result = best;
          result.secondBest = secondBest;
          return result;
        }
        function updateClassName(element, currentLang, resultLang) {
          const language = currentLang && aliases[currentLang] || resultLang;
          element.classList.add("hljs");
          element.classList.add(`language-${language}`);
        }
        function highlightElement(element) {
          let node = null;
          const language = blockLanguage(element);
          if (shouldNotHighlight(language))
            return;
          fire(
            "before:highlightElement",
            { el: element, language }
          );
          if (element.children.length > 0) {
            if (!options.ignoreUnescapedHTML) {
              console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
              console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
              console.warn("The element with unescaped HTML:");
              console.warn(element);
            }
            if (options.throwUnescapedHTML) {
              const err = new HTMLInjectionError2(
                "One of your code blocks includes unescaped HTML.",
                element.innerHTML
              );
              throw err;
            }
          }
          node = element;
          const text = node.textContent;
          const result = language ? highlight4(text, { language, ignoreIllegals: true }) : highlightAuto2(text);
          element.innerHTML = result.value;
          updateClassName(element, language, result.language);
          element.result = {
            language: result.language,
            // TODO: remove with version 11.0
            re: result.relevance,
            relevance: result.relevance
          };
          if (result.secondBest) {
            element.secondBest = {
              language: result.secondBest.language,
              relevance: result.secondBest.relevance
            };
          }
          fire("after:highlightElement", { el: element, result, text });
        }
        function configure(userOptions) {
          options = inherit2(options, userOptions);
        }
        const initHighlighting = () => {
          highlightAll();
          deprecated2("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function initHighlightingOnLoad() {
          highlightAll();
          deprecated2("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let wantsHighlight = false;
        function highlightAll() {
          if (document.readyState === "loading") {
            wantsHighlight = true;
            return;
          }
          const blocks = document.querySelectorAll(options.cssSelector);
          blocks.forEach(highlightElement);
        }
        function boot() {
          if (wantsHighlight)
            highlightAll();
        }
        if (typeof window !== "undefined" && window.addEventListener) {
          window.addEventListener("DOMContentLoaded", boot, false);
        }
        function registerLanguage2(languageName, languageDefinition) {
          let lang = null;
          try {
            lang = languageDefinition(hljs);
          } catch (error$1) {
            error3("Language definition for '{}' could not be registered.".replace("{}", languageName));
            if (!SAFE_MODE) {
              throw error$1;
            } else {
              error3(error$1);
            }
            lang = PLAINTEXT_LANGUAGE;
          }
          if (!lang.name)
            lang.name = languageName;
          languages[languageName] = lang;
          lang.rawDefinition = languageDefinition.bind(null, hljs);
          if (lang.aliases) {
            registerAliases(lang.aliases, { languageName });
          }
        }
        function unregisterLanguage(languageName) {
          delete languages[languageName];
          for (const alias of Object.keys(aliases)) {
            if (aliases[alias] === languageName) {
              delete aliases[alias];
            }
          }
        }
        function listLanguages2() {
          return Object.keys(languages);
        }
        function getLanguage(name) {
          name = (name || "").toLowerCase();
          return languages[name] || languages[aliases[name]];
        }
        function registerAliases(aliasList, { languageName }) {
          if (typeof aliasList === "string") {
            aliasList = [aliasList];
          }
          aliasList.forEach((alias) => {
            aliases[alias.toLowerCase()] = languageName;
          });
        }
        function autoDetection(name) {
          const lang = getLanguage(name);
          return lang && !lang.disableAutodetect;
        }
        function upgradePluginAPI(plugin) {
          if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
            plugin["before:highlightElement"] = (data) => {
              plugin["before:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
          if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
            plugin["after:highlightElement"] = (data) => {
              plugin["after:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
        }
        function addPlugin(plugin) {
          upgradePluginAPI(plugin);
          plugins3.push(plugin);
        }
        function removePlugin(plugin) {
          const index3 = plugins3.indexOf(plugin);
          if (index3 !== -1) {
            plugins3.splice(index3, 1);
          }
        }
        function fire(event, args) {
          const cb = event;
          plugins3.forEach(function(plugin) {
            if (plugin[cb]) {
              plugin[cb](args);
            }
          });
        }
        function deprecateHighlightBlock(el) {
          deprecated2("10.7.0", "highlightBlock will be removed entirely in v12.0");
          deprecated2("10.7.0", "Please use highlightElement now.");
          return highlightElement(el);
        }
        Object.assign(hljs, {
          highlight: highlight4,
          highlightAuto: highlightAuto2,
          highlightAll,
          highlightElement,
          // TODO: Remove with v12 API
          highlightBlock: deprecateHighlightBlock,
          configure,
          initHighlighting,
          initHighlightingOnLoad,
          registerLanguage: registerLanguage2,
          unregisterLanguage,
          listLanguages: listLanguages2,
          getLanguage,
          registerAliases,
          autoDetection,
          inherit: inherit2,
          addPlugin,
          removePlugin
        });
        hljs.debugMode = function() {
          SAFE_MODE = false;
        };
        hljs.safeMode = function() {
          SAFE_MODE = true;
        };
        hljs.versionString = version4;
        hljs.regex = {
          concat: concat2,
          lookahead: lookahead2,
          either: either2,
          optional: optional2,
          anyNumberOfTimes: anyNumberOfTimes2
        };
        for (const key in MODES4) {
          if (typeof MODES4[key] === "object") {
            deepFreeze2(MODES4[key]);
          }
        }
        Object.assign(hljs, MODES4);
        return hljs;
      };
      var highlight3 = HLJS2({});
      highlight3.newInstance = () => HLJS2({});
      module.exports = highlight3;
      highlight3.HighlightJS = highlight3;
      highlight3.default = highlight3;
    }
  });

  // node_modules/highlight.js/es/core.js
  var import_core34, core_default;
  var init_core = __esm({
    "node_modules/highlight.js/es/core.js"() {
      import_core34 = __toESM(require_core(), 1);
      core_default = import_core34.default;
    }
  });

  // node_modules/format/format.js
  var require_format = __commonJS({
    "node_modules/format/format.js"(exports, module) {
      (function() {
        var namespace;
        if (typeof module !== "undefined") {
          namespace = module.exports = format;
        } else {
          namespace = function() {
            return this || (1, eval)("this");
          }();
        }
        namespace.format = format;
        namespace.vsprintf = vsprintf;
        if (typeof console !== "undefined" && typeof console.log === "function") {
          namespace.printf = printf;
        }
        function printf() {
          console.log(format.apply(null, arguments));
        }
        function vsprintf(fmt, replacements) {
          return format.apply(null, [fmt].concat(replacements));
        }
        function format(fmt) {
          var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
            return args[argIndex++];
          }, slurpNumber = function() {
            var digits = "";
            while (/\d/.test(fmt[i])) {
              digits += fmt[i++];
              c = fmt[i];
            }
            return digits.length > 0 ? parseInt(digits) : null;
          };
          for (; i < n; ++i) {
            c = fmt[i];
            if (escaped) {
              escaped = false;
              if (c == ".") {
                leadingZero = false;
                c = fmt[++i];
              } else if (c == "0" && fmt[i + 1] == ".") {
                leadingZero = true;
                i += 2;
                c = fmt[i];
              } else {
                leadingZero = true;
              }
              precision = slurpNumber();
              switch (c) {
                case "b":
                  result += parseInt(nextArg(), 10).toString(2);
                  break;
                case "c":
                  arg = nextArg();
                  if (typeof arg === "string" || arg instanceof String)
                    result += arg;
                  else
                    result += String.fromCharCode(parseInt(arg, 10));
                  break;
                case "d":
                  result += parseInt(nextArg(), 10);
                  break;
                case "f":
                  tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                  result += leadingZero ? tmp : tmp.replace(/^0/, "");
                  break;
                case "j":
                  result += JSON.stringify(nextArg());
                  break;
                case "o":
                  result += "0" + parseInt(nextArg(), 10).toString(8);
                  break;
                case "s":
                  result += nextArg();
                  break;
                case "x":
                  result += "0x" + parseInt(nextArg(), 10).toString(16);
                  break;
                case "X":
                  result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                  break;
                default:
                  result += c;
                  break;
              }
            } else if (c === "%") {
              escaped = true;
            } else {
              result += c;
            }
          }
          return result;
        }
      })();
    }
  });

  // node_modules/fault/index.js
  function create(Constructor) {
    FormattedError.displayName = Constructor.displayName || Constructor.name;
    return FormattedError;
    function FormattedError(format, ...values) {
      const reason = format ? (0, import_format.default)(format, ...values) : format;
      return new Constructor(reason);
    }
  }
  var import_format, fault;
  var init_fault = __esm({
    "node_modules/fault/index.js"() {
      import_format = __toESM(require_format(), 1);
      fault = Object.assign(create(Error), {
        eval: create(EvalError),
        range: create(RangeError),
        reference: create(ReferenceError),
        syntax: create(SyntaxError),
        type: create(TypeError),
        uri: create(URIError)
      });
    }
  });

  // node_modules/lowlight/lib/core.js
  function highlight2(language, value, options = {}) {
    let prefix = options.prefix;
    if (typeof language !== "string") {
      throw fault("Expected `string` for name, got `%s`", language);
    }
    if (!core_default.getLanguage(language)) {
      throw fault("Unknown language: `%s` is not registered", language);
    }
    if (typeof value !== "string") {
      throw fault("Expected `string` for value, got `%s`", value);
    }
    if (prefix === null || prefix === void 0) {
      prefix = defaultPrefix;
    }
    core_default.configure({ __emitter: HastEmitter, classPrefix: prefix });
    const result = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      core_default.highlight(value, { language, ignoreIllegals: true })
    );
    core_default.configure({});
    if (result.errorRaised) {
      throw result.errorRaised;
    }
    result._emitter.root.data.language = result.language;
    result._emitter.root.data.relevance = result.relevance;
    return result._emitter.root;
  }
  function highlightAuto(value, options = {}) {
    const subset = options.subset || core_default.listLanguages();
    let prefix = options.prefix;
    let index3 = -1;
    let result = {
      type: "root",
      data: { language: null, relevance: 0 },
      children: []
    };
    if (prefix === null || prefix === void 0) {
      prefix = defaultPrefix;
    }
    if (typeof value !== "string") {
      throw fault("Expected `string` for value, got `%s`", value);
    }
    while (++index3 < subset.length) {
      const name = subset[index3];
      if (!core_default.getLanguage(name))
        continue;
      const current = highlight2(name, value, options);
      if (current.data.relevance > result.data.relevance)
        result = current;
    }
    return result;
  }
  function registerLanguage(language, syntax) {
    core_default.registerLanguage(language, syntax);
  }
  function registered2(aliasOrLanguage) {
    return Boolean(core_default.getLanguage(aliasOrLanguage));
  }
  function listLanguages() {
    return core_default.listLanguages();
  }
  var own, defaultPrefix, registerAlias, HastEmitter, lowlight;
  var init_core2 = __esm({
    "node_modules/lowlight/lib/core.js"() {
      init_core();
      init_fault();
      own = {}.hasOwnProperty;
      defaultPrefix = "hljs-";
      registerAlias = /**
       * @type {(
       *   ((language: string, alias: string|Array<string>) => void) &
       *   ((aliases: Record<string, string|Array<string>>) => void)
       * )}
       */
      /**
       * @param {string|Record<string, string|Array<string>>} language
       * @param {string|Array<string>} [alias]
       * @returns {void}
       */
      function(language, alias) {
        if (typeof language === "string") {
          core_default.registerAliases(alias, { languageName: language });
        } else {
          let key;
          for (key in language) {
            if (own.call(language, key)) {
              core_default.registerAliases(language[key], { languageName: key });
            }
          }
        }
      };
      HastEmitter = class {
        /**
         * @param {HighlightOptions} options
         */
        constructor(options) {
          this.options = options;
          this.root = {
            type: "root",
            data: { language: null, relevance: 0 },
            children: []
          };
          this.stack = [this.root];
        }
        /**
         * @param {string} value
         */
        addText(value) {
          if (value === "")
            return;
          const current = this.stack[this.stack.length - 1];
          const tail = current.children[current.children.length - 1];
          if (tail && tail.type === "text") {
            tail.value += value;
          } else {
            current.children.push({ type: "text", value });
          }
        }
        /**
         *
         * @param {unknown} rawName
         */
        startScope(rawName) {
          this.openNode(String(rawName));
        }
        /**
         */
        endScope() {
          this.closeNode();
        }
        /**
         * @param {HastEmitter} other
         * @param {string} name
         */
        __addSublanguage(other, name) {
          const current = this.stack[this.stack.length - 1];
          const results = other.root.children;
          if (name) {
            current.children.push({
              type: "element",
              tagName: "span",
              properties: { className: [name] },
              children: results
            });
          } else {
            current.children.push(...results);
          }
        }
        /**
         * @param {string} name
         */
        openNode(name) {
          const className = name.split(".").map((d, i) => i ? d + "_".repeat(i) : this.options.classPrefix + d);
          const current = this.stack[this.stack.length - 1];
          const child = {
            type: "element",
            tagName: "span",
            properties: { className },
            children: []
          };
          current.children.push(child);
          this.stack.push(child);
        }
        /**
         */
        closeNode() {
          this.stack.pop();
        }
        /**
         */
        finalize() {
        }
        /**
         */
        toHTML() {
          return "";
        }
      };
      lowlight = {
        highlight: highlight2,
        highlightAuto,
        registerLanguage,
        registered: registered2,
        listLanguages,
        registerAlias
      };
    }
  });

  // node_modules/highlight.js/es/languages/css.js
  function css2(hljs) {
    const regex = hljs.regex;
    const modes = MODES2(hljs);
    const VENDOR_PREFIX = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ };
    const AT_MODIFIERS = "and or not only";
    const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
    const IDENT_RE3 = "[a-zA-Z-][a-zA-Z0-9_-]*";
    const STRINGS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ];
    return {
      name: "CSS",
      case_insensitive: true,
      illegal: /[=|'\$]/,
      keywords: { keyframePosition: "from to" },
      classNameAliases: {
        // for visual continuity with `tag {}` and because we
        // don't have a great class for this?
        keyframePosition: "selector-tag"
      },
      contains: [
        modes.BLOCK_COMMENT,
        VENDOR_PREFIX,
        // to recognize keyframe 40% etc which are outside the scope of our
        // attribute value mode
        modes.CSS_NUMBER_MODE,
        {
          className: "selector-id",
          begin: /#[A-Za-z0-9_-]+/,
          relevance: 0
        },
        {
          className: "selector-class",
          begin: "\\." + IDENT_RE3,
          relevance: 0
        },
        modes.ATTRIBUTE_SELECTOR_MODE,
        {
          className: "selector-pseudo",
          variants: [
            { begin: ":(" + PSEUDO_CLASSES.join("|") + ")" },
            { begin: ":(:)?(" + PSEUDO_ELEMENTS.join("|") + ")" }
          ]
        },
        // we may actually need this (12/2020)
        // { // pseudo-selector params
        //   begin: /\(/,
        //   end: /\)/,
        //   contains: [ hljs.CSS_NUMBER_MODE ]
        // },
        modes.CSS_VARIABLE,
        {
          className: "attribute",
          begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
        },
        // attribute values
        {
          begin: /:/,
          end: /[;}{]/,
          contains: [
            modes.BLOCK_COMMENT,
            modes.HEXCOLOR,
            modes.IMPORTANT,
            modes.CSS_NUMBER_MODE,
            ...STRINGS,
            // needed to highlight these as strings and to avoid issues with
            // illegal characters that might be inside urls that would tigger the
            // languages illegal stack
            {
              begin: /(url|data-uri)\(/,
              end: /\)/,
              relevance: 0,
              // from keywords
              keywords: { built_in: "url data-uri" },
              contains: [
                ...STRINGS,
                {
                  className: "string",
                  // any character other than `)` as in `url()` will be the start
                  // of a string, which ends with `)` (from the parent mode)
                  begin: /[^)]/,
                  endsWithParent: true,
                  excludeEnd: true
                }
              ]
            },
            modes.FUNCTION_DISPATCH
          ]
        },
        {
          begin: regex.lookahead(/@/),
          end: "[{;]",
          relevance: 0,
          illegal: /:/,
          // break on Less variables @var: ...
          contains: [
            {
              className: "keyword",
              begin: AT_PROPERTY_RE
            },
            {
              begin: /\s/,
              endsWithParent: true,
              excludeEnd: true,
              relevance: 0,
              keywords: {
                $pattern: /[a-z-]+/,
                keyword: AT_MODIFIERS,
                attribute: MEDIA_FEATURES.join(" ")
              },
              contains: [
                {
                  begin: /[a-z-]+(?=:)/,
                  className: "attribute"
                },
                ...STRINGS,
                modes.CSS_NUMBER_MODE
              ]
            }
          ]
        },
        {
          className: "selector-tag",
          begin: "\\b(" + TAGS.join("|") + ")\\b"
        }
      ]
    };
  }
  var MODES2, TAGS, MEDIA_FEATURES, PSEUDO_CLASSES, PSEUDO_ELEMENTS, ATTRIBUTES;
  var init_css = __esm({
    "node_modules/highlight.js/es/languages/css.js"() {
      MODES2 = (hljs) => {
        return {
          IMPORTANT: {
            scope: "meta",
            begin: "!important"
          },
          BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
          HEXCOLOR: {
            scope: "number",
            begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
          },
          FUNCTION_DISPATCH: {
            className: "built_in",
            begin: /[\w-]+(?=\()/
          },
          ATTRIBUTE_SELECTOR_MODE: {
            scope: "selector-attr",
            begin: /\[/,
            end: /\]/,
            illegal: "$",
            contains: [
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE
            ]
          },
          CSS_NUMBER_MODE: {
            scope: "number",
            begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
            relevance: 0
          },
          CSS_VARIABLE: {
            className: "attr",
            begin: /--[A-Za-z][A-Za-z0-9_-]*/
          }
        };
      };
      TAGS = [
        "a",
        "abbr",
        "address",
        "article",
        "aside",
        "audio",
        "b",
        "blockquote",
        "body",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "dd",
        "del",
        "details",
        "dfn",
        "div",
        "dl",
        "dt",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "mark",
        "menu",
        "nav",
        "object",
        "ol",
        "p",
        "q",
        "quote",
        "samp",
        "section",
        "span",
        "strong",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "ul",
        "var",
        "video"
      ];
      MEDIA_FEATURES = [
        "any-hover",
        "any-pointer",
        "aspect-ratio",
        "color",
        "color-gamut",
        "color-index",
        "device-aspect-ratio",
        "device-height",
        "device-width",
        "display-mode",
        "forced-colors",
        "grid",
        "height",
        "hover",
        "inverted-colors",
        "monochrome",
        "orientation",
        "overflow-block",
        "overflow-inline",
        "pointer",
        "prefers-color-scheme",
        "prefers-contrast",
        "prefers-reduced-motion",
        "prefers-reduced-transparency",
        "resolution",
        "scan",
        "scripting",
        "update",
        "width",
        // TODO: find a better solution?
        "min-width",
        "max-width",
        "min-height",
        "max-height"
      ];
      PSEUDO_CLASSES = [
        "active",
        "any-link",
        "blank",
        "checked",
        "current",
        "default",
        "defined",
        "dir",
        // dir()
        "disabled",
        "drop",
        "empty",
        "enabled",
        "first",
        "first-child",
        "first-of-type",
        "fullscreen",
        "future",
        "focus",
        "focus-visible",
        "focus-within",
        "has",
        // has()
        "host",
        // host or host()
        "host-context",
        // host-context()
        "hover",
        "indeterminate",
        "in-range",
        "invalid",
        "is",
        // is()
        "lang",
        // lang()
        "last-child",
        "last-of-type",
        "left",
        "link",
        "local-link",
        "not",
        // not()
        "nth-child",
        // nth-child()
        "nth-col",
        // nth-col()
        "nth-last-child",
        // nth-last-child()
        "nth-last-col",
        // nth-last-col()
        "nth-last-of-type",
        //nth-last-of-type()
        "nth-of-type",
        //nth-of-type()
        "only-child",
        "only-of-type",
        "optional",
        "out-of-range",
        "past",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "right",
        "root",
        "scope",
        "target",
        "target-within",
        "user-invalid",
        "valid",
        "visited",
        "where"
        // where()
      ];
      PSEUDO_ELEMENTS = [
        "after",
        "backdrop",
        "before",
        "cue",
        "cue-region",
        "first-letter",
        "first-line",
        "grammar-error",
        "marker",
        "part",
        "placeholder",
        "selection",
        "slotted",
        "spelling-error"
      ];
      ATTRIBUTES = [
        "align-content",
        "align-items",
        "align-self",
        "all",
        "animation",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "backface-visibility",
        "background",
        "background-attachment",
        "background-blend-mode",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "block-size",
        "border",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "bottom",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "break-after",
        "break-before",
        "break-inside",
        "caption-side",
        "caret-color",
        "clear",
        "clip",
        "clip-path",
        "clip-rule",
        "color",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columns",
        "contain",
        "content",
        "content-visibility",
        "counter-increment",
        "counter-reset",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "direction",
        "display",
        "empty-cells",
        "filter",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "float",
        "flow",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-size",
        "font-size-adjust",
        "font-smoothing",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-variant",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "gap",
        "glyph-orientation-vertical",
        "grid",
        "grid-area",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-auto-rows",
        "grid-column",
        "grid-column-end",
        "grid-column-start",
        "grid-gap",
        "grid-row",
        "grid-row-end",
        "grid-row-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "hyphens",
        "icon",
        "image-orientation",
        "image-rendering",
        "image-resolution",
        "ime-mode",
        "inline-size",
        "isolation",
        "justify-content",
        "left",
        "letter-spacing",
        "line-break",
        "line-height",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "margin-top",
        "marks",
        "mask",
        "mask-border",
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width",
        "mask-clip",
        "mask-composite",
        "mask-image",
        "mask-mode",
        "mask-origin",
        "mask-position",
        "mask-repeat",
        "mask-size",
        "mask-type",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-width",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-width",
        "mix-blend-mode",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "none",
        "normal",
        "object-fit",
        "object-position",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "overflow",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "padding",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "padding-top",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "pause",
        "pause-after",
        "pause-before",
        "perspective",
        "perspective-origin",
        "pointer-events",
        "position",
        "quotes",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "right",
        "row-gap",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "scroll-snap-align",
        "scroll-snap-stop",
        "scroll-snap-type",
        "scrollbar-color",
        "scrollbar-gutter",
        "scrollbar-width",
        "shape-image-threshold",
        "shape-margin",
        "shape-outside",
        "speak",
        "speak-as",
        "src",
        // @font-face
        "tab-size",
        "table-layout",
        "text-align",
        "text-align-all",
        "text-align-last",
        "text-combine-upright",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-style",
        "text-emphasis",
        "text-emphasis-color",
        "text-emphasis-position",
        "text-emphasis-style",
        "text-indent",
        "text-justify",
        "text-orientation",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-position",
        "top",
        "transform",
        "transform-box",
        "transform-origin",
        "transform-style",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "unicode-bidi",
        "vertical-align",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "white-space",
        "widows",
        "width",
        "will-change",
        "word-break",
        "word-spacing",
        "word-wrap",
        "writing-mode",
        "z-index"
        // reverse makes sure longer attributes `font-weight` are matched fully
        // instead of getting false positives on say `font`
      ].reverse();
    }
  });

  // node_modules/highlight.js/es/languages/javascript.js
  function javascript(hljs) {
    const regex = hljs.regex;
    const hasClosingTag = (match, { after }) => {
      const tag = "</" + match[0].slice(1);
      const pos = match.input.indexOf(tag, after);
      return pos !== -1;
    };
    const IDENT_RE$1 = IDENT_RE2;
    const FRAGMENT = {
      begin: "<>",
      end: "</>"
    };
    const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
    const XML_TAG = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      /**
       * @param {RegExpMatchArray} match
       * @param {CallbackResponse} response
       */
      isTrulyOpeningTag: (match, response) => {
        const afterMatchIndex = match[0].length + match.index;
        const nextChar = match.input[afterMatchIndex];
        if (
          // HTML should not include another raw `<` inside a tag
          // nested type?
          // `<Array<Array<number>>`, etc.
          nextChar === "<" || // the , gives away that this is not HTML
          // `<T, A extends keyof T, V>`
          nextChar === ","
        ) {
          response.ignoreMatch();
          return;
        }
        if (nextChar === ">") {
          if (!hasClosingTag(match, { after: afterMatchIndex })) {
            response.ignoreMatch();
          }
        }
        let m;
        const afterMatch = match.input.substring(afterMatchIndex);
        if (m = afterMatch.match(/^\s*=/)) {
          response.ignoreMatch();
          return;
        }
        if (m = afterMatch.match(/^\s+extends\s+/)) {
          if (m.index === 0) {
            response.ignoreMatch();
            return;
          }
        }
      }
    };
    const KEYWORDS$1 = {
      $pattern: IDENT_RE2,
      keyword: KEYWORDS,
      literal: LITERALS,
      built_in: BUILT_INS,
      "variable.language": BUILT_IN_VARIABLES
    };
    const decimalDigits = "[0-9](_?[0-9])*";
    const frac = `\\.(${decimalDigits})`;
    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
    const NUMBER = {
      className: "number",
      variants: [
        // DecimalLiteral
        { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
        { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
        // DecimalBigIntegerLiteral
        { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
        // NonDecimalIntegerLiteral
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        // LegacyOctalIntegerLiteral (does not include underscore separators)
        // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
        { begin: "\\b0[0-7]+n?\\b" }
      ],
      relevance: 0
    };
    const SUBST = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: KEYWORDS$1,
      contains: []
      // defined later
    };
    const HTML_TEMPLATE = {
      begin: "html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "xml"
      }
    };
    const CSS_TEMPLATE = {
      begin: "css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "css"
      }
    };
    const GRAPHQL_TEMPLATE = {
      begin: "gql`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "graphql"
      }
    };
    const TEMPLATE_STRING = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ]
    };
    const JSDOC_COMMENT = hljs.COMMENT(
      /\/\*\*(?!\/)/,
      "\\*/",
      {
        relevance: 0,
        contains: [
          {
            begin: "(?=@[A-Za-z]+)",
            relevance: 0,
            contains: [
              {
                className: "doctag",
                begin: "@[A-Za-z]+"
              },
              {
                className: "type",
                begin: "\\{",
                end: "\\}",
                excludeEnd: true,
                excludeBegin: true,
                relevance: 0
              },
              {
                className: "variable",
                begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                endsParent: true,
                relevance: 0
              },
              // eat spaces (not newlines) so we can find
              // types or variables
              {
                begin: /(?=[^\n])\s/,
                relevance: 0
              }
            ]
          }
        ]
      }
    );
    const COMMENT2 = {
      className: "comment",
      variants: [
        JSDOC_COMMENT,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.C_LINE_COMMENT_MODE
      ]
    };
    const SUBST_INTERNALS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER
      // This is intentional:
      // See https://github.com/highlightjs/highlight.js/issues/3288
      // hljs.REGEXP_MODE
    ];
    SUBST.contains = SUBST_INTERNALS.concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
    const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
      // eat recursive parens in sub expressions
      {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS$1,
        contains: ["self"].concat(SUBST_AND_COMMENTS)
      }
    ]);
    const PARAMS = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: KEYWORDS$1,
      contains: PARAMS_CONTAINS
    };
    const CLASS_OR_EXTENDS = {
      variants: [
        // class Car extends vehicle
        {
          match: [
            /class/,
            /\s+/,
            IDENT_RE$1,
            /\s+/,
            /extends/,
            /\s+/,
            regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            5: "keyword",
            7: "title.class.inherited"
          }
        },
        // class Car
        {
          match: [
            /class/,
            /\s+/,
            IDENT_RE$1
          ],
          scope: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    };
    const CLASS_REFERENCE = {
      relevance: 0,
      match: regex.either(
        // Hard coded exceptions
        /\bJSON/,
        // Float32Array, OutT
        /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
        // CSSFactory, CSSFactoryT
        /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
        // FPs, FPsT
        /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
        // P
        // single letters are not highlighted
        // BLAH
        // this will be flagged as a UPPER_CASE_CONSTANT instead
      ),
      className: "title.class",
      keywords: {
        _: [
          // se we still get relevance credit for JS library classes
          ...TYPES,
          ...ERROR_TYPES
        ]
      }
    };
    const USE_STRICT = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    };
    const FUNCTION_DEFINITION = {
      variants: [
        {
          match: [
            /function/,
            /\s+/,
            IDENT_RE$1,
            /(?=\s*\()/
          ]
        },
        // anonymous function
        {
          match: [
            /function/,
            /\s*(?=\()/
          ]
        }
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [PARAMS],
      illegal: /%/
    };
    const UPPER_CASE_CONSTANT = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    function noneOf(list) {
      return regex.concat("(?!", list.join("|"), ")");
    }
    const FUNCTION_CALL = {
      match: regex.concat(
        /\b/,
        noneOf([
          ...BUILT_IN_GLOBALS,
          "super",
          "import"
        ]),
        IDENT_RE$1,
        regex.lookahead(/\(/)
      ),
      className: "title.function",
      relevance: 0
    };
    const PROPERTY_ACCESS = {
      begin: regex.concat(/\./, regex.lookahead(
        regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
      )),
      end: IDENT_RE$1,
      excludeBegin: true,
      keywords: "prototype",
      className: "property",
      relevance: 0
    };
    const GETTER_OR_SETTER = {
      match: [
        /get|set/,
        /\s+/,
        IDENT_RE$1,
        /(?=\()/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        {
          // eat to avoid empty params
          begin: /\(\)/
        },
        PARAMS
      ]
    };
    const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
    const FUNCTION_VARIABLE = {
      match: [
        /const|var|let/,
        /\s+/,
        IDENT_RE$1,
        /\s*/,
        /=\s*/,
        /(async\s*)?/,
        // async is optional
        regex.lookahead(FUNC_LEAD_IN_RE)
      ],
      keywords: "async",
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        PARAMS
      ]
    };
    return {
      name: "JavaScript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: KEYWORDS$1,
      // this will be extended by TypeScript
      exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
      illegal: /#(?![$_A-z])/,
      contains: [
        hljs.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        USE_STRICT,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        GRAPHQL_TEMPLATE,
        TEMPLATE_STRING,
        COMMENT2,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        NUMBER,
        CLASS_REFERENCE,
        {
          className: "attr",
          begin: IDENT_RE$1 + regex.lookahead(":"),
          relevance: 0
        },
        FUNCTION_VARIABLE,
        {
          // "value" container
          begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [
            COMMENT2,
            hljs.REGEXP_MODE,
            {
              className: "function",
              // we have to count the parens to make sure we actually have the
              // correct bounding ( ) before the =>.  There could be any number of
              // sub-expressions inside also surrounded by parens.
              begin: FUNC_LEAD_IN_RE,
              returnBegin: true,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: hljs.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: true
                    },
                    {
                      begin: /\(/,
                      end: /\)/,
                      excludeBegin: true,
                      excludeEnd: true,
                      keywords: KEYWORDS$1,
                      contains: PARAMS_CONTAINS
                    }
                  ]
                }
              ]
            },
            {
              // could be a comma delimited list of params to a function call
              begin: /,/,
              relevance: 0
            },
            {
              match: /\s+/,
              relevance: 0
            },
            {
              // JSX
              variants: [
                { begin: FRAGMENT.begin, end: FRAGMENT.end },
                { match: XML_SELF_CLOSING },
                {
                  begin: XML_TAG.begin,
                  // we carefully check the opening tag to see if it truly
                  // is a tag and not a false positive
                  "on:begin": XML_TAG.isTrulyOpeningTag,
                  end: XML_TAG.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: XML_TAG.begin,
                  end: XML_TAG.end,
                  skip: true,
                  contains: ["self"]
                }
              ]
            }
          ]
        },
        FUNCTION_DEFINITION,
        {
          // prevent this from getting swallowed up by function
          // since they appear "function like"
          beginKeywords: "while if switch catch for"
        },
        {
          // we have to count the parens to make sure we actually have the correct
          // bounding ( ).  There could be any number of sub-expressions inside
          // also surrounded by parens.
          begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          // end parens
          returnBegin: true,
          label: "func.def",
          contains: [
            PARAMS,
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
          ]
        },
        // catch ... so it won't trigger the property rule below
        {
          match: /\.\.\./,
          relevance: 0
        },
        PROPERTY_ACCESS,
        // hack: prevents detection of keywords in some circumstances
        // .keyword()
        // $keyword = x
        {
          match: "\\$" + IDENT_RE$1,
          relevance: 0
        },
        {
          match: [/\bconstructor(?=\s*\()/],
          className: { 1: "title.function" },
          contains: [PARAMS]
        },
        FUNCTION_CALL,
        UPPER_CASE_CONSTANT,
        CLASS_OR_EXTENDS,
        GETTER_OR_SETTER,
        {
          match: /\$[(.]/
          // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
        }
      ]
    };
  }
  var IDENT_RE2, KEYWORDS, LITERALS, TYPES, ERROR_TYPES, BUILT_IN_GLOBALS, BUILT_IN_VARIABLES, BUILT_INS;
  var init_javascript = __esm({
    "node_modules/highlight.js/es/languages/javascript.js"() {
      IDENT_RE2 = "[A-Za-z$_][0-9A-Za-z$_]*";
      KEYWORDS = [
        "as",
        // for exports
        "in",
        "of",
        "if",
        "for",
        "while",
        "finally",
        "var",
        "new",
        "function",
        "do",
        "return",
        "void",
        "else",
        "break",
        "catch",
        "instanceof",
        "with",
        "throw",
        "case",
        "default",
        "try",
        "switch",
        "continue",
        "typeof",
        "delete",
        "let",
        "yield",
        "const",
        "class",
        // JS handles these with a special rule
        // "get",
        // "set",
        "debugger",
        "async",
        "await",
        "static",
        "import",
        "from",
        "export",
        "extends"
      ];
      LITERALS = [
        "true",
        "false",
        "null",
        "undefined",
        "NaN",
        "Infinity"
      ];
      TYPES = [
        // Fundamental objects
        "Object",
        "Function",
        "Boolean",
        "Symbol",
        // numbers and dates
        "Math",
        "Date",
        "Number",
        "BigInt",
        // text
        "String",
        "RegExp",
        // Indexed collections
        "Array",
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Int32Array",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array",
        // Keyed collections
        "Set",
        "Map",
        "WeakSet",
        "WeakMap",
        // Structured data
        "ArrayBuffer",
        "SharedArrayBuffer",
        "Atomics",
        "DataView",
        "JSON",
        // Control abstraction objects
        "Promise",
        "Generator",
        "GeneratorFunction",
        "AsyncFunction",
        // Reflection
        "Reflect",
        "Proxy",
        // Internationalization
        "Intl",
        // WebAssembly
        "WebAssembly"
      ];
      ERROR_TYPES = [
        "Error",
        "EvalError",
        "InternalError",
        "RangeError",
        "ReferenceError",
        "SyntaxError",
        "TypeError",
        "URIError"
      ];
      BUILT_IN_GLOBALS = [
        "setInterval",
        "setTimeout",
        "clearInterval",
        "clearTimeout",
        "require",
        "exports",
        "eval",
        "isFinite",
        "isNaN",
        "parseFloat",
        "parseInt",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "unescape"
      ];
      BUILT_IN_VARIABLES = [
        "arguments",
        "this",
        "super",
        "console",
        "window",
        "document",
        "localStorage",
        "sessionStorage",
        "module",
        "global"
        // Node.js
      ];
      BUILT_INS = [].concat(
        BUILT_IN_GLOBALS,
        TYPES,
        ERROR_TYPES
      );
    }
  });

  // node_modules/highlight.js/es/languages/json.js
  function json(hljs) {
    const ATTRIBUTE = {
      className: "attr",
      begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
      relevance: 1.01
    };
    const PUNCTUATION = {
      match: /[{}[\],:]/,
      className: "punctuation",
      relevance: 0
    };
    const LITERALS2 = [
      "true",
      "false",
      "null"
    ];
    const LITERALS_MODE = {
      scope: "literal",
      beginKeywords: LITERALS2.join(" ")
    };
    return {
      name: "JSON",
      keywords: {
        literal: LITERALS2
      },
      contains: [
        ATTRIBUTE,
        PUNCTUATION,
        hljs.QUOTE_STRING_MODE,
        LITERALS_MODE,
        hljs.C_NUMBER_MODE,
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE
      ],
      illegal: "\\S"
    };
  }
  var init_json = __esm({
    "node_modules/highlight.js/es/languages/json.js"() {
    }
  });

  // node_modules/highlight.js/es/languages/ruby.js
  function ruby(hljs) {
    const regex = hljs.regex;
    const RUBY_METHOD_RE = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)";
    const CLASS_NAME_RE = regex.either(
      /\b([A-Z]+[a-z0-9]+)+/,
      // ends in caps
      /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
    );
    const CLASS_NAME_WITH_NAMESPACE_RE = regex.concat(CLASS_NAME_RE, /(::\w+)*/);
    const PSEUDO_KWS = [
      "include",
      "extend",
      "prepend",
      "public",
      "private",
      "protected",
      "raise",
      "throw"
    ];
    const RUBY_KEYWORDS = {
      "variable.constant": [
        "__FILE__",
        "__LINE__",
        "__ENCODING__"
      ],
      "variable.language": [
        "self",
        "super"
      ],
      keyword: [
        "alias",
        "and",
        "begin",
        "BEGIN",
        "break",
        "case",
        "class",
        "defined",
        "do",
        "else",
        "elsif",
        "end",
        "END",
        "ensure",
        "for",
        "if",
        "in",
        "module",
        "next",
        "not",
        "or",
        "redo",
        "require",
        "rescue",
        "retry",
        "return",
        "then",
        "undef",
        "unless",
        "until",
        "when",
        "while",
        "yield",
        ...PSEUDO_KWS
      ],
      built_in: [
        "proc",
        "lambda",
        "attr_accessor",
        "attr_reader",
        "attr_writer",
        "define_method",
        "private_constant",
        "module_function"
      ],
      literal: [
        "true",
        "false",
        "nil"
      ]
    };
    const YARDOCTAG = {
      className: "doctag",
      begin: "@[A-Za-z]+"
    };
    const IRB_OBJECT = {
      begin: "#<",
      end: ">"
    };
    const COMMENT_MODES = [
      hljs.COMMENT(
        "#",
        "$",
        { contains: [YARDOCTAG] }
      ),
      hljs.COMMENT(
        "^=begin",
        "^=end",
        {
          contains: [YARDOCTAG],
          relevance: 10
        }
      ),
      hljs.COMMENT("^__END__", hljs.MATCH_NOTHING_RE)
    ];
    const SUBST = {
      className: "subst",
      begin: /#\{/,
      end: /\}/,
      keywords: RUBY_KEYWORDS
    };
    const STRING = {
      className: "string",
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      variants: [
        {
          begin: /'/,
          end: /'/
        },
        {
          begin: /"/,
          end: /"/
        },
        {
          begin: /`/,
          end: /`/
        },
        {
          begin: /%[qQwWx]?\(/,
          end: /\)/
        },
        {
          begin: /%[qQwWx]?\[/,
          end: /\]/
        },
        {
          begin: /%[qQwWx]?\{/,
          end: /\}/
        },
        {
          begin: /%[qQwWx]?</,
          end: />/
        },
        {
          begin: /%[qQwWx]?\//,
          end: /\//
        },
        {
          begin: /%[qQwWx]?%/,
          end: /%/
        },
        {
          begin: /%[qQwWx]?-/,
          end: /-/
        },
        {
          begin: /%[qQwWx]?\|/,
          end: /\|/
        },
        // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
        // where ? is the last character of a preceding identifier, as in: `func?4`
        { begin: /\B\?(\\\d{1,3})/ },
        { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
        { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
        { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
        { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
        { begin: /\B\?\\?\S/ },
        // heredocs
        {
          // this guard makes sure that we have an entire heredoc and not a false
          // positive (auto-detect, etc.)
          begin: regex.concat(
            /<<[-~]?'?/,
            regex.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
          ),
          contains: [
            hljs.END_SAME_AS_BEGIN({
              begin: /(\w+)/,
              end: /(\w+)/,
              contains: [
                hljs.BACKSLASH_ESCAPE,
                SUBST
              ]
            })
          ]
        }
      ]
    };
    const decimal = "[1-9](_?[0-9])*|0";
    const digits = "[0-9](_?[0-9])*";
    const NUMBER = {
      className: "number",
      relevance: 0,
      variants: [
        // decimal integer/float, optionally exponential or rational, optionally imaginary
        { begin: `\\b(${decimal})(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b` },
        // explicit decimal/binary/octal/hexadecimal integer,
        // optionally rational and/or imaginary
        { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
        // 0-prefixed implicit octal integer, optionally rational and/or imaginary
        { begin: "\\b0(_?[0-7])+r?i?\\b" }
      ]
    };
    const PARAMS = {
      variants: [
        {
          match: /\(\)/
        },
        {
          className: "params",
          begin: /\(/,
          end: /(?=\))/,
          excludeBegin: true,
          endsParent: true,
          keywords: RUBY_KEYWORDS
        }
      ]
    };
    const INCLUDE_EXTEND = {
      match: [
        /(include|extend)\s+/,
        CLASS_NAME_WITH_NAMESPACE_RE
      ],
      scope: {
        2: "title.class"
      },
      keywords: RUBY_KEYWORDS
    };
    const CLASS_DEFINITION = {
      variants: [
        {
          match: [
            /class\s+/,
            CLASS_NAME_WITH_NAMESPACE_RE,
            /\s+<\s+/,
            CLASS_NAME_WITH_NAMESPACE_RE
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            CLASS_NAME_WITH_NAMESPACE_RE
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: RUBY_KEYWORDS
    };
    const UPPER_CASE_CONSTANT = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    const METHOD_DEFINITION = {
      match: [
        /def/,
        /\s+/,
        RUBY_METHOD_RE
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        PARAMS
      ]
    };
    const OBJECT_CREATION = {
      relevance: 0,
      match: [
        CLASS_NAME_WITH_NAMESPACE_RE,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    };
    const CLASS_REFERENCE = {
      relevance: 0,
      match: CLASS_NAME_RE,
      scope: "title.class"
    };
    const RUBY_DEFAULT_CONTAINS = [
      STRING,
      CLASS_DEFINITION,
      INCLUDE_EXTEND,
      OBJECT_CREATION,
      UPPER_CASE_CONSTANT,
      CLASS_REFERENCE,
      METHOD_DEFINITION,
      {
        // swallow namespace qualifiers before symbols
        begin: hljs.IDENT_RE + "::"
      },
      {
        className: "symbol",
        begin: hljs.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
        relevance: 0
      },
      {
        className: "symbol",
        begin: ":(?!\\s)",
        contains: [
          STRING,
          { begin: RUBY_METHOD_RE }
        ],
        relevance: 0
      },
      NUMBER,
      {
        // negative-look forward attempts to prevent false matches like:
        // @ident@ or $ident$ that might indicate this is not ruby at all
        className: "variable",
        begin: `(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])`
      },
      {
        className: "params",
        begin: /\|/,
        end: /\|/,
        excludeBegin: true,
        excludeEnd: true,
        relevance: 0,
        // this could be a lot of things (in other languages) other than params
        keywords: RUBY_KEYWORDS
      },
      {
        // regexp container
        begin: "(" + hljs.RE_STARTERS_RE + "|unless)\\s*",
        keywords: "unless",
        contains: [
          {
            className: "regexp",
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ],
            illegal: /\n/,
            variants: [
              {
                begin: "/",
                end: "/[a-z]*"
              },
              {
                begin: /%r\{/,
                end: /\}[a-z]*/
              },
              {
                begin: "%r\\(",
                end: "\\)[a-z]*"
              },
              {
                begin: "%r!",
                end: "![a-z]*"
              },
              {
                begin: "%r\\[",
                end: "\\][a-z]*"
              }
            ]
          }
        ].concat(IRB_OBJECT, COMMENT_MODES),
        relevance: 0
      }
    ].concat(IRB_OBJECT, COMMENT_MODES);
    SUBST.contains = RUBY_DEFAULT_CONTAINS;
    PARAMS.contains = RUBY_DEFAULT_CONTAINS;
    const SIMPLE_PROMPT = "[>?]>";
    const DEFAULT_PROMPT = "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]";
    const RVM_PROMPT = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>";
    const IRB_DEFAULT = [
      {
        begin: /^\s*=>/,
        starts: {
          end: "$",
          contains: RUBY_DEFAULT_CONTAINS
        }
      },
      {
        className: "meta.prompt",
        begin: "^(" + SIMPLE_PROMPT + "|" + DEFAULT_PROMPT + "|" + RVM_PROMPT + ")(?=[ ])",
        starts: {
          end: "$",
          keywords: RUBY_KEYWORDS,
          contains: RUBY_DEFAULT_CONTAINS
        }
      }
    ];
    COMMENT_MODES.unshift(IRB_OBJECT);
    return {
      name: "Ruby",
      aliases: [
        "rb",
        "gemspec",
        "podspec",
        "thor",
        "irb"
      ],
      keywords: RUBY_KEYWORDS,
      illegal: /\/\*/,
      contains: [hljs.SHEBANG({ binary: "ruby" })].concat(IRB_DEFAULT).concat(COMMENT_MODES).concat(RUBY_DEFAULT_CONTAINS)
    };
  }
  var init_ruby = __esm({
    "node_modules/highlight.js/es/languages/ruby.js"() {
    }
  });

  // node_modules/highlight.js/es/languages/scss.js
  function scss(hljs) {
    const modes = MODES3(hljs);
    const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS2;
    const PSEUDO_CLASSES$1 = PSEUDO_CLASSES2;
    const AT_IDENTIFIER = "@[a-z-]+";
    const AT_MODIFIERS = "and or not only";
    const IDENT_RE3 = "[a-zA-Z-][a-zA-Z0-9_-]*";
    const VARIABLE = {
      className: "variable",
      begin: "(\\$" + IDENT_RE3 + ")\\b",
      relevance: 0
    };
    return {
      name: "SCSS",
      case_insensitive: true,
      illegal: "[=/|']",
      contains: [
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        // to recognize keyframe 40% etc which are outside the scope of our
        // attribute value mode
        modes.CSS_NUMBER_MODE,
        {
          className: "selector-id",
          begin: "#[A-Za-z0-9_-]+",
          relevance: 0
        },
        {
          className: "selector-class",
          begin: "\\.[A-Za-z0-9_-]+",
          relevance: 0
        },
        modes.ATTRIBUTE_SELECTOR_MODE,
        {
          className: "selector-tag",
          begin: "\\b(" + TAGS2.join("|") + ")\\b",
          // was there, before, but why?
          relevance: 0
        },
        {
          className: "selector-pseudo",
          begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
        },
        {
          className: "selector-pseudo",
          begin: ":(:)?(" + PSEUDO_ELEMENTS$1.join("|") + ")"
        },
        VARIABLE,
        {
          // pseudo-selector params
          begin: /\(/,
          end: /\)/,
          contains: [modes.CSS_NUMBER_MODE]
        },
        modes.CSS_VARIABLE,
        {
          className: "attribute",
          begin: "\\b(" + ATTRIBUTES2.join("|") + ")\\b"
        },
        { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
        {
          begin: /:/,
          end: /[;}{]/,
          relevance: 0,
          contains: [
            modes.BLOCK_COMMENT,
            VARIABLE,
            modes.HEXCOLOR,
            modes.CSS_NUMBER_MODE,
            hljs.QUOTE_STRING_MODE,
            hljs.APOS_STRING_MODE,
            modes.IMPORTANT,
            modes.FUNCTION_DISPATCH
          ]
        },
        // matching these here allows us to treat them more like regular CSS
        // rules so everything between the {} gets regular rule highlighting,
        // which is what we want for page and font-face
        {
          begin: "@(page|font-face)",
          keywords: {
            $pattern: AT_IDENTIFIER,
            keyword: "@page @font-face"
          }
        },
        {
          begin: "@",
          end: "[{;]",
          returnBegin: true,
          keywords: {
            $pattern: /[a-z-]+/,
            keyword: AT_MODIFIERS,
            attribute: MEDIA_FEATURES2.join(" ")
          },
          contains: [
            {
              begin: AT_IDENTIFIER,
              className: "keyword"
            },
            {
              begin: /[a-z-]+(?=:)/,
              className: "attribute"
            },
            VARIABLE,
            hljs.QUOTE_STRING_MODE,
            hljs.APOS_STRING_MODE,
            modes.HEXCOLOR,
            modes.CSS_NUMBER_MODE
          ]
        },
        modes.FUNCTION_DISPATCH
      ]
    };
  }
  var MODES3, TAGS2, MEDIA_FEATURES2, PSEUDO_CLASSES2, PSEUDO_ELEMENTS2, ATTRIBUTES2;
  var init_scss = __esm({
    "node_modules/highlight.js/es/languages/scss.js"() {
      MODES3 = (hljs) => {
        return {
          IMPORTANT: {
            scope: "meta",
            begin: "!important"
          },
          BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
          HEXCOLOR: {
            scope: "number",
            begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
          },
          FUNCTION_DISPATCH: {
            className: "built_in",
            begin: /[\w-]+(?=\()/
          },
          ATTRIBUTE_SELECTOR_MODE: {
            scope: "selector-attr",
            begin: /\[/,
            end: /\]/,
            illegal: "$",
            contains: [
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE
            ]
          },
          CSS_NUMBER_MODE: {
            scope: "number",
            begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
            relevance: 0
          },
          CSS_VARIABLE: {
            className: "attr",
            begin: /--[A-Za-z][A-Za-z0-9_-]*/
          }
        };
      };
      TAGS2 = [
        "a",
        "abbr",
        "address",
        "article",
        "aside",
        "audio",
        "b",
        "blockquote",
        "body",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "dd",
        "del",
        "details",
        "dfn",
        "div",
        "dl",
        "dt",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "mark",
        "menu",
        "nav",
        "object",
        "ol",
        "p",
        "q",
        "quote",
        "samp",
        "section",
        "span",
        "strong",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "ul",
        "var",
        "video"
      ];
      MEDIA_FEATURES2 = [
        "any-hover",
        "any-pointer",
        "aspect-ratio",
        "color",
        "color-gamut",
        "color-index",
        "device-aspect-ratio",
        "device-height",
        "device-width",
        "display-mode",
        "forced-colors",
        "grid",
        "height",
        "hover",
        "inverted-colors",
        "monochrome",
        "orientation",
        "overflow-block",
        "overflow-inline",
        "pointer",
        "prefers-color-scheme",
        "prefers-contrast",
        "prefers-reduced-motion",
        "prefers-reduced-transparency",
        "resolution",
        "scan",
        "scripting",
        "update",
        "width",
        // TODO: find a better solution?
        "min-width",
        "max-width",
        "min-height",
        "max-height"
      ];
      PSEUDO_CLASSES2 = [
        "active",
        "any-link",
        "blank",
        "checked",
        "current",
        "default",
        "defined",
        "dir",
        // dir()
        "disabled",
        "drop",
        "empty",
        "enabled",
        "first",
        "first-child",
        "first-of-type",
        "fullscreen",
        "future",
        "focus",
        "focus-visible",
        "focus-within",
        "has",
        // has()
        "host",
        // host or host()
        "host-context",
        // host-context()
        "hover",
        "indeterminate",
        "in-range",
        "invalid",
        "is",
        // is()
        "lang",
        // lang()
        "last-child",
        "last-of-type",
        "left",
        "link",
        "local-link",
        "not",
        // not()
        "nth-child",
        // nth-child()
        "nth-col",
        // nth-col()
        "nth-last-child",
        // nth-last-child()
        "nth-last-col",
        // nth-last-col()
        "nth-last-of-type",
        //nth-last-of-type()
        "nth-of-type",
        //nth-of-type()
        "only-child",
        "only-of-type",
        "optional",
        "out-of-range",
        "past",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "right",
        "root",
        "scope",
        "target",
        "target-within",
        "user-invalid",
        "valid",
        "visited",
        "where"
        // where()
      ];
      PSEUDO_ELEMENTS2 = [
        "after",
        "backdrop",
        "before",
        "cue",
        "cue-region",
        "first-letter",
        "first-line",
        "grammar-error",
        "marker",
        "part",
        "placeholder",
        "selection",
        "slotted",
        "spelling-error"
      ];
      ATTRIBUTES2 = [
        "align-content",
        "align-items",
        "align-self",
        "all",
        "animation",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "backface-visibility",
        "background",
        "background-attachment",
        "background-blend-mode",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "block-size",
        "border",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "bottom",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "break-after",
        "break-before",
        "break-inside",
        "caption-side",
        "caret-color",
        "clear",
        "clip",
        "clip-path",
        "clip-rule",
        "color",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columns",
        "contain",
        "content",
        "content-visibility",
        "counter-increment",
        "counter-reset",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "direction",
        "display",
        "empty-cells",
        "filter",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "float",
        "flow",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-size",
        "font-size-adjust",
        "font-smoothing",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-variant",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "gap",
        "glyph-orientation-vertical",
        "grid",
        "grid-area",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-auto-rows",
        "grid-column",
        "grid-column-end",
        "grid-column-start",
        "grid-gap",
        "grid-row",
        "grid-row-end",
        "grid-row-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "hyphens",
        "icon",
        "image-orientation",
        "image-rendering",
        "image-resolution",
        "ime-mode",
        "inline-size",
        "isolation",
        "justify-content",
        "left",
        "letter-spacing",
        "line-break",
        "line-height",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "margin-top",
        "marks",
        "mask",
        "mask-border",
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width",
        "mask-clip",
        "mask-composite",
        "mask-image",
        "mask-mode",
        "mask-origin",
        "mask-position",
        "mask-repeat",
        "mask-size",
        "mask-type",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-width",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-width",
        "mix-blend-mode",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "none",
        "normal",
        "object-fit",
        "object-position",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "overflow",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "padding",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "padding-top",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "pause",
        "pause-after",
        "pause-before",
        "perspective",
        "perspective-origin",
        "pointer-events",
        "position",
        "quotes",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "right",
        "row-gap",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "scroll-snap-align",
        "scroll-snap-stop",
        "scroll-snap-type",
        "scrollbar-color",
        "scrollbar-gutter",
        "scrollbar-width",
        "shape-image-threshold",
        "shape-margin",
        "shape-outside",
        "speak",
        "speak-as",
        "src",
        // @font-face
        "tab-size",
        "table-layout",
        "text-align",
        "text-align-all",
        "text-align-last",
        "text-combine-upright",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-style",
        "text-emphasis",
        "text-emphasis-color",
        "text-emphasis-position",
        "text-emphasis-style",
        "text-indent",
        "text-justify",
        "text-orientation",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-position",
        "top",
        "transform",
        "transform-box",
        "transform-origin",
        "transform-style",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "unicode-bidi",
        "vertical-align",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "white-space",
        "widows",
        "width",
        "will-change",
        "word-break",
        "word-spacing",
        "word-wrap",
        "writing-mode",
        "z-index"
        // reverse makes sure longer attributes `font-weight` are matched fully
        // instead of getting false positives on say `font`
      ].reverse();
    }
  });

  // node_modules/highlight.js/es/languages/sql.js
  function sql(hljs) {
    const regex = hljs.regex;
    const COMMENT_MODE = hljs.COMMENT("--", "$");
    const STRING = {
      className: "string",
      variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [{ begin: /''/ }]
        }
      ]
    };
    const QUOTED_IDENTIFIER = {
      begin: /"/,
      end: /"/,
      contains: [{ begin: /""/ }]
    };
    const LITERALS2 = [
      "true",
      "false",
      // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
      // "null",
      "unknown"
    ];
    const MULTI_WORD_TYPES = [
      "double precision",
      "large object",
      "with timezone",
      "without timezone"
    ];
    const TYPES2 = [
      "bigint",
      "binary",
      "blob",
      "boolean",
      "char",
      "character",
      "clob",
      "date",
      "dec",
      "decfloat",
      "decimal",
      "float",
      "int",
      "integer",
      "interval",
      "nchar",
      "nclob",
      "national",
      "numeric",
      "real",
      "row",
      "smallint",
      "time",
      "timestamp",
      "varchar",
      "varying",
      // modifier (character varying)
      "varbinary"
    ];
    const NON_RESERVED_WORDS = [
      "add",
      "asc",
      "collation",
      "desc",
      "final",
      "first",
      "last",
      "view"
    ];
    const RESERVED_WORDS = [
      "abs",
      "acos",
      "all",
      "allocate",
      "alter",
      "and",
      "any",
      "are",
      "array",
      "array_agg",
      "array_max_cardinality",
      "as",
      "asensitive",
      "asin",
      "asymmetric",
      "at",
      "atan",
      "atomic",
      "authorization",
      "avg",
      "begin",
      "begin_frame",
      "begin_partition",
      "between",
      "bigint",
      "binary",
      "blob",
      "boolean",
      "both",
      "by",
      "call",
      "called",
      "cardinality",
      "cascaded",
      "case",
      "cast",
      "ceil",
      "ceiling",
      "char",
      "char_length",
      "character",
      "character_length",
      "check",
      "classifier",
      "clob",
      "close",
      "coalesce",
      "collate",
      "collect",
      "column",
      "commit",
      "condition",
      "connect",
      "constraint",
      "contains",
      "convert",
      "copy",
      "corr",
      "corresponding",
      "cos",
      "cosh",
      "count",
      "covar_pop",
      "covar_samp",
      "create",
      "cross",
      "cube",
      "cume_dist",
      "current",
      "current_catalog",
      "current_date",
      "current_default_transform_group",
      "current_path",
      "current_role",
      "current_row",
      "current_schema",
      "current_time",
      "current_timestamp",
      "current_path",
      "current_role",
      "current_transform_group_for_type",
      "current_user",
      "cursor",
      "cycle",
      "date",
      "day",
      "deallocate",
      "dec",
      "decimal",
      "decfloat",
      "declare",
      "default",
      "define",
      "delete",
      "dense_rank",
      "deref",
      "describe",
      "deterministic",
      "disconnect",
      "distinct",
      "double",
      "drop",
      "dynamic",
      "each",
      "element",
      "else",
      "empty",
      "end",
      "end_frame",
      "end_partition",
      "end-exec",
      "equals",
      "escape",
      "every",
      "except",
      "exec",
      "execute",
      "exists",
      "exp",
      "external",
      "extract",
      "false",
      "fetch",
      "filter",
      "first_value",
      "float",
      "floor",
      "for",
      "foreign",
      "frame_row",
      "free",
      "from",
      "full",
      "function",
      "fusion",
      "get",
      "global",
      "grant",
      "group",
      "grouping",
      "groups",
      "having",
      "hold",
      "hour",
      "identity",
      "in",
      "indicator",
      "initial",
      "inner",
      "inout",
      "insensitive",
      "insert",
      "int",
      "integer",
      "intersect",
      "intersection",
      "interval",
      "into",
      "is",
      "join",
      "json_array",
      "json_arrayagg",
      "json_exists",
      "json_object",
      "json_objectagg",
      "json_query",
      "json_table",
      "json_table_primitive",
      "json_value",
      "lag",
      "language",
      "large",
      "last_value",
      "lateral",
      "lead",
      "leading",
      "left",
      "like",
      "like_regex",
      "listagg",
      "ln",
      "local",
      "localtime",
      "localtimestamp",
      "log",
      "log10",
      "lower",
      "match",
      "match_number",
      "match_recognize",
      "matches",
      "max",
      "member",
      "merge",
      "method",
      "min",
      "minute",
      "mod",
      "modifies",
      "module",
      "month",
      "multiset",
      "national",
      "natural",
      "nchar",
      "nclob",
      "new",
      "no",
      "none",
      "normalize",
      "not",
      "nth_value",
      "ntile",
      "null",
      "nullif",
      "numeric",
      "octet_length",
      "occurrences_regex",
      "of",
      "offset",
      "old",
      "omit",
      "on",
      "one",
      "only",
      "open",
      "or",
      "order",
      "out",
      "outer",
      "over",
      "overlaps",
      "overlay",
      "parameter",
      "partition",
      "pattern",
      "per",
      "percent",
      "percent_rank",
      "percentile_cont",
      "percentile_disc",
      "period",
      "portion",
      "position",
      "position_regex",
      "power",
      "precedes",
      "precision",
      "prepare",
      "primary",
      "procedure",
      "ptf",
      "range",
      "rank",
      "reads",
      "real",
      "recursive",
      "ref",
      "references",
      "referencing",
      "regr_avgx",
      "regr_avgy",
      "regr_count",
      "regr_intercept",
      "regr_r2",
      "regr_slope",
      "regr_sxx",
      "regr_sxy",
      "regr_syy",
      "release",
      "result",
      "return",
      "returns",
      "revoke",
      "right",
      "rollback",
      "rollup",
      "row",
      "row_number",
      "rows",
      "running",
      "savepoint",
      "scope",
      "scroll",
      "search",
      "second",
      "seek",
      "select",
      "sensitive",
      "session_user",
      "set",
      "show",
      "similar",
      "sin",
      "sinh",
      "skip",
      "smallint",
      "some",
      "specific",
      "specifictype",
      "sql",
      "sqlexception",
      "sqlstate",
      "sqlwarning",
      "sqrt",
      "start",
      "static",
      "stddev_pop",
      "stddev_samp",
      "submultiset",
      "subset",
      "substring",
      "substring_regex",
      "succeeds",
      "sum",
      "symmetric",
      "system",
      "system_time",
      "system_user",
      "table",
      "tablesample",
      "tan",
      "tanh",
      "then",
      "time",
      "timestamp",
      "timezone_hour",
      "timezone_minute",
      "to",
      "trailing",
      "translate",
      "translate_regex",
      "translation",
      "treat",
      "trigger",
      "trim",
      "trim_array",
      "true",
      "truncate",
      "uescape",
      "union",
      "unique",
      "unknown",
      "unnest",
      "update",
      "upper",
      "user",
      "using",
      "value",
      "values",
      "value_of",
      "var_pop",
      "var_samp",
      "varbinary",
      "varchar",
      "varying",
      "versioning",
      "when",
      "whenever",
      "where",
      "width_bucket",
      "window",
      "with",
      "within",
      "without",
      "year"
    ];
    const RESERVED_FUNCTIONS = [
      "abs",
      "acos",
      "array_agg",
      "asin",
      "atan",
      "avg",
      "cast",
      "ceil",
      "ceiling",
      "coalesce",
      "corr",
      "cos",
      "cosh",
      "count",
      "covar_pop",
      "covar_samp",
      "cume_dist",
      "dense_rank",
      "deref",
      "element",
      "exp",
      "extract",
      "first_value",
      "floor",
      "json_array",
      "json_arrayagg",
      "json_exists",
      "json_object",
      "json_objectagg",
      "json_query",
      "json_table",
      "json_table_primitive",
      "json_value",
      "lag",
      "last_value",
      "lead",
      "listagg",
      "ln",
      "log",
      "log10",
      "lower",
      "max",
      "min",
      "mod",
      "nth_value",
      "ntile",
      "nullif",
      "percent_rank",
      "percentile_cont",
      "percentile_disc",
      "position",
      "position_regex",
      "power",
      "rank",
      "regr_avgx",
      "regr_avgy",
      "regr_count",
      "regr_intercept",
      "regr_r2",
      "regr_slope",
      "regr_sxx",
      "regr_sxy",
      "regr_syy",
      "row_number",
      "sin",
      "sinh",
      "sqrt",
      "stddev_pop",
      "stddev_samp",
      "substring",
      "substring_regex",
      "sum",
      "tan",
      "tanh",
      "translate",
      "translate_regex",
      "treat",
      "trim",
      "trim_array",
      "unnest",
      "upper",
      "value_of",
      "var_pop",
      "var_samp",
      "width_bucket"
    ];
    const POSSIBLE_WITHOUT_PARENS = [
      "current_catalog",
      "current_date",
      "current_default_transform_group",
      "current_path",
      "current_role",
      "current_schema",
      "current_transform_group_for_type",
      "current_user",
      "session_user",
      "system_time",
      "system_user",
      "current_time",
      "localtime",
      "current_timestamp",
      "localtimestamp"
    ];
    const COMBOS = [
      "create table",
      "insert into",
      "primary key",
      "foreign key",
      "not null",
      "alter table",
      "add constraint",
      "grouping sets",
      "on overflow",
      "character set",
      "respect nulls",
      "ignore nulls",
      "nulls first",
      "nulls last",
      "depth first",
      "breadth first"
    ];
    const FUNCTIONS = RESERVED_FUNCTIONS;
    const KEYWORDS2 = [
      ...RESERVED_WORDS,
      ...NON_RESERVED_WORDS
    ].filter((keyword) => {
      return !RESERVED_FUNCTIONS.includes(keyword);
    });
    const VARIABLE = {
      className: "variable",
      begin: /@[a-z0-9][a-z0-9_]*/
    };
    const OPERATOR = {
      className: "operator",
      begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
      relevance: 0
    };
    const FUNCTION_CALL = {
      begin: regex.concat(/\b/, regex.either(...FUNCTIONS), /\s*\(/),
      relevance: 0,
      keywords: { built_in: FUNCTIONS }
    };
    function reduceRelevancy(list, {
      exceptions,
      when
    } = {}) {
      const qualifyFn = when;
      exceptions = exceptions || [];
      return list.map((item) => {
        if (item.match(/\|\d+$/) || exceptions.includes(item)) {
          return item;
        } else if (qualifyFn(item)) {
          return `${item}|0`;
        } else {
          return item;
        }
      });
    }
    return {
      name: "SQL",
      case_insensitive: true,
      // does not include {} or HTML tags `</`
      illegal: /[{}]|<\//,
      keywords: {
        $pattern: /\b[\w\.]+/,
        keyword: reduceRelevancy(KEYWORDS2, { when: (x) => x.length < 3 }),
        literal: LITERALS2,
        type: TYPES2,
        built_in: POSSIBLE_WITHOUT_PARENS
      },
      contains: [
        {
          begin: regex.either(...COMBOS),
          relevance: 0,
          keywords: {
            $pattern: /[\w\.]+/,
            keyword: KEYWORDS2.concat(COMBOS),
            literal: LITERALS2,
            type: TYPES2
          }
        },
        {
          className: "type",
          begin: regex.either(...MULTI_WORD_TYPES)
        },
        FUNCTION_CALL,
        VARIABLE,
        STRING,
        QUOTED_IDENTIFIER,
        hljs.C_NUMBER_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        COMMENT_MODE,
        OPERATOR
      ]
    };
  }
  var init_sql = __esm({
    "node_modules/highlight.js/es/languages/sql.js"() {
    }
  });

  // node_modules/highlight.js/es/languages/xml.js
  function xml(hljs) {
    const regex = hljs.regex;
    const TAG_NAME_RE = regex.concat(/[\p{L}_]/u, regex.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u);
    const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
    const XML_ENTITIES = {
      className: "symbol",
      begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
    };
    const XML_META_KEYWORDS = {
      begin: /\s/,
      contains: [
        {
          className: "keyword",
          begin: /#?[a-z_][a-z1-9_-]+/,
          illegal: /\n/
        }
      ]
    };
    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
      begin: /\(/,
      end: /\)/
    });
    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
    const TAG_INTERNALS = {
      endsWithParent: true,
      illegal: /</,
      relevance: 0,
      contains: [
        {
          className: "attr",
          begin: XML_IDENT_RE,
          relevance: 0
        },
        {
          begin: /=\s*/,
          relevance: 0,
          contains: [
            {
              className: "string",
              endsParent: true,
              variants: [
                {
                  begin: /"/,
                  end: /"/,
                  contains: [XML_ENTITIES]
                },
                {
                  begin: /'/,
                  end: /'/,
                  contains: [XML_ENTITIES]
                },
                { begin: /[^\s"'=<>`]+/ }
              ]
            }
          ]
        }
      ]
    };
    return {
      name: "HTML, XML",
      aliases: [
        "html",
        "xhtml",
        "rss",
        "atom",
        "xjb",
        "xsd",
        "xsl",
        "plist",
        "wsf",
        "svg"
      ],
      case_insensitive: true,
      unicodeRegex: true,
      contains: [
        {
          className: "meta",
          begin: /<![a-z]/,
          end: />/,
          relevance: 10,
          contains: [
            XML_META_KEYWORDS,
            QUOTE_META_STRING_MODE,
            APOS_META_STRING_MODE,
            XML_META_PAR_KEYWORDS,
            {
              begin: /\[/,
              end: /\]/,
              contains: [
                {
                  className: "meta",
                  begin: /<![a-z]/,
                  end: />/,
                  contains: [
                    XML_META_KEYWORDS,
                    XML_META_PAR_KEYWORDS,
                    QUOTE_META_STRING_MODE,
                    APOS_META_STRING_MODE
                  ]
                }
              ]
            }
          ]
        },
        hljs.COMMENT(
          /<!--/,
          /-->/,
          { relevance: 10 }
        ),
        {
          begin: /<!\[CDATA\[/,
          end: /\]\]>/,
          relevance: 10
        },
        XML_ENTITIES,
        // xml processing instructions
        {
          className: "meta",
          end: /\?>/,
          variants: [
            {
              begin: /<\?xml/,
              relevance: 10,
              contains: [
                QUOTE_META_STRING_MODE
              ]
            },
            {
              begin: /<\?[a-z][a-z0-9]+/
            }
          ]
        },
        {
          className: "tag",
          /*
          The lookahead pattern (?=...) ensures that 'begin' only matches
          '<style' as a single word, followed by a whitespace or an
          ending bracket.
          */
          begin: /<style(?=\s|>)/,
          end: />/,
          keywords: { name: "style" },
          contains: [TAG_INTERNALS],
          starts: {
            end: /<\/style>/,
            returnEnd: true,
            subLanguage: [
              "css",
              "xml"
            ]
          }
        },
        {
          className: "tag",
          // See the comment in the <style tag about the lookahead pattern
          begin: /<script(?=\s|>)/,
          end: />/,
          keywords: { name: "script" },
          contains: [TAG_INTERNALS],
          starts: {
            end: /<\/script>/,
            returnEnd: true,
            subLanguage: [
              "javascript",
              "handlebars",
              "xml"
            ]
          }
        },
        // we need this for now for jSX
        {
          className: "tag",
          begin: /<>|<\/>/
        },
        // open tag
        {
          className: "tag",
          begin: regex.concat(
            /</,
            regex.lookahead(regex.concat(
              TAG_NAME_RE,
              // <tag/>
              // <tag>
              // <tag ...
              regex.either(/\/>/, />/, /\s/)
            ))
          ),
          end: /\/?>/,
          contains: [
            {
              className: "name",
              begin: TAG_NAME_RE,
              relevance: 0,
              starts: TAG_INTERNALS
            }
          ]
        },
        // close tag
        {
          className: "tag",
          begin: regex.concat(
            /<\//,
            regex.lookahead(regex.concat(
              TAG_NAME_RE,
              />/
            ))
          ),
          contains: [
            {
              className: "name",
              begin: TAG_NAME_RE,
              relevance: 0
            },
            {
              begin: />/,
              relevance: 0,
              endsParent: true
            }
          ]
        }
      ]
    };
  }
  var init_xml = __esm({
    "node_modules/highlight.js/es/languages/xml.js"() {
    }
  });

  // node_modules/highlight.js/es/languages/yaml.js
  function yaml(hljs) {
    const LITERALS2 = "true false yes no null";
    const URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
    const KEY = {
      className: "attr",
      variants: [
        { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
        {
          // double quoted keys
          begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)'
        },
        {
          // single quoted keys
          begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
        }
      ]
    };
    const TEMPLATE_VARIABLES = {
      className: "template-variable",
      variants: [
        {
          // jinja templates Ansible
          begin: /\{\{/,
          end: /\}\}/
        },
        {
          // Ruby i18n
          begin: /%\{/,
          end: /\}/
        }
      ]
    };
    const STRING = {
      className: "string",
      relevance: 0,
      variants: [
        {
          begin: /'/,
          end: /'/
        },
        {
          begin: /"/,
          end: /"/
        },
        { begin: /\S+/ }
      ],
      contains: [
        hljs.BACKSLASH_ESCAPE,
        TEMPLATE_VARIABLES
      ]
    };
    const CONTAINER_STRING = hljs.inherit(STRING, { variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      { begin: /[^\s,{}[\]]+/ }
    ] });
    const DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
    const TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
    const FRACTION_RE = "(\\.[0-9]*)?";
    const ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
    const TIMESTAMP = {
      className: "number",
      begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b"
    };
    const VALUE_CONTAINER = {
      end: ",",
      endsWithParent: true,
      excludeEnd: true,
      keywords: LITERALS2,
      relevance: 0
    };
    const OBJECT = {
      begin: /\{/,
      end: /\}/,
      contains: [VALUE_CONTAINER],
      illegal: "\\n",
      relevance: 0
    };
    const ARRAY = {
      begin: "\\[",
      end: "\\]",
      contains: [VALUE_CONTAINER],
      illegal: "\\n",
      relevance: 0
    };
    const MODES4 = [
      KEY,
      {
        className: "meta",
        begin: "^---\\s*$",
        relevance: 10
      },
      {
        // multi line string
        // Blocks start with a | or > followed by a newline
        //
        // Indentation of subsequent lines must be the same to
        // be considered part of the block
        className: "string",
        begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
      },
      {
        // Ruby/Rails erb
        begin: "<%[%=-]?",
        end: "[%-]?%>",
        subLanguage: "ruby",
        excludeBegin: true,
        excludeEnd: true,
        relevance: 0
      },
      {
        // named tags
        className: "type",
        begin: "!\\w+!" + URI_CHARACTERS
      },
      // https://yaml.org/spec/1.2/spec.html#id2784064
      {
        // verbatim tags
        className: "type",
        begin: "!<" + URI_CHARACTERS + ">"
      },
      {
        // primary tags
        className: "type",
        begin: "!" + URI_CHARACTERS
      },
      {
        // secondary tags
        className: "type",
        begin: "!!" + URI_CHARACTERS
      },
      {
        // fragment id &ref
        className: "meta",
        begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
      },
      {
        // fragment reference *ref
        className: "meta",
        begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
      },
      {
        // array listing
        className: "bullet",
        // TODO: remove |$ hack when we have proper look-ahead support
        begin: "-(?=[ ]|$)",
        relevance: 0
      },
      hljs.HASH_COMMENT_MODE,
      {
        beginKeywords: LITERALS2,
        keywords: { literal: LITERALS2 }
      },
      TIMESTAMP,
      // numbers are any valid C-style number that
      // sit isolated from other words
      {
        className: "number",
        begin: hljs.C_NUMBER_RE + "\\b",
        relevance: 0
      },
      OBJECT,
      ARRAY,
      STRING
    ];
    const VALUE_MODES = [...MODES4];
    VALUE_MODES.pop();
    VALUE_MODES.push(CONTAINER_STRING);
    VALUE_CONTAINER.contains = VALUE_MODES;
    return {
      name: "YAML",
      case_insensitive: true,
      aliases: ["yml"],
      contains: MODES4
    };
  }
  var init_yaml = __esm({
    "node_modules/highlight.js/es/languages/yaml.js"() {
    }
  });

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/lowlight.js
  var lowlight_exports = {};
  __export(lowlight_exports, {
    default: () => lowlight_default
  });
  var lowlight_default;
  var init_lowlight = __esm({
    "node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/lowlight.js"() {
      init_core2();
      init_css();
      init_javascript();
      init_json();
      init_ruby();
      init_scss();
      init_sql();
      init_xml();
      init_yaml();
      lowlight.registerLanguage("css", css2);
      lowlight.registerLanguage("javascript", javascript);
      lowlight.registerLanguage("json", json);
      lowlight.registerLanguage("ruby", ruby);
      lowlight.registerLanguage("scss", scss);
      lowlight.registerLanguage("sql", sql);
      lowlight.registerLanguage("xml", xml);
      lowlight.registerLanguage("yaml", yaml);
      lowlight_default = lowlight;
    }
  });

  // node_modules/@tiptap/extension-image/dist/index.js
  var dist_exports33 = {};
  __export(dist_exports33, {
    Image: () => Image,
    default: () => Image,
    inputRegex: () => inputRegex6
  });
  var inputRegex6, Image;
  var init_dist58 = __esm({
    "node_modules/@tiptap/extension-image/dist/index.js"() {
      init_dist16();
      inputRegex6 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
      Image = Node3.create({
        name: "image",
        addOptions() {
          return {
            inline: false,
            allowBase64: false,
            HTMLAttributes: {}
          };
        },
        inline() {
          return this.options.inline;
        },
        group() {
          return this.options.inline ? "inline" : "block";
        },
        draggable: true,
        addAttributes() {
          return {
            src: {
              default: null
            },
            alt: {
              default: null
            },
            title: {
              default: null
            }
          };
        },
        parseHTML() {
          return [
            {
              tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
            }
          ];
        },
        renderHTML({ HTMLAttributes }) {
          return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
        },
        addCommands() {
          return {
            setImage: (options) => ({ commands: commands2 }) => {
              return commands2.insertContent({
                type: this.name,
                attrs: options
              });
            }
          };
        },
        addInputRules() {
          return [
            nodeInputRule({
              find: inputRegex6,
              type: this.type,
              getAttributes: (match) => {
                const [, , alt, src, title] = match;
                return { src, alt, title };
              }
            })
          ];
        }
      });
    }
  });

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/extensions/slashCommands.js
  var slashCommands_exports = {};
  __export(slashCommands_exports, {
    default: () => slashCommands_default
  });
  var slashCommands_default;
  var init_slashCommands = __esm({
    "node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/extensions/slashCommands.js"() {
      init_dist16();
      init_dist45();
      slashCommands_default = Extension.create({
        name: "slashCommands",
        addOptions() {
          return {
            suggestion: {
              char: "/",
              command: ({ editor, range, props }) => {
                props.command({ editor, range });
              }
            }
          };
        },
        addProseMirrorPlugins() {
          return [
            Suggestion({
              editor: this.editor,
              ...this.options.suggestion
            })
          ];
        }
      });
    }
  });

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/assets/image_placeholder.png
  var image_placeholder_default;
  var init_image_placeholder = __esm({
    "node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/assets/image_placeholder.png"() {
      image_placeholder_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB1AAAABgCAYAAACjUOCDAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA0VSURBVHgB7d2/TxxXFwbgsWVbigu7MFKw5ERyLDkFFLgghYtQpEmTv9a1CyiggIJIEAmKUCRSbMkpoHAkB4nvezdz0fV6Z9nFmB3geaQVy/44e2dmqV7Oubf29vZOGgAAAAAAAABObjcAAAAAAAAADAhQAQAAAAAAAFoCVAAAAAAAAICWABUAAAAAAACgJUAFAAAAAAAAaAlQAQAAAAAAAFoCVAAAAAAAAICWABUAAAAAAACgJUAFAAAAAAAAaAlQAQAAAAAAAFoCVAAAAAAAAICWABUAAAAAAACgJUAFAAAAAAAAaAlQAQAAAAAAAFoCVAAAAAAAAICWABUAAAAAAACgJUAFAAAAAAAAaAlQAQAAAAAAAFoCVAAAAAAAAICWABUAAAAAAACgJUAFAAAAAAAAaAlQAQAAAAAAAFoCVAAAAAAAAICWABUAAAAAAACgJUAFAAAAAAAAaAlQAQAAAAAAAFoCVAAAAAAAAICWABUAAAAAAACgJUAFAAAAAAAAaN1pZuj9+/fN9vZ2c3R01Pz777/NZZufn28WFhaa+/fvNwAAAAAAAAAz60BNeLq2ttb8/fffMwlP482bN4M1ZC0AAAAAAAAAMwtQd3d3Zxac1rKGdMECAAAAAAAAzCxATfdnX2SEMAAAAAAAAMBM90Dtiz50ws5Sxiivr68P7j958qR58eJFcx51nUePHjUvX75sAAAAAAAA4CoRoF4Bm5ubg5D37t27zfLycnNdHR4eDkY7x4MHD5rFxcUGAAAAAAAALpMAtef++OOPj8Ydv3v3rpmbm2uuo+Pj40EXKwAAAAAAAMzKzPZAZTIJUGtv375tAAAAAAAAgC9DgNpj79+//6QjM4HqTd+zFQAAAAAAAL4UAWqP/fnnn6f3nzx5MviZ8HS4KxUAAAAAAAC4GALUHitB6VdffdUsLi42d+78t2VtvSfqNBK+Hh4eDvZR/Zwu1ouqc5HSrZv1ZF3jfO7a855JP2ucUiM/P0cfrwUAAAAAAMBVdqehlzK6t4Rrjx8/bu7evdt88803zcHBweC5hGYPHz6cqFbqbG9vfzIOOO9/+vRpc//+/anqHB0dfRTWTVvnvPL5Gxsbg/vz8/PN8+fPm99//31wTur15FyV58uaEkbnNnwOHj16NHjd3Nzc2M9OQLm/v//JsZe1LCwsnHn8ed+o9eZ9WUOu7+bm5uAzEpq/fPnyzPV0XdPUAgAAAAAAYHoC1J6qx/QmEIsEqQnfIl2okwSoCVoTOo7qTsxzCUQTAF5Wnc9VQuV85tra2sgOzjLmOOHijz/+2Ozu7naOPc5rclzLy8ud609Qube313TJtchtaWmpM7gs4e+o9dYBd+6f1ZW6s7Nz+j0YVq5FQtiEugAAAAAAAExHgNpD9T6nDx48OO1sTLdkxvgeHx8PArTvv/9+bJ0EcVtbW6ehZ7oav/vuu9PgNZ/x119/nTkS+Kw6ef8kdS5S6bzMOcla0nUapdO0rDuhZULFnLdnz54Nzmdem+cSiv7zzz+D1yZ0/Pnnnz/5nDo8LTXKfrR5b/15CWqznlGdqHV4WurktZH1pTN1kr1ts54SnpbrkOA31yahaTmm1CvPAwAAAAAAMDkBag/VQeRwAJbgLSFZArOMcR03ejZhWwntEtaly7IEjeWxjI5dXV0dhLKT1EkAmdGyw3XSJbu+vn4aSF6GrH04RM5assaEmZFwsozDrYPNvC7BY449a+46n3WoubKy8lGN3C8haF5Xgu/hNeWxcv661pLO1Zy/hKBdciwlzB1VJ4F2apXrmeuWuvW1AgAAAAAAYLzbDb1Th3YloBv1ewKyLnUXa2S87KggLQHc4uJiM066S4vhEHaaOhcpAWJXB25C53R5FnndqK7QHMe33357+vtweFnC15zzrhpRj+0dFYDW12HcWnJuxymhcORcj6qTxxKyx/B3AAAAAAAAgLPpQO2ZdCqW8bTpkBwOyRLm5ZbX5JaQbFSgWWp01amNey51Sndq13ja4jI7Hcetozxfwsx0pHZJQFoM7++ajs50eZ5lXI38Xq5FXte1R2pZc5fhOuP2m/36669PO1UTAgMAAAAAADA5AWrP1F2lXSFZHi9hWva6HNWJWQdnw12s07ioOpetDnMvMthNkJlbGckb48YW1x2pZc/Y85imTv38uJHAAAAAAAAAfOraBahlz9AEi1dRCUYT+nV1K+bxMs617jSt1QHfuA7Ms9QdlWd1fV5n+T5lb9qu893los5ffT2zjlevXk30vnF72wIAAAAAAPCpaxWgZrTpwsLCILTKvp3jOgP7KMFYCcoSto3bvzLPl3G/7969a+bm5povoQ7ubqIc/9bW1keduNlf9d69ex+N7u0KVusAtd6X9TzrAAAAAAAA4Mu7NgFqwqyyX2W6N3N/dXX1SnXg1YFpArvt7e2J3vf27duxAernnIPL3Ne0jzY2Nk7Dy4xOTofz8CjjPP/69esza13Udcg6xu2B2vU+AAAAAAAAztb7AHXSkbyLi4sfjUjN/ewNWkbd9l1CuHSgnkeC1+fPn3fu+1l3QU6rPqefU+cqqjuCMzZ5aWmpmVY9PvnDhw/NedXXM9eka7wzAAAAAAAAn6fXAWoZyRvpyOwak5rwcFRHXsLXjPG9Cvuh1sc2aVi3s7PTHBwcDILNhH11qPbw4cPT+xnxe97Ara6TzyiB9k1Qj+0d7jqdVB1Ap1P4vOogtl4XAAAAAAAAF+t201P1SN5YXl7+aM/JIsFpOk27JFwd9b6+2d/fP72fNU/i8ePHp/eH90utA+UEd+O6R8ftr5ngruzdeXR0NLbO53RY9tGk+46OCzTTOVrC15y7hNnn+bwE2eU6lH1vx0mtm9YxDAAAAAAAcBF6G6AOj+Qt+5qWECnqDtUuo97XNwnESniWwLI+7nESzNWhWh2Y5bhL12ke7xplnM+tw9thqfPs2bPTOl37sqbOb7/91lwndfftcEBdJDw967jr7t9ff/11ZFCac7u1tTWuzEf/KNBVp661trY2cQgMAAAAAADAf3oZoHaN5E2w+MMPP5z+nmB0krCx7IfaV3U4N+2I3BJuxvCo4pzHErDmM9bX1wediwnVEvzt7e1NFLI9ffr0tE7G+L5+/XrwMzVyy+dex7AuwWcdUOcYc9w5h/mZUHr4uDMyelSdMoI3r93Y2Bhcj5y7/J77eeys0bz5bpRu1uE65bFyLUrtrrHXAAAAAAAAjNa7tsyzRvImQErX6a1btybu1Iw+74dah1zT7rVZvz77odbnLufnxYsXzebm5unnJHQbloCvq8MyShdvAtjj4+NBMFdqTlPnqslx53yW7t2Ekmcdd7o/c8t7axlBnfOX72DO36hO3oSsGZM8TqmT13XVKdLFfd69bwEAAAAAAG6qXnWgTjKSNxKGpityWn3cDzXBW+lgTBg6TShc3jNuj80E0j/99NPIYDbdlQnZJjnnGWe7srIyts7S0lJz3eS7lvB41PemPu76GozqJM11TZ1RgWbqJKit9/ztkmA21yGf2fVdzlpS6zx/IwAAAAAAADfdrb29vZNmBl69evXJYwn6pg0Qp5WwcnV1ddBJWfvll1+a6y7HXkbMJrSr9/icRZ2r5qKOOyFr6TRNnXznS8dq+bvIY/l7OEvC2vJdHq4FAAAAAADA1E56M8I3nXxfOjyNsh9qGct6k+TYL+IcX1Sdq+aijjsB56hO3nqU86Sd0jclvAYAAAAAALgsvQlQd3Z2Bje4jvb395uTk5Ox+/vW+8fauxQAAAAAAGA2ehOgwnX15s2bZm9vb3A/I4CzF2/dyZqRvnm+BKjpPh3VoQoAAAAAAMCXN7MANfs1Du9DCtdRwtCEoglPE5LmltG75W8ge6smRI08try8fCNHJAMAAAAAAPTBzALUBEj1no+zND8/38CXkj1PV1ZWmoODg9NO1MPDw09el6B1YWHBvqYAAAAAAAAzdOv/gc5JMwPpultdXZ15F2o6/hJu6fjjMqTTNP84kNuHDx8Gj927d28Q4hvbCwAAAAAAMHMnMwtQIyHq7u7uYI/Iy5bgNJ1+S0tLwlMAAAAAAAAgZhugAgAAAAAAAPTIye0GAAAAAAAAgAEBKgAAAAAAAEBLgAoAAAAAAADQEqACAAAAAAAAtASoAAAAAAAAAC0BKgAAAAAAAEBLgAoAAAAAAADQEqACAAAAAAAAtASoAAAAAAAAAC0BKgAAAAAAAEBLgAoAAAAAAADQEqACAAAAAAAAtASoAAAAAAAAAC0BKgAAAAAAAEBLgAoAAAAAAADQEqACAAAAAAAAtASoAAAAAAAAAC0BKgAAAAAAAEBLgAoAAAAAAADQEqACAAAAAAAAtASoAAAAAAAAAC0BKgAAAAAAAEBLgAoAAAAAAADQEqACAAAAAAAAtASoAAAAAAAAAC0BKgAAAAAAAEBLgAoAAAAAAADQEqACAAAAAAAAtASoAAAAAAAAAK3/AcKv0540qsZyAAAAAElFTkSuQmCC";
    }
  });

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/suggestions/commands_options.js
  var commands_options_exports = {};
  __export(commands_options_exports, {
    default: () => commands_options_default
  });
  var commands_options_default;
  var init_commands_options = __esm({
    "node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/suggestions/commands_options.js"() {
      init_image_placeholder();
      init_renderer();
      commands_options_default = {
        decorationClass: "slash-command",
        items: ({ query }) => {
          return [
            {
              title: "Heading 1",
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).toggleHeading({ level: 1 }).run();
              }
            },
            {
              title: "Heading 2",
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).toggleHeading({ level: 2 }).run();
              }
            },
            {
              title: "Heading 3",
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).toggleHeading({ level: 3 }).run();
              }
            },
            {
              title: "Bulleted list",
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).toggleBulletList().run();
              }
            },
            {
              title: "Ordered list",
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).toggleOrderedList().run();
              }
            },
            {
              title: "Quote",
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).toggleBlockquote().run();
              }
            },
            {
              title: "Code",
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).toggleCodeBlock().run();
              }
            },
            {
              title: "Table",
              icon: `<svg viewBox="0 0 24 24" class="svg-inline">
                <path d="M21.75 3.75012H2.25C1.83516 3.75012 1.5 4.08528 1.5 4.50012V19.5001C1.5 19.915 1.83516 20.2501 2.25 20.2501H21.75C22.1648 20.2501 22.5 19.915 22.5 19.5001V4.50012C22.5 4.08528 22.1648 3.75012 21.75 3.75012ZM20.8125 8.62512H15.8438V5.43762H20.8125V8.62512ZM20.8125 13.8751H15.8438V10.1251H20.8125V13.8751ZM9.65625 10.1251H14.3438V13.8751H9.65625V10.1251ZM14.3438 8.62512H9.65625V5.43762H14.3438V8.62512ZM3.1875 10.1251H8.15625V13.8751H3.1875V10.1251ZM3.1875 5.43762H8.15625V8.62512H3.1875V5.43762ZM3.1875 15.3751H8.15625V18.5626H3.1875V15.3751ZM9.65625 15.3751H14.3438V18.5626H9.65625V15.3751ZM20.8125 18.5626H15.8438V15.3751H20.8125V18.5626Z" fill="#262626" />
              </svg>`,
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run();
              }
            },
            {
              title: "Image",
              icon: `<svg viewBox="0 0 512 512" class="svg-inline">
                <path fill="currentColor" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z" class=""></path>
              </svg>`,
              command: ({ editor, range }) => {
                editor.chain().focus().deleteRange(range).setImage({ src: image_placeholder_default }).run();
              }
            }
          ].filter((item) => item.title.toLowerCase().startsWith(query.toLowerCase())).slice(0, 10);
        },
        render: renderer_default({
          popUpOptions: {
            rootOptions: { className: "slash-commands-dropdown" }
          }
        })
      };
    }
  });

  // node_modules/slim-select/dist/slimselect.js
  var require_slimselect = __commonJS({
    "node_modules/slim-select/dist/slimselect.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.SlimSelect = factory());
      })(exports, function() {
        "use strict";
        function generateID() {
          return Math.random().toString(36).substring(2, 10);
        }
        function hasClassInTree(element, className) {
          function hasClass(e, c) {
            if (c && e && e.classList && e.classList.contains(c)) {
              return e;
            }
            if (c && e && e.dataset && e.dataset.id && e.dataset.id === className) {
              return e;
            }
            return null;
          }
          function parentByClass(e, c) {
            if (!e || e === document) {
              return null;
            } else if (hasClass(e, c)) {
              return e;
            } else {
              return parentByClass(e.parentNode, c);
            }
          }
          return hasClass(element, className) || parentByClass(element, className);
        }
        function debounce5(func, wait = 50, immediate = false) {
          let timeout;
          return function(...args) {
            const context = self;
            const later = () => {
              timeout = null;
              if (!immediate) {
                func.apply(context, args);
              }
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) {
              func.apply(context, args);
            }
          };
        }
        function isEqual(a, b) {
          return JSON.stringify(a) === JSON.stringify(b);
        }
        function kebabCase(str) {
          const result = str.replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, (match) => "-" + match.toLowerCase());
          return str[0] === str[0].toUpperCase() ? result.substring(1) : result;
        }
        class Optgroup {
          constructor(optgroup) {
            this.id = !optgroup.id || optgroup.id === "" ? generateID() : optgroup.id;
            this.label = optgroup.label || "";
            this.selectAll = optgroup.selectAll === void 0 ? false : optgroup.selectAll;
            this.selectAllText = optgroup.selectAllText || "Select All";
            this.closable = optgroup.closable || "off";
            this.options = [];
            if (optgroup.options) {
              for (const o of optgroup.options) {
                this.options.push(new Option(o));
              }
            }
          }
        }
        class Option {
          constructor(option2) {
            this.id = !option2.id || option2.id === "" ? generateID() : option2.id;
            this.value = option2.value === void 0 ? option2.text : option2.value;
            this.text = option2.text || "";
            this.html = option2.html || "";
            this.selected = option2.selected !== void 0 ? option2.selected : false;
            this.display = option2.display !== void 0 ? option2.display : true;
            this.disabled = option2.disabled !== void 0 ? option2.disabled : false;
            this.mandatory = option2.mandatory !== void 0 ? option2.mandatory : false;
            this.placeholder = option2.placeholder !== void 0 ? option2.placeholder : false;
            this.class = option2.class || "";
            this.style = option2.style || "";
            this.data = option2.data || {};
          }
        }
        class Store {
          constructor(type, data) {
            this.selectType = "single";
            this.data = [];
            this.selectType = type;
            this.setData(data);
          }
          validateDataArray(data) {
            if (!Array.isArray(data)) {
              return new Error("Data must be an array");
            }
            for (let dataObj of data) {
              if (dataObj instanceof Optgroup || "label" in dataObj) {
                if (!("label" in dataObj)) {
                  return new Error("Optgroup must have a label");
                }
                if ("options" in dataObj && dataObj.options) {
                  for (let option2 of dataObj.options) {
                    return this.validateOption(option2);
                  }
                }
              } else if (dataObj instanceof Option || "text" in dataObj) {
                return this.validateOption(dataObj);
              } else {
                return new Error("Data object must be a valid optgroup or option");
              }
            }
            return null;
          }
          validateOption(option2) {
            if (!("text" in option2)) {
              return new Error("Option must have a text");
            }
            return null;
          }
          partialToFullData(data) {
            let dataFinal = [];
            data.forEach((dataObj) => {
              if (dataObj instanceof Optgroup || "label" in dataObj) {
                let optOptions = [];
                if ("options" in dataObj && dataObj.options) {
                  dataObj.options.forEach((option2) => {
                    optOptions.push(new Option(option2));
                  });
                }
                if (optOptions.length > 0) {
                  dataFinal.push(new Optgroup(dataObj));
                }
              }
              if (dataObj instanceof Option || "text" in dataObj) {
                dataFinal.push(new Option(dataObj));
              }
            });
            return dataFinal;
          }
          setData(data) {
            this.data = this.partialToFullData(data);
            if (this.selectType === "single") {
              this.setSelectedBy("value", this.getSelected());
            }
          }
          getData() {
            return this.filter(null, true);
          }
          getDataOptions() {
            return this.filter(null, false);
          }
          addOption(option2) {
            this.setData(this.getData().concat(new Option(option2)));
          }
          setSelectedBy(selectedType, selectedValues) {
            let firstOption = null;
            let hasSelected = false;
            for (let dataObj of this.data) {
              if (dataObj instanceof Optgroup) {
                for (let option2 of dataObj.options) {
                  if (!firstOption) {
                    firstOption = option2;
                  }
                  option2.selected = hasSelected ? false : selectedValues.includes(option2[selectedType]);
                  if (option2.selected && this.selectType === "single") {
                    hasSelected = true;
                  }
                }
              }
              if (dataObj instanceof Option) {
                if (!firstOption) {
                  firstOption = dataObj;
                }
                dataObj.selected = hasSelected ? false : selectedValues.includes(dataObj[selectedType]);
                if (dataObj.selected && this.selectType === "single") {
                  hasSelected = true;
                }
              }
            }
            if (this.selectType === "single" && firstOption && !hasSelected) {
              firstOption.selected = true;
            }
          }
          getSelected() {
            let selectedOptions = this.getSelectedOptions();
            let selectedValues = [];
            selectedOptions.forEach((option2) => {
              selectedValues.push(option2.value);
            });
            return selectedValues;
          }
          getSelectedOptions() {
            return this.filter((opt) => {
              return opt.selected;
            }, false);
          }
          getSelectedIDs() {
            let selectedOptions = this.getSelectedOptions();
            let selectedIDs = [];
            selectedOptions.forEach((op) => {
              selectedIDs.push(op.id);
            });
            return selectedIDs;
          }
          getOptgroupByID(id) {
            for (let dataObj of this.data) {
              if (dataObj instanceof Optgroup && dataObj.id === id) {
                return dataObj;
              }
            }
            return null;
          }
          getOptionByID(id) {
            let options = this.filter((opt) => {
              return opt.id === id;
            }, false);
            return options.length ? options[0] : null;
          }
          getSelectType() {
            return this.selectType;
          }
          getFirstOption() {
            let option2 = null;
            for (let dataObj of this.data) {
              if (dataObj instanceof Optgroup) {
                option2 = dataObj.options[0];
              } else if (dataObj instanceof Option) {
                option2 = dataObj;
              }
              if (option2) {
                break;
              }
            }
            return option2;
          }
          search(search, searchFilter) {
            search = search.trim();
            if (search === "") {
              return this.getData();
            }
            return this.filter((opt) => {
              return searchFilter(opt, search);
            }, true);
          }
          filter(filter, includeOptgroup) {
            const dataSearch = [];
            this.data.forEach((dataObj) => {
              if (dataObj instanceof Optgroup) {
                let optOptions = [];
                dataObj.options.forEach((option2) => {
                  if (!filter || filter(option2)) {
                    if (!includeOptgroup) {
                      dataSearch.push(new Option(option2));
                    } else {
                      optOptions.push(new Option(option2));
                    }
                  }
                });
                if (optOptions.length > 0) {
                  let optgroup = new Optgroup(dataObj);
                  optgroup.options = optOptions;
                  dataSearch.push(optgroup);
                }
              }
              if (dataObj instanceof Option) {
                if (!filter || filter(dataObj)) {
                  dataSearch.push(new Option(dataObj));
                }
              }
            });
            return dataSearch;
          }
        }
        class Render {
          constructor(settings, store, callbacks) {
            this.classes = {
              main: "ss-main",
              placeholder: "ss-placeholder",
              values: "ss-values",
              single: "ss-single",
              max: "ss-max",
              value: "ss-value",
              valueText: "ss-value-text",
              valueDelete: "ss-value-delete",
              valueOut: "ss-value-out",
              deselect: "ss-deselect",
              deselectPath: "M10,10 L90,90 M10,90 L90,10",
              arrow: "ss-arrow",
              arrowClose: "M10,30 L50,70 L90,30",
              arrowOpen: "M10,70 L50,30 L90,70",
              content: "ss-content",
              openAbove: "ss-open-above",
              openBelow: "ss-open-below",
              search: "ss-search",
              searchHighlighter: "ss-search-highlight",
              searching: "ss-searching",
              addable: "ss-addable",
              addablePath: "M50,10 L50,90 M10,50 L90,50",
              list: "ss-list",
              optgroup: "ss-optgroup",
              optgroupLabel: "ss-optgroup-label",
              optgroupLabelText: "ss-optgroup-label-text",
              optgroupActions: "ss-optgroup-actions",
              optgroupSelectAll: "ss-selectall",
              optgroupSelectAllBox: "M60,10 L10,10 L10,90 L90,90 L90,50",
              optgroupSelectAllCheck: "M30,45 L50,70 L90,10",
              optgroupClosable: "ss-closable",
              option: "ss-option",
              optionDelete: "M10,10 L90,90 M10,90 L90,10",
              highlighted: "ss-highlighted",
              open: "ss-open",
              close: "ss-close",
              selected: "ss-selected",
              error: "ss-error",
              disabled: "ss-disabled",
              hide: "ss-hide"
            };
            this.store = store;
            this.settings = settings;
            this.callbacks = callbacks;
            this.main = this.mainDiv();
            this.content = this.contentDiv();
            this.updateClassStyles();
            this.updateAriaAttributes();
            this.settings.contentLocation.appendChild(this.content.main);
          }
          enable() {
            this.main.main.classList.remove(this.classes.disabled);
            this.content.search.input.disabled = false;
          }
          disable() {
            this.main.main.classList.add(this.classes.disabled);
            this.content.search.input.disabled = true;
          }
          open() {
            this.main.arrow.path.setAttribute("d", this.classes.arrowOpen);
            this.main.main.classList.add(this.settings.openPosition === "up" ? this.classes.openAbove : this.classes.openBelow);
            this.main.main.setAttribute("aria-expanded", "true");
            this.moveContent();
            const selectedOptions = this.store.getSelectedOptions();
            if (selectedOptions.length) {
              const selectedId = selectedOptions[selectedOptions.length - 1].id;
              const selectedOption = this.content.list.querySelector('[data-id="' + selectedId + '"]');
              if (selectedOption) {
                this.ensureElementInView(this.content.list, selectedOption);
              }
            }
          }
          close() {
            this.main.main.classList.remove(this.classes.openAbove);
            this.main.main.classList.remove(this.classes.openBelow);
            this.main.main.setAttribute("aria-expanded", "false");
            this.content.main.classList.remove(this.classes.openAbove);
            this.content.main.classList.remove(this.classes.openBelow);
            this.main.arrow.path.setAttribute("d", this.classes.arrowClose);
          }
          updateClassStyles() {
            this.main.main.className = "";
            this.main.main.removeAttribute("style");
            this.content.main.className = "";
            this.content.main.removeAttribute("style");
            this.main.main.classList.add(this.classes.main);
            this.content.main.classList.add(this.classes.content);
            if (this.settings.style !== "") {
              this.main.main.style.cssText = this.settings.style;
              this.content.main.style.cssText = this.settings.style;
            }
            if (this.settings.class.length) {
              for (const c of this.settings.class) {
                if (c.trim() !== "") {
                  this.main.main.classList.add(c.trim());
                  this.content.main.classList.add(c.trim());
                }
              }
            }
            if (this.settings.contentPosition === "relative") {
              this.content.main.classList.add("ss-" + this.settings.contentPosition);
            }
          }
          updateAriaAttributes() {
            this.main.main.role = "combobox";
            this.main.main.setAttribute("aria-haspopup", "listbox");
            this.main.main.setAttribute("aria-controls", this.content.main.id);
            this.main.main.setAttribute("aria-expanded", "false");
            this.content.main.setAttribute("role", "listbox");
          }
          mainDiv() {
            var _a;
            const main2 = document.createElement("div");
            main2.dataset.id = this.settings.id;
            main2.setAttribute("aria-label", this.settings.ariaLabel);
            main2.tabIndex = 0;
            main2.onkeydown = (e) => {
              switch (e.key) {
                case "ArrowUp":
                case "ArrowDown":
                  this.callbacks.open();
                  e.key === "ArrowDown" ? this.highlight("down") : this.highlight("up");
                  return false;
                case "Tab":
                  this.callbacks.close();
                  return true;
                case "Enter":
                case " ":
                  this.callbacks.open();
                  const highlighted = this.content.list.querySelector("." + this.classes.highlighted);
                  if (highlighted) {
                    highlighted.click();
                  }
                  return false;
                case "Escape":
                  this.callbacks.close();
                  return false;
              }
              return false;
            };
            main2.onclick = (e) => {
              if (this.settings.disabled) {
                return;
              }
              this.settings.isOpen ? this.callbacks.close() : this.callbacks.open();
            };
            const values = document.createElement("div");
            values.classList.add(this.classes.values);
            main2.appendChild(values);
            const deselect = document.createElement("div");
            deselect.classList.add(this.classes.deselect);
            const selectedOptions = (_a = this.store) === null || _a === void 0 ? void 0 : _a.getSelectedOptions();
            if (!this.settings.allowDeselect || this.settings.isMultiple && selectedOptions && selectedOptions.length <= 0) {
              deselect.classList.add(this.classes.hide);
            } else {
              deselect.classList.remove(this.classes.hide);
            }
            deselect.onclick = (e) => {
              e.stopPropagation();
              if (this.settings.disabled) {
                return;
              }
              let shouldDelete = true;
              const before = this.store.getSelectedOptions();
              const after = [];
              if (this.callbacks.beforeChange) {
                shouldDelete = this.callbacks.beforeChange(after, before) === true;
              }
              if (shouldDelete) {
                if (this.settings.isMultiple) {
                  this.callbacks.setSelected([], false);
                  this.updateDeselectAll();
                } else {
                  const firstOption = this.store.getFirstOption();
                  const value = firstOption ? firstOption.value : "";
                  this.callbacks.setSelected(value, false);
                }
                if (this.settings.closeOnSelect) {
                  this.callbacks.close();
                }
                if (this.callbacks.afterChange) {
                  this.callbacks.afterChange(this.store.getSelectedOptions());
                }
              }
            };
            const deselectSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            deselectSvg.setAttribute("viewBox", "0 0 100 100");
            const deselectPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            deselectPath.setAttribute("d", this.classes.deselectPath);
            deselectSvg.appendChild(deselectPath);
            deselect.appendChild(deselectSvg);
            main2.appendChild(deselect);
            const arrow4 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            arrow4.classList.add(this.classes.arrow);
            arrow4.setAttribute("viewBox", "0 0 100 100");
            const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            arrowPath.setAttribute("d", this.classes.arrowClose);
            if (this.settings.alwaysOpen) {
              arrow4.classList.add(this.classes.hide);
            }
            arrow4.appendChild(arrowPath);
            main2.appendChild(arrow4);
            return {
              main: main2,
              values,
              deselect: {
                main: deselect,
                svg: deselectSvg,
                path: deselectPath
              },
              arrow: {
                main: arrow4,
                path: arrowPath
              }
            };
          }
          mainFocus(eventType) {
            if (eventType !== "click") {
              this.main.main.focus({ preventScroll: true });
            }
          }
          placeholder() {
            const placeholderOption = this.store.filter((o) => o.placeholder, false);
            let placeholderText = this.settings.placeholderText;
            if (placeholderOption.length) {
              if (placeholderOption[0].html !== "") {
                placeholderText = placeholderOption[0].html;
              } else if (placeholderOption[0].text !== "") {
                placeholderText = placeholderOption[0].text;
              }
            }
            const placeholder = document.createElement("div");
            placeholder.classList.add(this.classes.placeholder);
            placeholder.innerHTML = placeholderText;
            return placeholder;
          }
          renderValues() {
            if (!this.settings.isMultiple) {
              this.renderSingleValue();
              return;
            }
            this.renderMultipleValues();
            this.updateDeselectAll();
          }
          renderSingleValue() {
            const selected = this.store.filter((o) => {
              return o.selected && !o.placeholder;
            }, false);
            const selectedSingle = selected.length > 0 ? selected[0] : null;
            if (!selectedSingle) {
              this.main.values.innerHTML = this.placeholder().outerHTML;
            } else {
              const singleValue = document.createElement("div");
              singleValue.classList.add(this.classes.single);
              if (selectedSingle.html) {
                singleValue.innerHTML = selectedSingle.html;
              } else {
                singleValue.innerText = selectedSingle.text;
              }
              this.main.values.innerHTML = singleValue.outerHTML;
            }
            if (!this.settings.allowDeselect || !selected.length) {
              this.main.deselect.main.classList.add(this.classes.hide);
            } else {
              this.main.deselect.main.classList.remove(this.classes.hide);
            }
          }
          renderMultipleValues() {
            let currentNodes = this.main.values.childNodes;
            let selectedOptions = this.store.filter((opt) => {
              return opt.selected && opt.display;
            }, false);
            if (selectedOptions.length === 0) {
              this.main.values.innerHTML = this.placeholder().outerHTML;
              return;
            } else {
              const placeholder = this.main.values.querySelector("." + this.classes.placeholder);
              if (placeholder) {
                placeholder.remove();
              }
            }
            if (selectedOptions.length > this.settings.maxValuesShown) {
              const singleValue = document.createElement("div");
              singleValue.classList.add(this.classes.max);
              singleValue.textContent = this.settings.maxValuesMessage.replace("{number}", selectedOptions.length.toString());
              this.main.values.innerHTML = singleValue.outerHTML;
              return;
            } else {
              const maxValuesMessage = this.main.values.querySelector("." + this.classes.max);
              if (maxValuesMessage) {
                maxValuesMessage.remove();
              }
            }
            let removeNodes = [];
            for (let i = 0; i < currentNodes.length; i++) {
              const node = currentNodes[i];
              const id = node.getAttribute("data-id");
              if (id) {
                const found2 = selectedOptions.filter((opt) => {
                  return opt.id === id;
                }, false);
                if (!found2.length) {
                  removeNodes.push(node);
                }
              }
            }
            for (const n of removeNodes) {
              n.classList.add(this.classes.valueOut);
              setTimeout(() => {
                if (this.main.values.hasChildNodes() && this.main.values.contains(n)) {
                  this.main.values.removeChild(n);
                }
              }, 100);
            }
            currentNodes = this.main.values.childNodes;
            for (let d = 0; d < selectedOptions.length; d++) {
              let shouldAdd = true;
              for (let i = 0; i < currentNodes.length; i++) {
                if (selectedOptions[d].id === String(currentNodes[i].dataset.id)) {
                  shouldAdd = false;
                }
              }
              if (shouldAdd) {
                if (this.settings.keepOrder) {
                  this.main.values.appendChild(this.multipleValue(selectedOptions[d]));
                } else {
                  if (currentNodes.length === 0) {
                    this.main.values.appendChild(this.multipleValue(selectedOptions[d]));
                  } else if (d === 0) {
                    this.main.values.insertBefore(this.multipleValue(selectedOptions[d]), currentNodes[d]);
                  } else {
                    currentNodes[d - 1].insertAdjacentElement("afterend", this.multipleValue(selectedOptions[d]));
                  }
                }
              }
            }
          }
          multipleValue(option2) {
            const value = document.createElement("div");
            value.classList.add(this.classes.value);
            value.dataset.id = option2.id;
            const text = document.createElement("div");
            text.classList.add(this.classes.valueText);
            text.innerText = option2.text;
            value.appendChild(text);
            if (!option2.mandatory) {
              const deleteDiv = document.createElement("div");
              deleteDiv.classList.add(this.classes.valueDelete);
              deleteDiv.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this.settings.disabled) {
                  return;
                }
                let shouldDelete = true;
                const before = this.store.getSelectedOptions();
                const after = before.filter((o) => {
                  return o.selected && o.id !== option2.id;
                }, true);
                if (this.settings.minSelected && after.length < this.settings.minSelected) {
                  return;
                }
                if (this.callbacks.beforeChange) {
                  shouldDelete = this.callbacks.beforeChange(after, before) === true;
                }
                if (shouldDelete) {
                  let selectedValues = [];
                  for (const o of after) {
                    if (o instanceof Optgroup) {
                      for (const c of o.options) {
                        selectedValues.push(c.value);
                      }
                    }
                    if (o instanceof Option) {
                      selectedValues.push(o.value);
                    }
                  }
                  this.callbacks.setSelected(selectedValues, false);
                  if (this.settings.closeOnSelect) {
                    this.callbacks.close();
                  }
                  if (this.callbacks.afterChange) {
                    this.callbacks.afterChange(after);
                  }
                  this.updateDeselectAll();
                }
              };
              const deleteSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              deleteSvg.setAttribute("viewBox", "0 0 100 100");
              const deletePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
              deletePath.setAttribute("d", this.classes.optionDelete);
              deleteSvg.appendChild(deletePath);
              deleteDiv.appendChild(deleteSvg);
              value.appendChild(deleteDiv);
            }
            return value;
          }
          contentDiv() {
            const main2 = document.createElement("div");
            main2.dataset.id = this.settings.id;
            const search = this.searchDiv();
            main2.appendChild(search.main);
            const list = this.listDiv();
            main2.appendChild(list);
            return {
              main: main2,
              search,
              list
            };
          }
          moveContent() {
            if (this.settings.contentPosition === "relative") {
              this.moveContentBelow();
              return;
            }
            if (this.settings.openPosition === "down") {
              this.moveContentBelow();
              return;
            } else if (this.settings.openPosition === "up") {
              this.moveContentAbove();
              return;
            }
            if (this.putContent() === "up") {
              this.moveContentAbove();
            } else {
              this.moveContentBelow();
            }
          }
          searchDiv() {
            const main2 = document.createElement("div");
            const input = document.createElement("input");
            const addable = document.createElement("div");
            main2.classList.add(this.classes.search);
            const searchReturn = {
              main: main2,
              input
            };
            if (!this.settings.showSearch) {
              main2.classList.add(this.classes.hide);
              input.readOnly = true;
            }
            input.type = "search";
            input.placeholder = this.settings.searchPlaceholder;
            input.tabIndex = -1;
            input.setAttribute("aria-label", this.settings.searchPlaceholder);
            input.setAttribute("autocapitalize", "off");
            input.setAttribute("autocomplete", "off");
            input.setAttribute("autocorrect", "off");
            input.oninput = debounce5((e) => {
              this.callbacks.search(e.target.value);
            }, 100);
            input.onkeydown = (e) => {
              switch (e.key) {
                case "ArrowUp":
                case "ArrowDown":
                  e.key === "ArrowDown" ? this.highlight("down") : this.highlight("up");
                  return false;
                case "Tab":
                  this.callbacks.close();
                  return true;
                case "Escape":
                  this.callbacks.close();
                  return false;
                case "Enter":
                case " ":
                  if (this.callbacks.addable && e.ctrlKey) {
                    addable.click();
                    return false;
                  } else {
                    const highlighted = this.content.list.querySelector("." + this.classes.highlighted);
                    if (highlighted) {
                      highlighted.click();
                      return false;
                    }
                  }
                  return true;
              }
              return true;
            };
            main2.appendChild(input);
            if (this.callbacks.addable) {
              addable.classList.add(this.classes.addable);
              const plus = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              plus.setAttribute("viewBox", "0 0 100 100");
              const plusPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
              plusPath.setAttribute("d", this.classes.addablePath);
              plus.appendChild(plusPath);
              addable.appendChild(plus);
              addable.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!this.callbacks.addable) {
                  return;
                }
                const inputValue = this.content.search.input.value.trim();
                if (inputValue === "") {
                  this.content.search.input.focus();
                  return;
                }
                const runFinish = (oo) => {
                  let newOption = new Option(oo);
                  this.callbacks.addOption(newOption);
                  if (this.settings.isMultiple) {
                    let values = this.store.getSelected();
                    values.push(newOption.value);
                    this.callbacks.setSelected(values, true);
                  } else {
                    this.callbacks.setSelected([newOption.value], true);
                  }
                  this.callbacks.search("");
                  if (this.settings.closeOnSelect) {
                    setTimeout(() => {
                      this.callbacks.close();
                    }, 100);
                  }
                };
                const addableValue = this.callbacks.addable(inputValue);
                if (addableValue === false || addableValue === void 0 || addableValue === null) {
                  return;
                }
                if (addableValue instanceof Promise) {
                  addableValue.then((value) => {
                    if (typeof value === "string") {
                      runFinish({
                        text: value,
                        value
                      });
                    } else {
                      runFinish(value);
                    }
                  });
                } else if (typeof addableValue === "string") {
                  runFinish({
                    text: addableValue,
                    value: addableValue
                  });
                } else {
                  runFinish(addableValue);
                }
                return;
              };
              main2.appendChild(addable);
              searchReturn.addable = {
                main: addable,
                svg: plus,
                path: plusPath
              };
            }
            return searchReturn;
          }
          searchFocus() {
            this.content.search.input.focus();
          }
          getOptions(notPlaceholder = false, notDisabled = false, notHidden = false) {
            let query = "." + this.classes.option;
            if (notPlaceholder) {
              query += ":not(." + this.classes.placeholder + ")";
            }
            if (notDisabled) {
              query += ":not(." + this.classes.disabled + ")";
            }
            if (notHidden) {
              query += ":not(." + this.classes.hide + ")";
            }
            return Array.from(this.content.list.querySelectorAll(query));
          }
          highlight(dir) {
            const options = this.getOptions(true, true, true);
            if (options.length === 0) {
              return;
            }
            if (options.length === 1) {
              if (!options[0].classList.contains(this.classes.highlighted)) {
                options[0].classList.add(this.classes.highlighted);
                return;
              }
            }
            let highlighted = false;
            for (const o of options) {
              if (o.classList.contains(this.classes.highlighted)) {
                highlighted = true;
              }
            }
            if (!highlighted) {
              for (const o of options) {
                if (o.classList.contains(this.classes.selected)) {
                  o.classList.add(this.classes.highlighted);
                  break;
                }
              }
            }
            for (let i = 0; i < options.length; i++) {
              if (options[i].classList.contains(this.classes.highlighted)) {
                const prevOption = options[i];
                prevOption.classList.remove(this.classes.highlighted);
                const prevParent = prevOption.parentElement;
                if (prevParent && prevParent.classList.contains(this.classes.open)) {
                  const optgroupLabel = prevParent.querySelector("." + this.classes.optgroupLabel);
                  if (optgroupLabel) {
                    optgroupLabel.click();
                  }
                }
                let selectOption = options[dir === "down" ? i + 1 < options.length ? i + 1 : 0 : i - 1 >= 0 ? i - 1 : options.length - 1];
                selectOption.classList.add(this.classes.highlighted);
                this.ensureElementInView(this.content.list, selectOption);
                const selectParent = selectOption.parentElement;
                if (selectParent && selectParent.classList.contains(this.classes.close)) {
                  const optgroupLabel = selectParent.querySelector("." + this.classes.optgroupLabel);
                  if (optgroupLabel) {
                    optgroupLabel.click();
                  }
                }
                return;
              }
            }
            options[dir === "down" ? 0 : options.length - 1].classList.add(this.classes.highlighted);
            this.ensureElementInView(this.content.list, options[dir === "down" ? 0 : options.length - 1]);
          }
          listDiv() {
            const options = document.createElement("div");
            options.classList.add(this.classes.list);
            return options;
          }
          renderError(error3) {
            this.content.list.innerHTML = "";
            const errorDiv = document.createElement("div");
            errorDiv.classList.add(this.classes.error);
            errorDiv.textContent = error3;
            this.content.list.appendChild(errorDiv);
          }
          renderSearching() {
            this.content.list.innerHTML = "";
            const searchingDiv = document.createElement("div");
            searchingDiv.classList.add(this.classes.searching);
            searchingDiv.textContent = this.settings.searchingText;
            this.content.list.appendChild(searchingDiv);
          }
          renderOptions(data) {
            this.content.list.innerHTML = "";
            if (data.length === 0) {
              const noResults = document.createElement("div");
              noResults.classList.add(this.classes.search);
              noResults.innerHTML = this.settings.searchText;
              this.content.list.appendChild(noResults);
              return;
            }
            for (const d of data) {
              if (d instanceof Optgroup) {
                const optgroupEl = document.createElement("div");
                optgroupEl.classList.add(this.classes.optgroup);
                const optgroupLabel = document.createElement("div");
                optgroupLabel.classList.add(this.classes.optgroupLabel);
                optgroupEl.appendChild(optgroupLabel);
                const optgroupLabelText = document.createElement("div");
                optgroupLabelText.classList.add(this.classes.optgroupLabelText);
                optgroupLabelText.textContent = d.label;
                optgroupLabel.appendChild(optgroupLabelText);
                const optgroupActions = document.createElement("div");
                optgroupActions.classList.add(this.classes.optgroupActions);
                optgroupLabel.appendChild(optgroupActions);
                if (this.settings.isMultiple && d.selectAll) {
                  const selectAll3 = document.createElement("div");
                  selectAll3.classList.add(this.classes.optgroupSelectAll);
                  let allSelected = true;
                  for (const o of d.options) {
                    if (!o.selected) {
                      allSelected = false;
                      break;
                    }
                  }
                  if (allSelected) {
                    selectAll3.classList.add(this.classes.selected);
                  }
                  const selectAllText = document.createElement("span");
                  selectAllText.textContent = d.selectAllText;
                  selectAll3.appendChild(selectAllText);
                  const selectAllSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                  selectAllSvg.setAttribute("viewBox", "0 0 100 100");
                  selectAll3.appendChild(selectAllSvg);
                  const selectAllBox = document.createElementNS("http://www.w3.org/2000/svg", "path");
                  selectAllBox.setAttribute("d", this.classes.optgroupSelectAllBox);
                  selectAllSvg.appendChild(selectAllBox);
                  const selectAllCheck = document.createElementNS("http://www.w3.org/2000/svg", "path");
                  selectAllCheck.setAttribute("d", this.classes.optgroupSelectAllCheck);
                  selectAllSvg.appendChild(selectAllCheck);
                  selectAll3.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const currentSelected = this.store.getSelected();
                    if (allSelected) {
                      const newSelected = currentSelected.filter((s) => {
                        for (const o of d.options) {
                          if (s === o.value) {
                            return false;
                          }
                        }
                        return true;
                      });
                      this.callbacks.setSelected(newSelected, true);
                      return;
                    } else {
                      const newSelected = currentSelected.concat(d.options.map((o) => o.value));
                      for (const o of d.options) {
                        if (!this.store.getOptionByID(o.id)) {
                          this.callbacks.addOption(o);
                        }
                      }
                      this.callbacks.setSelected(newSelected, true);
                      return;
                    }
                  });
                  optgroupActions.appendChild(selectAll3);
                }
                if (d.closable !== "off") {
                  const optgroupClosable = document.createElement("div");
                  optgroupClosable.classList.add(this.classes.optgroupClosable);
                  const optgroupClosableSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                  optgroupClosableSvg.setAttribute("viewBox", "0 0 100 100");
                  optgroupClosableSvg.classList.add(this.classes.arrow);
                  optgroupClosable.appendChild(optgroupClosableSvg);
                  const optgroupClosableArrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
                  optgroupClosableSvg.appendChild(optgroupClosableArrow);
                  if (d.options.some((o) => o.selected) || this.content.search.input.value.trim() !== "") {
                    optgroupClosable.classList.add(this.classes.open);
                    optgroupClosableArrow.setAttribute("d", this.classes.arrowOpen);
                  } else if (d.closable === "open") {
                    optgroupEl.classList.add(this.classes.open);
                    optgroupClosableArrow.setAttribute("d", this.classes.arrowOpen);
                  } else if (d.closable === "close") {
                    optgroupEl.classList.add(this.classes.close);
                    optgroupClosableArrow.setAttribute("d", this.classes.arrowClose);
                  }
                  optgroupLabel.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (optgroupEl.classList.contains(this.classes.close)) {
                      optgroupEl.classList.remove(this.classes.close);
                      optgroupEl.classList.add(this.classes.open);
                      optgroupClosableArrow.setAttribute("d", this.classes.arrowOpen);
                    } else {
                      optgroupEl.classList.remove(this.classes.open);
                      optgroupEl.classList.add(this.classes.close);
                      optgroupClosableArrow.setAttribute("d", this.classes.arrowClose);
                    }
                  });
                  optgroupActions.appendChild(optgroupClosable);
                }
                optgroupEl.appendChild(optgroupLabel);
                for (const o of d.options) {
                  optgroupEl.appendChild(this.option(o));
                }
                this.content.list.appendChild(optgroupEl);
              }
              if (d instanceof Option) {
                this.content.list.appendChild(this.option(d));
              }
            }
          }
          option(option2) {
            if (option2.placeholder) {
              const placeholder = document.createElement("div");
              placeholder.classList.add(this.classes.option);
              placeholder.classList.add(this.classes.hide);
              return placeholder;
            }
            const optionEl = document.createElement("div");
            optionEl.dataset.id = option2.id;
            optionEl.id = option2.id;
            optionEl.classList.add(this.classes.option);
            optionEl.setAttribute("role", "option");
            if (option2.class) {
              option2.class.split(" ").forEach((dataClass) => {
                optionEl.classList.add(dataClass);
              });
            }
            if (option2.style) {
              optionEl.style.cssText = option2.style;
            }
            if (this.settings.searchHighlight && this.content.search.input.value.trim() !== "") {
              optionEl.innerHTML = this.highlightText(option2.html !== "" ? option2.html : option2.text, this.content.search.input.value, this.classes.searchHighlighter);
            } else if (option2.html !== "") {
              optionEl.innerHTML = option2.html;
            } else {
              optionEl.textContent = option2.text;
            }
            if (this.settings.showOptionTooltips && optionEl.textContent) {
              optionEl.setAttribute("title", optionEl.textContent);
            }
            if (!option2.display) {
              optionEl.classList.add(this.classes.hide);
            }
            if (option2.disabled) {
              optionEl.classList.add(this.classes.disabled);
            }
            if (option2.selected && this.settings.hideSelected) {
              optionEl.classList.add(this.classes.hide);
            }
            if (option2.selected) {
              optionEl.classList.add(this.classes.selected);
              optionEl.setAttribute("aria-selected", "true");
              this.main.main.setAttribute("aria-activedescendant", optionEl.id);
            } else {
              optionEl.classList.remove(this.classes.selected);
              optionEl.setAttribute("aria-selected", "false");
            }
            optionEl.addEventListener("click", (e) => {
              e.preventDefault();
              e.stopPropagation();
              const selectedOptions = this.store.getSelected();
              const element = e.currentTarget;
              const elementID = String(element.dataset.id);
              if (option2.disabled || option2.selected && !this.settings.allowDeselect) {
                return;
              }
              if (this.settings.isMultiple && this.settings.maxSelected <= selectedOptions.length && !option2.selected || this.settings.isMultiple && this.settings.minSelected >= selectedOptions.length && option2.selected) {
                return;
              }
              let shouldUpdate = false;
              const before = this.store.getSelectedOptions();
              let after = [];
              if (this.settings.isMultiple) {
                if (option2.selected) {
                  after = before.filter((o) => o.id !== elementID);
                } else {
                  after = before.concat(option2);
                }
              }
              if (!this.settings.isMultiple) {
                if (option2.selected) {
                  after = [];
                } else {
                  after = [option2];
                }
              }
              if (!this.callbacks.beforeChange) {
                shouldUpdate = true;
              }
              if (this.callbacks.beforeChange) {
                if (this.callbacks.beforeChange(after, before) === false) {
                  shouldUpdate = false;
                } else {
                  shouldUpdate = true;
                }
              }
              if (shouldUpdate) {
                if (!this.store.getOptionByID(elementID)) {
                  this.callbacks.addOption(option2);
                }
                this.callbacks.setSelected(after.map((o) => o.value), false);
                if (this.settings.closeOnSelect) {
                  this.callbacks.close();
                }
                if (this.callbacks.afterChange) {
                  this.callbacks.afterChange(after);
                }
              }
            });
            return optionEl;
          }
          destroy() {
            this.main.main.remove();
            this.content.main.remove();
          }
          highlightText(str, search, className) {
            let completedString = str;
            const regex = new RegExp("(" + search.trim() + ")(?![^<]*>[^<>]*</)", "i");
            if (!str.match(regex)) {
              return str;
            }
            const matchStartPosition = str.match(regex).index;
            const matchEndPosition = matchStartPosition + str.match(regex)[0].toString().length;
            const originalTextFoundByRegex = str.substring(matchStartPosition, matchEndPosition);
            completedString = completedString.replace(regex, `<mark class="${className}">${originalTextFoundByRegex}</mark>`);
            return completedString;
          }
          moveContentAbove() {
            const mainHeight = this.main.main.offsetHeight;
            const contentHeight = this.content.main.offsetHeight;
            this.main.main.classList.remove(this.classes.openBelow);
            this.main.main.classList.add(this.classes.openAbove);
            this.content.main.classList.remove(this.classes.openBelow);
            this.content.main.classList.add(this.classes.openAbove);
            const containerRect = this.main.main.getBoundingClientRect();
            this.content.main.style.margin = "-" + (mainHeight + contentHeight - 1) + "px 0px 0px 0px";
            this.content.main.style.top = containerRect.top + containerRect.height + window.scrollY + "px";
            this.content.main.style.left = containerRect.left + window.scrollX + "px";
            this.content.main.style.width = containerRect.width + "px";
          }
          moveContentBelow() {
            this.main.main.classList.remove(this.classes.openAbove);
            this.main.main.classList.add(this.classes.openBelow);
            this.content.main.classList.remove(this.classes.openAbove);
            this.content.main.classList.add(this.classes.openBelow);
            const containerRect = this.main.main.getBoundingClientRect();
            this.content.main.style.margin = "-1px 0px 0px 0px";
            if (this.settings.contentPosition !== "relative") {
              this.content.main.style.top = containerRect.top + containerRect.height + window.scrollY + "px";
              this.content.main.style.left = containerRect.left + window.scrollX + "px";
              this.content.main.style.width = containerRect.width + "px";
            }
          }
          ensureElementInView(container, element) {
            const cTop = container.scrollTop + container.offsetTop;
            const cBottom = cTop + container.clientHeight;
            const eTop = element.offsetTop;
            const eBottom = eTop + element.clientHeight;
            if (eTop < cTop) {
              container.scrollTop -= cTop - eTop;
            } else if (eBottom > cBottom) {
              container.scrollTop += eBottom - cBottom;
            }
          }
          putContent() {
            const mainHeight = this.main.main.offsetHeight;
            const mainRect = this.main.main.getBoundingClientRect();
            const contentHeight = this.content.main.offsetHeight;
            const spaceBelow = window.innerHeight - (mainRect.top + mainHeight);
            if (spaceBelow <= contentHeight) {
              if (mainRect.top > contentHeight) {
                return "up";
              } else {
                return "down";
              }
            }
            return "down";
          }
          updateDeselectAll() {
            if (!this.store || !this.settings) {
              return;
            }
            const selected = this.store.getSelectedOptions();
            const hasSelectedItems = selected && selected.length > 0;
            const isMultiple = this.settings.isMultiple;
            const allowDeselect = this.settings.allowDeselect;
            const deselectButton = this.main.deselect.main;
            const hideClass = this.classes.hide;
            if (allowDeselect && !(isMultiple && !hasSelectedItems)) {
              deselectButton.classList.remove(hideClass);
            } else {
              deselectButton.classList.add(hideClass);
            }
          }
        }
        class Select {
          constructor(select) {
            this.listen = false;
            this.observer = null;
            this.select = select;
            this.valueChange = this.valueChange.bind(this);
            this.select.addEventListener("change", this.valueChange, {
              passive: true
            });
            this.observer = new MutationObserver(this.observeCall.bind(this));
            this.changeListen(true);
          }
          enable() {
            this.select.disabled = false;
          }
          disable() {
            this.select.disabled = true;
          }
          hideUI() {
            this.select.tabIndex = -1;
            this.select.style.display = "none";
            this.select.setAttribute("aria-hidden", "true");
          }
          showUI() {
            this.select.removeAttribute("tabindex");
            this.select.style.display = "";
            this.select.removeAttribute("aria-hidden");
          }
          changeListen(listen) {
            this.listen = listen;
            if (listen) {
              if (this.observer) {
                this.observer.observe(this.select, {
                  subtree: true,
                  childList: true,
                  attributes: true
                });
              }
            }
            if (!listen) {
              if (this.observer) {
                this.observer.disconnect();
              }
            }
          }
          valueChange(ev) {
            if (this.listen && this.onValueChange) {
              this.onValueChange(this.getSelectedValues());
            }
            return true;
          }
          observeCall(mutations) {
            if (!this.listen) {
              return;
            }
            let classChanged = false;
            let disabledChanged = false;
            let optgroupOptionChanged = false;
            for (const m of mutations) {
              if (m.target === this.select) {
                if (m.attributeName === "disabled") {
                  disabledChanged = true;
                }
                if (m.attributeName === "class") {
                  classChanged = true;
                }
              }
              if (m.target.nodeName === "OPTGROUP" || m.target.nodeName === "OPTION") {
                optgroupOptionChanged = true;
              }
            }
            if (classChanged && this.onClassChange) {
              this.onClassChange(this.select.className.split(" "));
            }
            if (disabledChanged && this.onDisabledChange) {
              this.changeListen(false);
              this.onDisabledChange(this.select.disabled);
              this.changeListen(true);
            }
            if (optgroupOptionChanged && this.onOptionsChange) {
              this.changeListen(false);
              this.onOptionsChange(this.getData());
              this.changeListen(true);
            }
          }
          getData() {
            let data = [];
            const nodes = this.select.childNodes;
            for (const n of nodes) {
              if (n.nodeName === "OPTGROUP") {
                data.push(this.getDataFromOptgroup(n));
              }
              if (n.nodeName === "OPTION") {
                data.push(this.getDataFromOption(n));
              }
            }
            return data;
          }
          getDataFromOptgroup(optgroup) {
            let data = {
              id: optgroup.id,
              label: optgroup.label,
              selectAll: optgroup.dataset ? optgroup.dataset.selectall === "true" : false,
              selectAllText: optgroup.dataset ? optgroup.dataset.selectalltext : "Select all",
              closable: optgroup.dataset ? optgroup.dataset.closable : "off",
              options: []
            };
            const options = optgroup.childNodes;
            for (const o of options) {
              if (o.nodeName === "OPTION") {
                data.options.push(this.getDataFromOption(o));
              }
            }
            return data;
          }
          getDataFromOption(option2) {
            return {
              id: option2.id,
              value: option2.value,
              text: option2.text,
              html: option2.dataset && option2.dataset.html ? option2.dataset.html : "",
              selected: option2.selected,
              display: option2.style.display === "none" ? false : true,
              disabled: option2.disabled,
              mandatory: option2.dataset ? option2.dataset.mandatory === "true" : false,
              placeholder: option2.dataset.placeholder === "true",
              class: option2.className,
              style: option2.style.cssText,
              data: option2.dataset
            };
          }
          getSelectedValues() {
            let values = [];
            const options = this.select.childNodes;
            for (const o of options) {
              if (o.nodeName === "OPTGROUP") {
                const optgroupOptions = o.childNodes;
                for (const oo of optgroupOptions) {
                  if (oo.nodeName === "OPTION") {
                    const option2 = oo;
                    if (option2.selected) {
                      values.push(option2.value);
                    }
                  }
                }
              }
              if (o.nodeName === "OPTION") {
                const option2 = o;
                if (option2.selected) {
                  values.push(option2.value);
                }
              }
            }
            return values;
          }
          setSelected(value) {
            this.changeListen(false);
            const options = this.select.childNodes;
            for (const o of options) {
              if (o.nodeName === "OPTGROUP") {
                const optgroup = o;
                const optgroupOptions = optgroup.childNodes;
                for (const oo of optgroupOptions) {
                  if (oo.nodeName === "OPTION") {
                    const option2 = oo;
                    option2.selected = value.includes(option2.value);
                  }
                }
              }
              if (o.nodeName === "OPTION") {
                const option2 = o;
                option2.selected = value.includes(option2.value);
              }
            }
            this.changeListen(true);
          }
          updateSelect(id, style2, classes) {
            this.changeListen(false);
            if (id) {
              this.select.dataset.id = id;
            }
            if (style2) {
              this.select.style.cssText = style2;
            }
            if (classes) {
              this.select.className = "";
              classes.forEach((c) => {
                if (c.trim() !== "") {
                  this.select.classList.add(c.trim());
                }
              });
            }
            this.changeListen(true);
          }
          updateOptions(data) {
            this.changeListen(false);
            this.select.innerHTML = "";
            for (const d of data) {
              if (d instanceof Optgroup) {
                this.select.appendChild(this.createOptgroup(d));
              }
              if (d instanceof Option) {
                this.select.appendChild(this.createOption(d));
              }
            }
            this.select.dispatchEvent(new Event("change"));
            this.changeListen(true);
          }
          createOptgroup(optgroup) {
            const optgroupEl = document.createElement("optgroup");
            optgroupEl.id = optgroup.id;
            optgroupEl.label = optgroup.label;
            if (optgroup.selectAll) {
              optgroupEl.dataset.selectAll = "true";
            }
            if (optgroup.closable !== "off") {
              optgroupEl.dataset.closable = optgroup.closable;
            }
            if (optgroup.options) {
              for (const o of optgroup.options) {
                optgroupEl.appendChild(this.createOption(o));
              }
            }
            return optgroupEl;
          }
          createOption(info) {
            const optionEl = document.createElement("option");
            optionEl.id = info.id;
            optionEl.value = info.value;
            optionEl.innerHTML = info.text;
            if (info.html !== "") {
              optionEl.setAttribute("data-html", info.html);
            }
            if (info.selected) {
              optionEl.selected = info.selected;
            }
            if (info.disabled) {
              optionEl.disabled = true;
            }
            if (info.display === false) {
              optionEl.style.display = "none";
            }
            if (info.placeholder) {
              optionEl.setAttribute("data-placeholder", "true");
            }
            if (info.mandatory) {
              optionEl.setAttribute("data-mandatory", "true");
            }
            if (info.class) {
              info.class.split(" ").forEach((optionClass) => {
                optionEl.classList.add(optionClass);
              });
            }
            if (info.data && typeof info.data === "object") {
              Object.keys(info.data).forEach((key) => {
                optionEl.setAttribute("data-" + kebabCase(key), info.data[key]);
              });
            }
            return optionEl;
          }
          destroy() {
            this.changeListen(false);
            this.select.removeEventListener("change", this.valueChange);
            if (this.observer) {
              this.observer.disconnect();
              this.observer = null;
            }
            delete this.select.dataset.id;
            this.showUI();
          }
        }
        class Settings {
          constructor(settings) {
            this.id = "";
            this.style = "";
            this.class = [];
            this.isMultiple = false;
            this.isOpen = false;
            this.isFullOpen = false;
            this.intervalMove = null;
            if (!settings) {
              settings = {};
            }
            this.id = "ss-" + generateID();
            this.style = settings.style || "";
            this.class = settings.class || [];
            this.disabled = settings.disabled !== void 0 ? settings.disabled : false;
            this.alwaysOpen = settings.alwaysOpen !== void 0 ? settings.alwaysOpen : false;
            this.showSearch = settings.showSearch !== void 0 ? settings.showSearch : true;
            this.ariaLabel = settings.ariaLabel || "Combobox";
            this.searchPlaceholder = settings.searchPlaceholder || "Search";
            this.searchText = settings.searchText || "No Results";
            this.searchingText = settings.searchingText || "Searching...";
            this.searchHighlight = settings.searchHighlight !== void 0 ? settings.searchHighlight : false;
            this.closeOnSelect = settings.closeOnSelect !== void 0 ? settings.closeOnSelect : true;
            this.contentLocation = settings.contentLocation || document.body;
            this.contentPosition = settings.contentPosition || "absolute";
            this.openPosition = settings.openPosition || "auto";
            this.placeholderText = settings.placeholderText !== void 0 ? settings.placeholderText : "Select Value";
            this.allowDeselect = settings.allowDeselect !== void 0 ? settings.allowDeselect : false;
            this.hideSelected = settings.hideSelected !== void 0 ? settings.hideSelected : false;
            this.keepOrder = settings.keepOrder !== void 0 ? settings.keepOrder : false;
            this.showOptionTooltips = settings.showOptionTooltips !== void 0 ? settings.showOptionTooltips : false;
            this.minSelected = settings.minSelected || 0;
            this.maxSelected = settings.maxSelected || 1e3;
            this.timeoutDelay = settings.timeoutDelay || 200;
            this.maxValuesShown = settings.maxValuesShown || 20;
            this.maxValuesMessage = settings.maxValuesMessage || "{number} selected";
          }
        }
        class SlimSelect {
          constructor(config) {
            var _a;
            this.events = {
              search: void 0,
              searchFilter: (opt, search) => {
                return opt.text.toLowerCase().indexOf(search.toLowerCase()) !== -1;
              },
              addable: void 0,
              beforeChange: void 0,
              afterChange: void 0,
              beforeOpen: void 0,
              afterOpen: void 0,
              beforeClose: void 0,
              afterClose: void 0
            };
            this.windowResize = debounce5(() => {
              if (!this.settings.isOpen && !this.settings.isFullOpen) {
                return;
              }
              this.render.moveContent();
            });
            this.windowScroll = debounce5(() => {
              if (!this.settings.isOpen && !this.settings.isFullOpen) {
                return;
              }
              this.render.moveContent();
            });
            this.documentClick = (e) => {
              if (!this.settings.isOpen) {
                return;
              }
              if (e.target && !hasClassInTree(e.target, this.settings.id)) {
                this.close(e.type);
              }
            };
            this.windowVisibilityChange = () => {
              if (document.hidden) {
                this.close();
              }
            };
            this.selectEl = typeof config.select === "string" ? document.querySelector(config.select) : config.select;
            if (!this.selectEl) {
              if (config.events && config.events.error) {
                config.events.error(new Error("Could not find select element"));
              }
              return;
            }
            if (this.selectEl.tagName !== "SELECT") {
              if (config.events && config.events.error) {
                config.events.error(new Error("Element isnt of type select"));
              }
              return;
            }
            if (this.selectEl.dataset.ssid) {
              this.destroy();
            }
            this.settings = new Settings(config.settings);
            const debounceEvents = ["afterChange", "beforeOpen", "afterOpen", "beforeClose", "afterClose"];
            for (const key in config.events) {
              if (!config.events.hasOwnProperty(key)) {
                continue;
              }
              if (debounceEvents.indexOf(key) !== -1) {
                this.events[key] = debounce5(config.events[key], 100);
              } else {
                this.events[key] = config.events[key];
              }
            }
            this.settings.disabled = ((_a = config.settings) === null || _a === void 0 ? void 0 : _a.disabled) ? config.settings.disabled : this.selectEl.disabled;
            this.settings.isMultiple = this.selectEl.multiple;
            this.settings.style = this.selectEl.style.cssText;
            this.settings.class = this.selectEl.className.split(" ");
            this.select = new Select(this.selectEl);
            this.select.updateSelect(this.settings.id, this.settings.style, this.settings.class);
            this.select.hideUI();
            this.select.onValueChange = (values) => {
              this.setSelected(values);
            };
            this.select.onClassChange = (classes) => {
              this.settings.class = classes;
              this.render.updateClassStyles();
            };
            this.select.onDisabledChange = (disabled) => {
              if (disabled) {
                this.disable();
              } else {
                this.enable();
              }
            };
            this.select.onOptionsChange = (data) => {
              this.setData(data);
            };
            this.store = new Store(this.settings.isMultiple ? "multiple" : "single", config.data ? config.data : this.select.getData());
            if (config.data) {
              this.select.updateOptions(this.store.getData());
            }
            const renderCallbacks = {
              open: this.open.bind(this),
              close: this.close.bind(this),
              addable: this.events.addable ? this.events.addable : void 0,
              setSelected: this.setSelected.bind(this),
              addOption: this.addOption.bind(this),
              search: this.search.bind(this),
              beforeChange: this.events.beforeChange,
              afterChange: this.events.afterChange
            };
            this.render = new Render(this.settings, this.store, renderCallbacks);
            this.render.renderValues();
            this.render.renderOptions(this.store.getData());
            const selectAriaLabel = this.selectEl.getAttribute("aria-label");
            const selectAriaLabelledBy = this.selectEl.getAttribute("aria-labelledby");
            if (selectAriaLabel) {
              this.render.main.main.setAttribute("aria-label", selectAriaLabel);
            } else if (selectAriaLabelledBy) {
              this.render.main.main.setAttribute("aria-labelledby", selectAriaLabelledBy);
            }
            if (this.selectEl.parentNode) {
              this.selectEl.parentNode.insertBefore(this.render.main.main, this.selectEl.nextSibling);
            }
            window.addEventListener("resize", this.windowResize, false);
            if (this.settings.openPosition === "auto") {
              window.addEventListener("scroll", this.windowScroll, false);
            }
            document.addEventListener("visibilitychange", this.windowVisibilityChange);
            if (this.settings.disabled) {
              this.disable();
            }
            if (this.settings.alwaysOpen) {
              this.open();
            }
            this.selectEl.slim = this;
          }
          enable() {
            this.settings.disabled = false;
            this.select.enable();
            this.render.enable();
          }
          disable() {
            this.settings.disabled = true;
            this.select.disable();
            this.render.disable();
          }
          getData() {
            return this.store.getData();
          }
          setData(data) {
            const selected = this.store.getSelected();
            const err = this.store.validateDataArray(data);
            if (err) {
              if (this.events.error) {
                this.events.error(err);
              }
              return;
            }
            this.store.setData(data);
            const dataClean = this.store.getData();
            this.select.updateOptions(dataClean);
            this.render.renderValues();
            this.render.renderOptions(dataClean);
            if (this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
              this.events.afterChange(this.store.getSelectedOptions());
            }
          }
          getSelected() {
            return this.store.getSelected();
          }
          setSelected(value, runAfterChange = true) {
            const selected = this.store.getSelected();
            this.store.setSelectedBy("value", Array.isArray(value) ? value : [value]);
            const data = this.store.getData();
            this.select.updateOptions(data);
            this.render.renderValues();
            if (this.render.content.search.input.value !== "") {
              this.search(this.render.content.search.input.value);
            } else {
              this.render.renderOptions(data);
            }
            if (runAfterChange && this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
              this.events.afterChange(this.store.getSelectedOptions());
            }
          }
          addOption(option2) {
            const selected = this.store.getSelected();
            if (!this.store.getDataOptions().some((o) => {
              var _a;
              return o.value === ((_a = option2.value) !== null && _a !== void 0 ? _a : option2.text);
            })) {
              this.store.addOption(option2);
            }
            const data = this.store.getData();
            this.select.updateOptions(data);
            this.render.renderValues();
            this.render.renderOptions(data);
            if (this.events.afterChange && !isEqual(selected, this.store.getSelected())) {
              this.events.afterChange(this.store.getSelectedOptions());
            }
          }
          open() {
            if (this.settings.disabled || this.settings.isOpen) {
              return;
            }
            if (this.events.beforeOpen) {
              this.events.beforeOpen();
            }
            this.render.open();
            if (this.settings.showSearch) {
              this.render.searchFocus();
            }
            this.settings.isOpen = true;
            setTimeout(() => {
              if (this.events.afterOpen) {
                this.events.afterOpen();
              }
              if (this.settings.isOpen) {
                this.settings.isFullOpen = true;
              }
              document.addEventListener("click", this.documentClick);
            }, this.settings.timeoutDelay);
            if (this.settings.contentPosition === "absolute") {
              if (this.settings.intervalMove) {
                clearInterval(this.settings.intervalMove);
              }
              this.settings.intervalMove = setInterval(this.render.moveContent.bind(this.render), 500);
            }
          }
          close(eventType = null) {
            if (!this.settings.isOpen || this.settings.alwaysOpen) {
              return;
            }
            if (this.events.beforeClose) {
              this.events.beforeClose();
            }
            this.render.close();
            if (this.render.content.search.input.value !== "") {
              this.search("");
            }
            this.render.mainFocus(eventType);
            this.settings.isOpen = false;
            this.settings.isFullOpen = false;
            setTimeout(() => {
              if (this.events.afterClose) {
                this.events.afterClose();
              }
              document.removeEventListener("click", this.documentClick);
            }, this.settings.timeoutDelay);
            if (this.settings.intervalMove) {
              clearInterval(this.settings.intervalMove);
            }
          }
          search(value) {
            if (this.render.content.search.input.value !== value) {
              this.render.content.search.input.value = value;
            }
            if (!this.events.search) {
              this.render.renderOptions(value === "" ? this.store.getData() : this.store.search(value, this.events.searchFilter));
              return;
            }
            this.render.renderSearching();
            const searchResp = this.events.search(value, this.store.getSelectedOptions());
            if (searchResp instanceof Promise) {
              searchResp.then((data) => {
                this.render.renderOptions(this.store.partialToFullData(data));
              }).catch((err) => {
                this.render.renderError(typeof err === "string" ? err : err.message);
              });
              return;
            } else if (Array.isArray(searchResp)) {
              this.render.renderOptions(this.store.partialToFullData(searchResp));
            } else {
              this.render.renderError("Search event must return a promise or an array of data");
            }
          }
          destroy() {
            document.removeEventListener("click", this.documentClick);
            window.removeEventListener("resize", this.windowResize, false);
            if (this.settings.openPosition === "auto") {
              window.removeEventListener("scroll", this.windowScroll, false);
            }
            document.removeEventListener("visibilitychange", this.windowVisibilityChange);
            this.store.setData([]);
            this.render.destroy();
            this.select.destroy();
          }
        }
        return SlimSelect;
      });
    }
  });

  // node_modules/lodash.debounce/index.js
  var require_lodash2 = __commonJS({
    "node_modules/lodash.debounce/index.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now2 = function() {
        return root.Date.now();
      };
      function debounce5(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function isObject2(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = debounce5;
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  (function() {
    if (window.Reflect === void 0 || window.customElements === void 0 || window.customElements.polyfillWrapFlushCallback) {
      return;
    }
    const BuiltInHTMLElement = HTMLElement;
    const wrapperForTheName = {
      HTMLElement: function HTMLElement2() {
        return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
      }
    };
    window.HTMLElement = wrapperForTheName["HTMLElement"];
    HTMLElement.prototype = BuiltInHTMLElement.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
  })();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window && /Apple Computer/.test(navigator.vendor)) {
      prototype = window.SubmitEvent.prototype;
    } else if ("SubmitEvent" in window) {
      return;
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle;
  (function(FrameLoadingStyle2) {
    FrameLoadingStyle2["eager"] = "eager";
    FrameLoadingStyle2["lazy"] = "lazy";
  })(FrameLoadingStyle || (FrameLoadingStyle = {}));
  var FrameElement = class _FrameElement extends HTMLElement {
    static get observedAttributes() {
      return ["disabled", "complete", "loading", "src"];
    }
    constructor() {
      super();
      this.loaded = Promise.resolve();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "complete") {
        this.delegate.completeChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else {
        this.delegate.disabledChanged();
      }
    }
    get src() {
      return this.getAttribute("src");
    }
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    get complete() {
      return !this.delegate.isLoading;
    }
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    get isPreview() {
      var _a, _b;
      return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style2) {
    switch (style2.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction(form, submitter) {
    const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formaction")) || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextAnimationFrame() {
    return new Promise((resolve2) => requestAnimationFrame(() => resolve2()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve2) => setTimeout(() => resolve2(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i) => {
      const value = values[i] == void 0 ? "" : values[i];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-";
      } else if (i == 14) {
        return "4";
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements2) {
    for (const value of elements2.map((element) => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements2) {
    return elements2.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements2) {
    for (const element of elements2) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements2) {
    for (const element of elements2) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve2) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve2();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve2, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements2) {
    const action = getAttribute("data-turbo-action", ...elements2);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    var _a;
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || ((_a = element.getRootNode()) === null || _a === void 0 ? void 0 : _a.host), selector);
    }
  }
  var FetchMethod;
  (function(FetchMethod2) {
    FetchMethod2[FetchMethod2["get"] = 0] = "get";
    FetchMethod2[FetchMethod2["post"] = 1] = "post";
    FetchMethod2[FetchMethod2["put"] = 2] = "put";
    FetchMethod2[FetchMethod2["patch"] = 3] = "patch";
    FetchMethod2[FetchMethod2["delete"] = 4] = "delete";
  })(FetchMethod || (FetchMethod = {}));
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchRequest = class {
    constructor(delegate, method, location2, body = new URLSearchParams(), target = null) {
      this.abortController = new AbortController();
      this.resolveRequestPromise = (_value) => {
      };
      this.delegate = delegate;
      this.method = method;
      this.headers = this.defaultHeaders;
      this.body = body;
      this.url = location2;
      this.target = target;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      await this.allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        const response = await fetch(this.url.href, fetchOptions);
        return await this.receive(response);
      } catch (error3) {
        if (error3.name !== "AbortError") {
          if (this.willDelegateErrorHandling(error3)) {
            this.delegate.requestErrored(this, error3);
          }
          throw error3;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get fetchOptions() {
      var _a;
      return {
        method: FetchMethod[this.method].toUpperCase(),
        credentials: "same-origin",
        headers: this.headers,
        redirect: "follow",
        body: this.isSafe ? null : this.body,
        signal: this.abortSignal,
        referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
      };
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return this.method === FetchMethod.get;
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve2) => this.resolveRequestPromise = resolve2);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.resolveRequestPromise
        },
        target: this.target
      });
      if (event.defaultPrevented)
        await requestInterception;
    }
    willDelegateErrorHandling(error3) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error: error3 }
      });
      return !event.defaultPrevented;
    }
  };
  var AppearanceObserver = class {
    constructor(delegate, element) {
      this.started = false;
      this.intersect = (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      };
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  StreamMessage.contentType = "text/vnd.turbo-stream.html";
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var FormSubmissionState;
  (function(FormSubmissionState2) {
    FormSubmissionState2[FormSubmissionState2["initialized"] = 0] = "initialized";
    FormSubmissionState2[FormSubmissionState2["requesting"] = 1] = "requesting";
    FormSubmissionState2[FormSubmissionState2["waiting"] = 2] = "waiting";
    FormSubmissionState2[FormSubmissionState2["receiving"] = 3] = "receiving";
    FormSubmissionState2[FormSubmissionState2["stopping"] = 4] = "stopping";
    FormSubmissionState2[FormSubmissionState2["stopped"] = 5] = "stopped";
  })(FormSubmissionState || (FormSubmissionState = {}));
  var FormEnctype;
  (function(FormEnctype2) {
    FormEnctype2["urlEncoded"] = "application/x-www-form-urlencoded";
    FormEnctype2["multipart"] = "multipart/form-data";
    FormEnctype2["plain"] = "text/plain";
  })(FormEnctype || (FormEnctype = {}));
  function formEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FormEnctype.multipart:
        return FormEnctype.multipart;
      case FormEnctype.plain:
        return FormEnctype.plain;
      default:
        return FormEnctype.urlEncoded;
    }
  }
  var FormSubmission = class _FormSubmission {
    static confirmMethod(message, _element, _submitter) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      this.state = FormSubmissionState.initialized;
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.formData = buildFormData(formElement, submitter);
      this.location = expandURL(this.action);
      if (this.method == FetchMethod.get) {
        mergeFormDataEntries(this.location, [...this.body.entries()]);
      }
      this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      var _a;
      const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formmethod")) || this.formElement.getAttribute("method") || "";
      return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
    }
    get action() {
      var _a;
      const formElementAction = typeof this.formElement.action === "string" ? this.formElement.action : null;
      if ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.hasAttribute("formaction")) {
        return this.submitter.getAttribute("formaction") || "";
      } else {
        return this.formElement.getAttribute("action") || formElementAction || "";
      }
    }
    get body() {
      if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
        return new URLSearchParams(this.stringFormData);
      } else {
        return this.formData;
      }
    }
    get enctype() {
      var _a;
      return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formenctype")) || this.formElement.enctype);
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get stringFormData() {
      return [...this.formData].reduce((entries, [name, value]) => {
        return entries.concat(typeof value == "string" ? [[name, value]] : []);
      }, []);
    }
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const answer = await _FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      var _a;
      this.state = FormSubmissionState.waiting;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute("disabled", "");
      this.setSubmitsWith();
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
      } else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error3 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error3);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error3) {
      this.result = { success: false, error: error3 };
      this.delegate.formSubmissionErrored(this, error3);
    }
    requestFinished(_request) {
      var _a;
      this.state = FormSubmissionState.stopped;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
      this.resetSubmitterText();
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: Object.assign({ formSubmission: this }, this.result)
      });
      this.delegate.formSubmissionFinished(this);
    }
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith)
        return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText)
        return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      var _a;
      return (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("name");
    const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function mergeFormDataEntries(url, entries) {
    const searchParams = new URLSearchParams();
    for (const [name, value] of entries) {
      if (value instanceof File)
        continue;
      searchParams.append(name, value);
    }
    url.search = searchParams.toString();
    return url;
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
      for (const element of this.element.querySelectorAll("[autofocus]")) {
        if (element.closest(inertDisabledOrHidden) == null)
          return element;
        else
          continue;
      }
      return null;
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id) {
      return getPermanentElementById(this.element, id);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id) {
    return node.querySelector(`#${id}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    constructor(delegate, eventTarget) {
      this.started = false;
      this.submitCaptured = () => {
        this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
        this.eventTarget.addEventListener("submit", this.submitBubbled, false);
      };
      this.submitBubbled = (event) => {
        if (!event.defaultPrevented) {
          const form = event.target instanceof HTMLFormElement ? event.target : void 0;
          const submitter = event.submitter || void 0;
          if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.delegate.formSubmitted(form, submitter);
          }
        }
      };
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  function submissionDoesNotDismissDialog(form, submitter) {
    const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter) {
    if ((submitter === null || submitter === void 0 ? void 0 : submitter.hasAttribute("formtarget")) || form.hasAttribute("target")) {
      const target = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formtarget")) || form.target;
      for (const element of document.getElementsByName(target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  var View = class {
    constructor(delegate, element) {
      this.resolveRenderPromise = (_value) => {
      };
      this.resolveInterceptionPromise = (_value) => {
      };
      this.delegate = delegate;
      this.element = element;
    }
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x, y }) {
      this.scrollRoot.scrollTo(x, y);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    async render(renderer) {
      const { isPreview, shouldRender, newSnapshot: snapshot } = renderer;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve2) => this.resolveRenderPromise = resolve2);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve2) => this.resolveInterceptionPromise = resolve2);
          const options = { resume: this.resolveInterceptionPromise, render: this.renderer.renderElement };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.clickBubbled = (event) => {
        if (this.respondsToEventTarget(event.target)) {
          this.clickEvent = event;
        } else {
          delete this.clickEvent;
        }
      };
      this.linkClicked = (event) => {
        if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
          if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
            this.clickEvent.preventDefault();
            event.preventDefault();
            this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
          }
        }
        delete this.clickEvent;
      };
      this.willVisit = (_event) => {
        delete this.clickEvent;
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    constructor(delegate, eventTarget) {
      this.started = false;
      this.clickCaptured = () => {
        this.eventTarget.removeEventListener("click", this.clickBubbled, false);
        this.eventTarget.addEventListener("click", this.clickBubbled, false);
      };
      this.clickBubbled = (event) => {
        if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
          const target = event.composedPath && event.composedPath()[0] || event.target;
          const link = this.findLinkFromClickTarget(target);
          if (link && doesNotTargetIFrame(link)) {
            const location2 = this.getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
              event.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      };
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
    findLinkFromClickTarget(target) {
      return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
    }
    getLocationForLink(link) {
      return expandURL(link.getAttribute("href") || "");
    }
  };
  function doesNotTargetIFrame(anchor) {
    if (anchor.hasAttribute("target")) {
      for (const element of document.getElementsByName(anchor.target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && link.hasAttribute("data-turbo-method");
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method)
        form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame)
        form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction)
        form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm)
        form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream)
        form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback2) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback2();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone4 = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone4);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      this.activeElement = null;
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = renderElement;
      this.promise = new Promise((resolve2, reject) => this.resolvingFunctions = { resolve: resolve2, reject });
    }
    get shouldRender() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback2) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback2);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (elementIsFocusable(element)) {
        element.focus();
      }
    }
    enteringBardo(currentPermanentElement) {
      if (this.activeElement)
        return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.activeElement) && this.activeElement instanceof HTMLElement) {
        this.activeElement.focus();
        this.activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
  };
  function elementIsFocusable(element) {
    return element && typeof element.focus == "function";
  }
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      var _a;
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextAnimationFrame();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextAnimationFrame();
      this.focusFirstAutofocusableElement();
      await nextAnimationFrame();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var ProgressBar = class _ProgressBar {
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    constructor() {
      this.hiding = false;
      this.value = 0;
      this.visible = false;
      this.trickle = () => {
        this.setValue(this.value + Math.random() / 100);
      };
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback2) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback2, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  ProgressBar.animationDuration = 300;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      this.detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result ? result[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return Object.assign(Object.assign({}, result), { [outerHTML]: Object.assign(Object.assign({}, details), { elements: [...details.elements, element] }) });
      }, {});
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements: elements2 } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements2];
        } else if (elements2.length > 1) {
          return [...result, ...elements2.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { elements: [element] } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ head, body }) {
      return new this(body, new HeadSnapshot(head));
    }
    constructor(element, headSnapshot) {
      super(element);
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index3, source2] of selectElements.entries()) {
        const clone4 = clonedSelectElements[index3];
        for (const option2 of clone4.selectedOptions)
          option2.selected = false;
        for (const option2 of source2.selectedOptions)
          clone4.options[option2.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(clonedElement, this.headSnapshot);
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      var _a;
      const root = (_a = this.getSetting("root")) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var TimingMetric;
  (function(TimingMetric2) {
    TimingMetric2["visitStart"] = "visitStart";
    TimingMetric2["requestStart"] = "requestStart";
    TimingMetric2["requestEnd"] = "requestEnd";
    TimingMetric2["visitEnd"] = "visitEnd";
  })(TimingMetric || (TimingMetric = {}));
  var VisitState;
  (function(VisitState2) {
    VisitState2["initialized"] = "initialized";
    VisitState2["started"] = "started";
    VisitState2["canceled"] = "canceled";
    VisitState2["failed"] = "failed";
    VisitState2["completed"] = "completed";
  })(VisitState || (VisitState = {}));
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var SystemStatusCode;
  (function(SystemStatusCode2) {
    SystemStatusCode2[SystemStatusCode2["networkFailure"] = 0] = "networkFailure";
    SystemStatusCode2[SystemStatusCode2["timeoutFailure"] = -1] = "timeoutFailure";
    SystemStatusCode2[SystemStatusCode2["contentTypeMismatch"] = -2] = "contentTypeMismatch";
  })(SystemStatusCode || (SystemStatusCode = {}));
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.identifier = uuid();
      this.timingMetrics = {};
      this.followedRedirect = false;
      this.historyChanged = false;
      this.scrolled = false;
      this.shouldCacheSnapshot = true;
      this.acceptsStreamResponse = false;
      this.snapshotCached = false;
      this.state = VisitState.initialized;
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const { action, historyChanged, referrer, snapshot, snapshotHTML, response, visitCachedSnapshot, willRender, updateHistory, shouldCacheSnapshot, acceptsStreamResponse } = Object.assign(Object.assign({}, defaultOptions), options);
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.adapter.visitCompleted(this);
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
      }
    }
    changeHistory() {
      var _a;
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot)
            this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender, this);
            this.performScroll();
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.view.renderPage(snapshot, isPreview, this.willRender, this);
            this.performScroll();
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      var _a;
      if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return Object.assign({}, this.timingMetrics);
    }
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback2) {
      this.cancelRender();
      await new Promise((resolve2) => {
        this.frame = requestAnimationFrame(() => resolve2());
      });
      await callback2();
      delete this.frame;
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      this.progressBar = new ProgressBar();
      this.showProgressBar = () => {
        this.progressBar.show();
      };
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      this.navigator.startVisit(location2, (options === null || options === void 0 ? void 0 : options.restorationIdentifier) || uuid(), options);
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitCompleted(_visit) {
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
    }
    visitRendered(_visit) {
    }
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload(reason) {
      var _a;
      dispatch("turbo:reload", { detail: reason });
      window.location.href = ((_a = this.location) === null || _a === void 0 ? void 0 : _a.toString()) || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      this.selector = "[data-turbo-temporary]";
      this.deprecatedSelector = "[data-turbo-cache=false]";
      this.started = false;
      this.removeTemporaryElements = (_event) => {
        for (const element of this.temporaryElements) {
          element.remove();
        }
      };
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements2 = document.querySelectorAll(this.deprecatedSelector);
      if (elements2.length) {
        console.warn(`The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`);
      }
      return [...elements2];
    }
  };
  var FrameRedirector = class {
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    shouldInterceptLinkClick(element, _location, _event) {
      return this.shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = this.findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == null && this.shouldSubmit(element, submitter) && this.shouldRedirect(element, submitter);
    }
    formSubmitted(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter);
      }
    }
    shouldSubmit(form, submitter) {
      var _a;
      const action = getAction(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/");
      return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    shouldRedirect(element, submitter) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame = this.findFrameElement(element, submitter);
        return frame ? frame != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    findFrameElement(element, submitter) {
      const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    constructor(delegate) {
      this.restorationIdentifier = uuid();
      this.restorationData = {};
      this.started = false;
      this.pageLoaded = false;
      this.onPopState = (event) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
          }
        }
      };
      this.onPageLoad = async (_event) => {
        await nextMicrotask();
        this.pageLoaded = true;
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      const state = { turbo: { restorationIdentifier } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
    }
    assumeControlOfScrollRestoration() {
      var _a;
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        if (locationIsVisitable(location2, this.view.snapshot.rootLocation)) {
          this.delegate.visitProposedToLocation(location2, options);
        } else {
          window.location.href = location2.toString();
        }
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({ referrer: this.location }, options));
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.getActionForFormSubmission(formSubmission);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        this.view.scrollToTop();
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error3) {
      console.error(error3);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    getActionForFormSubmission({ submitter, formElement }) {
      return getVisitAction(submitter, formElement) || "advance";
    }
  };
  var PageStage;
  (function(PageStage2) {
    PageStage2[PageStage2["initial"] = 0] = "initial";
    PageStage2[PageStage2["loading"] = 1] = "loading";
    PageStage2[PageStage2["interactive"] = 2] = "interactive";
    PageStage2[PageStage2["complete"] = 3] = "complete";
  })(PageStage || (PageStage = {}));
  var PageObserver = class {
    constructor(delegate) {
      this.stage = PageStage.initial;
      this.started = false;
      this.interpretReadyState = () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      };
      this.pageWillUnload = () => {
        this.delegate.pageWillUnload();
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      this.started = false;
      this.onScroll = () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => document.documentElement.appendChild(fragment));
    }
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
        if (elementInStream) {
          permanentElementMap[id] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  var StreamObserver = class {
    constructor(delegate) {
      this.sources = /* @__PURE__ */ new Set();
      this.started = false;
      this.inspectFetchResponse = (event) => {
        const response = fetchResponseFromEvent(event);
        if (response && fetchResponseIsStream(response)) {
          event.preventDefault();
          this.receiveMessageResponse(response);
        }
      };
      this.receiveMessageEvent = (event) => {
        if (this.started && typeof event.data == "string") {
          this.receiveMessageHTML(event.data);
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source2) {
      if (!this.streamSourceIsConnected(source2)) {
        this.sources.add(source2);
        source2.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source2) {
      if (this.streamSourceIsConnected(source2)) {
        this.sources.delete(source2);
        source2.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source2) {
      return this.sources.has(source2);
    }
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    var _a;
    const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    var _a;
    const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode2 = replaceableElement.parentNode;
        if (parentNode2) {
          const element = activateScriptElement(replaceableElement);
          parentNode2.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var PageRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index3, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index3, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index3, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var SnapshotCache = class {
    constructor(size) {
      this.keys = [];
      this.snapshots = {};
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index3 = this.keys.indexOf(key);
      if (index3 > -1)
        this.keys.splice(index3, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      this.snapshotCache = new SnapshotCache(10);
      this.lastRenderedLocation = new URL(location.href);
      this.forceReloaded = false;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const renderer = new PageRenderer(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2 === null || visit2 === void 0 ? void 0 : visit2.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2 === null || visit2 === void 0 ? void 0 : visit2.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    constructor(delegate) {
      this.selector = "a[data-turbo-preload]";
      this.delegate = delegate;
    }
    get snapshotCache() {
      return this.delegate.navigator.view.snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        return document.addEventListener("DOMContentLoaded", () => {
          this.preloadOnLoadLinksForView(document.body);
        });
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        this.preloadURL(link);
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      try {
        const response = await fetch(location2.toString(), { headers: { "VND.PREFETCH": "true", Accept: "text/html" } });
        const responseText = await response.text();
        const snapshot = PageSnapshot.fromHTMLString(responseText);
        this.snapshotCache.put(location2, snapshot);
      } catch (_) {
      }
    }
  };
  var Session = class {
    constructor() {
      this.navigator = new Navigator(this);
      this.history = new History(this);
      this.preloader = new Preloader(this);
      this.view = new PageView(this, document.documentElement);
      this.adapter = new BrowserAdapter(this);
      this.pageObserver = new PageObserver(this);
      this.cacheObserver = new CacheObserver();
      this.linkClickObserver = new LinkClickObserver(this, window);
      this.formSubmitObserver = new FormSubmitObserver(this, document);
      this.scrollObserver = new ScrollObserver(this);
      this.streamObserver = new StreamObserver(this);
      this.formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
      this.frameRedirector = new FrameRedirector(this, document.documentElement);
      this.streamMessageRenderer = new StreamMessageRenderer();
      this.drive = true;
      this.enabled = true;
      this.progressBarDelay = 500;
      this.started = false;
      this.formMode = "on";
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        frameElement.src = location2.toString();
        frameElement.loaded;
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    connectStreamSource(source2) {
      this.streamObserver.connectStreamSource(source2);
    }
    disconnectStreamSource(source2) {
      this.streamObserver.disconnectStreamSource(source2);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    setFormMode(mode) {
      this.formMode = mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    historyPoppedToLocationWithRestorationIdentifier(location2, restorationIdentifier) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    willSubmitForm(form, submitter) {
      const action = getAction(form, submitter);
      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    viewWillCacheSnapshot() {
      var _a;
      if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const { defaultPrevented, detail: { render: render2 } } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender();
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: Object.assign({ newBody }, options),
        cancelable: true
      });
    }
    notifyApplicationAfterRender() {
      return dispatch("turbo:render");
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(new HashChangeEvent("hashchange", {
        oldURL: oldURL.toString(),
        newURL: newURL.toString()
      }));
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    submissionIsNavigatable(form, submitter) {
      if (this.formMode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
        if (this.formMode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (this.drive || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var Cache = class {
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.setCacheControl("");
    }
    exemptPageFromCache() {
      this.setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.setCacheControl("no-preview");
    }
    setCacheControl(value) {
      setMetaContent("turbo-cache-control", value);
    }
  };
  var StreamActions = {
    after() {
      this.targetElements.forEach((e) => {
        var _a;
        return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e.nextSibling);
      });
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e) => {
        var _a;
        return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e);
      });
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e) => e.remove());
    },
    replace() {
      this.targetElements.forEach((e) => e.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((targetElement) => {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      });
    }
  };
  var session = new Session();
  var cache = new Cache(session);
  var { navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source2) {
    session.connectStreamSource(source2);
  }
  function disconnectStreamSource(source2) {
    session.disconnectStreamSource(source2);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn("Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  function setFormMode(mode) {
    session.setFormMode(mode);
  }
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode,
    StreamActions
  });
  var TurboFrameMissingError = class extends Error {
  };
  var FrameController = class {
    constructor(element) {
      this.fetchResponseLoaded = (_fetchResponse) => {
      };
      this.currentFetchRequest = null;
      this.resolveVisitPromise = () => {
      };
      this.connected = false;
      this.hasBeenLoaded = false;
      this.ignoredAttributes = /* @__PURE__ */ new Set();
      this.action = null;
      this.visitCachedSnapshot = ({ element: element2 }) => {
        const frame = element2.querySelector("#" + this.element.id);
        if (frame && this.previousFrameElement) {
          frame.replaceChildren(...this.previousFrameElement.children);
        }
        delete this.previousFrameElement;
      };
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    connect() {
      if (!this.connected) {
        this.connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.connected) {
        this.connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.isIgnoringChangesTo("src"))
        return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
        this.loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { src } = this.element;
      this.ignoringChangesToAttribute("complete", () => {
        this.element.removeAttribute("complete");
      });
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    completeChanged() {
      if (this.isIgnoringChangesTo("complete"))
        return;
      this.loadSourceURL();
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.loadSourceURL();
      }
    }
    async loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.loadFrameResponse(fetchResponse, document2);
          } else {
            await this.handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.fetchResponseLoaded = () => {
        };
      }
    }
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, element);
      this.loadSourceURL();
    }
    willSubmitFormLinkToLocation(link) {
      return this.shouldInterceptNavigation(link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = this.findFrameElement(link);
      if (frame)
        form.setAttribute("data-turbo-frame", frame.id);
    }
    shouldInterceptLinkClick(element, _location, _event) {
      return this.shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.navigateFrame(element, location2);
    }
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == this.element && this.shouldInterceptNavigation(element, submitter);
    }
    formSubmitted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    prepareRequest(request) {
      var _a;
      request.headers["Turbo-Frame"] = this.id;
      if ((_a = this.currentNavigationElement) === null || _a === void 0 ? void 0 : _a.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    requestErrored(request, error3) {
      console.error(error3);
      this.resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error3) {
      console.error(error3);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.findFrameElement(formElement));
    }
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: Object.assign({ newFrame }, options),
        cancelable: true
      });
      const { defaultPrevented, detail: { render: render2 } } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    async loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
        if (this.view.renderPromise)
          await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        this.fetchResponseLoaded(fetchResponse);
      } else if (this.willHandleFrameMissingFromResponse(fetchResponse)) {
        this.handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async visit(url) {
      var _a;
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
      this.currentFetchRequest = request;
      return new Promise((resolve2) => {
        this.resolveVisitPromise = () => {
          this.resolveVisitPromise = () => {
          };
          this.currentFetchRequest = null;
          resolve2();
        };
        request.perform();
      });
    }
    navigateFrame(element, url, submitter) {
      const frame = this.findFrameElement(element, submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, element, submitter);
      this.withCurrentNavigationElement(element, () => {
        frame.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame, element, submitter) {
      this.action = getVisitAction(submitter, element, frame);
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = frame.ownerDocument.documentElement.outerHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action)
              options.action = this.action;
            session.visit(frame.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(`The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`);
      await this.visitResponse(fetchResponse.response);
    }
    willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = async (url, options = {}) => {
        if (url instanceof Response) {
          this.visitResponse(url);
        } else {
          session.visit(url, options);
        }
      };
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.throwFrameMissingError(fetchResponse);
    }
    throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    findFrameElement(element, submitter) {
      var _a;
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error3) {
        console.error(error3);
        return new FrameElement();
      }
      return null;
    }
    formActionIsVisitable(form, submitter) {
      const action = getAction(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter && !session.elementIsNavigatable(submitter)) {
        return false;
      }
      return true;
    }
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      this.ignoringChangesToAttribute("complete", () => {
        if (value) {
          this.element.setAttribute("complete", "");
        } else {
          this.element.removeAttribute("complete");
        }
      });
    }
    get isActive() {
      return this.element.isActive && this.connected;
    }
    get rootLocation() {
      var _a;
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    isIgnoringChangesTo(attributeName) {
      return this.ignoredAttributes.has(attributeName);
    }
    ignoringChangesToAttribute(attributeName, callback2) {
      this.ignoredAttributes.add(attributeName);
      callback2();
      this.ignoredAttributes.delete(attributeName);
    }
    withCurrentNavigationElement(element, callback2) {
      this.currentNavigationElement = element;
      callback2();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamElement = class _StreamElement extends HTMLElement {
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error3) {
        console.error(error3);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      var _a;
      return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : this.renderPromise = (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextAnimationFrame();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch (_a) {
      }
    }
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c) => c.remove());
    }
    get duplicateChildren() {
      var _a;
      const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.id);
      const newChildrenIds = [...((_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children) || []].filter((c) => !!c.id).map((c) => c.id);
      return existingChildren.filter((c) => newChildrenIds.includes(c.id));
    }
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.raise("unknown action");
      }
      this.raise("action attribute is missing");
    }
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.raise("target or targets attribute is missing");
      }
    }
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.raise("first child element must be a <template> element");
    }
    get action() {
      return this.getAttribute("action");
    }
    get target() {
      return this.getAttribute("target");
    }
    get targets() {
      return this.getAttribute("targets");
    }
    raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      var _a, _b;
      return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      var _a;
      const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      var _a;
      const elements2 = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
      if (elements2.length !== 0) {
        return Array.prototype.slice.call(elements2);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.streamSource = null;
    }
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = Turbo;
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object")
      return obj;
    if (obj instanceof Date || obj instanceof RegExp)
      return obj;
    if (Array.isArray(obj))
      return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m, x) {
        return "_" + x.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter, body, form) {
    const formMethod = determineFormMethod(submitter);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter) {
    if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
      if (submitter.hasAttribute("formmethod")) {
        return submitter.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map4) => listeners.concat(Array.from(map4.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error3, message, detail = {}) {
      this.application.handleError(error3, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value }) {
      if (value)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value }) {
      if (value)
        event.preventDefault();
      return true;
    },
    self({ event, value, element }) {
      if (value) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source2 = descriptorString.trim();
    const matches3 = source2.match(descriptorPattern) || [];
    let eventName = matches3[2];
    let keyFilter = matches3[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches3[4]),
      eventName,
      eventOptions: matches3[7] ? parseEventOptions(matches3[7]) : {},
      identifier: matches3[5],
      methodName: matches3[6],
      keyFilter: matches3[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index3, descriptor, schema) {
      this.element = element;
      this.index = index3;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name, value } of Array.from(this.element.attributes)) {
        const match = name.match(pattern);
        const key = match && match[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift2] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift2;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name, value] of Object.entries(this.eventOptions)) {
        if (name in actionDescriptorFilters) {
          const filter = actionDescriptorFilters[name];
          passes = passes && filter({ name, value, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error3) {
        const { identifier, controller, element, index: index3 } = this;
        const detail = { identifier, controller, element, index: index3, event };
        this.context.handleError(error3, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback2) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback2();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches3 = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches3.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches3)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback2) {
      this.elementObserver.pause(callback2);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches3 = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches3);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map4, key, value) {
    fetch2(map4, key).add(value);
  }
  function del(map4, key, value) {
    fetch2(map4, key).delete(value);
    prune(map4, key);
  }
  function fetch2(map4, key) {
    let values = map4.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map4.set(key, values);
    }
    return values;
  }
  function prune(map4, key) {
    const values = map4.get(key);
    if (values != null && values.size == 0) {
      map4.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set2) => values.concat(Array.from(set2)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set2) => size + set2.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set2) => set2.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback2) {
      this.elementObserver.pause(callback2);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches3 = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches3 && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches3;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches3 = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
        return match.concat(matches3);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches3 = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches3 && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches3 && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback2) {
      this.attributeObserver.pause(callback2);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index3) => ({ element, attributeName, content, index: index3 }));
  }
  function zip(left2, right2) {
    const length = Math.max(left2.length, right2.length);
    return Array.from({ length }, (_, index3) => [left2[index3], right2[index3]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error3) {
        return { error: error3 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error3) {
          if (error3 instanceof TypeError) {
            error3.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error3.message}`;
          }
          throw error3;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors2 = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors2[descriptor.name] = descriptor;
      });
      return descriptors2;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error3) {
        this.handleError(error3, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error3) {
        this.handleError(error3, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error3) {
        this.handleError(error3, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error3, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error3, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a = function() {
        this.a.call(this);
      };
      const b = extendWithReflect(a);
      b.prototype.a = function() {
      };
      return new b();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error3) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements2 = this.scope.queryElements(selector);
      return elements2.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements2 = this.scope.queryElements(selector);
      return elements2.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error3, message, detail) {
      this.application.handleError(error3, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
      this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error3, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error3, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error3);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve2) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve2());
      } else {
        resolve2();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read2, writer: write2 } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write2(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token}` : token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value.replace(/_/g, ""));
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // node_modules/bali-view-components/app/javascript/bali/utils/form.js
  var autoFocusInput = (element) => {
    const autofocusNode = element.querySelector("[autofocus]");
    if (autofocusNode)
      autofocusNode.focus();
  };

  // node_modules/@kurkle/color/dist/color.esm.js
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l, h) => Math.max(Math.min(v, h), l);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b) => hex[b & 15];
  var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
  var eq = (b) => (b & 240) >> 4 === (b & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a, f) => a < 255 ? f(a) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h, w, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i;
    if (w + b > 1) {
      i = 1 / (w + b);
      w *= i;
      b *= i;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] *= 1 - w - b;
      rgb[i] += w;
    }
    return rgb;
  }
  function hueValue(r, g, b, d, max2) {
    if (r === max2) {
      return (g - b) / d + (g < b ? 6 : 0);
    }
    if (g === max2) {
      return (b - r) / d + 2;
    }
    return (r - g) / d + 4;
  }
  function rgb2hsl(v) {
    const range = 255;
    const r = v.r / range;
    const g = v.g / range;
    const b = v.b / range;
    const max2 = Math.max(r, g, b);
    const min2 = Math.min(r, g, b);
    const l = (max2 + min2) / 2;
    let h, s, d;
    if (max2 !== min2) {
      d = max2 - min2;
      s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
      h = hueValue(r, g, b, d, max2);
      h = h * 60 + 0.5;
    }
    return [h | 0, s || 0, l];
  }
  function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
  }
  function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
  }
  function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
  }
  function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
  }
  function hue(h) {
    return (h % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") {
      v = hwb2rgb(h, p1, p2);
    } else if (m[1] === "hsv") {
      v = hsv2rgb(h, p1, p2);
    } else {
      v = hsl2rgb(h, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a
    };
  }
  function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys2 = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i, j, k, ok, nk;
    for (i = 0; i < keys2.length; i++) {
      ok = nk = keys2[i];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m) {
      return;
    }
    if (m[7] !== r) {
      const v = +m[7];
      a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r,
      g,
      b,
      a
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate2(rgb1, rgb2, t) {
    const r = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
      r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
      g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
      a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class _Color {
    constructor(input) {
      if (input instanceof _Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === "object") {
        v = fromObject(input);
      } else if (type === "string") {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = c1.a - c2.a;
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t) {
      if (color2) {
        this._rgb = interpolate2(this._rgb, color2._rgb, t);
      }
      return this;
    }
    clone() {
      return new _Color(this.rgb);
    }
    alpha(a) {
      this._rgb.a = n2b(a);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // node_modules/chart.js/dist/chunks/helpers.segment.js
  function noop() {
  }
  var uid = /* @__PURE__ */ (() => {
    let id = 0;
    return () => id++;
  })();
  function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn2, args, thisArg) {
    if (fn2 && typeof fn2.call === "function") {
      return fn2.apply(thisArg, args);
    }
  }
  function each(loopable, fn2, thisArg, reverse) {
    let i, len, keys2;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i = len - 1; i >= 0; i--) {
          fn2.call(thisArg, loopable[i], i);
        }
      } else {
        for (i = 0; i < len; i++) {
          fn2.call(thisArg, loopable[i], i);
        }
      }
    } else if (isObject(loopable)) {
      keys2 = Object.keys(loopable);
      len = keys2.length;
      for (i = 0; i < len; i++) {
        fn2.call(thisArg, loopable[keys2[i]], keys2[i]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i = 0, ilen = a0.length; i < ilen; ++i) {
      v0 = a0[i];
      v1 = a1[i];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone2(source2) {
    if (isArray(source2)) {
      return source2.map(clone2);
    }
    if (isObject(source2)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys2 = Object.keys(source2);
      const klen = keys2.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys2[k]] = clone2(source2[keys2[k]]);
      }
      return target;
    }
    return source2;
  }
  function isValidKey(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source2, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source2[key];
    if (isObject(tval) && isObject(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone2(sval);
    }
  }
  function merge(target, source2, options) {
    const sources = isArray(source2) ? source2 : [
      source2
    ];
    const ilen = sources.length;
    if (!isObject(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for (let i = 0; i < ilen; ++i) {
      current = sources[i];
      if (!isObject(current)) {
        continue;
      }
      const keys2 = Object.keys(current);
      for (let k = 0, klen = keys2.length; k < klen; ++k) {
        merger(keys2[k], target, current, options);
      }
    }
    return target;
  }
  function mergeIf(target, source2) {
    return merge(target, source2, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source2) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source2[key];
    if (isObject(tval) && isObject(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone2(sval);
    }
  }
  var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v) => v,
    // default resolvers
    x: (o) => o.x,
    y: (o) => o.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys2 = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys2.push(tmp);
        tmp = "";
      }
    }
    return keys2;
  }
  function _getKeyResolver(key) {
    const keys2 = _splitKey(key);
    return (obj) => {
      for (const k of keys2) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction = (value) => typeof value === "function";
  var setsEqual = (a, b) => {
    if (a.size !== b.size) {
      return false;
    }
    for (const item of a) {
      if (!b.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
  }
  function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for (i = 1; i < sqrt; i++) {
      if (value % i === 0) {
        result.push(i);
        result.push(value / i);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a, b) => a - b).pop();
    return result;
  }
  function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for (i = 0, ilen = array.length; i < ilen; i++) {
      value = array[i][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
      return;
    }
    let e = 1;
    let p = 0;
    while (Math.round(x * e) / e !== x) {
      e *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start3, end2, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start3);
    const e = _normalizeAngle(end2);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min2, max2) {
    return Math.max(min2, Math.min(max2, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start3, end2, epsilon = 1e-6) {
    return value >= Math.min(start3, end2) - epsilon && value <= Math.max(start3, end2) + epsilon;
  }
  function _lookup(table, value, cmp2) {
    cmp2 = cmp2 || ((index3) => table[index3] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp2(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index3) => {
    const ti = table[index3][key];
    return ti < value || ti === value && table[index3 + 1][key] === value;
  } : (index3) => table[index3][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index3) => table[index3][key] >= value);
  function _filterBetween(values, min2, max2) {
    let start3 = 0;
    let end2 = values.length;
    while (start3 < end2 && values[start3] < min2) {
      start3++;
    }
    while (end2 > start3 && values[end2 - 1] > max2) {
      end2--;
    }
    return start3 > 0 || end2 < values.length ? values.slice(start3, end2) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base2 = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base2.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index3 = listeners.indexOf(listener);
    if (index3 !== -1) {
      listeners.splice(index3, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = new Set(items);
    if (set2.size === items.length) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn2, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn2.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce(fn2, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn2, delay, args);
      } else {
        fn2.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start3, end2) => align === "start" ? start3 : align === "end" ? end2 : (start3 + end2) / 2;
  var _textX = (align, left2, right2, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right2 : align === "center" ? (left2 + right2) / 2 : left2;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start3 = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, _parsed } = meta;
      const axis = iScale.axis;
      const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start3 = _limitValue(Math.min(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, axis, min2).lo,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min2)).lo
        ), 0, pointCount - 1);
      }
      if (maxDefined) {
        count = _limitValue(Math.max(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1
        ), start3, pointCount) - start3;
      } else {
        count = pointCount - start3;
      }
    }
    return {
      start: start3,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t) => t === 0 || t === 1;
  var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
  var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
  var effects = {
    linear: (t) => t,
    easeInQuad: (t) => t * t,
    easeOutQuad: (t) => -t * (t - 2),
    easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t) => t * t * t,
    easeOutCubic: (t) => (t -= 1) * t * t + 1,
    easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t) => t * t * t * t,
    easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t) => t * t * t * t * t,
    easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t) => Math.sin(t * HALF_PI),
    easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic(t) {
      const s = 0.1125;
      const p = 0.45;
      return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack(t) {
      const s = 1.70158;
      return t * t * ((s + 1) * t - s);
    },
    easeOutBack(t) {
      const s = 1.70158;
      return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack(t) {
      let s = 1.70158;
      if ((t /= 0.5) < 1) {
        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
      }
      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
    easeOutBounce(t) {
      const m = 7.5625;
      const d = 2.75;
      if (t < 1 / d) {
        return m * t * t;
      }
      if (t < 2 / d) {
        return m * (t -= 1.5 / d) * t + 0.75;
      }
      if (t < 2.5 / d) {
        return m * (t -= 2.25 / d) * t + 0.9375;
      }
      return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults4) {
    defaults4.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults4.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults4.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults4.describe("animations", {
      _fallback: "animation"
    });
    defaults4.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults4) {
    defaults4.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter2 = intlCache.get(cacheKey);
    if (!formatter2) {
      formatter2 = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter2);
    }
    return formatter2;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index3, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index3, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index3].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index3 > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index3, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults4) {
    defaults4.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults4.route("scale.ticks", "color", "", "color");
    defaults4.route("scale.grid", "color", "", "borderColor");
    defaults4.route("scale.border", "color", "", "borderColor");
    defaults4.route("scale.title", "color", "", "color");
    defaults4.describe("scale", {
      _fallback: false,
      _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
      _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults4.describe("scales", {
      _fallback: "scale"
    });
    defaults4.describe("scale.ticks", {
      _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
      _indexable: (name) => name !== "backdropPadding"
    });
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys2 = key.split(".");
    for (let i = 0, n = keys2.length; i < n; ++i) {
      const k = keys2[i];
      node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply2) => apply2(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache2) {
    cache2 = cache2 || {};
    let data = cache2.data = cache2.data || {};
    let gc = cache2.garbageCollect = cache2.garbageCollect || [];
    if (cache2.font !== font) {
      data = cache2.data = {};
      gc = cache2.garbageCollect = [];
      cache2.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for (i = 0; i < ilen; i++) {
      thing = arrayOfThings[i];
      if (thing !== void 0 && thing !== null && !isArray(thing)) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i = 0; i < gcLen; i++) {
        delete data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x, y) {
    drawPointLegend(ctx, options, x, y, null);
  }
  function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style2 = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style2 && typeof style2 === "object") {
      type = style2.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rad);
        ctx.drawImage(style2, -style2.width / 2, -style2.height / 2, style2.width, style2.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style2) {
      default:
        if (w) {
          ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x, y, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w ? w / 2 : radius;
        ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w ? w / 2 : size;
          ctx.rect(x - width, y - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "line":
        xOffset = w ? w / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        break;
      case "dash":
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip2, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip2) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip2) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip2 ? previous.cp1x : previous.cp2x, flip2 ? previous.cp1y : previous.cp2y, flip2 ? target.cp2x : target.cp1x, flip2 ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left2 = x - metrics.actualBoundingBoxLeft;
      const right2 = x + metrics.actualBoundingBoxRight;
      const top2 = y - metrics.actualBoundingBoxAscent;
      const bottom2 = y + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left2, yDecoration);
      ctx.lineTo(right2, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
      text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i = 0; i < lines.length; ++i) {
      line = lines[i];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x, y, opts.maxWidth);
      }
      ctx.fillText(line, x, y, opts.maxWidth);
      decorateText(ctx, x, y, line, opts);
      y += Number(font.lineHeight);
    }
    ctx.restore();
  }
  function addRoundedRectPath(ctx, rect) {
    const { x, y, w, h, radius } = rect;
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    ctx.lineTo(x, y + h - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y + radius.topRight);
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size) {
    const matches3 = ("" + value).match(LINE_HEIGHT);
    if (!matches3 || matches3[1] === "normal") {
      return size * 1.2;
    }
    value = +matches3[2];
    switch (matches3[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys2 = objProps ? Object.keys(props) : props;
    const read2 = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys2) {
      ret[prop] = numberOrZero(read2(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style2 = valueOrDefault(options.style, fallback.style);
    if (style2 && !("" + style2).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style2 + '"');
      style2 = void 0;
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style: style2,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index3, info) {
    let cacheable = true;
    let i, ilen, value;
    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
      value = inputs[i];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index3 !== void 0 && isArray(value)) {
        value = value[index3 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min: min2, max: max2 } = minmax;
    const change = toDimension(grace, (max2 - min2) / 2);
    const keepZero = (value, add2) => beginAtZero && value === 0 ? 0 : value + add2;
    return {
      min: keepZero(min2, -Math.abs(change)),
      max: keepZero(max2, change)
    };
  }
  function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes, fallback, getTarget = () => scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
      fallback = _resolve("_fallback", scopes);
    }
    const cache2 = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: finalRootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([
        scope,
        ...scopes
      ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache2, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache2 = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache2, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults4 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults4.scriptable, _indexable = defaults4.indexable, _allKeys = defaults4.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
      return value[_context.index % value.length];
    } else if (isObject(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s) => s !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set2), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
      value = _resolve(readKey(prefix, prop), scopes);
      if (typeof value !== "undefined") {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (typeof value !== "undefined") {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys2 = target._keys;
    if (!keys2) {
      keys2 = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys2;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start3, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index3, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index3 = i + start3;
      item = data[index3];
      parsed[i] = {
        r: iScale.parse(resolveObjectKey(item, key), index3)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01;
    const fb = t * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen - 1; ++i) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i], 0, EPSILON)) {
        mK[i] = mK[i + 1] = 0;
        continue;
      }
      alphaK = mK[i] / deltaK[i];
      betaK = mK[i + 1] / deltaK[i];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i] = alphaK * tauK * deltaK[i];
      mK[i + 1] = betaK * tauK * deltaK[i];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min2, max2) {
    return Math.max(Math.min(pt, max2), min2);
  }
  function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        point = points[i];
        controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles, style2, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i = 0; i < 4; i++) {
      const pos = positions[i];
      result[pos] = parseFloat(styles[style2 + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source2 = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source2;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
      x = offsetX;
      y = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x = source2.clientX - rect.left;
      y = source2.clientY - rect.top;
      box = true;
    }
    return {
      x,
      y,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style2 = getComputedStyle2(canvas);
    const borderBox = style2.boxSizing === "border-box";
    const paddings = getPositionedStyle(style2, "padding");
    const borders = getPositionedStyle(style2, "border", "width");
    const { x, y, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style2 = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style2, "margin");
    const maxWidth = parseMaxStyle(style2.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style2.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style2.boxSizing === "content-box") {
      const borders = getPositionedStyle(style2, "border", "width");
      const paddings = getPositionedStyle(style2, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      if (_isDomSupported()) {
        window.addEventListener("test", null, options);
        window.removeEventListener("test", null, options);
      }
    } catch (e) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches3 = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches3 ? +matches3[1] : void 0;
  }
  function _pointInLine(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: p1.y + t * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x) {
        return rectX + rectX + width - x;
      },
      setWidth(w) {
        width = w;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x, value) {
        return x - value;
      },
      leftForLtr(x, itemWidth) {
        return x - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x) {
        return x;
      },
      setWidth(w) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x, value) {
        return x + value;
      },
      leftForLtr(x, _itemWidth) {
        return x;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style2, original;
    if (direction === "ltr" || direction === "rtl") {
      style2 = ctx.canvas.style;
      original = [
        style2.getPropertyValue("direction"),
        style2.getPropertyPriority("direction")
      ];
      style2.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a, b) => a - b,
      normalize: (x) => x
    };
  }
  function normalizeSegment({ start: start3, end: end2, count, loop, style: style2 }) {
    return {
      start: start3 % count,
      end: end2 % count,
      loop: loop && (end2 - start3 + 1) % count === 0,
      style: style2
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize: normalize2 } = propertyFn(property);
    const count = points.length;
    let { start: start3, end: end2, loop } = segment;
    let i, ilen;
    if (loop) {
      start3 += count;
      end2 += count;
      for (i = 0, ilen = count; i < ilen; ++i) {
        if (!between(normalize2(points[start3 % count][property]), startBound, endBound)) {
          break;
        }
        start3--;
        end2--;
      }
      start3 %= count;
      end2 %= count;
    }
    if (end2 < start3) {
      end2 += count;
    }
    return {
      start: start3,
      end: end2,
      loop,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize: normalize2 } = propertyFn(property);
    const { start: start3, end: end2, loop, style: style2 } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i = start3, prev = start3; i <= end2; ++i) {
      point = points[i % count];
      if (point.skip) {
        continue;
      }
      value = normalize2(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i,
          loop,
          count,
          style: style2
        }));
        subStart = null;
      }
      prev = i;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end: end2,
        loop,
        count,
        style: style2
      }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i = 0; i < segments.length; i++) {
      const sub = _boundSegment(segments[i], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start3 = 0;
    let end2 = count - 1;
    if (loop && !spanGaps) {
      while (start3 < count && !points[start3].skip) {
        start3++;
      }
    }
    while (start3 < count && points[start3].skip) {
      start3++;
    }
    start3 %= count;
    if (loop) {
      end2 += start3;
    }
    while (end2 > start3 && points[end2 % count].skip) {
      end2--;
    }
    end2 %= count;
    return {
      start: start3,
      end: end2
    };
  }
  function solidSegments(points, start3, max2, loop) {
    const count = points.length;
    const result = [];
    let last = start3;
    let prev = points[start3];
    let end2;
    for (end2 = start3 + 1; end2 <= max2; ++end2) {
      const cur = points[end2 % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({
            start: start3 % count,
            end: (end2 - 1) % count,
            loop
          });
          start3 = last = cur.stop ? end2 : null;
        }
      } else {
        last = end2;
        if (prev.skip) {
          start3 = end2;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({
        start: start3 % count,
        end: last % count,
        loop
      });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start: start3, end: end2 } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [
        {
          start: start3,
          end: end2,
          loop
        }
      ], points, segmentOptions);
    }
    const max2 = end2 < start3 ? end2 + count : end2;
    const completeLoop = !!line._fullLoop && start3 === 0 && end2 === count - 1;
    return splitByStyles(line, solidSegments(points, start3, max2, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start3 = segments[0].start;
    let i = start3;
    function addStyle(s, e, l, st) {
      const dir = spanGaps ? -1 : 1;
      if (s === e) {
        return;
      }
      s += count;
      while (points[s % count].skip) {
        s -= dir;
      }
      while (points[e % count].skip) {
        e += dir;
      }
      if (s % count !== e % count) {
        result.push({
          start: s % count,
          end: e % count,
          loop: l,
          style: st
        });
        prevStyle = st;
        start3 = e % count;
      }
    }
    for (const segment of segments) {
      start3 = spanGaps ? start3 : segment.start;
      let prev = points[start3 % count];
      let style2;
      for (i = start3 + 1; i <= segment.end; i++) {
        const pt = points[i % count];
        style2 = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i - 1) % count,
          p1DataIndex: i % count,
          datasetIndex
        })));
        if (styleChanged(style2, prevStyle)) {
          addStyle(start3, i - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style2;
      }
      if (start3 < i - 1) {
        addStyle(start3, i - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style2, prevStyle) {
    if (!prevStyle) {
      return false;
    }
    const cache2 = [];
    const replacer = function(key, value) {
      if (!isPatternOrGradient(value)) {
        return value;
      }
      if (!cache2.includes(value)) {
        cache2.push(value);
      }
      return cache2.indexOf(value);
    };
    return JSON.stringify(style2, replacer) !== JSON.stringify(prevStyle, replacer);
  }

  // node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn2) => fn2({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        let draw2 = false;
        let item;
        for (; i >= 0; --i) {
          item = items[i];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      for (; i >= 0; --i) {
        items[i].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from3, to2, factor) {
      return factor > 0.5 ? to2 : from3;
    },
    color(from3, to2, factor) {
      const c0 = color(from3 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from3, to2, factor) {
      return from3 + (to2 - from3) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from3 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from3];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from3;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from3 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from3 !== to2 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from3;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from3, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i = 0; i < promises.length; i++) {
        promises[i][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject(config)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject(cfg)) {
          return;
        }
        const resolved = {};
        for (const option2 of animationOptions) {
          resolved[option2] = cfg[option2];
        }
        (isArray(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i;
      for (i = props.length - 1; i >= 0; --i) {
        const prop = props[i];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys2 = Object.keys(properties);
    for (let i = 0; i < keys2.length; i++) {
      const anim = animations[keys2[i]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
      });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min2 = opts.min === void 0 ? allowedOverflow : 0;
    const max2 = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max2 : min2,
      end: reverse ? min2 : max2
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
      top: y.end,
      right: x.end,
      bottom: y.start,
      left: x.start
    };
  }
  function toClip(value) {
    let t, r, b, l;
    if (isObject(value)) {
      t = value.top;
      r = value.right;
      b = value.bottom;
      l = value.left;
    } else {
      t = r = b = l = value;
    }
    return {
      top: t,
      right: r,
      bottom: b,
      left: l,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys2 = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      keys2.push(metasets[i].index);
    }
    return keys2;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys2 = stack.keys;
    const singleMode = options.mode === "single";
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    for (i = 0, ilen = keys2.length; i < ilen; ++i) {
      datasetIndex = +keys2[i];
      if (datasetIndex === dsIndex) {
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    return value;
  }
  function convertObjectDataToArray(data) {
    const keys2 = Object.keys(data);
    const adata = new Array(keys2.length);
    let i, ilen, key;
    for (i = 0, ilen = keys2.length; i < ilen; ++i) {
      key = keys2[i];
      adata[i] = {
        x: key,
        y: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min: min2, max: max2, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min2 : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max2 : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i = 0; i < ilen; ++i) {
      const item = parsed[i];
      const { [iAxis]: index3, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index3);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index3) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index3,
      index: index3,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index3, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index3,
      parsed: void 0,
      raw: void 0,
      element,
      index: index3,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    static defaults = {};
    static datasetElementType = null;
    static dataElementType = null;
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject(data)) {
        this._data = convertObjectDataToArray(data);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start3, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start3 === 0 && count === data.length ? true : meta._sorted;
      let prev = start3 > 0 && meta._parsed[start3 - 1];
      let i, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray(data[start3])) {
          parsed = this.parseArrayData(meta, data, start3, count);
        } else if (isObject(data[start3])) {
          parsed = this.parseObjectData(meta, data, start3, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start3, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i = 0; i < count; ++i) {
          meta._parsed[i + start3] = cur = parsed[i];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start3, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i, ilen, index3;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start3;
        parsed[i] = {
          [iAxis]: singleScale || iScale.parse(labels[index3], index3),
          [vAxis]: vScale.parse(data[index3], index3)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start3, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i, ilen, index3, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start3;
        item = data[index3];
        parsed[i] = {
          x: xScale.parse(item[0], index3),
          y: yScale.parse(item[1], index3)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start3, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i, ilen, index3, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start3;
        item = data[index3];
        parsed[i] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index3),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index3)
        };
      }
      return parsed;
    }
    getParsed(index3) {
      return this._cachedMeta._parsed[index3];
    }
    getDataElement(index3) {
      return this._cachedMeta.data[index3];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range.min = Math.min(range.min, value);
      range.max = Math.max(range.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i, parsed;
      function _skip() {
        parsed = _parsed[i];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i = 0; i < ilen; ++i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i = ilen - 1; i >= 0; --i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range, scale, parsed, stack);
          break;
        }
      }
      return range;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i, ilen, value;
      for (i = 0, ilen = parsed.length; i < ilen; ++i) {
        value = parsed[i][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index3);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start3 = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start3;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start3, count);
      }
      for (i = start3; i < start3 + count; ++i) {
        const element = elements2[i];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i = 0; i < active.length; ++i) {
        active[i].draw(ctx, area);
      }
    }
    getStyle(index3, active) {
      const mode = active ? "active" : "default";
      return index3 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index3 || 0, mode);
    }
    getContext(index3, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index3 >= 0 && index3 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index3];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index3, element));
        context.parsed = this.getParsed(index3);
        context.raw = dataset.data[index3];
        context.index = context.dataIndex = index3;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index3, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index3);
    }
    _resolveElementOptions(elementType2, mode = "default", index3) {
      const active = mode === "active";
      const cache2 = this._cachedDataOpts;
      const cacheKey = elementType2 + "-" + mode;
      const cached = cache2[cacheKey];
      const sharing = this.enableOptionSharing && defined(index3);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType2);
      const prefixes = active ? [
        `${elementType2}Hover`,
        "hover",
        elementType2,
        ""
      ] : [
        elementType2,
        ""
      ];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType2]);
      const context = () => this.getContext(index3, active, mode);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache2[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index3, transition, active) {
      const chart = this.chart;
      const cache2 = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache2[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index3, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache2[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start3, mode) {
      const firstOpts = this.resolveDataElementOptions(start3, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index3, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index3, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index3, mode, active) {
      element.active = active;
      const options = this.getStyle(index3, active);
      this._resolveAnimations(index3, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index3) {
      this._setStyle(element, index3, "active", false);
    }
    setHoverStyle(element, datasetIndex, index3) {
      this._setStyle(element, index3, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start3, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end2 = start3 + count;
      let i;
      const move = (arr) => {
        arr.length += count;
        for (i = arr.length - 1; i >= end2; i--) {
          arr[i] = arr[i - count];
        }
      };
      move(data);
      for (i = start3; i < end2; ++i) {
        data[i] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start3, count);
      if (resetNewElements) {
        this.updateElements(data, start3, count, "reset");
      }
    }
    updateElements(element, start3, count, mode) {
    }
    _removeElements(start3, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start3, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start3, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start3, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start3,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start3,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
        values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min2 = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min2 = Math.min(min2, Math.abs(curr - prev) || min2);
      }
      prev = curr;
    };
    for (i = 0, ilen = values.length; i < ilen; ++i) {
      curr = scale.getPixelForValue(values[i]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
      curr = scale.getPixelForTick(i);
      updateMinAndPrev();
    }
    return min2;
  }
  function computeFitCategoryTraits(index3, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index3] - size / 2
    };
  }
  function computeFlexCategoryTraits(index3, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index3];
    let prev = index3 > 0 ? pixels[index3 - 1] : null;
    let next = index3 < pixels.length - 1 ? pixels[index3 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start3 = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start: start3
    };
  }
  function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min2 = Math.min(startValue, endValue);
    const max2 = Math.max(startValue, endValue);
    let barStart = min2;
    let barEnd = max2;
    if (Math.abs(min2) > Math.abs(max2)) {
      barStart = max2;
      barEnd = min2;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min: min2,
      max: max2
    };
  }
  function parseValue(entry, item, vScale, i) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i);
    } else {
      item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start3, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for (i = start3, ilen = start3 + count; i < ilen; ++i) {
      entry = data[i];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
      parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start3, end2, top2, bottom2;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start3 = "left";
      end2 = "right";
    } else {
      reverse = properties.base < properties.y;
      start3 = "bottom";
      end2 = "top";
    }
    if (reverse) {
      top2 = "end";
      bottom2 = "start";
    } else {
      top2 = "start";
      bottom2 = "end";
    }
    return {
      start: start3,
      end: end2,
      reverse,
      top: top2,
      bottom: bottom2
    };
  }
  function setBorderSkipped(properties, options, stack, index3) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start: start3, end: end2, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index3) {
        edge = top2;
      } else if ((stack._bottom || 0) === index3) {
        edge = bottom2;
      } else {
        res[parseEdge(bottom2, start3, end2, reverse)] = true;
        edge = top2;
      }
    }
    res[parseEdge(edge, start3, end2, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
    if (reverse) {
      edge = swap(edge, a, b);
      edge = startEnd(edge, b, a);
    } else {
      edge = startEnd(edge, a, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start3, end2) {
    return v === "start" ? start3 : v === "end" ? end2 : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    static id = "bar";
    static defaults = {
      datasetElementType: false,
      dataElementType: "bar",
      categoryPercentage: 0.8,
      barPercentage: 0.9,
      grouped: true,
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "base",
            "width",
            "height"
          ]
        }
      }
    };
    static overrides = {
      scales: {
        _index_: {
          type: "category",
          offset: true,
          grid: {
            offset: true
          }
        },
        _value_: {
          type: "linear",
          beginAtZero: true
        }
      }
    };
    parsePrimitiveData(meta, data, start3, count) {
      return parseArrayOrPrimitive(meta, data, start3, count);
    }
    parseArrayData(meta, data, start3, count) {
      return parseArrayOrPrimitive(meta, data, start3, count);
    }
    parseObjectData(meta, data, start3, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i, ilen, item, obj;
      for (i = start3, ilen = start3 + count; i < ilen; ++i) {
        obj = data[i];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
      }
      return parsed;
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
      super.updateRangeFromParsed(range, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range.min = Math.min(range.min, custom.min);
        range.max = Math.max(range.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index3);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start3, count, mode) {
      const reset2 = mode === "reset";
      const { index: index3, _cachedMeta: { vScale } } = this;
      const base2 = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      for (let i = start3; i < start3 + count; i++) {
        const parsed = this.getParsed(i);
        const vpixels = reset2 || isNullOrUndef(parsed[vScale.axis]) ? {
          base: base2,
          head: base2
        } : this._calculateBarValuePixels(i);
        const ipixels = this._calculateBarIndexPixels(i, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index3 === stack._top || index3 === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
        }
        const options = properties.options || bars[i].options;
        setBorderSkipped(properties, options, stack, index3);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i], i, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const skipNull = (meta) => {
        const parsed = meta.controller.getParsed(dataIndex);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index3) {
      return this._getStacks(void 0, index3).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index3 = name !== void 0 ? stacks.indexOf(name) : -1;
      return index3 === -1 ? stacks.length - 1 : index3;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i, ilen;
      for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
      }
      const barThickness = opts.barThickness;
      const min2 = barThickness || computeMinSampleSize(meta);
      return {
        min: min2,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index3) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index3);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start3 = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start3 = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start3 = 0;
        }
        start3 += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start3;
      let base2 = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index3)) {
        head = vScale.getPixelForValue(start3 + length);
      } else {
        head = base2;
      }
      size = head - base2;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base2 -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min2 = Math.min(startPixel, endPixel);
        const max2 = Math.max(startPixel, endPixel);
        base2 = Math.max(Math.min(base2, max2), min2);
        head = base2 + size;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base2);
        }
      }
      if (base2 === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base2 += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base: base2,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index3, ruler) {
      const scale = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index3) : ruler.stackCount;
        const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index3, ruler, options, stackCount) : computeFitCategoryTraits(index3, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index3 : void 0);
        center = range.start + range.chunk * stackIndex + range.chunk / 2;
        size = Math.min(maxBarThickness, range.chunk * range.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index3)[scale.axis], index3);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i = 0;
      for (; i < ilen; ++i) {
        if (this.getParsed(i)[vScale.axis] !== null) {
          rects[i].draw(this._ctx);
        }
      }
    }
  };
  var BubbleController = class extends DatasetController {
    static id = "bubble";
    static defaults = {
      datasetElementType: false,
      dataElementType: "point",
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "borderWidth",
            "radius"
          ]
        }
      }
    };
    static overrides = {
      scales: {
        x: {
          type: "linear"
        },
        y: {
          type: "linear"
        }
      }
    };
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start3, count) {
      const parsed = super.parsePrimitiveData(meta, data, start3, count);
      for (let i = 0; i < parsed.length; i++) {
        parsed[i]._custom = this.resolveDataElementOptions(i + start3).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start3, count) {
      const parsed = super.parseArrayData(meta, data, start3, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start3 + i];
        parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start3).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start3, count) {
      const parsed = super.parseObjectData(meta, data, start3, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start3 + i];
        parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start3).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max2 = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max2 = Math.max(max2, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max2 > 0 && max2;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index3);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      const r = parsed._custom;
      return {
        label: labels[index3] || "",
        value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start3, count, mode) {
      const reset2 = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i = start3; i < start3 + count; i++) {
        const point = points[i];
        const parsed = !reset2 && this.getParsed(i);
        const properties = {};
        const iPixel = properties[iAxis] = reset2 ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset2 ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
          if (reset2) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i, properties, mode);
      }
    }
    resolveDataElementOptions(index3, mode) {
      const parsed = this.getParsed(index3);
      let values = super.resolveDataElementOptions(index3, mode);
      if (values.$shared) {
        values = Object.assign({}, values, {
          $shared: false
        });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
      const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    };
  }
  var DoughnutController = class extends DatasetController {
    static id = "doughnut";
    static defaults = {
      datasetElementType: false,
      dataElementType: "arc",
      animation: {
        animateRotate: true,
        animateScale: false
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "circumference",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "startAngle",
            "x",
            "y",
            "offset",
            "borderWidth",
            "spacing"
          ]
        }
      },
      cutout: "50%",
      rotation: 0,
      circumference: 360,
      radius: "100%",
      spacing: 0,
      indexAxis: "r"
    };
    static descriptors = {
      _scriptable: (name) => name !== "spacing",
      _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
    };
    static overrides = {
      aspectRatio: 1,
      plugins: {
        legend: {
          labels: {
            generateLabels(chart) {
              const data = chart.data;
              if (data.labels.length && data.datasets.length) {
                const { labels: { pointStyle, color: color2 } } = chart.legend.options;
                return data.labels.map((label, i) => {
                  const meta = chart.getDatasetMeta(0);
                  const style2 = meta.controller.getStyle(i);
                  return {
                    text: label,
                    fillStyle: style2.backgroundColor,
                    strokeStyle: style2.borderColor,
                    fontColor: color2,
                    lineWidth: style2.borderWidth,
                    pointStyle,
                    hidden: !chart.getDataVisibility(i),
                    index: i
                  };
                });
              }
              return [];
            }
          },
          onClick(e, legendItem, legend) {
            legend.chart.toggleDataVisibility(legendItem.index);
            legend.chart.update();
          }
        }
      }
    };
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start3, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i2) => +data[i2];
        if (isObject(data[start3])) {
          const { key = "value" } = this._parsing;
          getter = (i2) => +resolveObjectKey(data[i2], key);
        }
        let i, ilen;
        for (i = start3, ilen = start3 + count; i < ilen; ++i) {
          meta._parsed[i] = getter(i);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min2 = TAU;
      let max2 = -TAU;
      for (let i = 0; i < this.chart.data.datasets.length; ++i) {
        if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
          const controller = this.chart.getDatasetMeta(i).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min2 = Math.min(min2, rotation);
          max2 = Math.max(max2, rotation + circumference);
        }
      }
      return {
        rotation: min2,
        circumference: max2 - min2
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i, reset2) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset2 && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
    }
    updateElements(arcs, start3, count, mode) {
      const reset2 = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset2 && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      let startAngle = this._getRotation();
      let i;
      for (i = 0; i < start3; ++i) {
        startAngle += this._circumference(i, reset2);
      }
      for (i = start3; i < start3 + count; ++i) {
        const circumference = this._circumference(i, reset2);
        const arc = arcs[i];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i;
      for (i = 0; i < metaData.length; i++) {
        const value = meta._parsed[i];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index3], chart.options.locale);
      return {
        label: labels[index3] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max2 = 0;
      const chart = this.chart;
      let i, ilen, meta, controller, options;
      if (!arcs) {
        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        options = controller.resolveDataElementOptions(i);
        if (options.borderAlign !== "inner") {
          max2 = Math.max(max2, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max2;
    }
    getMaxOffset(arcs) {
      let max2 = 0;
      for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
        const options = this.resolveDataElementOptions(i);
        max2 = Math.max(max2, options.offset || 0, options.hoverOffset || 0);
      }
      return max2;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i = 0; i < datasetIndex; ++i) {
        if (this.chart.isDatasetVisible(i)) {
          ringWeightOffset += this._getRingWeight(i);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  var LineController = class extends DatasetController {
    static id = "line";
    static defaults = {
      datasetElementType: "line",
      dataElementType: "point",
      showLine: true,
      spanGaps: false
    };
    static overrides = {
      scales: {
        _index_: {
          type: "category"
        },
        _value_: {
          type: "linear"
        }
      }
    };
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start3, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start3;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start3 = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start3, count, mode);
    }
    updateElements(points, start3, count, mode) {
      const reset2 = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
      const end2 = start3 + count;
      const pointsCount = points.length;
      let prevParsed = start3 > 0 && this.getParsed(start3 - 1);
      for (let i = 0; i < pointsCount; ++i) {
        const point = points[i];
        const properties = directUpdate ? point : {};
        if (i < start3 || i >= end2) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  var PolarAreaController = class extends DatasetController {
    static id = "polarArea";
    static defaults = {
      dataElementType: "arc",
      animation: {
        animateRotate: true,
        animateScale: true
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius"
          ]
        }
      },
      indexAxis: "r",
      startAngle: 0
    };
    static overrides = {
      aspectRatio: 1,
      plugins: {
        legend: {
          labels: {
            generateLabels(chart) {
              const data = chart.data;
              if (data.labels.length && data.datasets.length) {
                const { labels: { pointStyle, color: color2 } } = chart.legend.options;
                return data.labels.map((label, i) => {
                  const meta = chart.getDatasetMeta(0);
                  const style2 = meta.controller.getStyle(i);
                  return {
                    text: label,
                    fillStyle: style2.backgroundColor,
                    strokeStyle: style2.borderColor,
                    fontColor: color2,
                    lineWidth: style2.borderWidth,
                    pointStyle,
                    hidden: !chart.getDataVisibility(i),
                    index: i
                  };
                });
              }
              return [];
            }
          },
          onClick(e, legendItem, legend) {
            legend.chart.toggleDataVisibility(legendItem.index);
            legend.chart.update();
          }
        }
      },
      scales: {
        r: {
          type: "radialLinear",
          angleLines: {
            display: false
          },
          beginAtZero: true,
          grid: {
            circular: true
          },
          pointLabels: {
            display: false
          },
          startAngle: 0
        }
      }
    };
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index3].r, chart.options.locale);
      return {
        label: labels[index3] || "",
        value
      };
    }
    parseObjectData(meta, data, start3, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start3, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      meta.data.forEach((element, index3) => {
        const parsed = this.getParsed(index3).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index3)) {
          if (parsed < range.min) {
            range.min = parsed;
          }
          if (parsed > range.max) {
            range.max = parsed;
          }
        }
      });
      return range;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start3, count, mode) {
      const reset2 = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i = 0; i < start3; ++i) {
        angle += this._computeAngle(i, mode, defaultAngle);
      }
      for (i = start3; i < start3 + count; i++) {
        const arc = arcs[i];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
        angle = endAngle;
        if (reset2) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index3) => {
        if (!isNaN(this.getParsed(index3).r) && this.chart.getDataVisibility(index3)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index3, mode, defaultAngle) {
      return this.chart.getDataVisibility(index3) ? toRadians(this.resolveDataElementOptions(index3, mode).angle || defaultAngle) : 0;
    }
  };
  var PieController = class extends DoughnutController {
    static id = "pie";
    static defaults = {
      cutout: 0,
      rotation: 0,
      circumference: 360,
      radius: "100%"
    };
  };
  var RadarController = class extends DatasetController {
    static id = "radar";
    static defaults = {
      datasetElementType: "line",
      dataElementType: "point",
      indexAxis: "r",
      showLine: true,
      elements: {
        line: {
          fill: "start"
        }
      }
    };
    static overrides = {
      aspectRatio: 1,
      scales: {
        r: {
          type: "radialLinear"
        }
      }
    };
    getLabelAndValue(index3) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index3);
      return {
        label: vScale.getLabels()[index3],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start3, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start3, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start3, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset2 = mode === "reset";
      for (let i = start3; i < start3 + count; i++) {
        const point = points[i];
        const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
        const x = reset2 ? scale.xCenter : pointPosition.x;
        const y = reset2 ? scale.yCenter : pointPosition.y;
        const properties = {
          x,
          y,
          angle: pointPosition.angle,
          skip: isNaN(x) || isNaN(y),
          options
        };
        this.updateElement(point, i, properties, mode);
      }
    }
  };
  var ScatterController = class extends DatasetController {
    static id = "scatter";
    static defaults = {
      datasetElementType: false,
      dataElementType: "point",
      showLine: false,
      fill: false
    };
    static overrides = {
      interaction: {
        mode: "point"
      },
      scales: {
        x: {
          type: "linear"
        },
        y: {
          type: "linear"
        }
      }
    };
    getLabelAndValue(index3) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index3);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      return {
        label: labels[index3] || "",
        value: "(" + x + ", " + y + ")"
      };
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start3, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start3;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start3 = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        if (!this.datasetElementType) {
          this.addElements();
        }
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      } else if (this.datasetElementType) {
        delete meta.dataset;
        this.datasetElementType = false;
      }
      this.updateElements(points, start3, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = this.chart.registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start3, count, mode) {
      const reset2 = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start3, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
      let prevParsed = start3 > 0 && this.getParsed(start3 - 1);
      for (let i = start3; i < start3 + count; ++i) {
        const point = points[i];
        const parsed = this.getParsed(i);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max2 = 0;
        for (let i = data.length - 1; i >= 0; --i) {
          max2 = Math.max(max2, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max2 > 0 && max2;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PieController,
    PolarAreaController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class _DateAdapterBase {
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(members) {
      Object.assign(_DateAdapterBase.prototype, members);
    }
    options;
    constructor(options) {
      this.options = options || {};
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value);
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range = typeof el.getRange === "function" && el.getRange(axis);
        if (range) {
          const start3 = lookupMethod(data, axis, value - range);
          const end2 = lookupMethod(data, axis, value + range);
          return {
            lo: start3.lo,
            hi: end2.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
      const { index: index3, data } = metasets[i];
      const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data[j];
        if (!element.skip) {
          handler(element, index3, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index3) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index3
        });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index3) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position.x,
        y: position.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index: index3
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index3) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index: index3
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index: index3
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index3) => {
      if (element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index3
        });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index3 = items[0].index;
          const element = meta.data[index3];
          if (element && !element.skip) {
            elements2.push({
              element,
              datasetIndex: meta.index,
              index: index3
            });
          }
        });
        return elements2;
      },
      dataset(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i = 0; i < data.length; ++i) {
            items.push({
              element: data[i],
              datasetIndex,
              index: i
            });
          }
        }
        return items;
      },
      point(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a, b) => {
      const v0 = reverse ? b : a;
      const v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
      box = boxes[i];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap2 of layouts2) {
      const { stack, pos, stackWeight } = wrap2;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i, ilen, layout;
    for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
      layout = layouts2[i];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap2) => wrap2.box.fullSize), true);
    const left2 = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right2 = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left2.concat(top2),
      rightAndBottom: right2.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left2.concat(right2).concat(centerVertical),
      horizontal: top2.concat(bottom2).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
      layout = boxes[i];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left2, top2, width, height) {
    box.top = top2;
    box.left = left2;
    box.right = left2 + width;
    box.bottom = top2 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y, width, height);
        }
        stack.start = y;
        stack.placed += width;
        y = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x, chartArea.top + stack.placed, width, height);
        }
        stack.start = x;
        stack.placed += height;
        x = box.right;
      }
    }
    chartArea.x = x;
    chartArea.y = y;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index3 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index3 !== -1) {
        chart.boxes.splice(index3, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap2) => wrap2.box.options && wrap2.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style2 = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style2.display,
          height: style2.height,
          width: style2.width
        }
      }
    };
    style2.display = style2.display || "block";
    style2.boxSizing = style2.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
  function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x, y } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x !== void 0 ? x : null,
      y: y !== void 0 ? y : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w = container.clientWidth;
      listener(width, height);
      if (w < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style2 = initial.style || {};
      Object.keys(style2).forEach((key) => {
        canvas.style[key] = style2[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers2 = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers2[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers2 = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers2[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element2 = class {
    static defaults = {};
    static defaultRoutes = void 0;
    x;
    y;
    active = false;
    options;
    $animations;
    tooltipPosition(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first2 = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first2) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first2 - avgMajorSpacing, first2);
      for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
        skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset2 = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
      const factor = factors[i];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (ticks[i].major) {
        result.push(i);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for (i = 0; i < ticks.length; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start3 = valueOrDefault(majorStart, 0);
    const end2 = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start3;
    while (next < 0) {
      count++;
      next = Math.round(start3 + count * spacing);
    }
    for (i = Math.max(start3, 0); i < end2; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = Math.round(start3 + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i = 1; i < len; ++i) {
      if (arr[i] - arr[i - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for (; i < len; i += increment) {
      result.push(arr[Math.floor(i)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index3, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index3, length - 1);
    const start3 = scale._startPixel;
    const end2 = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset2;
    if (offsetGridLines) {
      if (length === 1) {
        offset2 = Math.max(lineValue - start3, end2 - lineValue);
      } else if (index3 === 0) {
        offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset2 = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index3 ? offset2 : -offset2;
      if (lineValue < start3 - epsilon || lineValue > end2 + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache2) => {
      const gc = cache2.gc;
      const gcLen = gc.length / 2;
      let i;
      if (gcLen > length) {
        for (i = 0; i < gcLen; ++i) {
          delete cache2.data[gc[i]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index3, tick) {
    return createContext(parent, {
      tick,
      index: index3,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset2, position, align) {
    const { top: top2, left: left2, bottom: bottom2, right: right2, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom2 - top2;
    const width = right2 - left2;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left2, right2);
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset2;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
      } else {
        titleY = offsetFromEdge(scale, position, offset2);
      }
      maxWidth = right2 - left2;
    } else {
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset2;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
      } else {
        titleX = offsetFromEdge(scale, position, offset2);
      }
      titleY = _alignStartEnd(align, bottom2, top2);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class _Scale extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index3) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
      let range;
      if (minDefined && maxDefined) {
        return {
          min: min2,
          max: max2
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i = 0, ilen = metas.length; i < ilen; ++i) {
        range = metas[i].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min2 = Math.min(min2, range.min);
        }
        if (!maxDefined) {
          max2 = Math.max(max2, range.max);
        }
      }
      min2 = maxDefined && min2 > max2 ? max2 : min2;
      max2 = minDefined && min2 > max2 ? min2 : max2;
      return {
        min: finiteOrDefault(min2, finiteOrDefault(max2, min2)),
        max: finiteOrDefault(max2, finiteOrDefault(min2, max2))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        tick = ticks[i];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first: first2, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first2, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first2, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first2.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first2.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first2.width;
        } else if (align !== "inner") {
          paddingLeft = first2.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first2.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first2.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (isNullOrUndef(ticks[i].label)) {
          ticks.splice(i, 1);
          ilen--;
          i--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i, j, jlen, label, tickFont, fontString, cache2, lineHeight, width, height, nestedLabel;
      for (i = 0; i < length; i += increment) {
        label = ticks[i].label;
        tickFont = this._resolveTickFontOptions(i);
        ctx.font = fontString = tickFont.string;
        cache2 = caches[fontString] = caches[fontString] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache2.data, cache2.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache2.data, cache2.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index3) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index3) {
      const ticks = this.ticks;
      if (index3 < 0 || index3 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index3].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min: min2, max: max2 } = this;
      return min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
    }
    getContext(index3) {
      const ticks = this.ticks || [];
      if (index3 >= 0 && index3 < ticks.length) {
        const tick = ticks[index3];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index3, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w = labelSizes ? labelSizes.widest.width + padding : 0;
      const h = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position, border } = options;
      const offset2 = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset2 ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y2 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i = 0; i < ticksLength; i += step) {
        const context = this.getContext(i);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i, offset2);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i));
        pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x = pixel;
          if (textAlign === "inner") {
            if (i === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i];
          const width = labelSizes.widths[i];
          let top2 = textOffset - labelPadding.top;
          let left2 = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top2 -= height / 2;
              break;
            case "bottom":
              top2 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left2 -= width / 2;
              break;
            case "right":
              left2 -= width;
              break;
            case "inner":
              if (i === ilen - 1) {
                left2 -= width;
              } else if (i > 0) {
                left2 -= width / 2;
              }
              break;
          }
          backdrop = {
            left: left2,
            top: top2,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x,
              y
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x;
      if (position === "left") {
        if (mirror) {
          x = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x += widest;
          }
        } else {
          x = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x -= widest;
          }
        } else {
          x = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position === "top" || position === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left: left2, top: top2, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left2, top2, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index3 = ticks.findIndex((t) => t.value === value);
      if (index3 >= 0) {
        const opts = grid.setContext(this.getContext(index3));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i, ilen;
      const drawLine = (p1, p2, style2) => {
        if (!style2.width || !style2.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style2.width;
        ctx.strokeStyle = style2.color;
        ctx.setLineDash(style2.borderDash || []);
        ctx.lineDashOffset = style2.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          const item = items[i];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y2;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y2 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y = item.textOffset;
        renderText(ctx, label, 0, y, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset2 = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject(position)) {
        offset2 += padding.bottom;
        if (isArray(title.text)) {
          offset2 += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset2 += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        const meta = metas[i];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index3) {
      const opts = this.options.ticks.setContext(this.getContext(index3));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i = 0; i < this._typedRegistries.length; i++) {
        const reg = this._typedRegistries[i];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins3 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins3, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins3 = [];
    const keys2 = Object.keys(registry.plugins.items);
    for (let i = 0; i < keys2.length; i++) {
      plugins3.push(registry.getPlugin(keys2[i]));
    }
    const local = config.plugins || [];
    for (let i = 0; i < local.length; i++) {
      const plugin = local[i];
      if (plugins3.indexOf(plugin) === -1) {
        plugins3.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return {
      plugins: plugins3,
      localIds
    };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins3, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins3) {
      const id = plugin.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, {
          plugin,
          local: localIds[id]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context) {
    const keys2 = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys2);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") {
      return id;
    }
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
      return id;
    }
    for (const opts of scaleOptions) {
      const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
      if (axis) {
        return axis;
      }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) {
      return {
        axis
      };
    }
  }
  function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
      const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
      if (boundDs.length) {
        return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
      }
    }
    return {};
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
      scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || axis;
        scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id], [
          {
            axis
          },
          configScales[id],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [
        defaults.scales[scale.type],
        defaults.scale
      ]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys2 = keyCache.get(cacheKey);
    if (!keys2) {
      keys2 = generate();
      keyCache.set(cacheKey, keys2);
      keysCached.add(keys2);
    }
    return keys2;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType2) {
      return cachedKeys(`${datasetType}-${elementType2}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType2}`,
          `datasets.${datasetType}`,
          `elements.${elementType2}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id}`, () => [
        [
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache2 = _scopeCache.get(mainScope);
      if (!cache2 || resetCache) {
        cache2 = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache2);
      }
      return cache2;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache2 = this._cachedScopes(mainScope, resetCache);
      const cached = cache2.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys2) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys2.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys2.forEach((key) => addIfFound(scopes, options, key));
        keys2.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys2.forEach((key) => addIfFound(scopes, defaults, key));
        keys2.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache2.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache2 = resolverCache.get(scopes);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache2);
    }
    const cacheKey = prefixes.join();
    let cached = cache2.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache2.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "4.4.1";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c) => c.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start3, move) {
    const keys2 = Object.keys(obj);
    for (const key of keys2) {
      const intKey = +key;
      if (intKey >= start3) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start3) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e;
  }
  function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
  }
  function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
      };
    }
    return chartArea;
  }
  var Chart = class {
    static defaults = defaults;
    static instances = instances;
    static overrides = overrides;
    static registry = registry;
    static version = version;
    static getChart = getChart;
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a, b) => a.index - b.index);
      if (numMeta > numData) {
        for (let i = numData; i < numMeta; ++i) {
          this._destroyDatasetMeta(i);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index3) => {
        if (datasets.filter((x) => x === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index3);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i, ilen;
      this._removeUnreferencedMetasets();
      for (i = 0, ilen = datasets.length; i < ilen; i++) {
        const dataset = datasets[i];
        let meta = this.getDatasetMeta(i);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i);
          meta = this.getDatasetMeta(i);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i);
        if (meta.controller) {
          meta.controller.updateIndex(i);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
        const { controller } = this.getDatasetMeta(i);
        const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset2);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start: start3, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start3, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i = 1; i < datasetCount; i++) {
        if (!setsEqual(changeSet, makeSet(i))) {
          return;
        }
      }
      return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
        method: a[1],
        start: +a[2],
        count: +a[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index3) => {
        item._idx = index3;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this.getDatasetMeta(i).controller.configure();
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._updateDataset(i, isFunction(mode) ? mode({
          datasetIndex: i
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index3, mode) {
      const meta = this.getDatasetMeta(index3);
      const args = {
        meta,
        index: index3,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resize(width, height);
        this._resizeBeforeDraw = null;
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
        layers[i].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i < layers.length; ++i) {
        layers[i].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        const meta = metasets[i];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        this._drawDataset(metasets[i]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = getDatasetArea(meta, this.chartArea);
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index3) {
      this._hiddenIndices[index3] = !this._hiddenIndices[index3];
    }
    getDataVisibility(index3) {
      return !this._hiddenIndices[index3];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i, ilen;
      this.stop();
      animator.remove(this);
      for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._destroyDatasetMeta(i);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e, x, y) => {
        e.offsetX = x;
        e.offsetY = y;
        this._eventHandler(e);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix = enabled ? "set" : "remove";
      let meta, item, i, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix + "DatasetHoverStyle"]();
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index3 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index3],
          index: index3
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e, replay) {
      const args = {
        event: e,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e);
      const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [
          e,
          active,
          this
        ], this);
        if (isClick) {
          callback(options.onClick, [
            e,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  function invalidatePlugins() {
    return each(Chart.instances, (chart) => chart._plugins.invalidate());
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o.outerStart),
      outerEnd: computeOuterLimit(o.outerEnd),
      innerStart: _limitValue(o.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r, theta, x, y) {
    return {
      x: x + r * Math.cos(theta),
      y: y + r * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset2, spacing, end2, circular) {
    const { x, y, startAngle: start3, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset2 - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha3 = end2 - start3;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha3 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha3;
      spacingOffset = (alpha3 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha3 * outerRadius - offset2 / PI) / outerRadius;
    const angleOffset = (alpha3 - beta) / 2;
    const startAngle = start3 + angleOffset + spacingOffset;
    const endAngle = end2 - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
      ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
      ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
      ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x, y);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset2, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawBorder(ctx, element, offset2, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.stroke();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    if (!fullCircles) {
      pathArc(ctx, element, offset2, spacing, endAngle, circular);
      ctx.stroke();
    }
  }
  var ArcElement = class extends Element2 {
    static id = "arc";
    static defaults = {
      borderAlign: "center",
      borderColor: "#fff",
      borderDash: [],
      borderDashOffset: 0,
      borderJoinStyle: void 0,
      borderRadius: 0,
      borderWidth: 2,
      offset: 0,
      spacing: 0,
      angle: void 0,
      circular: true
    };
    static defaultRoutes = {
      backgroundColor: "backgroundColor"
    };
    static descriptors = {
      _scriptable: true,
      _indexable: (name) => name !== "borderDash"
    };
    circumference;
    endAngle;
    fullCircles;
    innerRadius;
    outerRadius;
    pixelMargin;
    startAngle;
    constructor(cfg) {
      super();
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, {
        x: chartX,
        y: chartY
      });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], useFinalPosition);
      const { offset: offset2, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
      return {
        x: x + Math.cos(halfAngle) * halfRadius,
        y: y + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset2 = (options.offset || 0) / 4;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * offset2, Math.sin(halfAngle) * offset2);
      const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
      const radiusOffset = offset2 * fix;
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, circular);
      ctx.restore();
    }
  };
  function setStyle(ctx, options, style2 = options) {
    ctx.lineCap = valueOrDefault(style2.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style2.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style2.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style2.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style2.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style2.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start3 = Math.max(paramsStart, segmentStart);
    const end2 = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start: start3,
      loop: segment.loop,
      ilen: end2 < start3 && !outside ? count + end2 - start3 : end2 - start3
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start: start3, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i, point, prev;
    for (i = 0; i <= ilen; ++i) {
      point = points[(start3 + (reverse ? ilen - i : i)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start3 + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start: start3, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index3) => (start3 + (reverse ? ilen - index3 : index3)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i = 0; i <= ilen; ++i) {
      point = points[pointIndex(i)];
      if (point.skip) {
        continue;
      }
      const x = point.x;
      const y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
        } else if (y > maxY) {
          maxY = y;
        }
        avgX = (countX * avgX + x) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x, y);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
      }
      lastY = y;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start3, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start3, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start3, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, {
        start: start3,
        end: start3 + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start3, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start3, count);
    } else {
      strokePathDirect(ctx, line, start3, count);
    }
  }
  var LineElement = class extends Element2 {
    static id = "line";
    static defaults = {
      borderCapStyle: "butt",
      borderDash: [],
      borderDashOffset: 0,
      borderJoinStyle: "miter",
      borderWidth: 3,
      capBezierPoints: true,
      cubicInterpolationMode: "default",
      fill: false,
      spanGaps: false,
      stepped: false,
      tension: 0
    };
    static defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    static descriptors = {
      _scriptable: true,
      _indexable: (name) => name !== "borderDash" && name !== "fill"
    };
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i, ilen;
      for (i = 0, ilen = segments.length; i < ilen; ++i) {
        const { start: start3, end: end2 } = segments[i];
        const p1 = points[start3];
        const p2 = points[end2];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start3, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start3 = start3 || 0;
      count = count || this.points.length - start3;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, {
          start: start3,
          end: start3 + count - 1
        });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start3, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start3, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element2 {
    static id = "point";
    parsed;
    skip;
    stop;
    /**
    * @type {any}
    */
    static defaults = {
      borderWidth: 1,
      hitRadius: 1,
      hoverBorderWidth: 1,
      hoverRadius: 4,
      pointStyle: "circle",
      radius: 3,
      rotation: 0
    };
    /**
    * @type {any}
    */
    static defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    constructor(cfg) {
      super();
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  function getBarBounds(bar, useFinalPosition) {
    const { x, y, base: base2, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left2, right2, top2, bottom2, half;
    if (bar.horizontal) {
      half = height / 2;
      left2 = Math.min(x, base2);
      right2 = Math.max(x, base2);
      top2 = y - half;
      bottom2 = y + half;
    } else {
      half = width / 2;
      left2 = x - half;
      right2 = x + half;
      top2 = Math.min(y, base2);
      bottom2 = Math.max(y, base2);
    }
    return {
      left: left2,
      top: top2,
      right: right2,
      bottom: bottom2
    };
  }
  function skipOrLimit(skip2, value, min2, max2) {
    return skip2 ? 0 : _limitValue(value, min2, max2);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o.top, 0, maxH),
      r: skipOrLimit(skip2.right, o.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
      x: rect.x + x,
      y: rect.y + y,
      w: rect.w + w,
      h: rect.h + h,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    static id = "bar";
    static defaults = {
      borderSkipped: "start",
      borderWidth: 0,
      borderRadius: 0,
      inflateAmount: "auto",
      pointStyle: void 0
    };
    static defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, base: base2, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x + base2) / 2 : x,
        y: horizontal ? y : (y + base2) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    BarElement,
    LineElement,
    PointElement
  });
  var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
    // grey
  ];
  var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
  }
  function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
  }
  function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
    return i;
  }
  function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
    return i;
  }
  function getColorizer(chart) {
    let i = 0;
    return (dataset, datasetIndex) => {
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      if (controller instanceof DoughnutController) {
        i = colorizeDoughnutDataset(dataset, i);
      } else if (controller instanceof PolarAreaController) {
        i = colorizePolarAreaDataset(dataset, i);
      } else if (controller) {
        i = colorizeDefaultDataset(dataset, i);
      }
    };
  }
  function containsColorsDefinitions(descriptors2) {
    let k;
    for (k in descriptors2) {
      if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
        return true;
      }
    }
    return false;
  }
  function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  var plugin_colors = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(chart, _args, options) {
      if (!options.enabled) {
        return;
      }
      const { data: { datasets }, options: chartOptions } = chart.config;
      const { elements: elements2 } = chartOptions;
      if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
        return;
      }
      const colorizer = getColorizer(chart);
      datasets.forEach(colorizer);
    }
  };
  function lttbDecimation(data, start3, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start3, start3 + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start3 + count - 1;
    let a = start3;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for (i = 0; i < samples - 2; i++) {
      let avgX = 0;
      let avgY = 0;
      let j;
      const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start3;
      const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start3;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j = avgRangeStart; j < avgRangeEnd; j++) {
        avgX += data[j].x;
        avgY += data[j].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i * bucketWidth) + 1 + start3;
      const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start3;
      const { x: pointAx, y: pointAy } = data[a];
      maxArea = area = -1;
      for (j = rangeOffs; j < rangeTo; j++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j];
          nextA = j;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start3, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start3 + count - 1;
    const xMin = data[start3].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i = start3; i < start3 + count; ++i) {
      point = data[i];
      x = (point.x - xMin) / dx * availableWidth;
      y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
          minIndex = i;
        } else if (y > maxY) {
          maxY = y;
          maxIndex = i;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push({
              ...data[intermediateIndex1],
              x: avgX
            });
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push({
              ...data[intermediateIndex2],
              x: avgX
            });
          }
        }
        if (i > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
        minIndex = maxIndex = startIndex = i;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: data
      });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start3 = 0;
    let count;
    const { iScale } = meta;
    const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start3 = _limitValue(_lookupByKey(points, iScale.axis, min2).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max2).hi + 1, start3, pointCount) - start3;
    } else {
      count = pointCount - start3;
    }
    return {
      start: start3,
      count
    };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([
          indexAxis,
          chart.options.indexAxis
        ]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start: start3, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d) {
              this._data = d;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start3, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start3, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start: start3, end: end2 } = segment;
      end2 = _findSegmentEnd(start3, end2, points);
      const bounds = _getBounds(property, points[start3], points[end2], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start3],
          end: points[end2]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first2, last, loop) {
    if (loop) {
      return;
    }
    let start3 = first2[property];
    let end2 = last[property];
    if (property === "angle") {
      start3 = _normalizeAngle(start3);
      end2 = _normalizeAngle(end2);
    }
    return {
      property,
      start: start3,
      end: end2
    };
  }
  function _pointsFromSegments(boundary, line) {
    const { x = null, y = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start: start3, end: end2 }) => {
      end2 = _findSegmentEnd(start3, end2, linePoints);
      const first2 = linePoints[start3];
      const last = linePoints[end2];
      if (y !== null) {
        points.push({
          x: first2.x,
          y
        });
        points.push({
          x: last.x,
          y
        });
      } else if (x !== null) {
        points.push({
          x,
          y: first2.y
        });
        points.push({
          x,
          y: last.y
        });
      }
    });
    return points;
  }
  function _findSegmentEnd(start3, end2, points) {
    for (; end2 > start3; end2--) {
      const point = points[end2];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end2;
  }
  function _getEdge(a, b, prop, fn2) {
    if (a && b) {
      return fn2(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: {
        tension: 0
      },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source2) {
    return source2 && source2.fill !== false;
  }
  function _resolveTarget(sources, index3, propagate) {
    const source2 = sources[index3];
    let fill2 = source2.fill;
    const visited = [
      index3
    ];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index3, count) {
    const fill2 = parseFillOption(line);
    if (isObject(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index3, target, count);
    }
    return [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index3, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index3 + target;
    }
    if (target === index3 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source2) {
    const { scale, index: index3, line } = source2;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index3);
    linesBelow.push(_createBoundaryLine({
      x: null,
      y: scale.bottom
    }, line));
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      for (let j = segment.start; j <= segment.end; j++) {
        addPointsBelow(points, sourcePoints[j], linesBelow);
      }
    }
    return new LineElement({
      points,
      options: {}
    });
  }
  function getLinesBelow(scale, index3) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i = 0; i < metas.length; i++) {
      const meta = metas[i];
      if (meta.index === index3) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j = 0; j < linesBelow.length; j++) {
      const line = linesBelow[j];
      const { first: first2, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first2 && last) {
        continue;
      }
      if (first2) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first2 = false;
    let last = false;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first2 = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return {
      first: first2,
      last,
      point
    };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x, y, radius } = this;
      bounds = bounds || {
        start: 0,
        end: TAU
      };
      ctx.arc(x, y, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x, y, radius } = this;
      const angle = point.angle;
      return {
        x: x + Math.cos(angle) * radius,
        y: y + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source2) {
    const { chart, fill: fill2, line } = source2;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source2);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source2);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index3) {
    const meta = chart.getDatasetMeta(index3);
    const visible = meta && chart.isDatasetVisible(index3);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source2) {
    const scale = source2.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source2);
    }
    return computeLinearBoundary(source2);
  }
  function computeLinearBoundary(source2) {
    const { scale = {}, fill: fill2 } = source2;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source2) {
    const { scale, fill: fill2 } = source2;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start3 = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start3);
    const target = [];
    if (options.grid.circular) {
      const center = scale.getPointPositionForValue(0, start3);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i = 0; i < length; ++i) {
      target.push(scale.getPointPositionForValue(i, value));
    }
    return target;
  }
  function _drawfill(ctx, source2, area) {
    const target = _getTarget(source2);
    const { line, scale, axis } = source2;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, {
        line,
        target,
        above,
        below,
        area,
        scale,
        axis
      });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, {
        line,
        target,
        color: above,
        scale,
        property
      });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
      line,
      target,
      color: below,
      scale,
      property
    });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first2 = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start: start3, end: end2 } = segment;
      const firstPoint = points[start3];
      const lastPoint = points[_findSegmentEnd(start3, end2, points)];
      if (first2) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first2 = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start: start3, end: end2 } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, notShape && _getBounds(property, start3, end2));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end2, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, {
          move: lineLoop,
          reverse: true
        });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start3, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, bounds) {
    const { top: top2, bottom: bottom2 } = scale.chart.chartArea;
    const { property, start: start3, end: end2 } = bounds || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start3, top2, end2 - start3, bottom2 - top2);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i, line, source2;
      for (i = 0; i < count; ++i) {
        meta = chart.getDatasetMeta(i);
        line = meta.dataset;
        source2 = null;
        if (line && line.options && line instanceof LineElement) {
          source2 = {
            visible: chart.isDatasetVisible(i),
            index: i,
            fill: _decodeFill(line, i, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source2;
        sources.push(source2);
      }
      for (i = 0; i < count; ++i) {
        source2 = sources[i];
        if (!source2 || source2.fill === false) {
          continue;
        }
        source2.fill = _resolveTarget(sources, i, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source2 = metasets[i].$filler;
        if (!source2) {
          continue;
        }
        source2.line.updateControlPoints(area, source2.axis);
        if (draw2 && source2.fill) {
          _drawfill(chart.ctx, source2, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source2 = metasets[i].$filler;
        if (_shouldApplyFill(source2)) {
          _drawfill(chart.ctx, source2, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source2 = args.meta.$filler;
      if (!_shouldApplyFill(source2) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source2, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
  var Legend = class extends Element2 {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top2 = -lineHeight;
      this.legendItems.forEach((legendItem, i) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
          top2 += lineHeight;
          row++;
        }
        hitboxes[i] = {
          left: 0,
          top: top2,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth2 = 0;
      let currentColHeight = 0;
      let left2 = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth2 + padding;
          columnSizes.push({
            width: currentColWidth2,
            height: currentColHeight
          });
          left2 += currentColWidth2 + padding;
          col++;
          currentColWidth2 = currentColHeight = 0;
        }
        hitboxes[i] = {
          left: left2,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth2 = Math.max(currentColWidth2, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth2;
      columnSizes.push({
        width: currentColWidth2,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left2), hitbox.width);
          left2 += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top2;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top2 += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x, y, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x, boxWidth / 2);
          const centerY = y + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x, y, legendItem) {
        renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x = cursor.x;
        let y = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i > 0 && x + width + padding > this.right) {
            y = cursor.y += lineHeight;
            cursor.line++;
            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i > 0 && y + lineHeight > this.bottom) {
          x = cursor.x = x + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x);
        drawLegendBox(realX, y, legendItem);
        x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x), y, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y;
      let left2 = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y = this.top + topPaddingPlusHalfFontSize;
        left2 = _alignStartEnd(opts.align, left2, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x = _alignStartEnd(position, left2, left2 + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x, y, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y) {
      let i, hitBox, lh;
      if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i = 0; i < lh.length; ++i) {
          hitBox = lh[i];
          if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i];
          }
        }
      }
      return null;
    }
    handleEvent(e) {
      const opts = this.options;
      if (!isListened(e.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e, legendItem, legend) {
        const index3 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index3)) {
          ci.hide(index3);
          legendItem.hidden = true;
        } else {
          ci.show(index3);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style2 = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style2.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style2.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style2.borderCapStyle,
              lineDash: style2.borderDash,
              lineDashOffset: style2.borderDashOffset,
              lineJoin: style2.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style2.borderColor,
              pointStyle: pointStyle || style2.pointStyle,
              rotation: style2.rotation,
              textAlign: textAlign || style2.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style2.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset2) {
      const { top: top2, left: left2, bottom: bottom2, right: right2, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left2, right2);
        titleY = top2 + offset2;
        maxWidth = right2 - left2;
      } else {
        if (options.position === "left") {
          titleX = left2 + offset2;
          titleY = _alignStartEnd(align, bottom2, top2);
          rotation = PI * -0.5;
        } else {
          titleX = right2 - offset2;
          titleY = _alignStartEnd(align, top2, bottom2);
          rotation = PI * 0.5;
        }
        maxWidth = bottom2 - top2;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset2 = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset2);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i, len;
      let x = 0;
      let y = 0;
      let count = 0;
      for (i = 0, len = items.length; i < len; ++i) {
        const el = items[i].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          x += pos.x;
          y += pos.y;
          ++count;
        }
      }
      return {
        x: x / count,
        y: y / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x = eventPosition.x;
      let y = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i, len, nearestElement;
      for (i = 0, len = items.length; i < len; ++i) {
        const el = items[i].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d = distanceBetweenPoints(eventPosition, center);
          if (d < minDistance) {
            minDistance = d;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x = tp.x;
        y = tp.y;
      }
      return {
        x,
        y
      };
    }
  };
  function pushOrConcat(base2, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base2, toPush);
      } else {
        base2.push(toPush);
      }
    }
    return base2;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index3 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index3);
    return {
      chart,
      label,
      parsed: controller.getParsed(index3),
      raw: chart.data.datasets[datasetIndex].data[index3],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index3,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size) {
    const { y, height } = size;
    if (y < height / 2) {
      return "top";
    } else if (y > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left: left2, right: right2 } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x <= (left2 + right2) / 2 ? "left" : "right";
    } else if (x <= width / 2) {
      xAlign = "left";
    } else if (x >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") {
      x -= width;
    } else if (xAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y, height } = size;
    if (yAlign === "top") {
      y += paddingAndSize;
    } else if (yAlign === "bottom") {
      y -= height + paddingAndSize;
    } else {
      y -= height / 2;
    }
    return y;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x += paddingAndSize;
      } else if (xAlign === "right") {
        x -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x, 0, chart.width - size.width),
      y: _limitValue(y, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var defaultCallbacks = {
    beforeTitle: noop,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop,
    beforeBody: noop,
    beforeLabel: noop,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options.borderColor,
        backgroundColor: options.backgroundColor,
        borderWidth: options.borderWidth,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options.pointStyle,
        rotation: options.rotation
      };
    },
    afterLabel: noop,
    afterBody: noop,
    beforeFooter: noop,
    footer: noop,
    afterFooter: noop
  };
  function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element2 {
    static positioners = positioners;
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
      const { callbacks } = options;
      const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
      const title = invokeCallbackWithFallback(callbacks, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i, len;
      for (i = 0, len = active.length; i < len; ++i) {
        tooltipItems.push(createTooltipItem(this.chart, active[i]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index3, array) => options.filter(element, index3, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y2, y3;
      if (yAlign === "center") {
        y2 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y2 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2,
        y3
      };
    }
    drawTitle(pt, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i + 1 === length) {
            pt.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i, rtlHelper, options) {
      const labelColor = this.labelColors[i];
      const labelPointStyle = this.labelPointStyles[i];
      const { boxHeight, boxWidth } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColor.borderColor;
        ctx.fillStyle = labelColor.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
        ctx.strokeStyle = labelColor.borderColor;
        ctx.setLineDash(labelColor.borderDash || []);
        ctx.lineDashOffset = labelColor.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
        const borderRadius = toTRBLCorners(labelColor.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i, j, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i = 0, ilen = body.length; i < ilen; ++i) {
        bodyItem = body[i];
        textColor = this.labelTextColors[i];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          fillLineOfText(lines[j]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.footerAlign, options);
        pt.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x, y } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x + topLeft, y);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width - topRight, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width, y + height - bottomRight);
      ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + bottomLeft, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x, y + topLeft);
      ctx.quadraticCurveTo(x, y, x + topLeft, y);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options);
        this.drawBody(pt, ctx, options);
        this.drawFooter(pt, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index3 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index3],
          index: index3
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e.x,
            y: e.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
      }
      const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({
          chart,
          options
        });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", {
          ...args,
          cancelable: true
        }) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index3, addedLabels) => {
    if (typeof raw === "string") {
      index3 = labels.push(raw) - 1;
      addedLabels.unshift({
        index: index3,
        label: raw
      });
    } else if (isNaN(raw)) {
      index3 = null;
    }
    return index3;
  };
  function findOrAddLabel(labels, raw, index3, addedLabels) {
    const first2 = labels.indexOf(raw);
    if (first2 === -1) {
      return addIfString(labels, raw, index3, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first2 !== last ? index3 : first2;
  }
  var validIndex = (index3, max2) => index3 === null ? null : _limitValue(Math.round(index3), 0, max2);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    static id = "category";
    static defaults = {
      ticks: {
        callback: _getLabelForValue
      }
    };
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index3, label } of added) {
          if (labels[index3] === label) {
            labels.splice(index3, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index3) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index3 = isFinite(index3) && labels[index3] === raw ? index3 : findOrAddLabel(labels, raw, valueOrDefault(index3, raw), this._addedLabels);
      return validIndex(index3, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min2, max: max2 } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min2 = 0;
        }
        if (!maxDefined) {
          max2 = this.getLabels().length - 1;
        }
      }
      this.min = min2;
      this.max = max2;
    }
    buildTicks() {
      const min2 = this.min;
      const max2 = this.max;
      const offset2 = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min2 === 0 && max2 === labels.length - 1 ? labels : labels.slice(min2, max2 + 1);
      this._valueRange = Math.max(labels.length - (offset2 ? 0 : 1), 1);
      this._startValue = this.min - (offset2 ? 0.5 : 0);
      for (let value = min2; value <= max2; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index3) {
      const ticks = this.ticks;
      if (index3 < 0 || index3 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index3].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min: min2, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min2);
    const maxDefined = !isNullOrUndef(max2);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max2 - min2) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max2 - min2) / spacing, maxTicks));
      spacing = (max2 - min2) / numSpaces;
      niceMin = min2;
      niceMax = max2;
    } else if (countDefined) {
      niceMin = minDefined ? min2 : niceMin;
      niceMax = maxDefined ? max2 : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min2) {
        ticks.push({
          value: min2
        });
        if (niceMin < min2) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min2, relativeLabelSize(min2, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min2) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
      if (maxDefined && tickValue > max2) {
        break;
      }
      ticks.push({
        value: tickValue
      });
    }
    if (maxDefined && includeBounds && niceMax !== max2) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max2;
      } else {
        ticks.push({
          value: max2
        });
      }
    } else if (!maxDefined || niceMax === max2) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index3) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min2, max: max2 } = this;
      const setMin = (v) => min2 = minDefined ? min2 : v;
      const setMax = (v) => max2 = maxDefined ? max2 : v;
      if (beginAtZero) {
        const minSign = sign(min2);
        const maxSign = sign(max2);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min2 === max2) {
        let offset2 = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
        setMax(max2 + offset2);
        if (!beginAtZero) {
          setMin(min2 - offset2);
        }
      }
      this.min = min2;
      this.max = max2;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start3 = this.min;
      let end2 = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset2 = (end2 - start3) / Math.max(ticks.length - 1, 1) / 2;
        start3 -= offset2;
        end2 += offset2;
      }
      this._startValue = start3;
      this._endValue = end2;
      this._valueRange = end2 - start3;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    static id = "linear";
    static defaults = {
      ticks: {
        callback: Ticks.formatters.numeric
      }
    };
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min2) ? min2 : 0;
      this.max = isNumberFinite(max2) ? max2 : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  var log10Floor = (v) => Math.floor(log10(v));
  var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min2, max2, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start3 = Math.floor(min2 / rangeStep);
    const end2 = Math.ceil(max2 / rangeStep);
    return end2 - start3;
  }
  function startExp(min2, max2) {
    const range = max2 - min2;
    let rangeExp = log10Floor(range);
    while (steps(min2, max2, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min2, max2, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min2));
  }
  function generateTicks(generationOptions, { min: min2, max: max2 }) {
    min2 = finiteOrDefault(generationOptions.min, min2);
    const ticks = [];
    const minExp = log10Floor(min2);
    let exp = startExp(min2, max2);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base2 = minExp > exp ? Math.pow(10, minExp) : 0;
    const start3 = Math.round((min2 - base2) * precision) / precision;
    const offset2 = Math.floor((min2 - base2) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start3 - offset2) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base2 + offset2 + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max2) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base2 + offset2 + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    static id = "logarithmic";
    static defaults = {
      ticks: {
        callback: Ticks.formatters.logarithmic,
        major: {
          enabled: true
        }
      }
    };
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index3) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw,
        index3
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min2) ? Math.max(0, min2) : null;
      this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min2 === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min2 = this.min;
      let max2 = this.max;
      const setMin = (v) => min2 = minDefined ? min2 : v;
      const setMax = (v) => max2 = maxDefined ? max2 : v;
      if (min2 === max2) {
        if (min2 <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(changeExponent(min2, -1));
          setMax(changeExponent(max2, 1));
        }
      }
      if (min2 <= 0) {
        setMin(changeExponent(max2, -1));
      }
      if (max2 <= 0) {
        setMax(changeExponent(min2, 1));
      }
      this.min = min2;
      this.max = max2;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start3 = this.min;
      super.configure();
      this._startValue = log10(start3);
      this._valueRange = log10(this.max) - log10(start3);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min2, max2) {
    if (angle === min2 || angle === max2) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min2 || angle > max2) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i = 0; i < valueCount; i++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
      padding[i] = opts.padding;
      const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
      labelSizes[i] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
      x = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
      x = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
      y = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
      y = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y);
    }
  }
  function createPointLabelItem(scale, index3, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index3, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left2 = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
      visible: true,
      x: pointLabelPosition.x,
      y,
      textAlign,
      left: left2,
      top: y,
      right: left2 + size.w,
      bottom: y + size.h
    };
  }
  function isNotOverlapped(item, area) {
    if (!area) {
      return true;
    }
    const { left: left2, top: top2, right: right2, bottom: bottom2 } = item;
    const apexesInArea = _isPointInArea({
      x: left2,
      y: top2
    }, area) || _isPointInArea({
      x: left2,
      y: bottom2
    }, area) || _isPointInArea({
      x: right2,
      y: top2
    }, area) || _isPointInArea({
      x: right2,
      y: bottom2
    }, area);
    return !apexesInArea;
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
      extra: getTickBackdropHeight(opts) / 2,
      additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for (let i = 0; i < valueCount; i++) {
      itemOpts.padding = padding[i];
      itemOpts.size = labelSizes[i];
      const item = createPointLabelItem(scale, i, itemOpts);
      items.push(item);
      if (display === "auto") {
        item.visible = isNotOverlapped(item, area);
        if (item.visible) {
          area = item;
        }
      }
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x, w, align) {
    if (align === "right") {
      x -= w;
    } else if (align === "center") {
      x -= w / 2;
    }
    return x;
  }
  function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
      y -= h / 2;
    } else if (angle > 270 || angle < 90) {
      y -= h;
    }
    return y;
  }
  function drawPointLabelBox(ctx, opts, item) {
    const { left: left2, top: top2, right: right2, bottom: bottom2 } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(opts.borderRadius);
      const padding = toPadding(opts.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left2 - padding.left;
      const backdropTop = top2 - padding.top;
      const backdropWidth = right2 - left2 + padding.width;
      const backdropHeight = bottom2 - top2 + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i = labelCount - 1; i >= 0; i--) {
      const item = scale._pointLabelItems[i];
      if (!item.visible) {
        continue;
      }
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
      drawPointLabelBox(ctx, optsAtIndex, item);
      const plFont = toFont(optsAtIndex.font);
      const { x, y, textAlign } = item;
      renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i = 1; i < labelCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index3, label) {
    return createContext(parent, {
      label,
      index: index3,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    static id = "radialLinear";
    static defaults = {
      display: true,
      animate: true,
      position: "chartArea",
      angleLines: {
        display: true,
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0
      },
      grid: {
        circular: false
      },
      startAngle: 0,
      ticks: {
        showLabelBackdrop: true,
        callback: Ticks.formatters.numeric
      },
      pointLabels: {
        backdropColor: void 0,
        backdropPadding: 2,
        display: true,
        font: {
          size: 10
        },
        callback(label) {
          return label;
        },
        padding: 5,
        centerPointLabels: false
      }
    };
    static defaultRoutes = {
      "angleLines.color": "borderColor",
      "pointLabels.color": "color",
      "ticks.color": "color"
    };
    static descriptors = {
      angleLines: {
        _fallback: "grid"
      }
    };
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w = this.width = this.maxWidth - padding.width;
      const h = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(false);
      this.min = isNumberFinite(min2) && !isNaN(min2) ? min2 : 0;
      this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index3) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index3
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v, i) => this.chart.getDataVisibility(i));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index3) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index3 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index3) {
      const pointLabels = this._pointLabels || [];
      if (index3 >= 0 && index3 < pointLabels.length) {
        const pointLabel = pointLabels[index3];
        return createPointLabelContext(this.getContext(), index3, pointLabel);
      }
    }
    getPointPosition(index3, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index3) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index3, value) {
      return this.getPointPosition(index3, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index3) {
      return this.getPointPositionForValue(index3 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index3) {
      const { left: left2, top: top2, right: right2, bottom: bottom2 } = this._pointLabelItems[index3];
      return {
        left: left2,
        top: top2,
        right: right2,
        bottom: bottom2
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i, offset2, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index3) => {
          if (index3 !== 0) {
            offset2 = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index3);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset2, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
          position = this.getPointPosition(i, offset2);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset2, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index3) => {
        if (index3 === 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index3));
        const tickFont = toFont(optsAtIndex.font);
        offset2 = this.getDistanceFromCenterForValue(this.ticks[index3].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset2, tickFont, {
          color: optsAtIndex.color,
          strokeColor: optsAtIndex.textStrokeColor,
          strokeWidth: optsAtIndex.textStrokeWidth
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a, b) {
    return a - b;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round3, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round3) {
      value = round3 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round3);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
    const ilen = UNITS.length;
    for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
      const interval = INTERVALS[UNITS[i]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
        return UNITS[i];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min2, max2) {
    for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
      const unit = UNITS[i];
      if (INTERVALS[unit].common && scale._adapter.diff(max2, min2, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
      if (INTERVALS[UNITS[i]].common) {
        return UNITS[i];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map4, majorUnit) {
    const adapter = scale._adapter;
    const first2 = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index3;
    for (major = first2; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index3 = map4[major];
      if (index3 >= 0) {
        ticks[index3].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map4 = {};
    const ilen = values.length;
    let i, value;
    for (i = 0; i < ilen; ++i) {
      value = values[i];
      map4[value] = i;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map4, majorUnit);
  }
  var TimeScale = class extends Scale {
    static id = "time";
    static defaults = {
      bounds: "data",
      adapters: {},
      time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: "millisecond",
        displayFormats: {}
      },
      ticks: {
        source: "auto",
        callback: false,
        major: {
          enabled: false
        }
      }
    };
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index3) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min2 = Math.min(min2, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max2 = Math.max(max2, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min2 = isNumberFinite(min2) && !isNaN(min2) ? min2 : +adapter.startOf(Date.now(), unit);
      max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min2, max2 - 1);
      this.max = Math.max(min2 + 1, max2);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min2 = Number.POSITIVE_INFINITY;
      let max2 = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min2 = arr[0];
        max2 = arr[arr.length - 1];
      }
      return {
        min: min2,
        max: max2
      };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min2 = this.min;
      const max2 = this.max;
      const ticks = _filterBetween(timestamps, min2, max2);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min2)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start3 = 0;
      let end2 = 0;
      let first2, last;
      if (this.options.offset && timestamps.length) {
        first2 = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start3 = 1 - first2;
        } else {
          start3 = (this.getDecimalForValue(timestamps[1]) - first2) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end2 = last;
        } else {
          end2 = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start3 = _limitValue(start3, 0, limit);
      end2 = _limitValue(end2, 0, limit);
      this._offsets = {
        start: start3,
        end: end2,
        factor: 1 / (start3 + 1 + end2)
      };
    }
    _generate() {
      const adapter = this._adapter;
      const min2 = this.min;
      const max2 = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, this._getLabelCapacity(min2));
      const stepSize = valueOrDefault(options.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first2 = min2;
      let time, count;
      if (hasWeekday) {
        first2 = +adapter.startOf(first2, "isoWeek", weekday);
      }
      first2 = +adapter.startOf(first2, hasWeekday ? "day" : minor);
      if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
        throw new Error(min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first2, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max2 || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort(sorter).map((x) => +x);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const fmt = format || formats[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index3, ticks, format) {
      const options = this.options;
      const formatter2 = options.ticks.callback;
      if (formatter2) {
        return callback(formatter2, [
          time,
          index3,
          ticks
        ], this);
      }
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index3];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        tick.label = this._tickFormatFunction(tick.value, i, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i = 0, ilen = labels.length; i < ilen; ++i) {
        timestamps.push(parse(this, labels[i]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  function interpolate3(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    static id = "timeseries";
    static defaults = TimeScale.defaults;
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate3(table, this.min);
      this._tableRange = interpolate3(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min: min2, max: max2 } = this;
      const items = [];
      const table = [];
      let i, ilen, prev, curr, next;
      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];
        if (curr >= min2 && curr <= max2) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min2,
            pos: 0
          },
          {
            time: max2,
            pos: 1
          }
        ];
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }
      return table;
    }
    _generate() {
      const min2 = this.min;
      const max2 = this.max;
      let timestamps = super.getDataTimestamps();
      if (!timestamps.includes(min2) || !timestamps.length) {
        timestamps.splice(0, 0, min2);
      }
      if (!timestamps.includes(max2) || timestamps.length === 1) {
        timestamps.push(max2);
      }
      return timestamps.sort((a, b) => a - b);
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate3(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate3(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/chart.js/auto/auto.js
  Chart.register(...registerables);

  // node_modules/bali-view-components/app/components/bali/modal/index.js
  var ModalController = class extends Controller {
    static targets = ["template", "background", "wrapper", "content", "closeBtn"];
    async connect() {
      this.setupListeners("openModal");
    }
    setupListeners = (eventName) => {
      if (this.hasWrapperTarget) {
        this.wrapperClasses = this.normalizeClass(
          this.wrapperTarget.getAttribute("data-wrapper-class")
        );
      }
      if (this.hasBackgroundTarget) {
        this.backgroundTarget.addEventListener("click", this._closeModal);
      }
      if (this.hasCloseBtnTarget) {
        this.closeBtnTarget.addEventListener("click", this._closeModal);
      }
      document.addEventListener(eventName, this.setOptionsAndOpenModal);
    };
    disconnect() {
      this.removeListeners("openModal");
    }
    removeListeners = (eventName) => {
      if (this.hasBackgroundTarget) {
        this.backgroundTarget.removeEventListener("click", this._closeModal);
      }
      if (this.hasCloseBtnTarget) {
        this.closeBtnTarget.removeEventListener("click", this._closeModal);
      }
      document.removeEventListener(eventName, this.setOptionsAndOpenModal);
    };
    templateTargetConnected() {
      if (!this.hasBackgroundTarget)
        return;
      this.backgroundTarget.addEventListener("click", this._closeModal);
    }
    templateTargetDisconnected() {
      if (!this.hasBackgroundTarget)
        return;
      this.backgroundTarget.removeEventListener("click", this._closeModal);
    }
    setOptionsAndOpenModal = (event) => {
      this.setOptions(event.detail.options);
      this.openModal(event.detail.content);
    };
    openModal(content) {
      this.wrapperTarget.classList.add(...this.wrapperClasses);
      this.templateTarget.classList.add("is-active");
      this.contentTarget.innerHTML = content;
      autoFocusInput(this.contentTarget);
    }
    setOptions(options) {
      const keys2 = Object.keys(options);
      keys2.forEach((key, _i) => {
        this[key] = options[key];
      });
    }
    _closeModal = () => {
      this.templateTarget.classList.remove("is-active");
      if (this.wrapperClasses) {
        this.wrapperTarget.classList.remove(...this.wrapperClasses);
      }
      this.contentTarget.innerHTML = "";
    };
    _buildURL = (path, redirectTo = null) => {
      const url = new URL(path, window.location.origin);
      url.searchParams.set("layout", "false");
      if (redirectTo) {
        url.searchParams.set("redirect_to", redirectTo);
      }
      return url.toString();
    };
    _extractResponseBodyAndTitle = (html) => {
      const element = document.createElement("html");
      element.innerHTML = html;
      return {
        body: element.querySelector("body").innerHTML,
        title: element.querySelector("title").text
      };
    };
    _replaceBodyAndURL = (html, url) => {
      const { body, title } = this._extractResponseBodyAndTitle(html);
      document.body.innerHTML = body;
      history.pushState({}, title, url);
    };
    /**
     * Public Methods
     */
    open = (event) => {
      event.preventDefault();
      const target = event.currentTarget;
      this.wrapperClasses = this.normalizeClass(
        target.getAttribute("data-wrapper-class")
      );
      this.redirectTo = target.getAttribute("data-redirect-to");
      this.skipRender = Boolean(target.getAttribute("data-skip-render"));
      this.extraProps = JSON.parse(target.getAttribute("data-extra-props"));
      fetch(this._buildURL(target.href)).then((response) => response.text()).then((body) => this.openModal(body));
    };
    close = (event) => {
      event.preventDefault();
      this._closeModal();
    };
    /**
     * submit
     *
     * This action is called when a form within a modal is submitted. There
     * are 2 scenarios we need to handle:
     *
     * 1. When Form is submitted successfully, the server redirects to a new page.
     * 2. When Form has an error, the server returns the form with the errors.
     *
     * On a successful scenario we get a full HTML page and we then proceed to extract
     * the <body> tag from the page and replace the existing body tag.
     *
     * On a error scenario we just replace the modal contents with the response, since we
     * are already only getting the contents inside the modal.
     */
    submit = (event) => {
      event.preventDefault();
      event.target.classList.add("is-loading");
      event.target.setAttribute("disabled", "");
      const form = event.target.closest("form");
      const formURL = form.getAttribute("action");
      const enableTurbo = event.target.dataset.turbo || form.dataset.turbo;
      const url = this._buildURL(formURL, this.redirectTo);
      const options = {
        method: "POST",
        mode: "same-origin",
        redirect: "follow",
        credentials: "include",
        body: new FormData(form)
      };
      if (enableTurbo) {
        options.headers = {
          Accept: "text/vnd.turbo-stream.html, text/html, application/xhtml+xml"
        };
      } else {
        options.headers = {
          Accept: "text/html, application/xhtml+xml"
        };
      }
      let redirected = false;
      let redirectURL = null;
      let responseOk = null;
      const redirectData = this.extraProps || {};
      fetch(url, options).then((response) => {
        redirected = response.redirected;
        redirectURL = response.url;
        const url2 = new URL(response.url);
        url2.searchParams.forEach((value, key) => {
          redirectData[key] = value;
        });
        responseOk = response.ok;
        return response.text();
      }).then((responseText) => {
        const event2 = new CustomEvent("modal:success", { detail: redirectData });
        if (redirected) {
          document.dispatchEvent(event2);
          if (this.skipRender) {
            this._closeModal();
          } else {
            this._replaceBodyAndURL(responseText, redirectURL);
          }
        } else {
          if (responseOk) {
            document.dispatchEvent(event2);
          }
          this.openModal(responseText);
        }
      });
    };
    normalizeClass(classes) {
      if (!classes)
        return [];
      return classes.split(" ");
    }
  };

  // node_modules/bali-view-components/app/components/bali/dropdown/index.js
  var DropdownController = class extends Controller {
    static values = {
      hoverable: { type: Boolean, default: false },
      closeOnClick: { type: Boolean, default: true }
    };
    connect() {
      if (this.closeOnClickValue) {
        document.addEventListener("click", this.closeDropdowns);
      }
      if (!this.hoverableValue)
        return;
      this.element.addEventListener("mouseenter", this.toggleMenu);
      this.element.addEventListener("mouseleave", this.closeDropdowns);
    }
    disconnect() {
      if (this.closeOnClickValue) {
        document.removeEventListener("click", this.closeDropdowns);
      }
      if (!this.hoverableValue)
        return;
      this.element.removeEventListener("mouseenter", this.toggleMenu);
      this.element.removeEventListener("mouseleave", this.closeDropdowns);
    }
    toggleMenu = (e) => {
      e.stopPropagation();
      e.preventDefault();
      this.element.classList.toggle("is-active");
    };
    closeDropdowns = () => {
      this.element.classList.remove("is-active");
    };
  };

  // node_modules/sortablejs/modular/sortable.esm.js
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source2), true).forEach(function(key) {
          _defineProperty(target, key, source2[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
      } else {
        ownKeys(Object(source2)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
        });
      }
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source2 = arguments[i];
        for (var key in source2) {
          if (Object.prototype.hasOwnProperty.call(source2, key)) {
            target[key] = source2[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source2, excluded) {
    if (source2 == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source2);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source2[key];
    }
    return target;
  }
  function _objectWithoutProperties(source2, excluded) {
    if (source2 == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source2, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source2, key))
          continue;
        target[key] = source2[key];
      }
    }
    return target;
  }
  var version2 = "1.15.2";
  function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) {
      return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
    }
  }
  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
  var captureMode = {
    capture: false,
    passive: false
  };
  function on(el, event, fn2) {
    el.addEventListener(event, fn2, !IE11OrLess && captureMode);
  }
  function off(el, event, fn2) {
    el.removeEventListener(event, fn2, !IE11OrLess && captureMode);
  }
  function matches(el, selector) {
    if (!selector)
      return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }
    return false;
  }
  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }
  function closest(el, selector, ctx, includeCTX) {
    if (el) {
      ctx = ctx || document;
      do {
        if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
          return el;
        }
        if (el === ctx)
          break;
      } while (el = getParentOrHost(el));
    }
    return null;
  }
  var R_SPACE = /\s+/g;
  function toggleClass(el, name, state) {
    if (el && name) {
      if (el.classList) {
        el.classList[state ? "add" : "remove"](name);
      } else {
        var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
        el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
      }
    }
  }
  function css(el, prop, val) {
    var style2 = el && el.style;
    if (style2) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, "");
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style2) && prop.indexOf("webkit") === -1) {
          prop = "-webkit-" + prop;
        }
        style2[prop] = val + (typeof val === "string" ? "" : "px");
      }
    }
  }
  function matrix(el, selfOnly) {
    var appliedTransforms = "";
    if (typeof el === "string") {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, "transform");
        if (transform && transform !== "none") {
          appliedTransforms = transform + " " + appliedTransforms;
        }
      } while (!selfOnly && (el = el.parentNode));
    }
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    return matrixFn && new matrixFn(appliedTransforms);
  }
  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window)
      return;
    var elRect, top2, left2, bottom2, right2, height, width;
    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top2 = elRect.top;
      left2 = elRect.left;
      bottom2 = elRect.bottom;
      right2 = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top2 = 0;
      left2 = 0;
      bottom2 = window.innerHeight;
      right2 = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      container = container || el.parentNode;
      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
            var containerRect = container.getBoundingClientRect();
            top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
            left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
            bottom2 = top2 + elRect.height;
            right2 = left2 + elRect.width;
            break;
          }
        } while (container = container.parentNode);
      }
    }
    if (undoScale && el !== window) {
      var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
      if (elMatrix) {
        top2 /= scaleY;
        left2 /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom2 = top2 + height;
        right2 = left2 + width;
      }
    }
    return {
      top: top2,
      left: left2,
      bottom: bottom2,
      right: right2,
      width,
      height
    };
  }
  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
    while (parent) {
      var parentSideVal = getRect(parent)[parentSide], visible = void 0;
      if (parentSide === "top" || parentSide === "left") {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }
      if (!visible)
        return parent;
      if (parent === getWindowScrollingElement())
        break;
      parent = getParentAutoScrollElement(parent, false);
    }
    return false;
  }
  function getChild(el, childNum, options, includeDragEl) {
    var currentChild = 0, i = 0, children = el.children;
    while (i < children.length) {
      if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i];
        }
        currentChild++;
      }
      i++;
    }
    return null;
  }
  function lastChild(el, selector) {
    var last = el.lastElementChild;
    while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
      last = last.previousElementSibling;
    }
    return last || null;
  }
  function index2(el, selector) {
    var index3 = 0;
    if (!el || !el.parentNode) {
      return -1;
    }
    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index3++;
      }
    }
    return index3;
  }
  function getRelativeScrollOffset(el) {
    var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
    if (el) {
      do {
        var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }
    return [offsetLeft, offsetTop];
  }
  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i))
        continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
          return Number(i);
      }
    }
    return -1;
  }
  function getParentAutoScrollElement(el, includeSelf) {
    if (!el || !el.getBoundingClientRect)
      return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;
    do {
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
          if (!elem.getBoundingClientRect || elem === document.body)
            return getWindowScrollingElement();
          if (gotSelf || includeSelf)
            return elem;
          gotSelf = true;
        }
      }
    } while (elem = elem.parentNode);
    return getWindowScrollingElement();
  }
  function extend3(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }
  var _throttleTimeout;
  function throttle(callback2, ms) {
    return function() {
      if (!_throttleTimeout) {
        var args = arguments, _this = this;
        if (args.length === 1) {
          callback2.call(_this, args[0]);
        } else {
          callback2.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function() {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }
  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }
  function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
  }
  function clone3(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }
  function getChildContainingRectFromElement(container, options, ghostEl2) {
    var rect = {};
    Array.from(container.children).forEach(function(child) {
      var _rect$left, _rect$top, _rect$right, _rect$bottom;
      if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2)
        return;
      var childRect = getRect(child);
      rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
      rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
      rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
      rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
    });
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
  function AnimationStateManager() {
    var animationStates = [], animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation)
          return;
        var children = [].slice.call(this.el.children);
        children.forEach(function(child) {
          if (css(child, "display") === "none" || child === Sortable.ghost)
            return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });
          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target
        }), 1);
      },
      animateAll: function animateAll(callback2) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback2 === "function")
            callback2();
          return;
        }
        var animating = false, animationTime = 0;
        animationStates.forEach(function(state) {
          var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
          if (targetMatrix) {
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          }
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function() {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback2 === "function")
            callback2();
        } else {
          animationCallbackId = setTimeout(function() {
            if (typeof callback2 === "function")
              callback2();
          }, animationTime);
        }
        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, "transition", "");
          css(target, "transform", "");
          var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
          this.forRepaintDummy = repaint(target);
          css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
          css(target, "transform", "translate3d(0,0,0)");
          typeof target.animated === "number" && clearTimeout(target.animated);
          target.animated = setTimeout(function() {
            css(target, "transition", "");
            css(target, "transform", "");
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }
  function repaint(target) {
    return target.offsetWidth;
  }
  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }
  var plugins2 = [];
  var defaults2 = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      for (var option2 in defaults2) {
        if (defaults2.hasOwnProperty(option2) && !(option2 in plugin)) {
          plugin[option2] = defaults2[option2];
        }
      }
      plugins2.forEach(function(p) {
        if (p.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins2.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function() {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + "Global";
      plugins2.forEach(function(plugin) {
        if (!sortable[plugin.pluginName])
          return;
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable
          }, evt));
        }
        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults4, options) {
      plugins2.forEach(function(plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault)
          return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized;
        _extends(defaults4, initialized.defaults);
      });
      for (var option2 in sortable.options) {
        if (!sortable.options.hasOwnProperty(option2))
          continue;
        var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
        if (typeof modified !== "undefined") {
          sortable.options[option2] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins2.forEach(function(plugin) {
        if (typeof plugin.eventProperties !== "function")
          return;
        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins2.forEach(function(plugin) {
        if (!sortable[plugin.pluginName])
          return;
        if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };
  function dispatchEvent2(_ref) {
    var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl2 && rootEl2[expando];
    if (!sortable)
      return;
    var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent(name, true, true);
    }
    evt.to = toEl || rootEl2;
    evt.from = fromEl || rootEl2;
    evt.item = targetEl || rootEl2;
    evt.clone = cloneEl2;
    evt.oldIndex = oldIndex2;
    evt.newIndex = newIndex2;
    evt.oldDraggableIndex = oldDraggableIndex2;
    evt.newDraggableIndex = newDraggableIndex2;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
    for (var option2 in allEventProperties) {
      evt[option2] = allEventProperties[option2];
    }
    if (rootEl2) {
      rootEl2.dispatchEvent(evt);
    }
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  var _excluded = ["evt"];
  var pluginEvent2 = function pluginEvent3(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      dragStarted: moved,
      putSortable,
      activeSortable: Sortable.active,
      originalEvent,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name) {
        _dispatchEvent({
          sortable,
          name,
          originalEvent
        });
      }
    }, data));
  };
  function _dispatchEvent(info) {
    dispatchEvent2(_objectSpread2({
      putSortable,
      cloneEl,
      targetEl: dragEl,
      rootEl,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex
    }, info));
  }
  var dragEl;
  var parentEl;
  var ghostEl;
  var rootEl;
  var nextEl;
  var lastDownEl;
  var cloneEl;
  var cloneHidden;
  var oldIndex;
  var newIndex;
  var oldDraggableIndex;
  var newDraggableIndex;
  var activeGroup;
  var putSortable;
  var awaitingDragStarted = false;
  var ignoreNextClick = false;
  var sortables = [];
  var tapEvt;
  var touchEvt;
  var lastDx;
  var lastDy;
  var tapDistanceLeft;
  var tapDistanceTop;
  var moved;
  var lastTarget;
  var lastDirection;
  var pastFirstInvertThresh = false;
  var isCircumstantialInvert = false;
  var targetMoveDistance;
  var ghostRelativeParent;
  var ghostRelativeParentInitialScroll = [];
  var _silent = false;
  var savedInputChecked = [];
  var documentExists = typeof document !== "undefined";
  var PositionGhostAbsolutely = IOS;
  var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
  var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
  var supportCssPointerEvents = function() {
    if (!documentExists)
      return;
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement("x");
    el.style.cssText = "pointer-events:auto";
    return el.style.pointerEvents === "auto";
  }();
  var _detectDirection = function _detectDirection2(el, options) {
    var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === "flex") {
      return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    }
    if (elCSS.display === "grid") {
      return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
      var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
      return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
    }
    return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
  };
  var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  };
  var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
    var ret;
    sortables.some(function(sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable))
        return;
      var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  };
  var _prepareGroup = function _prepareGroup2(options) {
    function toFn(value, pull) {
      return function(to2, from3, dragEl2, evt) {
        var sameGroup = to2.options.group.name && from3.options.group.name && to2.options.group.name === from3.options.group.name;
        if (value == null && (pull || sameGroup)) {
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === "clone") {
          return value;
        } else if (typeof value === "function") {
          return toFn(value(to2, from3, dragEl2, evt), pull)(to2, from3, dragEl2, evt);
        } else {
          var otherGroup = (pull ? to2 : from3).options.group.name;
          return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != "object") {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  };
  var _hideGhostForTarget = function _hideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "none");
    }
  };
  var _unhideGhostForTarget = function _unhideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "");
    }
  };
  if (documentExists && !ChromeForAndroid) {
    document.addEventListener("click", function(evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }
  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        var event = {};
        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }
        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;
        nearest[expando]._onDragOver(event);
      }
    }
  };
  var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }
    this.el = el;
    this.options = options = _extends({}, options);
    el[expando] = this;
    var defaults4 = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el, this.options);
      },
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl2) {
        dataTransfer.setData("Text", dragEl2.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults4);
    for (var name in defaults4) {
      !(name in options) && (options[name] = defaults4[name]);
    }
    _prepareGroup(options);
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      this.options.touchStartThreshold = 1;
    }
    if (options.supportPointer) {
      on(el, "pointerdown", this._onTapStart);
    } else {
      on(el, "mousedown", this._onTapStart);
      on(el, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el, "dragover", this);
      on(el, "dragenter", this);
    }
    sortables.push(this.el);
    options.store && options.store.get && this.sort(options.store.get(this) || []);
    _extends(this, AnimationStateManager());
  }
  Sortable.prototype = /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(evt) {
      if (!evt.cancelable)
        return;
      var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
      _saveInputCheckedState(el);
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return;
      }
      if (originalTarget.isContentEditable) {
        return;
      }
      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
        return;
      }
      target = closest(target, options.draggable, el, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        return;
      }
      oldIndex = index2(target);
      oldDraggableIndex = index2(target, options.draggable);
      if (typeof filter === "function") {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: "filter",
            targetEl: target,
            toEl: el,
            fromEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return;
        }
      } else if (filter) {
        filter = filter.split(",").some(function(criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: "filter",
              targetEl: target,
              fromEl: el,
              toEl: el
            });
            pluginEvent2("filter", _this, {
              evt
            });
            return true;
          }
        });
        if (filter) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return;
        }
      }
      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      }
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(evt, touch, target) {
      var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style["will-change"] = "all";
        dragStartFn = function dragStartFn2() {
          pluginEvent2("delayEnded", _this, {
            evt
          });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          }
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          }
          _this._triggerDragStart(evt, touch);
          _dispatchEvent({
            sortable: _this,
            name: "choose",
            originalEvent: evt
          });
          toggleClass(dragEl, options.chosenClass, true);
        };
        options.ignore.split(",").forEach(function(criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop);
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent2("delayStart", this, {
          evt
        });
        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
          on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
          on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
      var touch = e.touches ? e.touches[0] : e;
      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._disableDelayedDrag);
      off(ownerDocument, "touchend", this._disableDelayedDrag);
      off(ownerDocument, "touchcancel", this._disableDelayedDrag);
      off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(evt, touch) {
      touch = touch || evt.pointerType == "touch" && evt;
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._onTouchMove);
        } else if (touch) {
          on(document, "touchmove", this._onTouchMove);
        } else {
          on(document, "mousemove", this._onTouchMove);
        }
      } else {
        on(dragEl, "dragend", this);
        on(rootEl, "dragstart", this._onDragStart);
      }
      try {
        if (document.selection) {
          _nextTick(function() {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {
      }
    },
    _dragStarted: function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent2("dragStarted", this, {
          evt
        });
        if (this.nativeDraggable) {
          on(document, "dragover", _checkOutsideTargetEl);
        }
        var options = this.options;
        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost();
        _dispatchEvent({
          sortable: this,
          name: "start",
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent)
            break;
          parent = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target,
                rootEl: parent
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent;
          } while (parent = parent.parentNode);
        }
        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(evt) {
      if (tapEvt) {
        var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }
          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, "webkitTransform", cssMatrix);
          css(ghostEl, "mozTransform", cssMatrix);
          css(ghostEl, "msTransform", cssMatrix);
          css(ghostEl, "transform", cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
        if (PositionGhostAbsolutely) {
          ghostRelativeParent = container;
          while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document)
              ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, "transition", "");
        css(ghostEl, "transform", "");
        css(ghostEl, "box-sizing", "border-box");
        css(ghostEl, "margin", 0);
        css(ghostEl, "top", rect.top);
        css(ghostEl, "left", rect.left);
        css(ghostEl, "width", rect.width);
        css(ghostEl, "height", rect.height);
        css(ghostEl, "opacity", "0.8");
        css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
        css(ghostEl, "zIndex", "100000");
        css(ghostEl, "pointerEvents", "none");
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl);
        css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
      }
    },
    _onDragStart: function _onDragStart(evt, fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent2("dragStart", this, {
        evt
      });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent2("setupClone", this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone3(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style["will-change"] = "";
        this._hideClone();
        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      }
      _this.cloneId = _nextTick(function() {
        pluginEvent2("clone", _this);
        if (Sortable.eventCanceled)
          return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({
          sortable: _this,
          name: "clone"
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true);
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        off(document, "mouseup", _this._onDrop);
        off(document, "touchend", _this._onDrop);
        off(document, "touchcancel", _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = "move";
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, "drop", _this);
        css(dragEl, "transform", "translateZ(0)");
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, "selectstart", _this);
      moved = true;
      if (Safari) {
        css(document.body, "user-select", "none");
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(evt) {
      var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
      if (_silent)
        return;
      function dragOverEvent(name, extra) {
        pluginEvent2(name, _this, _objectSpread2({
          evt,
          isOwner,
          axis: vertical ? "vertical" : "horizontal",
          revert,
          dragRect,
          targetRect,
          canSort,
          fromSortable,
          target,
          completed,
          onMove: function onMove(target2, after2) {
            return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
          },
          changed
        }, extra));
      }
      function capture() {
        dragOverEvent("dragOverAnimationCapture");
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      }
      function completed(insertion) {
        dragOverEvent("dragOverCompleted", {
          insertion
        });
        if (insertion) {
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          }
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function() {
            dragOverEvent("dragOverAnimationComplete");
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        }
        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        }
        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      }
      function changed() {
        newIndex = index2(dragEl);
        newDraggableIndex = index2(dragEl, options.draggable);
        _dispatchEvent({
          sortable: _this,
          name: "change",
          toEl: el,
          newIndex,
          newDraggableIndex,
          originalEvent: evt
        });
      }
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options.draggable, el, true);
      dragOverEvent("dragOver");
      if (Sortable.eventCanceled)
        return completedFired;
      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === "vertical";
        dragRect = getRect(dragEl);
        dragOverEvent("dragOverValid");
        if (Sortable.eventCanceled)
          return completedFired;
        if (revert) {
          parentEl = rootEl;
          capture();
          this._hideClone();
          dragOverEvent("revert");
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el, options.draggable);
        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          if (elLastChild === dragEl) {
            return completed(false);
          }
          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            if (elLastChild && elLastChild.nextSibling) {
              el.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el.appendChild(dragEl);
            }
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
          var firstChild = getChild(el, 0, options, true);
          if (firstChild === dragEl) {
            return completed(false);
          }
          target = firstChild;
          targetRect = getRect(target);
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el.insertBefore(dragEl, firstChild);
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }
          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;
          if (direction !== 0) {
            var dragIndex = index2(dragEl);
            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
          }
          if (direction === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction;
          var nextSibling2 = target.nextElementSibling, after = false;
          after = direction === 1;
          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling2) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling2 : target);
            }
            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }
            parentEl = dragEl.parentNode;
            if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }
            changed();
            return completed(true);
          }
        }
        if (el.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, "mousemove", this._onTouchMove);
      off(document, "touchmove", this._onTouchMove);
      off(document, "pointermove", this._onTouchMove);
      off(document, "dragover", nearestEmptyInsertDetectEvent);
      off(document, "mousemove", nearestEmptyInsertDetectEvent);
      off(document, "touchmove", nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._onDrop);
      off(ownerDocument, "touchend", this._onDrop);
      off(ownerDocument, "pointerup", this._onDrop);
      off(ownerDocument, "touchcancel", this._onDrop);
      off(document, "selectstart", this);
    },
    _onDrop: function _onDrop(evt) {
      var el = this.el, options = this.options;
      newIndex = index2(dragEl);
      newDraggableIndex = index2(dragEl, options.draggable);
      pluginEvent2("drop", this, {
        evt
      });
      parentEl = dragEl && dragEl.parentNode;
      newIndex = index2(dragEl);
      newDraggableIndex = index2(dragEl, options.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId);
      if (this.nativeDraggable) {
        off(document, "drop", this);
        off(el, "dragstart", this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, "user-select", "");
      }
      css(dragEl, "transform", "");
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, "dragend", this);
          }
          _disableDraggable(dragEl);
          dragEl.style["will-change"] = "";
          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }
          toggleClass(dragEl, this.options.chosenClass, false);
          _dispatchEvent({
            sortable: this,
            name: "unchoose",
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              _dispatchEvent({
                rootEl: parentEl,
                name: "add",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "remove",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                rootEl: parentEl,
                name: "sort",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  sortable: this,
                  name: "update",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }
          if (Sortable.active) {
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: "end",
              toEl: parentEl,
              originalEvent: evt
            });
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent2("nulling", this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function(el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(evt) {
      switch (evt.type) {
        case "drop":
        case "dragend":
          this._onDrop(evt);
          break;
        case "dragenter":
        case "dragover":
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case "selectstart":
          evt.preventDefault();
          break;
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order2 = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
      for (; i < n; i++) {
        el = children[i];
        if (closest(el, options.draggable, this.el, false)) {
          order2.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }
      return order2;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order2, useAnimation) {
      var items = {}, rootEl2 = this.el;
      this.toArray().forEach(function(id, i) {
        var el = rootEl2.children[i];
        if (closest(el, this.options.draggable, rootEl2, false)) {
          items[id] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order2.forEach(function(id) {
        if (items[id]) {
          rootEl2.removeChild(items[id]);
          rootEl2.appendChild(items[id]);
        }
      });
      useAnimation && this.animateAll();
    },
    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name, value) {
      var options = this.options;
      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);
        if (typeof modifiedValue !== "undefined") {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }
        if (name === "group") {
          _prepareGroup(options);
        }
      }
    },
    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent2("destroy", this);
      var el = this.el;
      el[expando] = null;
      off(el, "mousedown", this._onTapStart);
      off(el, "touchstart", this._onTapStart);
      off(el, "pointerdown", this._onTapStart);
      if (this.nativeDraggable) {
        off(el, "dragover", this);
        off(el, "dragenter", this);
      }
      Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
        el2.removeAttribute("draggable");
      });
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent2("hideClone", this);
        if (Sortable.eventCanceled)
          return;
        css(cloneEl, "display", "none");
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable2) {
      if (putSortable2.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent2("showClone", this);
        if (Sortable.eventCanceled)
          return;
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, "display", "");
        cloneHidden = false;
      }
    }
  };
  function _globalDragOver(evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = "move";
    }
    evt.cancelable && evt.preventDefault();
  }
  function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent("move", {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl2;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  function _disableDraggable(el) {
    el.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsFirst(evt, vertical, sortable) {
    var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
  }
  function _ghostIsLast(evt, vertical, sortable) {
    var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
  }
  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
    if (!invertSwap) {
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }
    invert = invert || invertSwap;
    if (invert) {
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }
  function _getInsertDirection(target) {
    if (index2(dragEl) < index2(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
    while (i--) {
      sum += str.charCodeAt(i);
    }
    return sum.toString(36);
  }
  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName("input");
    var idx = inputs.length;
    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }
  function _nextTick(fn2) {
    return setTimeout(fn2, 0);
  }
  function _cancelNextTick(id) {
    return clearTimeout(id);
  }
  if (documentExists) {
    on(document, "touchmove", function(evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  }
  Sortable.utils = {
    on,
    off,
    css,
    find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend3,
    throttle,
    closest,
    toggleClass,
    clone: clone3,
    index: index2,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild
  };
  Sortable.get = function(element) {
    return element[expando];
  };
  Sortable.mount = function() {
    for (var _len = arguments.length, plugins3 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins3[_key] = arguments[_key];
    }
    if (plugins3[0].constructor === Array)
      plugins3 = plugins3[0];
    plugins3.forEach(function(plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }
      if (plugin.utils)
        Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  Sortable.create = function(el, options) {
    return new Sortable(el, options);
  };
  Sortable.version = version2;
  var autoScrolls = [];
  var scrollEl;
  var scrollRootEl;
  var scrolling = false;
  var lastAutoScrollX;
  var lastAutoScrollY;
  var touchEvt$1;
  var pointerElemChangedInterval;
  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      };
      for (var fn2 in this) {
        if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
          this[fn2] = this[fn2].bind(this);
        }
      }
    }
    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;
        if (this.sortable.nativeDraggable) {
          on(document, "dragover", this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, "touchmove", this._handleFallbackAutoScroll);
          } else {
            on(document, "mousemove", this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop3() {
        if (this.sortable.nativeDraggable) {
          off(document, "dragover", this._handleAutoScroll);
        } else {
          off(document, "pointermove", this._handleFallbackAutoScroll);
          off(document, "touchmove", this._handleFallbackAutoScroll);
          off(document, "mousemove", this._handleFallbackAutoScroll);
        }
        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;
        var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
        touchEvt$1 = evt;
        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback);
          var ogElemScroller = getParentAutoScrollElement(elem, true);
          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval();
            pointerElemChangedInterval = setInterval(function() {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }
              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y;
          }
        } else {
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }
          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: "scroll",
      initializeByDefault: true
    });
  }
  function clearAutoScrolls() {
    autoScrolls.forEach(function(autoScroll2) {
      clearInterval(autoScroll2.pid);
    });
    autoScrolls = [];
  }
  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }
  var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
    if (!options.scroll)
      return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
    var scrollThisInstance = false, scrollCustomFn;
    if (scrollRootEl !== rootEl2) {
      scrollRootEl = rootEl2;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl2, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
      }
      var vx = canScrollX && (Math.abs(right2 - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom2 - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }
      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          autoScrolls[layersOut].pid = setInterval(function() {
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1);
            }
            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
            if (typeof scrollCustomFn === "function") {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                return;
              }
            }
            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }
      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance;
  }, 30);
  var drop = function drop2(_ref) {
    var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent)
      return;
    var toSortable = putSortable2 || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent("spill");
      this.onSpill({
        dragEl: dragEl2,
        putSortable: putSortable2
      });
    }
  };
  function Revert() {
  }
  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex2 = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex2;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable2) {
        putSortable2.captureAnimationState();
      }
      var nextSibling2 = getChild(this.sortable.el, this.startIndex, this.options);
      if (nextSibling2) {
        this.sortable.el.insertBefore(dragEl2, nextSibling2);
      } else {
        this.sortable.el.appendChild(dragEl2);
      }
      this.sortable.animateAll();
      if (putSortable2) {
        putSortable2.animateAll();
      }
    },
    drop
  };
  _extends(Revert, {
    pluginName: "revertOnSpill"
  });
  function Remove() {
  }
  Remove.prototype = {
    onSpill: function onSpill2(_ref4) {
      var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
      var parentSortable = putSortable2 || this.sortable;
      parentSortable.captureAnimationState();
      dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
      parentSortable.animateAll();
    },
    drop
  };
  _extends(Remove, {
    pluginName: "removeOnSpill"
  });
  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);

  // node_modules/bali-view-components/app/components/bali/gantt_chart/index.js
  var import_lodash = __toESM(require_lodash());
  init_src2();

  // node_modules/@googlemaps/markerclusterer/dist/index.esm.js
  var import_fast_deep_equal = __toESM(require_fast_deep_equal());
  var MarkerClustererEvents;
  (function(MarkerClustererEvents2) {
    MarkerClustererEvents2["CLUSTERING_BEGIN"] = "clusteringbegin";
    MarkerClustererEvents2["CLUSTERING_END"] = "clusteringend";
    MarkerClustererEvents2["CLUSTER_CLICK"] = "click";
  })(MarkerClustererEvents || (MarkerClustererEvents = {}));

  // node_modules/bali-view-components/app/components/bali/navbar/index.js
  var import_lodash2 = __toESM(require_lodash());

  // node_modules/bali-view-components/app/components/bali/notification/index.js
  var NotificationController = class extends Controller {
    static classes = ["animation"];
    static values = {
      delay: { type: Number, default: 3e3 },
      dismiss: { type: Boolean, default: true }
    };
    connect() {
      this.closed = false;
      if (this.dismissValue) {
        setTimeout(() => this.close(), this.delayValue);
      }
    }
    disconnect() {
      if (this.closed)
        return;
      this.removeElement();
    }
    close() {
      const animationClass = this.hasAnimationClass ? this.animationClass : "fadeOutRight";
      this.element.classList.add(animationClass);
      this.element.addEventListener("animationend", () => {
        this.closed = true;
        this.removeElement();
      });
    }
    removeElement() {
      if (this.element) {
        this.element.remove();
      }
    }
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/index.js
  var import_lodash4 = __toESM(require_lodash());

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/useDefaults.js
  var defaultTargets = [
    "bubbleMenu",
    "alignLeft",
    "alignCenter",
    "alignRight",
    "color"
  ];
  var toolbarExtensions = [
    { target: "alignLeft", name: { textAlign: "left" } },
    { target: "alignCenter", name: { textAlign: "center" } },
    { target: "alignRight", name: { textAlign: "right" } }
  ];
  var useDefaults_default = async (controller, options = {}) => {
    const { default: Document2 } = await Promise.resolve().then(() => (init_dist17(), dist_exports2));
    const { default: Dropcursor2 } = await Promise.resolve().then(() => (init_dist20(), dist_exports3));
    const { default: Gapcursor2 } = await Promise.resolve().then(() => (init_dist23(), dist_exports4));
    const { default: History3 } = await Promise.resolve().then(() => (init_dist27(), dist_exports5));
    const { default: Placeholder2 } = await Promise.resolve().then(() => (init_dist28(), dist_exports6));
    const { default: BubbleMenu2 } = await Promise.resolve().then(() => (init_dist29(), dist_exports7));
    const { default: TextAlign2 } = await Promise.resolve().then(() => (init_dist30(), dist_exports8));
    const { default: Color3 } = await Promise.resolve().then(() => (init_dist32(), dist_exports10));
    const DefaultExtensions = [
      Color3.configure({
        types: ["textStyle"]
      }),
      Document2,
      Dropcursor2,
      Gapcursor2,
      History3,
      Placeholder2.configure({
        placeholder: ({ node }) => {
          if (node.type.name === "heading") {
            return `Heading ${node.attrs.level}`;
          }
          if (node.type.name === "codeBlock")
            return "";
          return options.placeholder;
        }
      }),
      TextAlign2.configure({
        types: ["heading", "paragraph"]
      })
    ];
    const setTextAlignLeft = () => {
      controller.runCommand("setTextAlign", "left");
    };
    const setTextAlignCenter = () => {
      controller.runCommand("setTextAlign", "center");
    };
    const setTextAlignRight = () => {
      controller.runCommand("setTextAlign", "right");
    };
    const setColor = (event) => {
      controller.runCommand("setColor", event.target.value);
    };
    const enableSelectedExtensions = () => {
      toolbarExtensions.forEach(({ target, name }) => {
        if (!controller.editor.isActive(name))
          return;
        const targetNode = controller.targets.find(target);
        if (targetNode) {
          targetNode.classList.add("is-active");
        }
      });
    };
    const enableSelectedColor = () => {
      const targetNode = controller.targets.find("color");
      if (targetNode) {
        targetNode.value = controller.editor.getAttributes("textStyle").color;
      }
    };
    if (controller.editableValue && controller.hasBubbleMenuTarget) {
      DefaultExtensions.push(
        BubbleMenu2.configure({
          element: controller.bubbleMenuTarget,
          tippyOptions: { appendTo: controller.element, duration: 100 }
        })
      );
    }
    Object.assign(controller, {
      setTextAlignLeft,
      setTextAlignCenter,
      setTextAlignRight,
      setColor,
      enableSelectedExtensions,
      enableSelectedColor
    });
    return { DefaultExtensions };
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/useMarks.js
  var marksTargets = ["bold", "italic", "underline", "strike", "link"];
  var toolbarMarks = [
    { target: "bold", name: "bold" },
    { target: "italic", name: "italic" },
    { target: "underline", name: "underline" },
    { target: "strike", name: "strike" },
    { target: "link", name: "link" }
  ];
  var useMarks_default = async (controller, _options = {}) => {
    const { default: Bold2 } = await Promise.resolve().then(() => (init_dist33(), dist_exports11));
    const { default: Code2 } = await Promise.resolve().then(() => (init_dist34(), dist_exports12));
    const { default: Italic2 } = await Promise.resolve().then(() => (init_dist35(), dist_exports13));
    const { default: Strike2 } = await Promise.resolve().then(() => (init_dist36(), dist_exports14));
    const { default: TextStyle4 } = await Promise.resolve().then(() => (init_dist31(), dist_exports9));
    const { default: Underline2 } = await Promise.resolve().then(() => (init_dist37(), dist_exports15));
    const MarkExtensions = [Bold2, Code2, Italic2, Strike2, Underline2, TextStyle4];
    const toggleBold = () => {
      controller.runCommand("toggleBold");
    };
    const toggleItalic = () => {
      controller.runCommand("toggleItalic");
    };
    const toggleUnderline = () => {
      controller.runCommand("toggleUnderline");
    };
    const toggleStrike = () => {
      controller.runCommand("toggleStrike");
    };
    const enableSelectedToolbarMarks = () => {
      toolbarMarks.forEach(({ target, name, attributes }) => {
        if (!controller.editor.isActive(name, attributes))
          return;
        const targetNode = controller.targets.find(target);
        if (targetNode) {
          targetNode.classList.add("is-active");
        }
      });
    };
    Object.assign(controller, {
      toggleBold,
      toggleItalic,
      toggleUnderline,
      toggleStrike,
      enableSelectedToolbarMarks
    });
    return { MarkExtensions };
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/useTable.js
  var defaultOptions2 = {
    resizable: false
  };
  var tableTargets = ["tablePanel", "tableModifier"];
  var useTable_default = async (controller, options = {}) => {
    const { default: Table2 } = await Promise.resolve().then(() => (init_dist40(), dist_exports16));
    const { default: TableRow2 } = await Promise.resolve().then(() => (init_dist41(), dist_exports17));
    const { default: TableCell2 } = await Promise.resolve().then(() => (init_dist42(), dist_exports18));
    const { default: TableHeader2 } = await Promise.resolve().then(() => (init_dist43(), dist_exports19));
    const { resizable } = Object.assign({}, defaultOptions2, options);
    const TableExtensions = [
      Table2.configure({
        resizable
      }),
      TableRow2,
      TableCell2,
      TableHeader2
    ];
    const runTableCommand = (event, name) => {
      if (!controller.editor.isActive("table")) {
        return event.stopPropagation();
      }
      controller.runCommand(name);
    };
    const insertTable = () => {
      controller.runCommand("insertTable", {
        rows: 3,
        cols: 3,
        withHeaderRow: true
      });
    };
    const addColumnBefore2 = (e) => runTableCommand(e, "addColumnBefore");
    const addColumnAfter2 = (e) => runTableCommand(e, "addColumnAfter");
    const addRowBefore2 = (e) => runTableCommand(e, "addRowBefore");
    const addRowAfter2 = (e) => runTableCommand(e, "addRowAfter");
    const deleteColumn2 = (e) => runTableCommand(e, "deleteColumn");
    const deleteRow2 = (e) => runTableCommand(e, "deleteRow");
    const updateTableModifiers = () => {
      const tableIsActive = controller.editor.isActive("table");
      controller.tableModifierTargets.forEach((modifier) => {
        tableIsActive ? modifier.classList.remove("disabled") : modifier.classList.add("disabled");
      });
    };
    const openTablePanel = () => {
      controller.closeNodeSelect();
      controller.closeLinkPanel();
      controller.closeImagePanel();
    };
    const closeTablePanel = () => {
      if (!controller.hasTablePanelTarget)
        return;
      controller.tablePanelTarget.classList.remove("is-active");
    };
    Object.assign(controller, {
      insertTable,
      addColumnBefore: addColumnBefore2,
      addColumnAfter: addColumnAfter2,
      addRowBefore: addRowBefore2,
      addRowAfter: addRowAfter2,
      deleteColumn: deleteColumn2,
      deleteRow: deleteRow2,
      updateTableModifiers,
      openTablePanel,
      closeTablePanel
    });
    return { TableExtensions };
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/useLink.js
  var defaultOptions3 = {
    openOnClick: false
  };
  var linkTargets = ["linkPanel", "linkInput"];
  var useLink_default = async (controller, options = {}) => {
    const { default: Link2 } = await Promise.resolve().then(() => (init_dist44(), dist_exports20));
    const { openOnClick } = Object.assign({}, defaultOptions3, options);
    const LinkExtensions = [
      Link2.configure({
        openOnClick
      })
    ];
    const closeLinkPanel = () => {
      if (!controller.hasLinkPanelTarget)
        return;
      controller.linkPanelTarget.classList.remove("is-active");
    };
    const openLinkPanel = () => {
      controller.closeNodeSelect();
      controller.closeTablePanel();
      controller.closeImagePanel();
      const link = controller.editor.getAttributes("link");
      controller.linkInputTarget.innerHTML = link.href || "";
      controller.linkInputTarget.focus();
    };
    const saveLinkUrl = (event) => {
      if (event.key !== "Enter")
        return;
      const url = event.target.innerHTML;
      if (url === "") {
        controller.editor.chain().focus().extendMarkRange("link").unsetLink().run();
      } else {
        controller.editor.chain().focus().extendMarkRange("link").setLink({ href: event.target.innerHTML, target: "_blank" }).run();
      }
      controller.linkInputTarget.innerHTML = "";
    };
    const savePageLink = (event) => {
      const { url } = event.target.dataset;
      controller.editor.chain().focus().extendMarkRange("link").setLink({ href: url, target: "_self" }).run();
    };
    Object.assign(controller, {
      closeLinkPanel,
      openLinkPanel,
      saveLinkUrl,
      savePageLink
    });
    return { LinkExtensions };
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/useMention.js
  var useMention_default = async (_controller, _options = {}) => {
    const { default: Mention2 } = await Promise.resolve().then(() => (init_dist46(), dist_exports21));
    const { default: suggestion } = await Promise.resolve().then(() => (init_pages_options(), pages_options_exports));
    const MentionExtensions = [
      Mention2.configure({
        HTMLAttributes: {
          class: "suggestion"
        },
        renderLabel({ options, node }) {
          return `${options.suggestion.char}${node.attrs.label}`;
        },
        suggestion
      })
    ];
    return { MentionExtensions };
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/useNodes.js
  var nodesTargets = [
    "nodeSelect",
    "nodeSelectTrigger",
    "text",
    "h1",
    "h2",
    "h3",
    "ul",
    "ol",
    "blockquote",
    "codeBlock"
  ];
  var toolbarNodes = [
    {
      target: "h1",
      name: "heading",
      attributes: { level: 1 },
      text: "Heading 1"
    },
    {
      target: "h2",
      name: "heading",
      attributes: { level: 2 },
      text: "Heading 2"
    },
    {
      target: "h3",
      name: "heading",
      attributes: { level: 3 },
      text: "Heading 3"
    },
    {
      name: "bulletList",
      target: "ul",
      text: "Bulleted List"
    },
    {
      name: "orderedList",
      target: "ol",
      text: "Ordered List"
    },
    {
      name: "blockquote",
      target: "blockquote",
      text: "Quote"
    },
    {
      name: "codeBlock",
      target: "codeBlock",
      text: "Code"
    },
    {
      name: "paragraph",
      target: "text",
      text: "Text"
    }
  ];
  var useNodes_default = async (controller, _options = {}) => {
    const { default: Blockquote2 } = await Promise.resolve().then(() => (init_dist47(), dist_exports22));
    const { default: BulletList2 } = await Promise.resolve().then(() => (init_dist48(), dist_exports23));
    const { default: CodeBlock2 } = await Promise.resolve().then(() => (init_dist49(), dist_exports24));
    const { default: CodeBlockLowlight2 } = await Promise.resolve().then(() => (init_dist50(), dist_exports25));
    const { default: HardBreak2 } = await Promise.resolve().then(() => (init_dist51(), dist_exports26));
    const { default: Heading2 } = await Promise.resolve().then(() => (init_dist52(), dist_exports27));
    const { default: HorizontalRule2 } = await Promise.resolve().then(() => (init_dist53(), dist_exports28));
    const { default: ListItem4 } = await Promise.resolve().then(() => (init_dist54(), dist_exports29));
    const { default: OrderedList2 } = await Promise.resolve().then(() => (init_dist55(), dist_exports30));
    const { default: Paragraph2 } = await Promise.resolve().then(() => (init_dist56(), dist_exports31));
    const { default: Text3 } = await Promise.resolve().then(() => (init_dist57(), dist_exports32));
    const { default: lowlight2 } = await Promise.resolve().then(() => (init_lowlight(), lowlight_exports));
    const NodesExtensions = [
      Blockquote2,
      BulletList2,
      CodeBlock2,
      CodeBlockLowlight2.configure({
        lowlight: lowlight2
      }),
      HardBreak2,
      Heading2,
      HorizontalRule2,
      ListItem4,
      OrderedList2,
      Paragraph2,
      Text3
    ];
    const toggleH1 = () => {
      controller.runCommand("toggleHeading", { level: 1 });
    };
    const toggleH2 = () => {
      controller.runCommand("toggleHeading", { level: 2 });
    };
    const toggleH3 = () => {
      controller.runCommand("toggleHeading", { level: 3 });
    };
    const setParagraph = () => {
      controller.runCommand("setParagraph");
    };
    const toggleBulletList = () => {
      controller.runCommand("toggleBulletList");
    };
    const toggleOrderedList = () => {
      controller.runCommand("toggleOrderedList");
    };
    const toggleBlockquote = () => {
      controller.runCommand("toggleBlockquote");
    };
    const toggleCodeBlock = () => {
      controller.runCommand("toggleCodeBlock");
    };
    const enableSelectedToolbarNode = () => {
      toolbarNodes.some(({ target, name, text, attributes }) => {
        if (!controller.editor.isActive(name, attributes))
          return false;
        const targetNode = controller.targets.find(target);
        if (!targetNode)
          return false;
        if (controller.hasNodeSelectTriggerTarget) {
          controller.nodeSelectTriggerTarget.innerHTML = text;
        }
        targetNode.classList.add("is-active");
        return true;
      });
    };
    const openNodeSelect = () => {
      controller.closeLinkPanel();
      controller.closeTablePanel();
      controller.closeImagePanel();
    };
    const closeNodeSelect = () => {
      if (!controller.hasNodeSelectTarget)
        return;
      controller.nodeSelectTarget.classList.remove("is-active");
    };
    Object.assign(controller, {
      toggleH1,
      toggleH2,
      toggleH3,
      setParagraph,
      toggleBulletList,
      toggleOrderedList,
      toggleBlockquote,
      toggleCodeBlock,
      enableSelectedToolbarNode,
      openNodeSelect,
      closeNodeSelect
    });
    return { NodesExtensions };
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/useImage.js
  init_src2();
  var imageTargets = ["imagePanel", "imageGrid"];
  var useImage_default = async (controller, _options = {}) => {
    const { default: Image2 } = await Promise.resolve().then(() => (init_dist58(), dist_exports33));
    const ImageExtensions = [Image2];
    const reloadImages = async () => {
      const response = await get(controller.imagesUrlValue);
      if (response.ok) {
        controller.imageGridTarget.innerHTML = await response.html;
      }
    };
    let isOpen = false;
    const openImagePanel = () => {
      controller.closeNodeSelect();
      controller.closeTablePanel();
      controller.closeLinkPanel();
      if (!controller.hasImagePanelTarget)
        return;
      isOpen = true;
      reloadImages();
      controller.imagePanelTarget.classList.add("is-active");
    };
    const closeImagePanel = () => {
      if (!controller.hasImagePanelTarget)
        return;
      isOpen = false;
      controller.imagePanelTarget.classList.remove("is-active");
    };
    const toggleImagePanel = () => {
      if (isOpen) {
        closeImagePanel();
      } else {
        openImagePanel();
      }
    };
    const addImage = (event) => {
      controller.runCommand("setImage", {
        src: event.target.dataset.sourceUrl
      });
    };
    Object.assign(controller, {
      openImagePanel,
      closeImagePanel,
      toggleImagePanel,
      addImage
    });
    return { ImageExtensions };
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/javascript/useSlashCommands.js
  var useSlashCommands_default = async (_controller, _options = {}) => {
    const { default: SlashCommands } = await Promise.resolve().then(() => (init_slashCommands(), slashCommands_exports));
    const { default: suggestion } = await Promise.resolve().then(() => (init_commands_options(), commands_options_exports));
    const SlashCommandsExtension = [SlashCommands.configure({ suggestion })];
    return { SlashCommandsExtension };
  };

  // node_modules/bali-view-components/app/components/bali/rich_text_editor/index.js
  var RichTextEditorController = class extends Controller {
    static targets = [
      ...defaultTargets,
      ...nodesTargets,
      ...marksTargets,
      ...linkTargets,
      ...tableTargets,
      ...imageTargets,
      "output"
    ];
    static values = {
      content: { type: String, default: "" },
      placeholder: { type: String, default: "" },
      editable: { type: Boolean, default: true },
      imagesUrl: String
    };
    allMenuButtons = toolbarMarks.concat(toolbarNodes, toolbarExtensions);
    async connect() {
      const { Editor: Editor2 } = await Promise.resolve().then(() => (init_dist16(), dist_exports));
      const { DefaultExtensions } = await useDefaults_default(this, {
        placeholder: this.placeholderValue
      });
      const { NodesExtensions } = await useNodes_default(this);
      const { MarkExtensions } = await useMarks_default(this);
      const { TableExtensions } = await useTable_default(this);
      const { LinkExtensions } = await useLink_default(this);
      const { MentionExtensions } = await useMention_default(this);
      const { ImageExtensions } = await useImage_default(this);
      const { SlashCommandsExtension } = await useSlashCommands_default(this);
      this.editor = new Editor2({
        element: this.element,
        extensions: [
          ...DefaultExtensions,
          ...NodesExtensions,
          ...MarkExtensions,
          ...LinkExtensions,
          ...TableExtensions,
          ...MentionExtensions,
          ...ImageExtensions,
          ...SlashCommandsExtension
        ],
        autofocus: true,
        content: this.contentValue,
        onUpdate: this.throttledUpdate,
        editable: this.editableValue
      });
      this.editor.on("transaction", () => {
        this.closeAllPanels();
        this.resetMenuButtons();
        this.enableSelectedToolbarMarks();
        this.enableSelectedToolbarNode();
        this.enableSelectedExtensions();
        this.enableSelectedColor();
        this.updateTableModifiers();
      });
    }
    disconnect() {
      this.editor.destroy();
    }
    onUpdate = ({ editor }) => {
      if (!this.hasOutputTarget)
        return;
      this.outputTarget.value = editor.getHTML();
    };
    throttledUpdate = (0, import_lodash4.default)(this.onUpdate, 1e3);
    runCommand(name, attributes) {
      const editor = this.editor.chain().focus();
      editor[name](attributes).run();
    }
    closeAllPanels() {
      this.closeNodeSelect();
      this.closeLinkPanel();
      this.closeTablePanel();
      this.closeImagePanel();
    }
    resetMenuButtons() {
      this.allMenuButtons.forEach(({ target }) => {
        const targetNode = this.targets.find(target);
        if (targetNode) {
          targetNode.classList.remove("is-active");
        }
      });
    }
    hideMenu() {
      this.editor.chain().focus().blur().run();
    }
  };

  // node_modules/bali-view-components/app/components/bali/sortable_list/index.js
  init_src2();

  // node_modules/bali-view-components/app/components/bali/tabs/index.js
  init_src2();
  var TabsController = class extends Controller {
    static targets = ["tab", "tabContent"];
    connect() {
      if (!this.hasTabTarget)
        return;
      this._loadActiveTabContent();
    }
    open(event) {
      event.preventDefault();
      this._hideAllTabs();
      this._openTab(event.params, event.currentTarget);
    }
    _hideAllTabs() {
      this.tabContentTargets.forEach((tc) => tc.classList.add("is-hidden"));
      this.tabTargets.forEach((t) => t.classList.remove("is-active"));
    }
    _openTab(params, tabLi) {
      const contentDiv = this.tabContentTargets.find(
        (t) => t.dataset.tabsIndexParam === params.index.toString()
      );
      contentDiv.classList.remove("is-hidden");
      tabLi.classList.add("is-active");
      this._loadTabContent(tabLi, contentDiv, params);
    }
    _loadActiveTabContent() {
      const activeTab = this.tabTargets.find(
        (t) => t.classList.contains("is-active")
      );
      const activeTabContent = this.tabContentTargets.find(
        (t) => t.dataset.tabsIndexParam === activeTab.dataset.tabsIndexParam
      );
      const src = activeTab.dataset.tabsSrcParam;
      const reload = activeTab.dataset.tabsReloadParam;
      this._loadTabContent(activeTab, activeTabContent, { src, reload });
    }
    async _loadTabContent(tabLi, tabContentDiv, { src, reload }) {
      if (!src)
        return;
      const contentLoaded = tabLi.dataset.contentLoaded;
      if (reload.toString() === "false" && contentLoaded)
        return;
      const response = await get(src, { query: { layout: false } });
      if (response.ok) {
        const body = await response.text;
        tabContentDiv.innerHTML = body;
        tabLi.dataset.contentLoaded = true;
      }
    }
  };

  // node_modules/bali-view-components/app/components/bali/tree_view/item/index.js
  var TreeViewItemController = class extends Controller {
    static targets = ["caret", "children"];
    static values = { url: String };
    toggle(event) {
      event.preventDefault();
      this.caretTarget.classList.toggle("caret-down");
      if (this.hasChildrenTarget) {
        this.childrenTarget.classList.toggle("is-hidden");
      }
    }
    navigateTo(event) {
      if (this.caretTarget === event.target)
        return;
      if (window.Turbo) {
        window.Turbo.visit(this.urlValue);
      } else {
        event.preventDefault();
        console.log("Turbo not configured");
      }
    }
  };

  // node_modules/bali-view-components/app/javascript/bali/controllers/elements-overlap-controller.js
  var import_lodash5 = __toESM(require_lodash());

  // node_modules/bali-view-components/app/javascript/bali/controllers/file-input-controller.js
  var FileInputController = class extends Controller {
    static targets = ["value", "input"];
    static values = {
      nonSelectedText: String,
      multiple: { type: Boolean, default: false }
    };
    connect() {
      this.filesArray = [];
    }
    onChange(event) {
      const newFiles = Array.from(event.target.files);
      this.filesArray = this.filesArray.concat(newFiles);
      this.updateFileList();
    }
    removeFile(event) {
      event.preventDefault();
      const { name } = event.params;
      this.filesArray = this.filesArray.filter((f) => f.name !== name);
      this.updateFileList();
    }
    updateFileList() {
      this.inputTarget.files = this.convertToFileList();
      this.valueTarget.innerHTML = this.filesValueContent();
    }
    convertToFileList() {
      const dataTransfer = new DataTransfer();
      this.filesArray.forEach((file) => dataTransfer.items.add(file));
      return dataTransfer.files;
    }
    filesValueContent() {
      if (this.filesArray.length === 0) {
        return this.nonSelectedTextValue;
      }
      if (!this.multipleValue) {
        return this.filesArray.map((f) => f.name).join(", ");
      }
      return this.filesListUI();
    }
    filesListUI() {
      return `
      <ul>
        ${this.filesArray.map((file) => this.fileItemUI(file)).join("")}
      </ul>
    `;
    }
    fileItemUI(file) {
      return `
      <li>
        <span>${file.name}</span>
        <a data-action="file-input#removeFile" data-file-input-name-param="${file.name}">
          <span class="icon-component icon has-text-danger">
            <svg viewBox="0 0 448 512" class="svg-inline">
              <path fill="currentColor"
                d="M268 416h24a12 12 0 0012-12V188a12 12 0 00-12-12h-24a12 12 0 00-12 12v216a12 12 0 0012 12zM432 80h-82.4l-34-56.7A48 48 0 00274.4 0H173.6a48 48 0 00-41.2 23.3L98.4 80H16A16 16 0 000 96v16a16 16 0 0016 16h16v336a48 48 0 0048 48h288a48 48 0 0048-48V128h16a16 16 0 0016-16V96a16 16 0 00-16-16zM171.8 51a6 6 0 015.2-3h94a6 6 0 015.2 3l17.4 29H154.4zM368 464H80V128h288zm-212-48h24a12 12 0 0012-12V188a12 12 0 00-12-12h-24a12 12 0 00-12 12v216a12 12 0 0012 12z"
                class=""></path>
            </svg>
          </span>
        </a>
      </li>
    `;
    }
  };

  // node_modules/bali-view-components/app/javascript/bali/controllers/input-on-change-controller.js
  init_src2();

  // node_modules/bali-view-components/app/javascript/bali/controllers/print-controller.js
  var PrintController = class extends Controller {
    connect() {
      window.print();
      window.onfocus = window.close;
    }
  };

  // node_modules/bali-view-components/app/javascript/bali/controllers/slim-select-controller.js
  init_src2();
  var SlimSelectController = class extends Controller {
    static values = {
      addItems: Boolean,
      showContent: String,
      showSearch: Boolean,
      searchPlaceholder: String,
      addToBody: Boolean,
      closeOnSelect: Boolean,
      allowDeselectOption: Boolean,
      ajaxParamName: String,
      ajaxValueName: String,
      ajaxTextName: String,
      ajaxUrl: String,
      placeholder: { type: String, default: "Select value" },
      ajaxPlaceholder: {
        type: String,
        default: "Type 2 chars to search..."
      }
    };
    static targets = ["select", "selectAllButton", "deselectAllButton"];
    async connect() {
      const { default: SlimSelect } = await Promise.resolve().then(() => __toESM(require_slimselect()));
      const options = {
        select: this.selectTarget,
        settings: {
          placeholderText: this.placeholderValue,
          showSearch: this.showSearchValue,
          openPosition: this.showContentValue === "undefined" ? "down" : this.showContentValue,
          searchPlaceholder: this.searchPlaceholderValue,
          closeOnSelect: this.closeOnSelectValue,
          allowDeselect: this.allowDeselectOptionValue
        },
        events: {}
      };
      if (this.hasInnerHTML()) {
        options.data = this.dataWithHTML();
      }
      if (this.hasAjaxValues()) {
        options.events.search = this.search;
      }
      if (this.addItemsValue) {
        options.events.addable = (value) => value;
      }
      this.select = new SlimSelect(options);
    }
    disconnect() {
      this.select.destroy();
    }
    dataWithHTML() {
      return Array.from(this.selectTarget.children).map((option2) => {
        return {
          text: option2.text,
          value: option2.value,
          innerHTML: option2.dataset.innerHtml,
          selected: option2.selected,
          disabled: option2.disabled
        };
      });
    }
    hasInnerHTML() {
      const firstOption = this.selectTarget.children[0];
      return firstOption && !!firstOption.dataset.innerHtml;
    }
    selectAll() {
      const allValues = Array.from(this.selectTarget.children).map(
        (option2) => option2.value
      );
      this.select.set(allValues);
      this.selectAllButtonTarget.style.display = "none";
      this.deselectAllButtonTarget.style.display = "block";
    }
    deselectAll() {
      this.select.set([]);
      this.deselectAllButtonTarget.style.display = "none";
      this.selectAllButtonTarget.style.display = "block";
    }
    search = (search, currentData) => {
      return new Promise((resolve2, reject) => {
        if (search.length < 2) {
          return reject(this.ajaxPlaceholderValue);
        }
        get(
          this.ajaxUrlValue,
          { query: { [this.ajaxParamNameValue]: search }, responseKind: "json" }
        ).then((response) => response.json).then((data) => {
          const options = data.map((record) => {
            return {
              text: record[this.ajaxTextNameValue],
              value: record[this.ajaxValueNameValue]
            };
          });
          resolve2(options);
        });
      });
    };
    hasAjaxValues() {
      return this.hasAjaxParamNameValue && this.hasAjaxValueNameValue && this.hasAjaxTextNameValue && this.hasAjaxUrlValue;
    }
  };

  // node_modules/bali-view-components/app/javascript/bali/controllers/submit-on-change-controller.js
  var import_lodash6 = __toESM(require_lodash2());
  var SubmitOnChangeController = class extends Controller {
    static values = { delay: Number, action: String, method: String };
    connect() {
      if (this.hasDelayValue && this.delayValue > 0) {
        this.submit = (0, import_lodash6.default)(this.submit, this.delayValue);
      }
      if (this.hasActionValue || this.hasMethodValue) {
        this.submitterNode = this.createSubmitterNode();
        this.element.appendChild(this.submitterNode);
      }
    }
    async submit() {
      this.element.requestSubmit(this.submitterNode);
    }
    createSubmitterNode() {
      const input = document.createElement("input");
      input.type = "submit";
      input.className = "is-hidden";
      input.setAttribute("formaction", this.formAction);
      input.setAttribute("formmethod", this.formMethod);
      return input;
    }
    get formAction() {
      return this.hasActionValue ? this.actionValue : this.element.getAttribute("action");
    }
    get formMethod() {
      return this.hasMethodValue ? this.methodValue : this.element.getAttribute("method");
    }
  };

  // app/javascript/documentation/application.js
  var application = Application.start();
  application.register("dropdown", DropdownController);
  application.register("file-input", FileInputController);
  application.register("modal", ModalController);
  application.register("notification", NotificationController);
  application.register("print", PrintController);
  application.register("rich-text-editor", RichTextEditorController);
  application.register("slim-select", SlimSelectController);
  application.register("submit-on-change", SubmitOnChangeController);
  application.register("tabs", TabsController);
  application.register("tree-view-item", TreeViewItemController);
})();
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.1
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.1
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   *)

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.2
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)

@googlemaps/markerclusterer/dist/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=application.js.map
