(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from5, except, desc) => {
    if (from5 && typeof from5 === "object" || typeof from5 === "function") {
      for (let key2 of __getOwnPropNames(from5))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from5[key2], enumerable: !(desc = __getOwnPropDesc(from5, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __publicField = (obj, key2, value) => {
    __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
    return value;
  };

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: self.console,
        WebSocket: self.WebSocket
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => new Date().getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(() => {
            this.reconnectIfStale();
            this.poll();
          }, this.getPollInterval());
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(() => {
              if (this.connectionIsStale() || !this.connection.isOpen()) {
                logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                this.connection.reopen();
              }
            }, 200);
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, protocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isActive()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error3) {
              logger_default.log("Failed to reopen WebSocket", error3);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              return this.subscriptions.notify(identifier, "connected");
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key2 in properties) {
            const value = properties[key2];
            object[key2] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(() => {
            if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
              this.pendingSubscriptions.map((subscription) => {
                logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                this.subscriptions.subscribe(subscription);
              });
            }
          }, 500);
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s) => s !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s) => s.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command2) {
          const { identifier } = subscription;
          return this.consumer.send({ command: command2, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a = document.createElement("a");
      a.href = url;
      a.href = a.href;
      a.protocol = a.protocol.replace("http", "ws");
      return a.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // node_modules/lodash.throttle/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.throttle/index.js"(exports2, module2) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now2 = function() {
        return root.Date.now();
      };
      function debounce3(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result3 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result3, maxWait - timeSinceLastInvoke) : result3;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result2;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush2() {
          return timerId === void 0 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush2;
        return debounced;
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce3(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function isObject2(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module2.exports = throttle2;
    }
  });

  // node_modules/slim-select/dist/slimselect.min.mjs
  var slimselect_min_exports = {};
  __export(slimselect_min_exports, {
    default: () => slimselect_min_default
  });
  var exports, slimselect_min_default;
  var init_slimselect_min = __esm({
    "node_modules/slim-select/dist/slimselect.min.mjs"() {
      exports = {};
      !function(e, t) {
        typeof exports == "object" && typeof module == "object" ? module.exports = t() : typeof define == "function" && define.amd ? define([], t) : typeof exports == "object" ? exports.SlimSelect = t() : e.SlimSelect = t();
      }(window, function() {
        return n = {}, s.m = i = [function(e, t, i2) {
          "use strict";
          function n2(e2, t2) {
            t2 = t2 || { bubbles: false, cancelable: false, detail: void 0 };
            var i3 = document.createEvent("CustomEvent");
            return i3.initCustomEvent(e2, t2.bubbles, t2.cancelable, t2.detail), i3;
          }
          t.__esModule = true, t.kebabCase = t.highlight = t.isValueInArrayOfObjects = t.debounce = t.putContent = t.ensureElementInView = t.hasClassInTree = void 0, t.hasClassInTree = function(e2, t2) {
            function n3(e3, t3) {
              return t3 && e3 && e3.classList && e3.classList.contains(t3) ? e3 : null;
            }
            return n3(e2, t2) || function e3(t3, i3) {
              return t3 && t3 !== document ? n3(t3, i3) ? t3 : e3(t3.parentNode, i3) : null;
            }(e2, t2);
          }, t.ensureElementInView = function(e2, t2) {
            var i3 = e2.scrollTop + e2.offsetTop, n3 = i3 + e2.clientHeight, s2 = t2.offsetTop, t2 = s2 + t2.clientHeight;
            s2 < i3 ? e2.scrollTop -= i3 - s2 : n3 < t2 && (e2.scrollTop += t2 - n3);
          }, t.putContent = function(e2, t2, i3) {
            var n3 = e2.offsetHeight, s2 = e2.getBoundingClientRect(), e2 = i3 ? s2.top : s2.top - n3, n3 = i3 ? s2.bottom : s2.bottom + n3;
            return e2 <= 0 ? "below" : n3 >= window.innerHeight ? "above" : i3 ? t2 : "below";
          }, t.debounce = function(s2, a, o) {
            var l;
            return a === void 0 && (a = 100), o === void 0 && (o = false), function() {
              for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
                e2[t2] = arguments[t2];
              var i3 = self, n3 = o && !l;
              clearTimeout(l), l = setTimeout(function() {
                l = null, o || s2.apply(i3, e2);
              }, a), n3 && s2.apply(i3, e2);
            };
          }, t.isValueInArrayOfObjects = function(e2, t2, i3) {
            if (!Array.isArray(e2))
              return e2[t2] === i3;
            for (var n3 = 0, s2 = e2; n3 < s2.length; n3++) {
              var a = s2[n3];
              if (a && a[t2] && a[t2] === i3)
                return true;
            }
            return false;
          }, t.highlight = function(e2, t2, i3) {
            var n3 = e2, s2 = new RegExp("(" + t2.trim() + ")(?![^<]*>[^<>]*</)", "i");
            if (!e2.match(s2))
              return e2;
            var a = e2.match(s2).index, t2 = a + e2.match(s2)[0].toString().length, t2 = e2.substring(a, t2);
            return n3 = n3.replace(s2, '<mark class="'.concat(i3, '">').concat(t2, "</mark>"));
          }, t.kebabCase = function(e2) {
            var t2 = e2.replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, function(e3) {
              return "-" + e3.toLowerCase();
            });
            return e2[0] === e2[0].toUpperCase() ? t2.substring(1) : t2;
          }, typeof (t = window).CustomEvent != "function" && (n2.prototype = t.Event.prototype, t.CustomEvent = n2);
        }, function(e, t, i2) {
          "use strict";
          t.__esModule = true, t.validateOption = t.validateData = t.Data = void 0;
          var n2 = (s2.prototype.newOption = function(e2) {
            return { id: e2.id || String(Math.floor(1e8 * Math.random())), value: e2.value || "", text: e2.text || "", innerHTML: e2.innerHTML || "", selected: e2.selected || false, display: e2.display === void 0 || e2.display, disabled: e2.disabled || false, placeholder: e2.placeholder || false, class: e2.class || void 0, data: e2.data || {}, mandatory: e2.mandatory || false };
          }, s2.prototype.add = function(e2) {
            this.data.push({ id: String(Math.floor(1e8 * Math.random())), value: e2.value, text: e2.text, innerHTML: "", selected: false, display: true, disabled: false, placeholder: false, class: void 0, mandatory: e2.mandatory, data: {} });
          }, s2.prototype.parseSelectData = function() {
            this.data = [];
            for (var e2 = 0, t2 = this.main.select.element.childNodes; e2 < t2.length; e2++) {
              var i3 = t2[e2];
              if (i3.nodeName === "OPTGROUP") {
                for (var n3 = { label: i3.label, options: [] }, s3 = 0, a = i3.childNodes; s3 < a.length; s3++) {
                  var o, l = a[s3];
                  l.nodeName === "OPTION" && (o = this.pullOptionData(l), n3.options.push(o), o.placeholder && o.text.trim() !== "" && (this.main.config.placeholderText = o.text));
                }
                this.data.push(n3);
              } else
                i3.nodeName === "OPTION" && (o = this.pullOptionData(i3), this.data.push(o), o.placeholder && o.text.trim() !== "" && (this.main.config.placeholderText = o.text));
            }
          }, s2.prototype.pullOptionData = function(e2) {
            return { id: !!e2.dataset && e2.dataset.id || String(Math.floor(1e8 * Math.random())), value: e2.value, text: e2.text, innerHTML: e2.innerHTML, selected: e2.selected, disabled: e2.disabled, placeholder: e2.dataset.placeholder === "true", class: e2.className, style: e2.style.cssText, data: e2.dataset, mandatory: !!e2.dataset && e2.dataset.mandatory === "true" };
          }, s2.prototype.setSelectedFromSelect = function() {
            if (this.main.config.isMultiple) {
              for (var e2 = [], t2 = 0, i3 = this.main.select.element.options; t2 < i3.length; t2++) {
                var n3 = i3[t2];
                !n3.selected || (n3 = this.getObjectFromData(n3.value, "value")) && n3.id && e2.push(n3.id);
              }
              this.setSelected(e2, "id");
            } else {
              var s3 = this.main.select.element;
              s3.selectedIndex !== -1 && (s3 = s3.options[s3.selectedIndex].value, this.setSelected(s3, "value"));
            }
          }, s2.prototype.setSelected = function(e2, t2) {
            t2 === void 0 && (t2 = "id");
            for (var i3 = 0, n3 = this.data; i3 < n3.length; i3++) {
              var s3 = n3[i3];
              if (s3.hasOwnProperty("label")) {
                if (s3.hasOwnProperty("options")) {
                  var a = s3.options;
                  if (a)
                    for (var o = 0, l = a; o < l.length; o++) {
                      var r2 = l[o];
                      r2.placeholder || (r2.selected = this.shouldBeSelected(r2, e2, t2));
                    }
                }
              } else
                s3.selected = this.shouldBeSelected(s3, e2, t2);
            }
          }, s2.prototype.shouldBeSelected = function(e2, t2, i3) {
            if (i3 === void 0 && (i3 = "id"), Array.isArray(t2))
              for (var n3 = 0, s3 = t2; n3 < s3.length; n3++) {
                var a = s3[n3];
                if (i3 in e2 && String(e2[i3]) === String(a))
                  return true;
              }
            else if (i3 in e2 && String(e2[i3]) === String(t2))
              return true;
            return false;
          }, s2.prototype.getSelected = function() {
            for (var e2 = { text: "", placeholder: this.main.config.placeholderText }, t2 = [], i3 = 0, n3 = this.data; i3 < n3.length; i3++) {
              var s3 = n3[i3];
              if (s3.hasOwnProperty("label")) {
                if (s3.hasOwnProperty("options")) {
                  var a = s3.options;
                  if (a)
                    for (var o = 0, l = a; o < l.length; o++) {
                      var r2 = l[o];
                      r2.selected && (this.main.config.isMultiple ? t2.push(r2) : e2 = r2);
                    }
                }
              } else
                s3.selected && (this.main.config.isMultiple ? t2.push(s3) : e2 = s3);
            }
            return this.main.config.isMultiple ? t2 : e2;
          }, s2.prototype.addToSelected = function(e2, t2) {
            if (t2 === void 0 && (t2 = "id"), this.main.config.isMultiple) {
              var i3 = [], n3 = this.getSelected();
              if (Array.isArray(n3))
                for (var s3 = 0, a = n3; s3 < a.length; s3++) {
                  var o = a[s3];
                  i3.push(o[t2]);
                }
              i3.push(e2), this.setSelected(i3, t2);
            }
          }, s2.prototype.removeFromSelected = function(e2, t2) {
            if (t2 === void 0 && (t2 = "id"), this.main.config.isMultiple) {
              for (var i3 = [], n3 = 0, s3 = this.getSelected(); n3 < s3.length; n3++) {
                var a = s3[n3];
                String(a[t2]) !== String(e2) && i3.push(a[t2]);
              }
              this.setSelected(i3, t2);
            }
          }, s2.prototype.onDataChange = function() {
            this.main.onChange && this.isOnChangeEnabled && this.main.onChange(JSON.parse(JSON.stringify(this.getSelected())));
          }, s2.prototype.getObjectFromData = function(e2, t2) {
            t2 === void 0 && (t2 = "id");
            for (var i3 = 0, n3 = this.data; i3 < n3.length; i3++) {
              var s3 = n3[i3];
              if (t2 in s3 && String(s3[t2]) === String(e2))
                return s3;
              if (s3.hasOwnProperty("options")) {
                if (s3.options)
                  for (var a = 0, o = s3.options; a < o.length; a++) {
                    var l = o[a];
                    if (String(l[t2]) === String(e2))
                      return l;
                  }
              }
            }
            return null;
          }, s2.prototype.search = function(n3) {
            var s3, e2;
            (this.searchValue = n3).trim() !== "" ? (s3 = this.main.config.searchFilter, e2 = this.data.slice(0), n3 = n3.trim(), e2 = e2.map(function(e3) {
              if (e3.hasOwnProperty("options")) {
                var t2 = e3, i3 = [];
                if ((i3 = t2.options ? t2.options.filter(function(e4) {
                  return s3(e4, n3);
                }) : i3).length !== 0) {
                  t2 = Object.assign({}, t2);
                  return t2.options = i3, t2;
                }
              }
              if (e3.hasOwnProperty("text") && s3(e3, n3))
                return e3;
              return null;
            }), this.filtered = e2.filter(function(e3) {
              return e3;
            })) : this.filtered = null;
          }, s2);
          function s2(e2) {
            this.contentOpen = false, this.contentPosition = "below", this.isOnChangeEnabled = true, this.main = e2.main, this.searchValue = "", this.data = [], this.filtered = null, this.parseSelectData(), this.setSelectedFromSelect();
          }
          function r(e2) {
            return e2.text !== void 0 || (console.error("Data object option must have at least have a text value. Check object: " + JSON.stringify(e2)), false);
          }
          t.Data = n2, t.validateData = function(e2) {
            if (!e2)
              return console.error("Data must be an array of objects"), false;
            for (var t2 = 0, i3 = 0, n3 = e2; i3 < n3.length; i3++) {
              var s3 = n3[i3];
              if (s3.hasOwnProperty("label")) {
                if (s3.hasOwnProperty("options")) {
                  var a = s3.options;
                  if (a)
                    for (var o = 0, l = a; o < l.length; o++)
                      r(l[o]) || t2++;
                }
              } else
                r(s3) || t2++;
            }
            return t2 === 0;
          }, t.validateOption = r;
        }, function(e, t, i2) {
          "use strict";
          t.__esModule = true;
          var n2 = i2(3), s2 = i2(4), a = i2(5), r = i2(1), o = i2(0), i2 = (l.prototype.validate = function(e2) {
            e2 = typeof e2.select == "string" ? document.querySelector(e2.select) : e2.select;
            if (!e2)
              throw new Error("Could not find select element");
            if (e2.tagName !== "SELECT")
              throw new Error("Element isnt of type select");
            return e2;
          }, l.prototype.selected = function() {
            if (this.config.isMultiple) {
              for (var e2 = [], t2 = 0, i3 = s3 = this.data.getSelected(); t2 < i3.length; t2++) {
                var n3 = i3[t2];
                e2.push(n3.value);
              }
              return e2;
            }
            var s3;
            return (s3 = this.data.getSelected()) ? s3.value : "";
          }, l.prototype.set = function(e2, t2, i3, n3) {
            t2 === void 0 && (t2 = "value"), i3 === void 0 && (i3 = true), n3 === void 0 && (n3 = true), this.config.isMultiple && !Array.isArray(e2) ? this.data.addToSelected(e2, t2) : this.data.setSelected(e2, t2), this.select.setValue(), this.data.onDataChange(), this.render(), (i3 = this.config.hideSelectedOption && this.config.isMultiple && this.data.getSelected().length === this.data.data.length ? true : i3) && this.close();
          }, l.prototype.setSelected = function(e2, t2, i3, n3) {
            this.set(e2, t2 = t2 === void 0 ? "value" : t2, i3 = i3 === void 0 ? true : i3, n3 = n3 === void 0 ? true : n3);
          }, l.prototype.setData = function(e2) {
            if ((0, r.validateData)(e2)) {
              for (var t2 = JSON.parse(JSON.stringify(e2)), i3 = this.data.getSelected(), n3 = 0; n3 < t2.length; n3++)
                t2[n3].value || t2[n3].placeholder || (t2[n3].value = t2[n3].text);
              if (this.config.isAjax && i3)
                if (this.config.isMultiple)
                  for (var s3 = 0, a2 = i3.reverse(); s3 < a2.length; s3++) {
                    var o2 = a2[s3];
                    t2.unshift(o2);
                  }
                else {
                  t2.unshift(i3);
                  for (n3 = 0; n3 < t2.length; n3++)
                    t2[n3].placeholder || t2[n3].value !== i3.value || t2[n3].text !== i3.text || t2.splice(n3, 1);
                  for (var l2 = false, n3 = 0; n3 < t2.length; n3++)
                    t2[n3].placeholder && (l2 = true);
                  l2 || t2.unshift({ text: "", placeholder: true });
                }
              this.select.create(t2), this.data.parseSelectData(), this.data.setSelectedFromSelect();
            } else
              console.error("Validation problem on: #" + this.select.element.id);
          }, l.prototype.addData = function(e2) {
            (0, r.validateData)([e2]) ? (this.data.add(this.data.newOption(e2)), this.select.create(this.data.data), this.data.parseSelectData(), this.data.setSelectedFromSelect(), this.render()) : console.error("Validation problem on: #" + this.select.element.id);
          }, l.prototype.open = function() {
            var e2, t2 = this;
            this.config.isEnabled && (this.data.contentOpen || this.config.hideSelectedOption && this.config.isMultiple && this.data.getSelected().length === this.data.data.length || (this.beforeOpen && this.beforeOpen(), this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.plus.classList.add("ss-cross") : this.slim.singleSelected && (this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-down"), this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-up")), this.slim[this.config.isMultiple ? "multiSelected" : "singleSelected"].container.classList.add(this.data.contentPosition === "above" ? this.config.openAbove : this.config.openBelow), this.config.addToBody && (e2 = this.slim.container.getBoundingClientRect(), this.slim.content.style.top = e2.top + e2.height + window.scrollY + "px", this.slim.content.style.left = e2.left + window.scrollX + "px", this.slim.content.style.width = e2.width + "px"), this.slim.content.classList.add(this.config.open), this.config.showContent.toLowerCase() === "up" || this.config.showContent.toLowerCase() !== "down" && (0, o.putContent)(this.slim.content, this.data.contentPosition, this.data.contentOpen) === "above" ? this.moveContentAbove() : this.moveContentBelow(), this.config.isMultiple || (e2 = this.data.getSelected()) && (e2 = e2.id, (e2 = this.slim.list.querySelector('[data-id="' + e2 + '"]')) && (0, o.ensureElementInView)(this.slim.list, e2)), setTimeout(function() {
              t2.data.contentOpen = true, t2.config.searchFocus && t2.slim.search.input.focus(), t2.afterOpen && t2.afterOpen();
            }, this.config.timeoutDelay)));
          }, l.prototype.close = function() {
            var e2 = this;
            this.data.contentOpen && (this.beforeClose && this.beforeClose(), this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove), this.slim.multiSelected.container.classList.remove(this.config.openBelow), this.slim.multiSelected.plus.classList.remove("ss-cross")) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openAbove), this.slim.singleSelected.container.classList.remove(this.config.openBelow), this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-down"), this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-up")), this.slim.content.classList.remove(this.config.open), this.data.contentOpen = false, this.search(""), setTimeout(function() {
              e2.slim.content.removeAttribute("style"), e2.data.contentPosition = "below", e2.config.isMultiple && e2.slim.multiSelected ? (e2.slim.multiSelected.container.classList.remove(e2.config.openAbove), e2.slim.multiSelected.container.classList.remove(e2.config.openBelow)) : e2.slim.singleSelected && (e2.slim.singleSelected.container.classList.remove(e2.config.openAbove), e2.slim.singleSelected.container.classList.remove(e2.config.openBelow)), e2.slim.search.input.blur(), e2.afterClose && e2.afterClose();
            }, this.config.timeoutDelay));
          }, l.prototype.moveContentAbove = function() {
            var e2 = 0;
            this.config.isMultiple && this.slim.multiSelected ? e2 = this.slim.multiSelected.container.offsetHeight : this.slim.singleSelected && (e2 = this.slim.singleSelected.container.offsetHeight);
            var t2 = e2 + this.slim.content.offsetHeight - 1;
            this.slim.content.style.margin = "-" + t2 + "px 0 0 0", this.slim.content.style.height = t2 - e2 + 1 + "px", this.slim.content.style.transformOrigin = "center bottom", this.data.contentPosition = "above", this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openBelow), this.slim.multiSelected.container.classList.add(this.config.openAbove)) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openBelow), this.slim.singleSelected.container.classList.add(this.config.openAbove));
          }, l.prototype.moveContentBelow = function() {
            this.data.contentPosition = "below", this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove), this.slim.multiSelected.container.classList.add(this.config.openBelow)) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openAbove), this.slim.singleSelected.container.classList.add(this.config.openBelow));
          }, l.prototype.enable = function() {
            this.config.isEnabled = true, this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.container.classList.remove(this.config.disabled) : this.slim.singleSelected && this.slim.singleSelected.container.classList.remove(this.config.disabled), this.select.triggerMutationObserver = false, this.select.element.disabled = false, this.slim.search.input.disabled = false, this.select.triggerMutationObserver = true;
          }, l.prototype.disable = function() {
            this.config.isEnabled = false, this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.container.classList.add(this.config.disabled) : this.slim.singleSelected && this.slim.singleSelected.container.classList.add(this.config.disabled), this.select.triggerMutationObserver = false, this.select.element.disabled = true, this.slim.search.input.disabled = true, this.select.triggerMutationObserver = true;
          }, l.prototype.search = function(t2) {
            var i3;
            this.data.searchValue !== t2 && (this.slim.search.input.value = t2, this.config.isAjax ? ((i3 = this).config.isSearching = true, this.render(), this.ajax && this.ajax(t2, function(e2) {
              i3.config.isSearching = false, Array.isArray(e2) ? (e2.unshift({ text: "", placeholder: true }), i3.setData(e2), i3.data.search(t2), i3.render()) : typeof e2 == "string" ? i3.slim.options(e2) : i3.render();
            })) : (this.data.search(t2), this.render()));
          }, l.prototype.setSearchText = function(e2) {
            this.config.searchText = e2;
          }, l.prototype.render = function() {
            this.config.isMultiple ? this.slim.values() : (this.slim.placeholder(), this.slim.deselect()), this.slim.options();
          }, l.prototype.destroy = function(e2) {
            var t2 = (e2 = e2 === void 0 ? null : e2) ? document.querySelector("." + e2 + ".ss-main") : this.slim.container, i3 = e2 ? document.querySelector("[data-ssid=".concat(e2, "]")) : this.select.element;
            t2 && i3 && (document.removeEventListener("click", this.documentClick), this.config.showContent === "auto" && window.removeEventListener("scroll", this.windowScroll, false), i3.style.display = "", delete i3.dataset.ssid, i3.slim = null, t2.parentElement && t2.parentElement.removeChild(t2), !this.config.addToBody || (e2 = e2 ? document.querySelector("." + e2 + ".ss-content") : this.slim.content) && document.body.removeChild(e2));
          }, l);
          function l(e2) {
            var t2 = this;
            this.ajax = null, this.addable = null, this.beforeOnChange = null, this.onChange = null, this.beforeOpen = null, this.afterOpen = null, this.beforeClose = null, this.afterClose = null, this.windowScroll = (0, o.debounce)(function(e3) {
              t2.data.contentOpen && ((0, o.putContent)(t2.slim.content, t2.data.contentPosition, t2.data.contentOpen) === "above" ? t2.moveContentAbove() : t2.moveContentBelow());
            }), this.documentClick = function(e3) {
              e3.target && !(0, o.hasClassInTree)(e3.target, t2.config.id) && t2.close();
            };
            var i3 = this.validate(e2);
            i3.dataset.ssid && this.destroy(i3.dataset.ssid), e2.ajax && (this.ajax = e2.ajax), e2.addable && (this.addable = e2.addable), this.config = new n2.Config({ select: i3, isAjax: !!e2.ajax, showSearch: e2.showSearch, searchPlaceholder: e2.searchPlaceholder, searchText: e2.searchText, searchingText: e2.searchingText, searchFocus: e2.searchFocus, searchHighlight: e2.searchHighlight, searchFilter: e2.searchFilter, closeOnSelect: e2.closeOnSelect, showContent: e2.showContent, placeholderText: e2.placeholder, allowDeselect: e2.allowDeselect, allowDeselectOption: e2.allowDeselectOption, hideSelectedOption: e2.hideSelectedOption, deselectLabel: e2.deselectLabel, isEnabled: e2.isEnabled, valuesUseText: e2.valuesUseText, showOptionTooltips: e2.showOptionTooltips, selectByGroup: e2.selectByGroup, limit: e2.limit, timeoutDelay: e2.timeoutDelay, addToBody: e2.addToBody }), this.select = new s2.Select({ select: i3, main: this }), this.data = new r.Data({ main: this }), this.slim = new a.Slim({ main: this }), this.select.element.parentNode && this.select.element.parentNode.insertBefore(this.slim.container, this.select.element.nextSibling), e2.data ? this.setData(e2.data) : this.render(), document.addEventListener("click", this.documentClick), this.config.showContent === "auto" && window.addEventListener("scroll", this.windowScroll, false), e2.beforeOnChange && (this.beforeOnChange = e2.beforeOnChange), e2.onChange && (this.onChange = e2.onChange), e2.beforeOpen && (this.beforeOpen = e2.beforeOpen), e2.afterOpen && (this.afterOpen = e2.afterOpen), e2.beforeClose && (this.beforeClose = e2.beforeClose), e2.afterClose && (this.afterClose = e2.afterClose), this.config.isEnabled || this.disable();
          }
          t.default = i2;
        }, function(e, t, i2) {
          "use strict";
          t.__esModule = true, t.Config = void 0;
          var n2 = (s2.prototype.searchFilter = function(e2, t2) {
            return e2.text.toLowerCase().indexOf(t2.toLowerCase()) !== -1;
          }, s2);
          function s2(e2) {
            this.id = "", this.isMultiple = false, this.isAjax = false, this.isSearching = false, this.showSearch = true, this.searchFocus = true, this.searchHighlight = false, this.closeOnSelect = true, this.showContent = "auto", this.searchPlaceholder = "Search", this.searchText = "No Results", this.searchingText = "Searching...", this.placeholderText = "Select Value", this.allowDeselect = false, this.allowDeselectOption = false, this.hideSelectedOption = false, this.deselectLabel = "x", this.isEnabled = true, this.valuesUseText = false, this.showOptionTooltips = false, this.selectByGroup = false, this.limit = 0, this.timeoutDelay = 200, this.addToBody = false, this.main = "ss-main", this.singleSelected = "ss-single-selected", this.arrow = "ss-arrow", this.multiSelected = "ss-multi-selected", this.add = "ss-add", this.plus = "ss-plus", this.values = "ss-values", this.value = "ss-value", this.valueText = "ss-value-text", this.valueDelete = "ss-value-delete", this.content = "ss-content", this.open = "ss-open", this.openAbove = "ss-open-above", this.openBelow = "ss-open-below", this.search = "ss-search", this.searchHighlighter = "ss-search-highlight", this.addable = "ss-addable", this.list = "ss-list", this.optgroup = "ss-optgroup", this.optgroupLabel = "ss-optgroup-label", this.optgroupLabelSelectable = "ss-optgroup-label-selectable", this.option = "ss-option", this.optionSelected = "ss-option-selected", this.highlighted = "ss-highlighted", this.disabled = "ss-disabled", this.hide = "ss-hide", this.id = "ss-" + Math.floor(1e5 * Math.random()), this.style = e2.select.style.cssText, this.class = e2.select.className.split(" "), this.isMultiple = e2.select.multiple, this.isAjax = e2.isAjax, this.showSearch = e2.showSearch !== false, this.searchFocus = e2.searchFocus !== false, this.searchHighlight = e2.searchHighlight === true, this.closeOnSelect = e2.closeOnSelect !== false, e2.showContent && (this.showContent = e2.showContent), this.isEnabled = e2.isEnabled !== false, e2.searchPlaceholder && (this.searchPlaceholder = e2.searchPlaceholder), e2.searchText && (this.searchText = e2.searchText), e2.searchingText && (this.searchingText = e2.searchingText), e2.placeholderText && (this.placeholderText = e2.placeholderText), this.allowDeselect = e2.allowDeselect === true, this.allowDeselectOption = e2.allowDeselectOption === true, this.hideSelectedOption = e2.hideSelectedOption === true, e2.deselectLabel && (this.deselectLabel = e2.deselectLabel), e2.valuesUseText && (this.valuesUseText = e2.valuesUseText), e2.showOptionTooltips && (this.showOptionTooltips = e2.showOptionTooltips), e2.selectByGroup && (this.selectByGroup = e2.selectByGroup), e2.limit && (this.limit = e2.limit), e2.searchFilter && (this.searchFilter = e2.searchFilter), e2.timeoutDelay != null && (this.timeoutDelay = e2.timeoutDelay), this.addToBody = e2.addToBody === true;
          }
          t.Config = n2;
        }, function(e, t, i2) {
          "use strict";
          t.__esModule = true, t.Select = void 0;
          var n2 = i2(0), i2 = (s2.prototype.setValue = function() {
            if (this.main.data.getSelected()) {
              if (this.main.config.isMultiple)
                for (var e2 = this.main.data.getSelected(), t2 = 0, i3 = this.element.options; t2 < i3.length; t2++) {
                  var n3 = i3[t2];
                  n3.selected = false;
                  for (var s3 = 0, a = e2; s3 < a.length; s3++)
                    a[s3].value === n3.value && (n3.selected = true);
                }
              else {
                e2 = this.main.data.getSelected();
                this.element.value = e2 ? e2.value : "";
              }
              this.main.data.isOnChangeEnabled = false, this.element.dispatchEvent(new CustomEvent("change", { bubbles: true })), this.main.data.isOnChangeEnabled = true;
            }
          }, s2.prototype.addAttributes = function() {
            this.element.tabIndex = -1, this.element.style.display = "none", this.element.dataset.ssid = this.main.config.id, this.element.setAttribute("aria-hidden", "true");
          }, s2.prototype.addEventListeners = function() {
            var t2 = this;
            this.element.addEventListener("change", function(e2) {
              t2.main.data.setSelectedFromSelect(), t2.main.render();
            });
          }, s2.prototype.addMutationObserver = function() {
            var t2 = this;
            this.main.config.isAjax || (this.mutationObserver = new MutationObserver(function(e2) {
              t2.triggerMutationObserver && (t2.main.data.parseSelectData(), t2.main.data.setSelectedFromSelect(), t2.main.render(), e2.forEach(function(e3) {
                e3.attributeName === "class" && t2.main.slim.updateContainerDivClass(t2.main.slim.container);
              }));
            }), this.observeMutationObserver());
          }, s2.prototype.observeMutationObserver = function() {
            this.mutationObserver && this.mutationObserver.observe(this.element, { attributes: true, childList: true, characterData: true });
          }, s2.prototype.disconnectMutationObserver = function() {
            this.mutationObserver && this.mutationObserver.disconnect();
          }, s2.prototype.create = function(e2) {
            this.element.innerHTML = "";
            for (var t2 = 0, i3 = e2; t2 < i3.length; t2++) {
              var n3 = i3[t2];
              if (n3.hasOwnProperty("options")) {
                var s3 = n3, a = document.createElement("optgroup");
                if (a.label = s3.label, s3.options)
                  for (var o = 0, l = s3.options; o < l.length; o++) {
                    var r = l[o];
                    a.appendChild(this.createOption(r));
                  }
                this.element.appendChild(a);
              } else
                this.element.appendChild(this.createOption(n3));
            }
          }, s2.prototype.createOption = function(t2) {
            var i3 = document.createElement("option");
            return i3.value = t2.value !== "" ? t2.value : t2.text, i3.innerHTML = t2.innerHTML || t2.text, t2.selected && (i3.selected = t2.selected), t2.display === false && (i3.style.display = "none"), t2.disabled && (i3.disabled = true), t2.placeholder && i3.setAttribute("data-placeholder", "true"), t2.mandatory && i3.setAttribute("data-mandatory", "true"), t2.class && t2.class.split(" ").forEach(function(e2) {
              i3.classList.add(e2);
            }), t2.data && typeof t2.data == "object" && Object.keys(t2.data).forEach(function(e2) {
              i3.setAttribute("data-" + (0, n2.kebabCase)(e2), t2.data[e2]);
            }), i3;
          }, s2);
          function s2(e2) {
            this.triggerMutationObserver = true, this.element = e2.select, this.main = e2.main, this.element.disabled && (this.main.config.isEnabled = false), this.addAttributes(), this.addEventListeners(), this.mutationObserver = null, this.addMutationObserver(), this.element.slim = e2.main;
          }
          t.Select = i2;
        }, function(e, t, i2) {
          "use strict";
          t.__esModule = true, t.Slim = void 0;
          var n2 = i2(0), o = i2(1), i2 = (s2.prototype.containerDiv = function() {
            var e2 = document.createElement("div");
            return e2.style.cssText = this.main.config.style, this.updateContainerDivClass(e2), e2;
          }, s2.prototype.updateContainerDivClass = function(e2) {
            this.main.config.class = this.main.select.element.className.split(" "), e2.className = "", e2.classList.add(this.main.config.id), e2.classList.add(this.main.config.main);
            for (var t2 = 0, i3 = this.main.config.class; t2 < i3.length; t2++) {
              var n3 = i3[t2];
              n3.trim() !== "" && e2.classList.add(n3);
            }
          }, s2.prototype.singleSelectedDiv = function() {
            var t2 = this, e2 = document.createElement("div");
            e2.classList.add(this.main.config.singleSelected);
            var i3 = document.createElement("span");
            i3.classList.add("placeholder"), e2.appendChild(i3);
            var n3 = document.createElement("span");
            n3.innerHTML = this.main.config.deselectLabel, n3.classList.add("ss-deselect"), n3.onclick = function(e3) {
              e3.stopPropagation(), t2.main.config.isEnabled && t2.main.set("");
            }, e2.appendChild(n3);
            var s3 = document.createElement("span");
            s3.classList.add(this.main.config.arrow);
            var a = document.createElement("span");
            return a.classList.add("arrow-down"), s3.appendChild(a), e2.appendChild(s3), e2.onclick = function() {
              t2.main.config.isEnabled && (t2.main.data.contentOpen ? t2.main.close() : t2.main.open());
            }, { container: e2, placeholder: i3, deselect: n3, arrowIcon: { container: s3, arrow: a } };
          }, s2.prototype.placeholder = function() {
            var e2, t2 = this.main.data.getSelected();
            t2 === null || t2 && t2.placeholder ? ((e2 = document.createElement("span")).classList.add(this.main.config.disabled), e2.innerHTML = this.main.config.placeholderText, this.singleSelected && (this.singleSelected.placeholder.innerHTML = e2.outerHTML)) : (e2 = "", t2 && (e2 = t2.innerHTML && this.main.config.valuesUseText !== true ? t2.innerHTML : t2.text), this.singleSelected && (this.singleSelected.placeholder.innerHTML = t2 ? e2 : ""));
          }, s2.prototype.deselect = function() {
            this.singleSelected && (!this.main.config.allowDeselect || this.main.selected() === "" ? this.singleSelected.deselect.classList.add("ss-hide") : this.singleSelected.deselect.classList.remove("ss-hide"));
          }, s2.prototype.multiSelectedDiv = function() {
            var t2 = this, e2 = document.createElement("div");
            e2.classList.add(this.main.config.multiSelected);
            var i3 = document.createElement("div");
            i3.classList.add(this.main.config.values), e2.appendChild(i3);
            var n3 = document.createElement("div");
            n3.classList.add(this.main.config.add);
            var s3 = document.createElement("span");
            return s3.classList.add(this.main.config.plus), s3.onclick = function(e3) {
              t2.main.data.contentOpen && (t2.main.close(), e3.stopPropagation());
            }, n3.appendChild(s3), e2.appendChild(n3), e2.onclick = function(e3) {
              t2.main.config.isEnabled && (e3.target.classList.contains(t2.main.config.valueDelete) || (t2.main.data.contentOpen ? t2.main.close() : t2.main.open()));
            }, { container: e2, values: i3, add: n3, plus: s3 };
          }, s2.prototype.values = function() {
            if (this.multiSelected) {
              for (var e2 = this.multiSelected.values.childNodes, t2 = this.main.data.getSelected(), i3 = [], n3 = 0, s3 = e2; n3 < s3.length; n3++) {
                for (var a = s3[n3], o2 = true, l = 0, r = t2; l < r.length; l++) {
                  var c = r[l];
                  String(c.id) === String(a.dataset.id) && (o2 = false);
                }
                o2 && i3.push(a);
              }
              for (var d = 0, h = i3; d < h.length; d++) {
                var u = h[d];
                u.classList.add("ss-out"), this.multiSelected.values.removeChild(u);
              }
              for (var p, e2 = this.multiSelected.values.childNodes, c = 0; c < t2.length; c++) {
                o2 = false;
                for (var m = 0, f = e2; m < f.length; m++) {
                  a = f[m];
                  String(t2[c].id) === String(a.dataset.id) && (o2 = true);
                }
                o2 || (e2.length !== 0 && HTMLElement.prototype.insertAdjacentElement ? c === 0 ? this.multiSelected.values.insertBefore(this.valueDiv(t2[c]), e2[c]) : e2[c - 1].insertAdjacentElement("afterend", this.valueDiv(t2[c])) : this.multiSelected.values.appendChild(this.valueDiv(t2[c])));
              }
              t2.length === 0 && ((p = document.createElement("span")).classList.add(this.main.config.disabled), p.innerHTML = this.main.config.placeholderText, this.multiSelected.values.innerHTML = p.outerHTML);
            }
          }, s2.prototype.valueDiv = function(s3) {
            var a = this, e2 = document.createElement("div");
            e2.classList.add(this.main.config.value), e2.dataset.id = s3.id;
            var t2 = document.createElement("span");
            return t2.classList.add(this.main.config.valueText), t2.innerHTML = s3.innerHTML && this.main.config.valuesUseText !== true ? s3.innerHTML : s3.text, e2.appendChild(t2), s3.mandatory || ((t2 = document.createElement("span")).classList.add(this.main.config.valueDelete), t2.innerHTML = this.main.config.deselectLabel, t2.onclick = function(e3) {
              e3.preventDefault(), e3.stopPropagation();
              var t3 = false;
              if (a.main.beforeOnChange || (t3 = true), a.main.beforeOnChange) {
                for (var e3 = a.main.data.getSelected(), i3 = JSON.parse(JSON.stringify(e3)), n3 = 0; n3 < i3.length; n3++)
                  i3[n3].id === s3.id && i3.splice(n3, 1);
                a.main.beforeOnChange(i3) !== false && (t3 = true);
              }
              t3 && (a.main.data.removeFromSelected(s3.id, "id"), a.main.render(), a.main.select.setValue(), a.main.data.onDataChange());
            }, e2.appendChild(t2)), e2;
          }, s2.prototype.contentDiv = function() {
            var e2 = document.createElement("div");
            return e2.classList.add(this.main.config.content), e2;
          }, s2.prototype.searchDiv = function() {
            var n3 = this, e2 = document.createElement("div"), s3 = document.createElement("input"), a = document.createElement("div");
            e2.classList.add(this.main.config.search);
            var t2 = { container: e2, input: s3 };
            return this.main.config.showSearch || (e2.classList.add(this.main.config.hide), s3.readOnly = true), s3.type = "search", s3.placeholder = this.main.config.searchPlaceholder, s3.tabIndex = 0, s3.setAttribute("aria-label", this.main.config.searchPlaceholder), s3.setAttribute("autocapitalize", "off"), s3.setAttribute("autocomplete", "off"), s3.setAttribute("autocorrect", "off"), s3.onclick = function(e3) {
              setTimeout(function() {
                e3.target.value === "" && n3.main.search("");
              }, 10);
            }, s3.onkeydown = function(e3) {
              e3.key === "ArrowUp" ? (n3.main.open(), n3.highlightUp(), e3.preventDefault()) : e3.key === "ArrowDown" ? (n3.main.open(), n3.highlightDown(), e3.preventDefault()) : e3.key === "Tab" ? n3.main.data.contentOpen ? n3.main.close() : setTimeout(function() {
                n3.main.close();
              }, n3.main.config.timeoutDelay) : e3.key === "Enter" && e3.preventDefault();
            }, s3.onkeyup = function(e3) {
              var t3 = e3.target;
              if (e3.key === "Enter") {
                if (n3.main.addable && e3.ctrlKey)
                  return a.click(), e3.preventDefault(), void e3.stopPropagation();
                var i3 = n3.list.querySelector("." + n3.main.config.highlighted);
                i3 && i3.click();
              } else
                e3.key === "ArrowUp" || e3.key === "ArrowDown" || (e3.key === "Escape" ? n3.main.close() : n3.main.config.showSearch && n3.main.data.contentOpen ? n3.main.search(t3.value) : s3.value = "");
              e3.preventDefault(), e3.stopPropagation();
            }, s3.onfocus = function() {
              n3.main.open();
            }, e2.appendChild(s3), this.main.addable && (a.classList.add(this.main.config.addable), a.innerHTML = "+", a.onclick = function(e3) {
              var t3;
              n3.main.addable && (e3.preventDefault(), e3.stopPropagation(), (e3 = n3.search.input.value).trim() !== "" ? (e3 = n3.main.addable(e3), t3 = "", e3 && (typeof e3 == "object" ? (0, o.validateOption)(e3) && (n3.main.addData(e3), t3 = e3.value || e3.text) : (n3.main.addData(n3.main.data.newOption({ text: e3, value: e3 })), t3 = e3), n3.main.search(""), setTimeout(function() {
                n3.main.set(t3, "value", false, false);
              }, 100), n3.main.config.closeOnSelect && setTimeout(function() {
                n3.main.close();
              }, 100))) : n3.search.input.focus());
            }, e2.appendChild(a), t2.addable = a), t2;
          }, s2.prototype.highlightUp = function() {
            var e2 = this.list.querySelector("." + this.main.config.highlighted), t2 = null;
            if (e2)
              for (t2 = e2.previousSibling; t2 !== null && t2.classList.contains(this.main.config.disabled); )
                t2 = t2.previousSibling;
            else
              var i3 = this.list.querySelectorAll("." + this.main.config.option + ":not(." + this.main.config.disabled + ")"), t2 = i3[i3.length - 1];
            (t2 = t2 && t2.classList.contains(this.main.config.optgroupLabel) ? null : t2) !== null || (i3 = e2.parentNode).classList.contains(this.main.config.optgroup) && (!i3.previousSibling || (i3 = i3.previousSibling.querySelectorAll("." + this.main.config.option + ":not(." + this.main.config.disabled + ")")).length && (t2 = i3[i3.length - 1])), t2 && (e2 && e2.classList.remove(this.main.config.highlighted), t2.classList.add(this.main.config.highlighted), (0, n2.ensureElementInView)(this.list, t2));
          }, s2.prototype.highlightDown = function() {
            var e2, t2 = this.list.querySelector("." + this.main.config.highlighted), i3 = null;
            if (t2)
              for (i3 = t2.nextSibling; i3 !== null && i3.classList.contains(this.main.config.disabled); )
                i3 = i3.nextSibling;
            else
              i3 = this.list.querySelector("." + this.main.config.option + ":not(." + this.main.config.disabled + ")");
            i3 !== null || t2 === null || (e2 = t2.parentNode).classList.contains(this.main.config.optgroup) && e2.nextSibling && (i3 = e2.nextSibling.querySelector("." + this.main.config.option + ":not(." + this.main.config.disabled + ")")), i3 && (t2 && t2.classList.remove(this.main.config.highlighted), i3.classList.add(this.main.config.highlighted), (0, n2.ensureElementInView)(this.list, i3));
          }, s2.prototype.listDiv = function() {
            var e2 = document.createElement("div");
            return e2.classList.add(this.main.config.list), e2.setAttribute("role", "listbox"), e2;
          }, s2.prototype.options = function(e2) {
            e2 === void 0 && (e2 = "");
            var t2 = this.main.data.filtered || this.main.data.data;
            if ((this.list.innerHTML = "") !== e2)
              return (i3 = document.createElement("div")).classList.add(this.main.config.option), i3.classList.add(this.main.config.disabled), i3.innerHTML = e2, void this.list.appendChild(i3);
            if (this.main.config.isAjax && this.main.config.isSearching)
              return (i3 = document.createElement("div")).classList.add(this.main.config.option), i3.classList.add(this.main.config.disabled), i3.innerHTML = this.main.config.searchingText, void this.list.appendChild(i3);
            if (t2.length === 0) {
              var i3 = document.createElement("div");
              return i3.classList.add(this.main.config.option), i3.classList.add(this.main.config.disabled), i3.innerHTML = this.main.config.searchText, void this.list.appendChild(i3);
            }
            for (var r = this, n3 = 0, s3 = t2; n3 < s3.length; n3++)
              !function(e3) {
                if (e3.hasOwnProperty("label")) {
                  var t3 = e3, s4 = document.createElement("div");
                  s4.classList.add(r.main.config.optgroup);
                  var i4 = document.createElement("div");
                  i4.classList.add(r.main.config.optgroupLabel), r.main.config.selectByGroup && r.main.config.isMultiple && i4.classList.add(r.main.config.optgroupLabelSelectable), i4.innerHTML = t3.label, s4.appendChild(i4);
                  t3 = t3.options;
                  if (t3) {
                    for (var a, n4 = 0, o2 = t3; n4 < o2.length; n4++) {
                      var l = o2[n4];
                      s4.appendChild(r.option(l));
                    }
                    r.main.config.selectByGroup && r.main.config.isMultiple && (a = r, i4.addEventListener("click", function(e4) {
                      e4.preventDefault(), e4.stopPropagation();
                      for (var t4 = 0, i5 = s4.children; t4 < i5.length; t4++) {
                        var n5 = i5[t4];
                        n5.className.indexOf(a.main.config.option) !== -1 && n5.click();
                      }
                    }));
                  }
                  r.list.appendChild(s4);
                } else
                  r.list.appendChild(r.option(e3));
              }(s3[n3]);
          }, s2.prototype.option = function(o2) {
            if (o2.placeholder) {
              var e2 = document.createElement("div");
              return e2.classList.add(this.main.config.option), e2.classList.add(this.main.config.hide), e2;
            }
            var t2 = document.createElement("div");
            t2.classList.add(this.main.config.option), t2.setAttribute("role", "option"), o2.class && o2.class.split(" ").forEach(function(e3) {
              t2.classList.add(e3);
            }), o2.style && (t2.style.cssText = o2.style);
            var l = this.main.data.getSelected();
            t2.dataset.id = o2.id, this.main.config.searchHighlight && this.main.slim && o2.innerHTML && this.main.slim.search.input.value.trim() !== "" ? t2.innerHTML = (0, n2.highlight)(o2.innerHTML, this.main.slim.search.input.value, this.main.config.searchHighlighter) : o2.innerHTML && (t2.innerHTML = o2.innerHTML), this.main.config.showOptionTooltips && t2.textContent && t2.setAttribute("title", t2.textContent);
            var r = this;
            t2.addEventListener("click", function(e3) {
              e3.preventDefault(), e3.stopPropagation();
              var t3 = this.dataset.id;
              if (o2.selected === true && r.main.config.allowDeselectOption) {
                var i3 = false;
                if (r.main.beforeOnChange && r.main.config.isMultiple || (i3 = true), r.main.beforeOnChange && r.main.config.isMultiple) {
                  for (var n3 = r.main.data.getSelected(), s3 = JSON.parse(JSON.stringify(n3)), a = 0; a < s3.length; a++)
                    s3[a].id === t3 && s3.splice(a, 1);
                  r.main.beforeOnChange(s3) !== false && (i3 = true);
                }
                i3 && (r.main.config.isMultiple ? (r.main.data.removeFromSelected(t3, "id"), r.main.render(), r.main.select.setValue(), r.main.data.onDataChange()) : r.main.set(""));
              } else
                o2.disabled || o2.selected || r.main.config.limit && Array.isArray(l) && r.main.config.limit <= l.length || (r.main.beforeOnChange ? (n3 = void 0, (i3 = JSON.parse(JSON.stringify(r.main.data.getObjectFromData(t3)))).selected = true, r.main.config.isMultiple ? (n3 = JSON.parse(JSON.stringify(l))).push(i3) : n3 = JSON.parse(JSON.stringify(i3)), r.main.beforeOnChange(n3) !== false && r.main.set(t3, "id", r.main.config.closeOnSelect)) : r.main.set(t3, "id", r.main.config.closeOnSelect));
            });
            e2 = l && (0, n2.isValueInArrayOfObjects)(l, "id", o2.id);
            return (o2.disabled || e2) && (t2.onclick = null, r.main.config.allowDeselectOption || t2.classList.add(this.main.config.disabled), r.main.config.hideSelectedOption && t2.classList.add(this.main.config.hide)), e2 ? t2.classList.add(this.main.config.optionSelected) : t2.classList.remove(this.main.config.optionSelected), t2;
          }, s2);
          function s2(e2) {
            this.main = e2.main, this.container = this.containerDiv(), this.content = this.contentDiv(), this.search = this.searchDiv(), this.list = this.listDiv(), this.options(), this.singleSelected = null, this.multiSelected = null, this.main.config.isMultiple ? (this.multiSelected = this.multiSelectedDiv(), this.multiSelected && this.container.appendChild(this.multiSelected.container)) : (this.singleSelected = this.singleSelectedDiv(), this.container.appendChild(this.singleSelected.container)), this.main.config.addToBody ? (this.content.classList.add(this.main.config.id), document.body.appendChild(this.content)) : this.container.appendChild(this.content), this.content.appendChild(this.search.container), this.content.appendChild(this.list);
          }
          t.Slim = i2;
        }], s.c = n, s.d = function(e, t, i2) {
          s.o(e, t) || Object.defineProperty(e, t, { enumerable: true, get: i2 });
        }, s.r = function(e) {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: true });
        }, s.t = function(t, e) {
          if (1 & e && (t = s(t)), 8 & e)
            return t;
          if (4 & e && typeof t == "object" && t && t.__esModule)
            return t;
          var i2 = /* @__PURE__ */ Object.create(null);
          if (s.r(i2), Object.defineProperty(i2, "default", { enumerable: true, value: t }), 2 & e && typeof t != "string")
            for (var n2 in t)
              s.d(i2, n2, function(e2) {
                return t[e2];
              }.bind(null, n2));
          return i2;
        }, s.n = function(e) {
          var t = e && e.__esModule ? function() {
            return e.default;
          } : function() {
            return e;
          };
          return s.d(t, "a", t), t;
        }, s.o = function(e, t) {
          return Object.prototype.hasOwnProperty.call(e, t);
        }, s.p = "", s(s.s = 2).default;
        function s(e) {
          if (n[e])
            return n[e].exports;
          var t = n[e] = { i: e, l: false, exports: {} };
          return i[e].call(t.exports, t, t.exports, s), t.l = true, t.exports;
        }
        var i, n;
      });
      slimselect_min_default = exports.SlimSelect;
    }
  });

  // node_modules/highlight.js/lib/core.js
  var require_core = __commonJS({
    "node_modules/highlight.js/lib/core.js"(exports2, module2) {
      function deepFreeze2(obj) {
        if (obj instanceof Map) {
          obj.clear = obj.delete = obj.set = function() {
            throw new Error("map is read-only");
          };
        } else if (obj instanceof Set) {
          obj.add = obj.clear = obj.delete = function() {
            throw new Error("set is read-only");
          };
        }
        Object.freeze(obj);
        Object.getOwnPropertyNames(obj).forEach(function(name) {
          var prop = obj[name];
          if (typeof prop == "object" && !Object.isFrozen(prop)) {
            deepFreeze2(prop);
          }
        });
        return obj;
      }
      var deepFreezeEs62 = deepFreeze2;
      var _default2 = deepFreeze2;
      deepFreezeEs62.default = _default2;
      var Response2 = class {
        constructor(mode) {
          if (mode.data === void 0)
            mode.data = {};
          this.data = mode.data;
          this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      };
      function escapeHTML2(value) {
        return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function inherit2(original, ...objects) {
        const result2 = /* @__PURE__ */ Object.create(null);
        for (const key2 in original) {
          result2[key2] = original[key2];
        }
        objects.forEach(function(obj) {
          for (const key2 in obj) {
            result2[key2] = obj[key2];
          }
        });
        return result2;
      }
      var SPAN_CLOSE2 = "</span>";
      var emitsWrappingTags2 = (node5) => {
        return !!node5.kind;
      };
      var HTMLRenderer2 = class {
        constructor(parseTree, options) {
          this.buffer = "";
          this.classPrefix = options.classPrefix;
          parseTree.walk(this);
        }
        addText(text4) {
          this.buffer += escapeHTML2(text4);
        }
        openNode(node5) {
          if (!emitsWrappingTags2(node5))
            return;
          let className = node5.kind;
          if (!node5.sublanguage) {
            className = `${this.classPrefix}${className}`;
          }
          this.span(className);
        }
        closeNode(node5) {
          if (!emitsWrappingTags2(node5))
            return;
          this.buffer += SPAN_CLOSE2;
        }
        value() {
          return this.buffer;
        }
        span(className) {
          this.buffer += `<span class="${className}">`;
        }
      };
      var TokenTree2 = class {
        constructor() {
          this.rootNode = { children: [] };
          this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        add(node5) {
          this.top.children.push(node5);
        }
        openNode(kind) {
          const node5 = { kind, children: [] };
          this.add(node5);
          this.stack.push(node5);
        }
        closeNode() {
          if (this.stack.length > 1) {
            return this.stack.pop();
          }
          return void 0;
        }
        closeAllNodes() {
          while (this.closeNode())
            ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        walk(builder) {
          return this.constructor._walk(builder, this.rootNode);
        }
        static _walk(builder, node5) {
          if (typeof node5 === "string") {
            builder.addText(node5);
          } else if (node5.children) {
            builder.openNode(node5);
            node5.children.forEach((child5) => this._walk(builder, child5));
            builder.closeNode(node5);
          }
          return builder;
        }
        static _collapse(node5) {
          if (typeof node5 === "string")
            return;
          if (!node5.children)
            return;
          if (node5.children.every((el) => typeof el === "string")) {
            node5.children = [node5.children.join("")];
          } else {
            node5.children.forEach((child5) => {
              TokenTree2._collapse(child5);
            });
          }
        }
      };
      var TokenTreeEmitter2 = class extends TokenTree2 {
        constructor(options) {
          super();
          this.options = options;
        }
        addKeyword(text4, kind) {
          if (text4 === "") {
            return;
          }
          this.openNode(kind);
          this.addText(text4);
          this.closeNode();
        }
        addText(text4) {
          if (text4 === "") {
            return;
          }
          this.add(text4);
        }
        addSublanguage(emitter, name) {
          const node5 = emitter.root;
          node5.kind = name;
          node5.sublanguage = true;
          this.add(node5);
        }
        toHTML() {
          const renderer = new HTMLRenderer2(this, this.options);
          return renderer.value();
        }
        finalize() {
          return true;
        }
      };
      function escape2(value) {
        return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "m");
      }
      function source2(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function concat2(...args) {
        const joined = args.map((x) => source2(x)).join("");
        return joined;
      }
      function either2(...args) {
        const joined = "(" + args.map((x) => source2(x)).join("|") + ")";
        return joined;
      }
      function countMatchGroups2(re) {
        return new RegExp(re.toString() + "|").exec("").length - 1;
      }
      function startsWith2(re, lexeme) {
        const match = re && re.exec(lexeme);
        return match && match.index === 0;
      }
      var BACKREF_RE2 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function join2(regexps, separator = "|") {
        let numCaptures = 0;
        return regexps.map((regex) => {
          numCaptures += 1;
          const offset4 = numCaptures;
          let re = source2(regex);
          let out = "";
          while (re.length > 0) {
            const match = BACKREF_RE2.exec(re);
            if (!match) {
              out += re;
              break;
            }
            out += re.substring(0, match.index);
            re = re.substring(match.index + match[0].length);
            if (match[0][0] === "\\" && match[1]) {
              out += "\\" + String(Number(match[1]) + offset4);
            } else {
              out += match[0];
              if (match[0] === "(") {
                numCaptures++;
              }
            }
          }
          return out;
        }).map((re) => `(${re})`).join(separator);
      }
      var MATCH_NOTHING_RE2 = /\b\B/;
      var IDENT_RE2 = "[a-zA-Z]\\w*";
      var UNDERSCORE_IDENT_RE2 = "[a-zA-Z_]\\w*";
      var NUMBER_RE2 = "\\b\\d+(\\.\\d+)?";
      var C_NUMBER_RE2 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
      var BINARY_NUMBER_RE2 = "\\b(0b[01]+)";
      var RE_STARTERS_RE2 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
      var SHEBANG2 = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
          opts.begin = concat2(beginShebang, /.*\b/, opts.binary, /\b.*/);
        }
        return inherit2({
          className: "meta",
          begin: beginShebang,
          end: /$/,
          relevance: 0,
          "on:begin": (m, resp) => {
            if (m.index !== 0)
              resp.ignoreMatch();
          }
        }, opts);
      };
      var BACKSLASH_ESCAPE2 = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      };
      var APOS_STRING_MODE2 = {
        className: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE2]
      };
      var QUOTE_STRING_MODE2 = {
        className: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE2]
      };
      var PHRASAL_WORDS_MODE2 = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      };
      var COMMENT2 = function(begin, end4, modeOptions = {}) {
        const mode = inherit2({
          className: "comment",
          begin,
          end: end4,
          contains: []
        }, modeOptions);
        mode.contains.push(PHRASAL_WORDS_MODE2);
        mode.contains.push({
          className: "doctag",
          begin: "(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",
          relevance: 0
        });
        return mode;
      };
      var C_LINE_COMMENT_MODE2 = COMMENT2("//", "$");
      var C_BLOCK_COMMENT_MODE2 = COMMENT2("/\\*", "\\*/");
      var HASH_COMMENT_MODE2 = COMMENT2("#", "$");
      var NUMBER_MODE2 = {
        className: "number",
        begin: NUMBER_RE2,
        relevance: 0
      };
      var C_NUMBER_MODE2 = {
        className: "number",
        begin: C_NUMBER_RE2,
        relevance: 0
      };
      var BINARY_NUMBER_MODE2 = {
        className: "number",
        begin: BINARY_NUMBER_RE2,
        relevance: 0
      };
      var CSS_NUMBER_MODE2 = {
        className: "number",
        begin: NUMBER_RE2 + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      };
      var REGEXP_MODE2 = {
        begin: /(?=\/[^/\n]*\/)/,
        contains: [{
          className: "regexp",
          begin: /\//,
          end: /\/[gimuy]*/,
          illegal: /\n/,
          contains: [
            BACKSLASH_ESCAPE2,
            {
              begin: /\[/,
              end: /\]/,
              relevance: 0,
              contains: [BACKSLASH_ESCAPE2]
            }
          ]
        }]
      };
      var TITLE_MODE2 = {
        className: "title",
        begin: IDENT_RE2,
        relevance: 0
      };
      var UNDERSCORE_TITLE_MODE2 = {
        className: "title",
        begin: UNDERSCORE_IDENT_RE2,
        relevance: 0
      };
      var METHOD_GUARD2 = {
        begin: "\\.\\s*" + UNDERSCORE_IDENT_RE2,
        relevance: 0
      };
      var END_SAME_AS_BEGIN2 = function(mode) {
        return Object.assign(mode, {
          "on:begin": (m, resp) => {
            resp.data._beginMatch = m[1];
          },
          "on:end": (m, resp) => {
            if (resp.data._beginMatch !== m[1])
              resp.ignoreMatch();
          }
        });
      };
      var MODES2 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE: MATCH_NOTHING_RE2,
        IDENT_RE: IDENT_RE2,
        UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE2,
        NUMBER_RE: NUMBER_RE2,
        C_NUMBER_RE: C_NUMBER_RE2,
        BINARY_NUMBER_RE: BINARY_NUMBER_RE2,
        RE_STARTERS_RE: RE_STARTERS_RE2,
        SHEBANG: SHEBANG2,
        BACKSLASH_ESCAPE: BACKSLASH_ESCAPE2,
        APOS_STRING_MODE: APOS_STRING_MODE2,
        QUOTE_STRING_MODE: QUOTE_STRING_MODE2,
        PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE2,
        COMMENT: COMMENT2,
        C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE2,
        C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE2,
        HASH_COMMENT_MODE: HASH_COMMENT_MODE2,
        NUMBER_MODE: NUMBER_MODE2,
        C_NUMBER_MODE: C_NUMBER_MODE2,
        BINARY_NUMBER_MODE: BINARY_NUMBER_MODE2,
        CSS_NUMBER_MODE: CSS_NUMBER_MODE2,
        REGEXP_MODE: REGEXP_MODE2,
        TITLE_MODE: TITLE_MODE2,
        UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE2,
        METHOD_GUARD: METHOD_GUARD2,
        END_SAME_AS_BEGIN: END_SAME_AS_BEGIN2
      });
      function skipIfhasPrecedingDot2(match, response) {
        const before3 = match.input[match.index - 1];
        if (before3 === ".") {
          response.ignoreMatch();
        }
      }
      function beginKeywords2(mode, parent) {
        if (!parent)
          return;
        if (!mode.beginKeywords)
          return;
        mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
        mode.__beforeBegin = skipIfhasPrecedingDot2;
        mode.keywords = mode.keywords || mode.beginKeywords;
        delete mode.beginKeywords;
        if (mode.relevance === void 0)
          mode.relevance = 0;
      }
      function compileIllegal2(mode, _parent) {
        if (!Array.isArray(mode.illegal))
          return;
        mode.illegal = either2(...mode.illegal);
      }
      function compileMatch2(mode, _parent) {
        if (!mode.match)
          return;
        if (mode.begin || mode.end)
          throw new Error("begin & end are not supported with match");
        mode.begin = mode.match;
        delete mode.match;
      }
      function compileRelevance2(mode, _parent) {
        if (mode.relevance === void 0)
          mode.relevance = 1;
      }
      var COMMON_KEYWORDS2 = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        "list",
        "value"
      ];
      var DEFAULT_KEYWORD_CLASSNAME2 = "keyword";
      function compileKeywords2(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME2) {
        const compiledKeywords = {};
        if (typeof rawKeywords === "string") {
          compileList(className, rawKeywords.split(" "));
        } else if (Array.isArray(rawKeywords)) {
          compileList(className, rawKeywords);
        } else {
          Object.keys(rawKeywords).forEach(function(className2) {
            Object.assign(compiledKeywords, compileKeywords2(rawKeywords[className2], caseInsensitive, className2));
          });
        }
        return compiledKeywords;
        function compileList(className2, keywordList) {
          if (caseInsensitive) {
            keywordList = keywordList.map((x) => x.toLowerCase());
          }
          keywordList.forEach(function(keyword) {
            const pair = keyword.split("|");
            compiledKeywords[pair[0]] = [className2, scoreForKeyword2(pair[0], pair[1])];
          });
        }
      }
      function scoreForKeyword2(keyword, providedScore) {
        if (providedScore) {
          return Number(providedScore);
        }
        return commonKeyword2(keyword) ? 0 : 1;
      }
      function commonKeyword2(keyword) {
        return COMMON_KEYWORDS2.includes(keyword.toLowerCase());
      }
      function compileLanguage2(language, { plugins }) {
        function langRe(value, global2) {
          return new RegExp(source2(value), "m" + (language.case_insensitive ? "i" : "") + (global2 ? "g" : ""));
        }
        class MultiRegex {
          constructor() {
            this.matchIndexes = {};
            this.regexes = [];
            this.matchAt = 1;
            this.position = 0;
          }
          addRule(re, opts) {
            opts.position = this.position++;
            this.matchIndexes[this.matchAt] = opts;
            this.regexes.push([opts, re]);
            this.matchAt += countMatchGroups2(re) + 1;
          }
          compile() {
            if (this.regexes.length === 0) {
              this.exec = () => null;
            }
            const terminators = this.regexes.map((el) => el[1]);
            this.matcherRe = langRe(join2(terminators), true);
            this.lastIndex = 0;
          }
          exec(s) {
            this.matcherRe.lastIndex = this.lastIndex;
            const match = this.matcherRe.exec(s);
            if (!match) {
              return null;
            }
            const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
            const matchData = this.matchIndexes[i];
            match.splice(0, i);
            return Object.assign(match, matchData);
          }
        }
        class ResumableMultiRegex {
          constructor() {
            this.rules = [];
            this.multiRegexes = [];
            this.count = 0;
            this.lastIndex = 0;
            this.regexIndex = 0;
          }
          getMatcher(index3) {
            if (this.multiRegexes[index3])
              return this.multiRegexes[index3];
            const matcher = new MultiRegex();
            this.rules.slice(index3).forEach(([re, opts]) => matcher.addRule(re, opts));
            matcher.compile();
            this.multiRegexes[index3] = matcher;
            return matcher;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          addRule(re, opts) {
            this.rules.push([re, opts]);
            if (opts.type === "begin")
              this.count++;
          }
          exec(s) {
            const m = this.getMatcher(this.regexIndex);
            m.lastIndex = this.lastIndex;
            let result2 = m.exec(s);
            if (this.resumingScanAtSamePosition()) {
              if (result2 && result2.index === this.lastIndex)
                ;
              else {
                const m2 = this.getMatcher(0);
                m2.lastIndex = this.lastIndex + 1;
                result2 = m2.exec(s);
              }
            }
            if (result2) {
              this.regexIndex += result2.position + 1;
              if (this.regexIndex === this.count) {
                this.considerAll();
              }
            }
            return result2;
          }
        }
        function buildModeRegex(mode) {
          const mm = new ResumableMultiRegex();
          mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
          if (mode.terminatorEnd) {
            mm.addRule(mode.terminatorEnd, { type: "end" });
          }
          if (mode.illegal) {
            mm.addRule(mode.illegal, { type: "illegal" });
          }
          return mm;
        }
        function compileMode(mode, parent) {
          const cmode = mode;
          if (mode.isCompiled)
            return cmode;
          [
            compileMatch2
          ].forEach((ext) => ext(mode, parent));
          language.compilerExtensions.forEach((ext) => ext(mode, parent));
          mode.__beforeBegin = null;
          [
            beginKeywords2,
            compileIllegal2,
            compileRelevance2
          ].forEach((ext) => ext(mode, parent));
          mode.isCompiled = true;
          let keywordPattern = null;
          if (typeof mode.keywords === "object") {
            keywordPattern = mode.keywords.$pattern;
            delete mode.keywords.$pattern;
          }
          if (mode.keywords) {
            mode.keywords = compileKeywords2(mode.keywords, language.case_insensitive);
          }
          if (mode.lexemes && keywordPattern) {
            throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
          }
          keywordPattern = keywordPattern || mode.lexemes || /\w+/;
          cmode.keywordPatternRe = langRe(keywordPattern, true);
          if (parent) {
            if (!mode.begin)
              mode.begin = /\B|\b/;
            cmode.beginRe = langRe(mode.begin);
            if (mode.endSameAsBegin)
              mode.end = mode.begin;
            if (!mode.end && !mode.endsWithParent)
              mode.end = /\B|\b/;
            if (mode.end)
              cmode.endRe = langRe(mode.end);
            cmode.terminatorEnd = source2(mode.end) || "";
            if (mode.endsWithParent && parent.terminatorEnd) {
              cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
            }
          }
          if (mode.illegal)
            cmode.illegalRe = langRe(mode.illegal);
          if (!mode.contains)
            mode.contains = [];
          mode.contains = [].concat(...mode.contains.map(function(c) {
            return expandOrCloneMode2(c === "self" ? mode : c);
          }));
          mode.contains.forEach(function(c) {
            compileMode(c, cmode);
          });
          if (mode.starts) {
            compileMode(mode.starts, parent);
          }
          cmode.matcher = buildModeRegex(cmode);
          return cmode;
        }
        if (!language.compilerExtensions)
          language.compilerExtensions = [];
        if (language.contains && language.contains.includes("self")) {
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        }
        language.classNameAliases = inherit2(language.classNameAliases || {});
        return compileMode(language);
      }
      function dependencyOnParent2(mode) {
        if (!mode)
          return false;
        return mode.endsWithParent || dependencyOnParent2(mode.starts);
      }
      function expandOrCloneMode2(mode) {
        if (mode.variants && !mode.cachedVariants) {
          mode.cachedVariants = mode.variants.map(function(variant) {
            return inherit2(mode, { variants: null }, variant);
          });
        }
        if (mode.cachedVariants) {
          return mode.cachedVariants;
        }
        if (dependencyOnParent2(mode)) {
          return inherit2(mode, { starts: mode.starts ? inherit2(mode.starts) : null });
        }
        if (Object.isFrozen(mode)) {
          return inherit2(mode);
        }
        return mode;
      }
      var version2 = "10.7.3";
      function hasValueOrEmptyAttribute2(value) {
        return Boolean(value || value === "");
      }
      function BuildVuePlugin2(hljs) {
        const Component = {
          props: ["language", "code", "autodetect"],
          data: function() {
            return {
              detectedLanguage: "",
              unknownLanguage: false
            };
          },
          computed: {
            className() {
              if (this.unknownLanguage)
                return "";
              return "hljs " + this.detectedLanguage;
            },
            highlighted() {
              if (!this.autoDetect && !hljs.getLanguage(this.language)) {
                console.warn(`The language "${this.language}" you specified could not be found.`);
                this.unknownLanguage = true;
                return escapeHTML2(this.code);
              }
              let result2 = {};
              if (this.autoDetect) {
                result2 = hljs.highlightAuto(this.code);
                this.detectedLanguage = result2.language;
              } else {
                result2 = hljs.highlight(this.language, this.code, this.ignoreIllegals);
                this.detectedLanguage = this.language;
              }
              return result2.value;
            },
            autoDetect() {
              return !this.language || hasValueOrEmptyAttribute2(this.autodetect);
            },
            ignoreIllegals() {
              return true;
            }
          },
          render(createElement) {
            return createElement("pre", {}, [
              createElement("code", {
                class: this.className,
                domProps: { innerHTML: this.highlighted }
              })
            ]);
          }
        };
        const VuePlugin = {
          install(Vue) {
            Vue.component("highlightjs", Component);
          }
        };
        return { Component, VuePlugin };
      }
      var mergeHTMLPlugin2 = {
        "after:highlightElement": ({ el, result: result2, text: text4 }) => {
          const originalStream = nodeStream2(el);
          if (!originalStream.length)
            return;
          const resultNode = document.createElement("div");
          resultNode.innerHTML = result2.value;
          result2.value = mergeStreams2(originalStream, nodeStream2(resultNode), text4);
        }
      };
      function tag2(node5) {
        return node5.nodeName.toLowerCase();
      }
      function nodeStream2(node5) {
        const result2 = [];
        (function _nodeStream(node6, offset4) {
          for (let child5 = node6.firstChild; child5; child5 = child5.nextSibling) {
            if (child5.nodeType === 3) {
              offset4 += child5.nodeValue.length;
            } else if (child5.nodeType === 1) {
              result2.push({
                event: "start",
                offset: offset4,
                node: child5
              });
              offset4 = _nodeStream(child5, offset4);
              if (!tag2(child5).match(/br|hr|img|input/)) {
                result2.push({
                  event: "stop",
                  offset: offset4,
                  node: child5
                });
              }
            }
          }
          return offset4;
        })(node5, 0);
        return result2;
      }
      function mergeStreams2(original, highlighted, value) {
        let processed = 0;
        let result2 = "";
        const nodeStack = [];
        function selectStream() {
          if (!original.length || !highlighted.length) {
            return original.length ? original : highlighted;
          }
          if (original[0].offset !== highlighted[0].offset) {
            return original[0].offset < highlighted[0].offset ? original : highlighted;
          }
          return highlighted[0].event === "start" ? original : highlighted;
        }
        function open2(node5) {
          function attributeString(attr) {
            return " " + attr.nodeName + '="' + escapeHTML2(attr.value) + '"';
          }
          result2 += "<" + tag2(node5) + [].map.call(node5.attributes, attributeString).join("") + ">";
        }
        function close6(node5) {
          result2 += "</" + tag2(node5) + ">";
        }
        function render2(event) {
          (event.event === "start" ? open2 : close6)(event.node);
        }
        while (original.length || highlighted.length) {
          let stream = selectStream();
          result2 += escapeHTML2(value.substring(processed, stream[0].offset));
          processed = stream[0].offset;
          if (stream === original) {
            nodeStack.reverse().forEach(close6);
            do {
              render2(stream.splice(0, 1)[0]);
              stream = selectStream();
            } while (stream === original && stream.length && stream[0].offset === processed);
            nodeStack.reverse().forEach(open2);
          } else {
            if (stream[0].event === "start") {
              nodeStack.push(stream[0].node);
            } else {
              nodeStack.pop();
            }
            render2(stream.splice(0, 1)[0]);
          }
        }
        return result2 + escapeHTML2(value.substr(processed));
      }
      var seenDeprecations2 = {};
      var error3 = (message) => {
        console.error(message);
      };
      var warn2 = (message, ...args) => {
        console.log(`WARN: ${message}`, ...args);
      };
      var deprecated2 = (version3, message) => {
        if (seenDeprecations2[`${version3}/${message}`])
          return;
        console.log(`Deprecated as of ${version3}. ${message}`);
        seenDeprecations2[`${version3}/${message}`] = true;
      };
      var escape$12 = escapeHTML2;
      var inherit$12 = inherit2;
      var NO_MATCH2 = Symbol("nomatch");
      var HLJS2 = function(hljs) {
        const languages = /* @__PURE__ */ Object.create(null);
        const aliases = /* @__PURE__ */ Object.create(null);
        const plugins = [];
        let SAFE_MODE = true;
        const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
        const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
        let options = {
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          tabReplace: null,
          useBR: false,
          languages: null,
          __emitter: TokenTreeEmitter2
        };
        function shouldNotHighlight(languageName) {
          return options.noHighlightRe.test(languageName);
        }
        function blockLanguage(block) {
          let classes = block.className + " ";
          classes += block.parentNode ? block.parentNode.className : "";
          const match = options.languageDetectRe.exec(classes);
          if (match) {
            const language = getLanguage(match[1]);
            if (!language) {
              warn2(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
              warn2("Falling back to no-highlight mode for this block.", block);
            }
            return language ? match[1] : "no-highlight";
          }
          return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
        }
        function highlight3(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
          let code = "";
          let languageName = "";
          if (typeof optionsOrCode === "object") {
            code = codeOrlanguageName;
            ignoreIllegals = optionsOrCode.ignoreIllegals;
            languageName = optionsOrCode.language;
            continuation = void 0;
          } else {
            deprecated2("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
            deprecated2("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
            languageName = codeOrlanguageName;
            code = optionsOrCode;
          }
          const context = {
            code,
            language: languageName
          };
          fire("before:highlight", context);
          const result2 = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals, continuation);
          result2.code = context.code;
          fire("after:highlight", result2);
          return result2;
        }
        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
          function keywordData(mode, match) {
            const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
            return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
          }
          function processKeywords() {
            if (!top2.keywords) {
              emitter.addText(modeBuffer);
              return;
            }
            let lastIndex = 0;
            top2.keywordPatternRe.lastIndex = 0;
            let match = top2.keywordPatternRe.exec(modeBuffer);
            let buf = "";
            while (match) {
              buf += modeBuffer.substring(lastIndex, match.index);
              const data = keywordData(top2, match);
              if (data) {
                const [kind, keywordRelevance] = data;
                emitter.addText(buf);
                buf = "";
                relevance += keywordRelevance;
                if (kind.startsWith("_")) {
                  buf += match[0];
                } else {
                  const cssClass = language.classNameAliases[kind] || kind;
                  emitter.addKeyword(match[0], cssClass);
                }
              } else {
                buf += match[0];
              }
              lastIndex = top2.keywordPatternRe.lastIndex;
              match = top2.keywordPatternRe.exec(modeBuffer);
            }
            buf += modeBuffer.substr(lastIndex);
            emitter.addText(buf);
          }
          function processSubLanguage() {
            if (modeBuffer === "")
              return;
            let result3 = null;
            if (typeof top2.subLanguage === "string") {
              if (!languages[top2.subLanguage]) {
                emitter.addText(modeBuffer);
                return;
              }
              result3 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
              continuations[top2.subLanguage] = result3.top;
            } else {
              result3 = highlightAuto2(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
            }
            if (top2.relevance > 0) {
              relevance += result3.relevance;
            }
            emitter.addSublanguage(result3.emitter, result3.language);
          }
          function processBuffer() {
            if (top2.subLanguage != null) {
              processSubLanguage();
            } else {
              processKeywords();
            }
            modeBuffer = "";
          }
          function startNewMode(mode) {
            if (mode.className) {
              emitter.openNode(language.classNameAliases[mode.className] || mode.className);
            }
            top2 = Object.create(mode, { parent: { value: top2 } });
            return top2;
          }
          function endOfMode(mode, match, matchPlusRemainder) {
            let matched = startsWith2(mode.endRe, matchPlusRemainder);
            if (matched) {
              if (mode["on:end"]) {
                const resp = new Response2(mode);
                mode["on:end"](match, resp);
                if (resp.isMatchIgnored)
                  matched = false;
              }
              if (matched) {
                while (mode.endsParent && mode.parent) {
                  mode = mode.parent;
                }
                return mode;
              }
            }
            if (mode.endsWithParent) {
              return endOfMode(mode.parent, match, matchPlusRemainder);
            }
          }
          function doIgnore(lexeme) {
            if (top2.matcher.regexIndex === 0) {
              modeBuffer += lexeme[0];
              return 1;
            } else {
              resumeScanAtSamePosition = true;
              return 0;
            }
          }
          function doBeginMatch(match) {
            const lexeme = match[0];
            const newMode = match.rule;
            const resp = new Response2(newMode);
            const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
            for (const cb of beforeCallbacks) {
              if (!cb)
                continue;
              cb(match, resp);
              if (resp.isMatchIgnored)
                return doIgnore(lexeme);
            }
            if (newMode && newMode.endSameAsBegin) {
              newMode.endRe = escape2(lexeme);
            }
            if (newMode.skip) {
              modeBuffer += lexeme;
            } else {
              if (newMode.excludeBegin) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (!newMode.returnBegin && !newMode.excludeBegin) {
                modeBuffer = lexeme;
              }
            }
            startNewMode(newMode);
            return newMode.returnBegin ? 0 : lexeme.length;
          }
          function doEndMatch(match) {
            const lexeme = match[0];
            const matchPlusRemainder = codeToHighlight.substr(match.index);
            const endMode = endOfMode(top2, match, matchPlusRemainder);
            if (!endMode) {
              return NO_MATCH2;
            }
            const origin = top2;
            if (origin.skip) {
              modeBuffer += lexeme;
            } else {
              if (!(origin.returnEnd || origin.excludeEnd)) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (origin.excludeEnd) {
                modeBuffer = lexeme;
              }
            }
            do {
              if (top2.className) {
                emitter.closeNode();
              }
              if (!top2.skip && !top2.subLanguage) {
                relevance += top2.relevance;
              }
              top2 = top2.parent;
            } while (top2 !== endMode.parent);
            if (endMode.starts) {
              if (endMode.endSameAsBegin) {
                endMode.starts.endRe = endMode.endRe;
              }
              startNewMode(endMode.starts);
            }
            return origin.returnEnd ? 0 : lexeme.length;
          }
          function processContinuations() {
            const list = [];
            for (let current = top2; current !== language; current = current.parent) {
              if (current.className) {
                list.unshift(current.className);
              }
            }
            list.forEach((item) => emitter.openNode(item));
          }
          let lastMatch = {};
          function processLexeme(textBeforeMatch, match) {
            const lexeme = match && match[0];
            modeBuffer += textBeforeMatch;
            if (lexeme == null) {
              processBuffer();
              return 0;
            }
            if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
              modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
              if (!SAFE_MODE) {
                const err3 = new Error("0 width match regex");
                err3.languageName = languageName;
                err3.badRule = lastMatch.rule;
                throw err3;
              }
              return 1;
            }
            lastMatch = match;
            if (match.type === "begin") {
              return doBeginMatch(match);
            } else if (match.type === "illegal" && !ignoreIllegals) {
              const err3 = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.className || "<unnamed>") + '"');
              err3.mode = top2;
              throw err3;
            } else if (match.type === "end") {
              const processed = doEndMatch(match);
              if (processed !== NO_MATCH2) {
                return processed;
              }
            }
            if (match.type === "illegal" && lexeme === "") {
              return 1;
            }
            if (iterations > 1e5 && iterations > match.index * 3) {
              const err3 = new Error("potential infinite loop, way more iterations than matches");
              throw err3;
            }
            modeBuffer += lexeme;
            return lexeme.length;
          }
          const language = getLanguage(languageName);
          if (!language) {
            error3(LANGUAGE_NOT_FOUND.replace("{}", languageName));
            throw new Error('Unknown language: "' + languageName + '"');
          }
          const md = compileLanguage2(language, { plugins });
          let result2 = "";
          let top2 = continuation || md;
          const continuations = {};
          const emitter = new options.__emitter(options);
          processContinuations();
          let modeBuffer = "";
          let relevance = 0;
          let index3 = 0;
          let iterations = 0;
          let resumeScanAtSamePosition = false;
          try {
            top2.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top2.matcher.considerAll();
              }
              top2.matcher.lastIndex = index3;
              const match = top2.matcher.exec(codeToHighlight);
              if (!match)
                break;
              const beforeMatch = codeToHighlight.substring(index3, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index3 = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substr(index3));
            emitter.closeAllNodes();
            emitter.finalize();
            result2 = emitter.toHTML();
            return {
              relevance: Math.floor(relevance),
              value: result2,
              language: languageName,
              illegal: false,
              emitter,
              top: top2
            };
          } catch (err3) {
            if (err3.message && err3.message.includes("Illegal")) {
              return {
                illegal: true,
                illegalBy: {
                  msg: err3.message,
                  context: codeToHighlight.slice(index3 - 100, index3 + 100),
                  mode: err3.mode
                },
                sofar: result2,
                relevance: 0,
                value: escape$12(codeToHighlight),
                emitter
              };
            } else if (SAFE_MODE) {
              return {
                illegal: false,
                relevance: 0,
                value: escape$12(codeToHighlight),
                emitter,
                language: languageName,
                top: top2,
                errorRaised: err3
              };
            } else {
              throw err3;
            }
          }
        }
        function justTextHighlightResult(code) {
          const result2 = {
            relevance: 0,
            emitter: new options.__emitter(options),
            value: escape$12(code),
            illegal: false,
            top: PLAINTEXT_LANGUAGE
          };
          result2.emitter.addText(code);
          return result2;
        }
        function highlightAuto2(code, languageSubset) {
          languageSubset = languageSubset || options.languages || Object.keys(languages);
          const plaintext = justTextHighlightResult(code);
          const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name) => _highlight(name, code, false));
          results.unshift(plaintext);
          const sorted = results.sort((a, b) => {
            if (a.relevance !== b.relevance)
              return b.relevance - a.relevance;
            if (a.language && b.language) {
              if (getLanguage(a.language).supersetOf === b.language) {
                return 1;
              } else if (getLanguage(b.language).supersetOf === a.language) {
                return -1;
              }
            }
            return 0;
          });
          const [best, secondBest] = sorted;
          const result2 = best;
          result2.second_best = secondBest;
          return result2;
        }
        function fixMarkup(html) {
          if (!(options.tabReplace || options.useBR)) {
            return html;
          }
          return html.replace(fixMarkupRe, (match) => {
            if (match === "\n") {
              return options.useBR ? "<br>" : match;
            } else if (options.tabReplace) {
              return match.replace(/\t/g, options.tabReplace);
            }
            return match;
          });
        }
        function updateClassName(element, currentLang, resultLang) {
          const language = currentLang ? aliases[currentLang] : resultLang;
          element.classList.add("hljs");
          if (language)
            element.classList.add(language);
        }
        const brPlugin = {
          "before:highlightElement": ({ el }) => {
            if (options.useBR) {
              el.innerHTML = el.innerHTML.replace(/\n/g, "").replace(/<br[ /]*>/g, "\n");
            }
          },
          "after:highlightElement": ({ result: result2 }) => {
            if (options.useBR) {
              result2.value = result2.value.replace(/\n/g, "<br>");
            }
          }
        };
        const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
        const tabReplacePlugin = {
          "after:highlightElement": ({ result: result2 }) => {
            if (options.tabReplace) {
              result2.value = result2.value.replace(TAB_REPLACE_RE, (m) => m.replace(/\t/g, options.tabReplace));
            }
          }
        };
        function highlightElement(element) {
          let node5 = null;
          const language = blockLanguage(element);
          if (shouldNotHighlight(language))
            return;
          fire("before:highlightElement", { el: element, language });
          node5 = element;
          const text4 = node5.textContent;
          const result2 = language ? highlight3(text4, { language, ignoreIllegals: true }) : highlightAuto2(text4);
          fire("after:highlightElement", { el: element, result: result2, text: text4 });
          element.innerHTML = result2.value;
          updateClassName(element, language, result2.language);
          element.result = {
            language: result2.language,
            re: result2.relevance,
            relavance: result2.relevance
          };
          if (result2.second_best) {
            element.second_best = {
              language: result2.second_best.language,
              re: result2.second_best.relevance,
              relavance: result2.second_best.relevance
            };
          }
        }
        function configure(userOptions) {
          if (userOptions.useBR) {
            deprecated2("10.3.0", "'useBR' will be removed entirely in v11.0");
            deprecated2("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
          }
          options = inherit$12(options, userOptions);
        }
        const initHighlighting = () => {
          if (initHighlighting.called)
            return;
          initHighlighting.called = true;
          deprecated2("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");
          const blocks = document.querySelectorAll("pre code");
          blocks.forEach(highlightElement);
        };
        function initHighlightingOnLoad() {
          deprecated2("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
          wantsHighlight = true;
        }
        let wantsHighlight = false;
        function highlightAll() {
          if (document.readyState === "loading") {
            wantsHighlight = true;
            return;
          }
          const blocks = document.querySelectorAll("pre code");
          blocks.forEach(highlightElement);
        }
        function boot() {
          if (wantsHighlight)
            highlightAll();
        }
        if (typeof window !== "undefined" && window.addEventListener) {
          window.addEventListener("DOMContentLoaded", boot, false);
        }
        function registerLanguage2(languageName, languageDefinition) {
          let lang = null;
          try {
            lang = languageDefinition(hljs);
          } catch (error$1) {
            error3("Language definition for '{}' could not be registered.".replace("{}", languageName));
            if (!SAFE_MODE) {
              throw error$1;
            } else {
              error3(error$1);
            }
            lang = PLAINTEXT_LANGUAGE;
          }
          if (!lang.name)
            lang.name = languageName;
          languages[languageName] = lang;
          lang.rawDefinition = languageDefinition.bind(null, hljs);
          if (lang.aliases) {
            registerAliases(lang.aliases, { languageName });
          }
        }
        function unregisterLanguage(languageName) {
          delete languages[languageName];
          for (const alias of Object.keys(aliases)) {
            if (aliases[alias] === languageName) {
              delete aliases[alias];
            }
          }
        }
        function listLanguages2() {
          return Object.keys(languages);
        }
        function requireLanguage(name) {
          deprecated2("10.4.0", "requireLanguage will be removed entirely in v11.");
          deprecated2("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");
          const lang = getLanguage(name);
          if (lang) {
            return lang;
          }
          const err3 = new Error("The '{}' language is required, but not loaded.".replace("{}", name));
          throw err3;
        }
        function getLanguage(name) {
          name = (name || "").toLowerCase();
          return languages[name] || languages[aliases[name]];
        }
        function registerAliases(aliasList, { languageName }) {
          if (typeof aliasList === "string") {
            aliasList = [aliasList];
          }
          aliasList.forEach((alias) => {
            aliases[alias.toLowerCase()] = languageName;
          });
        }
        function autoDetection(name) {
          const lang = getLanguage(name);
          return lang && !lang.disableAutodetect;
        }
        function upgradePluginAPI(plugin) {
          if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
            plugin["before:highlightElement"] = (data) => {
              plugin["before:highlightBlock"](Object.assign({ block: data.el }, data));
            };
          }
          if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
            plugin["after:highlightElement"] = (data) => {
              plugin["after:highlightBlock"](Object.assign({ block: data.el }, data));
            };
          }
        }
        function addPlugin(plugin) {
          upgradePluginAPI(plugin);
          plugins.push(plugin);
        }
        function fire(event, args) {
          const cb = event;
          plugins.forEach(function(plugin) {
            if (plugin[cb]) {
              plugin[cb](args);
            }
          });
        }
        function deprecateFixMarkup(arg) {
          deprecated2("10.2.0", "fixMarkup will be removed entirely in v11.0");
          deprecated2("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");
          return fixMarkup(arg);
        }
        function deprecateHighlightBlock(el) {
          deprecated2("10.7.0", "highlightBlock will be removed entirely in v12.0");
          deprecated2("10.7.0", "Please use highlightElement now.");
          return highlightElement(el);
        }
        Object.assign(hljs, {
          highlight: highlight3,
          highlightAuto: highlightAuto2,
          highlightAll,
          fixMarkup: deprecateFixMarkup,
          highlightElement,
          highlightBlock: deprecateHighlightBlock,
          configure,
          initHighlighting,
          initHighlightingOnLoad,
          registerLanguage: registerLanguage2,
          unregisterLanguage,
          listLanguages: listLanguages2,
          getLanguage,
          registerAliases,
          requireLanguage,
          autoDetection,
          inherit: inherit$12,
          addPlugin,
          vuePlugin: BuildVuePlugin2(hljs).VuePlugin
        });
        hljs.debugMode = function() {
          SAFE_MODE = false;
        };
        hljs.safeMode = function() {
          SAFE_MODE = true;
        };
        hljs.versionString = version2;
        for (const key2 in MODES2) {
          if (typeof MODES2[key2] === "object") {
            deepFreezeEs62(MODES2[key2]);
          }
        }
        Object.assign(hljs, MODES2);
        hljs.addPlugin(brPlugin);
        hljs.addPlugin(mergeHTMLPlugin2);
        hljs.addPlugin(tabReplacePlugin);
        return hljs;
      };
      var highlight2 = HLJS2({});
      module2.exports = highlight2;
    }
  });

  // node_modules/format/format.js
  var require_format = __commonJS({
    "node_modules/format/format.js"(exports2, module2) {
      (function() {
        var namespace;
        if (typeof module2 !== "undefined") {
          namespace = module2.exports = format3;
        } else {
          namespace = function() {
            return this || (1, eval)("this");
          }();
        }
        namespace.format = format3;
        namespace.vsprintf = vsprintf;
        if (typeof console !== "undefined" && typeof console.log === "function") {
          namespace.printf = printf;
        }
        function printf() {
          console.log(format3.apply(null, arguments));
        }
        function vsprintf(fmt, replacements) {
          return format3.apply(null, [fmt].concat(replacements));
        }
        function format3(fmt) {
          var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result2 = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
            return args[argIndex++];
          }, slurpNumber = function() {
            var digits = "";
            while (/\d/.test(fmt[i])) {
              digits += fmt[i++];
              c = fmt[i];
            }
            return digits.length > 0 ? parseInt(digits) : null;
          };
          for (; i < n; ++i) {
            c = fmt[i];
            if (escaped) {
              escaped = false;
              if (c == ".") {
                leadingZero = false;
                c = fmt[++i];
              } else if (c == "0" && fmt[i + 1] == ".") {
                leadingZero = true;
                i += 2;
                c = fmt[i];
              } else {
                leadingZero = true;
              }
              precision = slurpNumber();
              switch (c) {
                case "b":
                  result2 += parseInt(nextArg(), 10).toString(2);
                  break;
                case "c":
                  arg = nextArg();
                  if (typeof arg === "string" || arg instanceof String)
                    result2 += arg;
                  else
                    result2 += String.fromCharCode(parseInt(arg, 10));
                  break;
                case "d":
                  result2 += parseInt(nextArg(), 10);
                  break;
                case "f":
                  tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                  result2 += leadingZero ? tmp : tmp.replace(/^0/, "");
                  break;
                case "j":
                  result2 += JSON.stringify(nextArg());
                  break;
                case "o":
                  result2 += "0" + parseInt(nextArg(), 10).toString(8);
                  break;
                case "s":
                  result2 += nextArg();
                  break;
                case "x":
                  result2 += "0x" + parseInt(nextArg(), 10).toString(16);
                  break;
                case "X":
                  result2 += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                  break;
                default:
                  result2 += c;
                  break;
              }
            } else if (c === "%") {
              escaped = true;
            } else {
              result2 += c;
            }
          }
          return result2;
        }
      })();
    }
  });

  // node_modules/fault/index.js
  var require_fault = __commonJS({
    "node_modules/fault/index.js"(exports2, module2) {
      "use strict";
      var formatter2 = require_format();
      var fault2 = create9(Error);
      module2.exports = fault2;
      fault2.eval = create9(EvalError);
      fault2.range = create9(RangeError);
      fault2.reference = create9(ReferenceError);
      fault2.syntax = create9(SyntaxError);
      fault2.type = create9(TypeError);
      fault2.uri = create9(URIError);
      fault2.create = create9;
      function create9(EConstructor) {
        FormattedError.displayName = EConstructor.displayName || EConstructor.name;
        return FormattedError;
        function FormattedError(format3) {
          if (format3) {
            format3 = formatter2.apply(null, arguments);
          }
          return new EConstructor(format3);
        }
      }
    }
  });

  // node_modules/lowlight/lib/core.js
  var require_core2 = __commonJS({
    "node_modules/lowlight/lib/core.js"(exports2) {
      "use strict";
      var high2 = require_core();
      var fault2 = require_fault();
      exports2.highlight = highlight2;
      exports2.highlightAuto = highlightAuto2;
      exports2.registerLanguage = registerLanguage2;
      exports2.listLanguages = listLanguages2;
      exports2.registerAlias = registerAlias2;
      Emitter2.prototype.addText = text4;
      Emitter2.prototype.addKeyword = addKeyword2;
      Emitter2.prototype.addSublanguage = addSublanguage2;
      Emitter2.prototype.openNode = open2;
      Emitter2.prototype.closeNode = close6;
      Emitter2.prototype.closeAllNodes = noop3;
      Emitter2.prototype.finalize = noop3;
      Emitter2.prototype.toHTML = toHtmlNoop2;
      var defaultPrefix2 = "hljs-";
      function highlight2(name, value, options) {
        var before3 = high2.configure({});
        var settings = options || {};
        var prefix = settings.prefix;
        var result2;
        if (typeof name !== "string") {
          throw fault2("Expected `string` for name, got `%s`", name);
        }
        if (!high2.getLanguage(name)) {
          throw fault2("Unknown language: `%s` is not registered", name);
        }
        if (typeof value !== "string") {
          throw fault2("Expected `string` for value, got `%s`", value);
        }
        if (prefix === null || prefix === void 0) {
          prefix = defaultPrefix2;
        }
        high2.configure({ __emitter: Emitter2, classPrefix: prefix });
        result2 = high2.highlight(value, { language: name, ignoreIllegals: true });
        high2.configure(before3 || {});
        if (result2.errorRaised) {
          throw result2.errorRaised;
        }
        return {
          relevance: result2.relevance,
          language: result2.language,
          value: result2.emitter.rootNode.children
        };
      }
      function highlightAuto2(value, options) {
        var settings = options || {};
        var subset = settings.subset || high2.listLanguages();
        var prefix = settings.prefix;
        var length = subset.length;
        var index3 = -1;
        var result2;
        var secondBest;
        var current;
        var name;
        if (prefix === null || prefix === void 0) {
          prefix = defaultPrefix2;
        }
        if (typeof value !== "string") {
          throw fault2("Expected `string` for value, got `%s`", value);
        }
        secondBest = { relevance: 0, language: null, value: [] };
        result2 = { relevance: 0, language: null, value: [] };
        while (++index3 < length) {
          name = subset[index3];
          if (!high2.getLanguage(name)) {
            continue;
          }
          current = highlight2(name, value, options);
          current.language = name;
          if (current.relevance > secondBest.relevance) {
            secondBest = current;
          }
          if (current.relevance > result2.relevance) {
            secondBest = result2;
            result2 = current;
          }
        }
        if (secondBest.language) {
          result2.secondBest = secondBest;
        }
        return result2;
      }
      function registerLanguage2(name, syntax) {
        high2.registerLanguage(name, syntax);
      }
      function listLanguages2() {
        return high2.listLanguages();
      }
      function registerAlias2(name, alias) {
        var map22 = name;
        var key2;
        if (alias) {
          map22 = {};
          map22[name] = alias;
        }
        for (key2 in map22) {
          high2.registerAliases(map22[key2], { languageName: key2 });
        }
      }
      function Emitter2(options) {
        this.options = options;
        this.rootNode = { children: [] };
        this.stack = [this.rootNode];
      }
      function addKeyword2(value, name) {
        this.openNode(name);
        this.addText(value);
        this.closeNode();
      }
      function addSublanguage2(other, name) {
        var stack = this.stack;
        var current = stack[stack.length - 1];
        var results = other.rootNode.children;
        var node5 = name ? {
          type: "element",
          tagName: "span",
          properties: { className: [name] },
          children: results
        } : results;
        current.children = current.children.concat(node5);
      }
      function text4(value) {
        var stack = this.stack;
        var current;
        var tail;
        if (value === "")
          return;
        current = stack[stack.length - 1];
        tail = current.children[current.children.length - 1];
        if (tail && tail.type === "text") {
          tail.value += value;
        } else {
          current.children.push({ type: "text", value });
        }
      }
      function open2(name) {
        var stack = this.stack;
        var className = this.options.classPrefix + name;
        var current = stack[stack.length - 1];
        var child5 = {
          type: "element",
          tagName: "span",
          properties: { className: [className] },
          children: []
        };
        current.children.push(child5);
        stack.push(child5);
      }
      function close6() {
        this.stack.pop();
      }
      function toHtmlNoop2() {
        return "";
      }
      function noop3() {
      }
    }
  });

  // node_modules/highlight.js/lib/languages/css.js
  var require_css = __commonJS({
    "node_modules/highlight.js/lib/languages/css.js"(exports2, module2) {
      var MODES2 = (hljs) => {
        return {
          IMPORTANT: {
            className: "meta",
            begin: "!important"
          },
          HEXCOLOR: {
            className: "number",
            begin: "#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})"
          },
          ATTRIBUTE_SELECTOR_MODE: {
            className: "selector-attr",
            begin: /\[/,
            end: /\]/,
            illegal: "$",
            contains: [
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE
            ]
          }
        };
      };
      var TAGS = [
        "a",
        "abbr",
        "address",
        "article",
        "aside",
        "audio",
        "b",
        "blockquote",
        "body",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "dd",
        "del",
        "details",
        "dfn",
        "div",
        "dl",
        "dt",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "mark",
        "menu",
        "nav",
        "object",
        "ol",
        "p",
        "q",
        "quote",
        "samp",
        "section",
        "span",
        "strong",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "ul",
        "var",
        "video"
      ];
      var MEDIA_FEATURES = [
        "any-hover",
        "any-pointer",
        "aspect-ratio",
        "color",
        "color-gamut",
        "color-index",
        "device-aspect-ratio",
        "device-height",
        "device-width",
        "display-mode",
        "forced-colors",
        "grid",
        "height",
        "hover",
        "inverted-colors",
        "monochrome",
        "orientation",
        "overflow-block",
        "overflow-inline",
        "pointer",
        "prefers-color-scheme",
        "prefers-contrast",
        "prefers-reduced-motion",
        "prefers-reduced-transparency",
        "resolution",
        "scan",
        "scripting",
        "update",
        "width",
        "min-width",
        "max-width",
        "min-height",
        "max-height"
      ];
      var PSEUDO_CLASSES = [
        "active",
        "any-link",
        "blank",
        "checked",
        "current",
        "default",
        "defined",
        "dir",
        "disabled",
        "drop",
        "empty",
        "enabled",
        "first",
        "first-child",
        "first-of-type",
        "fullscreen",
        "future",
        "focus",
        "focus-visible",
        "focus-within",
        "has",
        "host",
        "host-context",
        "hover",
        "indeterminate",
        "in-range",
        "invalid",
        "is",
        "lang",
        "last-child",
        "last-of-type",
        "left",
        "link",
        "local-link",
        "not",
        "nth-child",
        "nth-col",
        "nth-last-child",
        "nth-last-col",
        "nth-last-of-type",
        "nth-of-type",
        "only-child",
        "only-of-type",
        "optional",
        "out-of-range",
        "past",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "right",
        "root",
        "scope",
        "target",
        "target-within",
        "user-invalid",
        "valid",
        "visited",
        "where"
      ];
      var PSEUDO_ELEMENTS = [
        "after",
        "backdrop",
        "before",
        "cue",
        "cue-region",
        "first-letter",
        "first-line",
        "grammar-error",
        "marker",
        "part",
        "placeholder",
        "selection",
        "slotted",
        "spelling-error"
      ];
      var ATTRIBUTES = [
        "align-content",
        "align-items",
        "align-self",
        "animation",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "auto",
        "backface-visibility",
        "background",
        "background-attachment",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "border",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "bottom",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "break-after",
        "break-before",
        "break-inside",
        "caption-side",
        "clear",
        "clip",
        "clip-path",
        "color",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columns",
        "content",
        "counter-increment",
        "counter-reset",
        "cursor",
        "direction",
        "display",
        "empty-cells",
        "filter",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "float",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-size",
        "font-size-adjust",
        "font-smoothing",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-variant-ligatures",
        "font-variation-settings",
        "font-weight",
        "height",
        "hyphens",
        "icon",
        "image-orientation",
        "image-rendering",
        "image-resolution",
        "ime-mode",
        "inherit",
        "initial",
        "justify-content",
        "left",
        "letter-spacing",
        "line-height",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-bottom",
        "margin-left",
        "margin-right",
        "margin-top",
        "marks",
        "mask",
        "max-height",
        "max-width",
        "min-height",
        "min-width",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "none",
        "normal",
        "object-fit",
        "object-position",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "overflow",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "padding",
        "padding-bottom",
        "padding-left",
        "padding-right",
        "padding-top",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "perspective",
        "perspective-origin",
        "pointer-events",
        "position",
        "quotes",
        "resize",
        "right",
        "src",
        "tab-size",
        "table-layout",
        "text-align",
        "text-align-last",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-style",
        "text-indent",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-position",
        "top",
        "transform",
        "transform-origin",
        "transform-style",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "unicode-bidi",
        "vertical-align",
        "visibility",
        "white-space",
        "widows",
        "width",
        "word-break",
        "word-spacing",
        "word-wrap",
        "z-index"
      ].reverse();
      function source2(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function lookahead(re) {
        return concat2("(?=", re, ")");
      }
      function concat2(...args) {
        const joined = args.map((x) => source2(x)).join("");
        return joined;
      }
      function css2(hljs) {
        const modes = MODES2(hljs);
        const FUNCTION_DISPATCH = {
          className: "built_in",
          begin: /[\w-]+(?=\()/
        };
        const VENDOR_PREFIX = {
          begin: /-(webkit|moz|ms|o)-(?=[a-z])/
        };
        const AT_MODIFIERS = "and or not only";
        const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
        const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
        const STRINGS = [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ];
        return {
          name: "CSS",
          case_insensitive: true,
          illegal: /[=|'\$]/,
          keywords: {
            keyframePosition: "from to"
          },
          classNameAliases: {
            keyframePosition: "selector-tag"
          },
          contains: [
            hljs.C_BLOCK_COMMENT_MODE,
            VENDOR_PREFIX,
            hljs.CSS_NUMBER_MODE,
            {
              className: "selector-id",
              begin: /#[A-Za-z0-9_-]+/,
              relevance: 0
            },
            {
              className: "selector-class",
              begin: "\\." + IDENT_RE2,
              relevance: 0
            },
            modes.ATTRIBUTE_SELECTOR_MODE,
            {
              className: "selector-pseudo",
              variants: [
                {
                  begin: ":(" + PSEUDO_CLASSES.join("|") + ")"
                },
                {
                  begin: "::(" + PSEUDO_ELEMENTS.join("|") + ")"
                }
              ]
            },
            {
              className: "attribute",
              begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
            },
            {
              begin: ":",
              end: "[;}]",
              contains: [
                modes.HEXCOLOR,
                modes.IMPORTANT,
                hljs.CSS_NUMBER_MODE,
                ...STRINGS,
                {
                  begin: /(url|data-uri)\(/,
                  end: /\)/,
                  relevance: 0,
                  keywords: {
                    built_in: "url data-uri"
                  },
                  contains: [
                    {
                      className: "string",
                      begin: /[^)]/,
                      endsWithParent: true,
                      excludeEnd: true
                    }
                  ]
                },
                FUNCTION_DISPATCH
              ]
            },
            {
              begin: lookahead(/@/),
              end: "[{;]",
              relevance: 0,
              illegal: /:/,
              contains: [
                {
                  className: "keyword",
                  begin: AT_PROPERTY_RE
                },
                {
                  begin: /\s/,
                  endsWithParent: true,
                  excludeEnd: true,
                  relevance: 0,
                  keywords: {
                    $pattern: /[a-z-]+/,
                    keyword: AT_MODIFIERS,
                    attribute: MEDIA_FEATURES.join(" ")
                  },
                  contains: [
                    {
                      begin: /[a-z-]+(?=:)/,
                      className: "attribute"
                    },
                    ...STRINGS,
                    hljs.CSS_NUMBER_MODE
                  ]
                }
              ]
            },
            {
              className: "selector-tag",
              begin: "\\b(" + TAGS.join("|") + ")\\b"
            }
          ]
        };
      }
      module2.exports = css2;
    }
  });

  // node_modules/highlight.js/lib/languages/javascript.js
  var require_javascript = __commonJS({
    "node_modules/highlight.js/lib/languages/javascript.js"(exports2, module2) {
      var IDENT_RE2 = "[A-Za-z$_][0-9A-Za-z$_]*";
      var KEYWORDS = [
        "as",
        "in",
        "of",
        "if",
        "for",
        "while",
        "finally",
        "var",
        "new",
        "function",
        "do",
        "return",
        "void",
        "else",
        "break",
        "catch",
        "instanceof",
        "with",
        "throw",
        "case",
        "default",
        "try",
        "switch",
        "continue",
        "typeof",
        "delete",
        "let",
        "yield",
        "const",
        "class",
        "debugger",
        "async",
        "await",
        "static",
        "import",
        "from",
        "export",
        "extends"
      ];
      var LITERALS = [
        "true",
        "false",
        "null",
        "undefined",
        "NaN",
        "Infinity"
      ];
      var TYPES = [
        "Intl",
        "DataView",
        "Number",
        "Math",
        "Date",
        "String",
        "RegExp",
        "Object",
        "Function",
        "Boolean",
        "Error",
        "Symbol",
        "Set",
        "Map",
        "WeakSet",
        "WeakMap",
        "Proxy",
        "Reflect",
        "JSON",
        "Promise",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Float32Array",
        "Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "ArrayBuffer",
        "BigInt64Array",
        "BigUint64Array",
        "BigInt"
      ];
      var ERROR_TYPES = [
        "EvalError",
        "InternalError",
        "RangeError",
        "ReferenceError",
        "SyntaxError",
        "TypeError",
        "URIError"
      ];
      var BUILT_IN_GLOBALS = [
        "setInterval",
        "setTimeout",
        "clearInterval",
        "clearTimeout",
        "require",
        "exports",
        "eval",
        "isFinite",
        "isNaN",
        "parseFloat",
        "parseInt",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "unescape"
      ];
      var BUILT_IN_VARIABLES = [
        "arguments",
        "this",
        "super",
        "console",
        "window",
        "document",
        "localStorage",
        "module",
        "global"
      ];
      var BUILT_INS = [].concat(BUILT_IN_GLOBALS, BUILT_IN_VARIABLES, TYPES, ERROR_TYPES);
      function source2(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function lookahead(re) {
        return concat2("(?=", re, ")");
      }
      function concat2(...args) {
        const joined = args.map((x) => source2(x)).join("");
        return joined;
      }
      function javascript2(hljs) {
        const hasClosingTag = (match, { after: after3 }) => {
          const tag2 = "</" + match[0].slice(1);
          const pos = match.input.indexOf(tag2, after3);
          return pos !== -1;
        };
        const IDENT_RE$1 = IDENT_RE2;
        const FRAGMENT = {
          begin: "<>",
          end: "</>"
        };
        const XML_TAG = {
          begin: /<[A-Za-z0-9\\._:-]+/,
          end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
          isTrulyOpeningTag: (match, response) => {
            const afterMatchIndex = match[0].length + match.index;
            const nextChar = match.input[afterMatchIndex];
            if (nextChar === "<") {
              response.ignoreMatch();
              return;
            }
            if (nextChar === ">") {
              if (!hasClosingTag(match, { after: afterMatchIndex })) {
                response.ignoreMatch();
              }
            }
          }
        };
        const KEYWORDS$1 = {
          $pattern: IDENT_RE2,
          keyword: KEYWORDS,
          literal: LITERALS,
          built_in: BUILT_INS
        };
        const decimalDigits = "[0-9](_?[0-9])*";
        const frac = `\\.(${decimalDigits})`;
        const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
        const NUMBER = {
          className: "number",
          variants: [
            { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
            { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
            { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
            { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
            { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
            { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
            { begin: "\\b0[0-7]+n?\\b" }
          ],
          relevance: 0
        };
        const SUBST = {
          className: "subst",
          begin: "\\$\\{",
          end: "\\}",
          keywords: KEYWORDS$1,
          contains: []
        };
        const HTML_TEMPLATE = {
          begin: "html`",
          end: "",
          starts: {
            end: "`",
            returnEnd: false,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ],
            subLanguage: "xml"
          }
        };
        const CSS_TEMPLATE = {
          begin: "css`",
          end: "",
          starts: {
            end: "`",
            returnEnd: false,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ],
            subLanguage: "css"
          }
        };
        const TEMPLATE_STRING = {
          className: "string",
          begin: "`",
          end: "`",
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ]
        };
        const JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+",
              contains: [
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        });
        const COMMENT2 = {
          className: "comment",
          variants: [
            JSDOC_COMMENT,
            hljs.C_BLOCK_COMMENT_MODE,
            hljs.C_LINE_COMMENT_MODE
          ]
        };
        const SUBST_INTERNALS = [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          TEMPLATE_STRING,
          NUMBER,
          hljs.REGEXP_MODE
        ];
        SUBST.contains = SUBST_INTERNALS.concat({
          begin: /\{/,
          end: /\}/,
          keywords: KEYWORDS$1,
          contains: [
            "self"
          ].concat(SUBST_INTERNALS)
        });
        const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
        const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS$1,
            contains: ["self"].concat(SUBST_AND_COMMENTS)
          }
        ]);
        const PARAMS = {
          className: "params",
          begin: /\(/,
          end: /\)/,
          excludeBegin: true,
          excludeEnd: true,
          keywords: KEYWORDS$1,
          contains: PARAMS_CONTAINS
        };
        return {
          name: "Javascript",
          aliases: ["js", "jsx", "mjs", "cjs"],
          keywords: KEYWORDS$1,
          exports: { PARAMS_CONTAINS },
          illegal: /#(?![$_A-z])/,
          contains: [
            hljs.SHEBANG({
              label: "shebang",
              binary: "node",
              relevance: 5
            }),
            {
              label: "use_strict",
              className: "meta",
              relevance: 10,
              begin: /^\s*['"]use (strict|asm)['"]/
            },
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            HTML_TEMPLATE,
            CSS_TEMPLATE,
            TEMPLATE_STRING,
            COMMENT2,
            NUMBER,
            {
              begin: concat2(/[{,\n]\s*/, lookahead(concat2(/(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/, IDENT_RE$1 + "\\s*:"))),
              relevance: 0,
              contains: [
                {
                  className: "attr",
                  begin: IDENT_RE$1 + lookahead("\\s*:"),
                  relevance: 0
                }
              ]
            },
            {
              begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
              keywords: "return throw case",
              contains: [
                COMMENT2,
                hljs.REGEXP_MODE,
                {
                  className: "function",
                  begin: "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>",
                  returnBegin: true,
                  end: "\\s*=>",
                  contains: [
                    {
                      className: "params",
                      variants: [
                        {
                          begin: hljs.UNDERSCORE_IDENT_RE,
                          relevance: 0
                        },
                        {
                          className: null,
                          begin: /\(\s*\)/,
                          skip: true
                        },
                        {
                          begin: /\(/,
                          end: /\)/,
                          excludeBegin: true,
                          excludeEnd: true,
                          keywords: KEYWORDS$1,
                          contains: PARAMS_CONTAINS
                        }
                      ]
                    }
                  ]
                },
                {
                  begin: /,/,
                  relevance: 0
                },
                {
                  className: "",
                  begin: /\s/,
                  end: /\s*/,
                  skip: true
                },
                {
                  variants: [
                    { begin: FRAGMENT.begin, end: FRAGMENT.end },
                    {
                      begin: XML_TAG.begin,
                      "on:begin": XML_TAG.isTrulyOpeningTag,
                      end: XML_TAG.end
                    }
                  ],
                  subLanguage: "xml",
                  contains: [
                    {
                      begin: XML_TAG.begin,
                      end: XML_TAG.end,
                      skip: true,
                      contains: ["self"]
                    }
                  ]
                }
              ],
              relevance: 0
            },
            {
              className: "function",
              beginKeywords: "function",
              end: /[{;]/,
              excludeEnd: true,
              keywords: KEYWORDS$1,
              contains: [
                "self",
                hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
                PARAMS
              ],
              illegal: /%/
            },
            {
              beginKeywords: "while if switch catch for"
            },
            {
              className: "function",
              begin: hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
              returnBegin: true,
              contains: [
                PARAMS,
                hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 })
              ]
            },
            {
              variants: [
                { begin: "\\." + IDENT_RE$1 },
                { begin: "\\$" + IDENT_RE$1 }
              ],
              relevance: 0
            },
            {
              className: "class",
              beginKeywords: "class",
              end: /[{;=]/,
              excludeEnd: true,
              illegal: /[:"[\]]/,
              contains: [
                { beginKeywords: "extends" },
                hljs.UNDERSCORE_TITLE_MODE
              ]
            },
            {
              begin: /\b(?=constructor)/,
              end: /[{;]/,
              excludeEnd: true,
              contains: [
                hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
                "self",
                PARAMS
              ]
            },
            {
              begin: "(get|set)\\s+(?=" + IDENT_RE$1 + "\\()",
              end: /\{/,
              keywords: "get set",
              contains: [
                hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
                { begin: /\(\)/ },
                PARAMS
              ]
            },
            {
              begin: /\$[(.]/
            }
          ]
        };
      }
      module2.exports = javascript2;
    }
  });

  // node_modules/highlight.js/lib/languages/json.js
  var require_json = __commonJS({
    "node_modules/highlight.js/lib/languages/json.js"(exports2, module2) {
      function json2(hljs) {
        const LITERALS = {
          literal: "true false null"
        };
        const ALLOWED_COMMENTS = [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ];
        const TYPES = [
          hljs.QUOTE_STRING_MODE,
          hljs.C_NUMBER_MODE
        ];
        const VALUE_CONTAINER = {
          end: ",",
          endsWithParent: true,
          excludeEnd: true,
          contains: TYPES,
          keywords: LITERALS
        };
        const OBJECT = {
          begin: /\{/,
          end: /\}/,
          contains: [
            {
              className: "attr",
              begin: /"/,
              end: /"/,
              contains: [hljs.BACKSLASH_ESCAPE],
              illegal: "\\n"
            },
            hljs.inherit(VALUE_CONTAINER, {
              begin: /:/
            })
          ].concat(ALLOWED_COMMENTS),
          illegal: "\\S"
        };
        const ARRAY = {
          begin: "\\[",
          end: "\\]",
          contains: [hljs.inherit(VALUE_CONTAINER)],
          illegal: "\\S"
        };
        TYPES.push(OBJECT, ARRAY);
        ALLOWED_COMMENTS.forEach(function(rule) {
          TYPES.push(rule);
        });
        return {
          name: "JSON",
          contains: TYPES,
          keywords: LITERALS,
          illegal: "\\S"
        };
      }
      module2.exports = json2;
    }
  });

  // node_modules/highlight.js/lib/languages/ruby.js
  var require_ruby = __commonJS({
    "node_modules/highlight.js/lib/languages/ruby.js"(exports2, module2) {
      function source2(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function lookahead(re) {
        return concat2("(?=", re, ")");
      }
      function concat2(...args) {
        const joined = args.map((x) => source2(x)).join("");
        return joined;
      }
      function ruby2(hljs) {
        const RUBY_METHOD_RE = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)";
        const RUBY_KEYWORDS = {
          keyword: "and then defined module in return redo if BEGIN retry end for self when next until do begin unless END rescue else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor __FILE__",
          built_in: "proc lambda",
          literal: "true false nil"
        };
        const YARDOCTAG = {
          className: "doctag",
          begin: "@[A-Za-z]+"
        };
        const IRB_OBJECT = {
          begin: "#<",
          end: ">"
        };
        const COMMENT_MODES = [
          hljs.COMMENT("#", "$", {
            contains: [YARDOCTAG]
          }),
          hljs.COMMENT("^=begin", "^=end", {
            contains: [YARDOCTAG],
            relevance: 10
          }),
          hljs.COMMENT("^__END__", "\\n$")
        ];
        const SUBST = {
          className: "subst",
          begin: /#\{/,
          end: /\}/,
          keywords: RUBY_KEYWORDS
        };
        const STRING = {
          className: "string",
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          variants: [
            {
              begin: /'/,
              end: /'/
            },
            {
              begin: /"/,
              end: /"/
            },
            {
              begin: /`/,
              end: /`/
            },
            {
              begin: /%[qQwWx]?\(/,
              end: /\)/
            },
            {
              begin: /%[qQwWx]?\[/,
              end: /\]/
            },
            {
              begin: /%[qQwWx]?\{/,
              end: /\}/
            },
            {
              begin: /%[qQwWx]?</,
              end: />/
            },
            {
              begin: /%[qQwWx]?\//,
              end: /\//
            },
            {
              begin: /%[qQwWx]?%/,
              end: /%/
            },
            {
              begin: /%[qQwWx]?-/,
              end: /-/
            },
            {
              begin: /%[qQwWx]?\|/,
              end: /\|/
            },
            {
              begin: /\B\?(\\\d{1,3})/
            },
            {
              begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/
            },
            {
              begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/
            },
            {
              begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/
            },
            {
              begin: /\B\?\\(c|C-)[\x20-\x7e]/
            },
            {
              begin: /\B\?\\?\S/
            },
            {
              begin: /<<[-~]?'?(\w+)\n(?:[^\n]*\n)*?\s*\1\b/,
              returnBegin: true,
              contains: [
                {
                  begin: /<<[-~]?'?/
                },
                hljs.END_SAME_AS_BEGIN({
                  begin: /(\w+)/,
                  end: /(\w+)/,
                  contains: [
                    hljs.BACKSLASH_ESCAPE,
                    SUBST
                  ]
                })
              ]
            }
          ]
        };
        const decimal = "[1-9](_?[0-9])*|0";
        const digits = "[0-9](_?[0-9])*";
        const NUMBER = {
          className: "number",
          relevance: 0,
          variants: [
            {
              begin: `\\b(${decimal})(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b`
            },
            {
              begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b"
            },
            {
              begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b"
            },
            {
              begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b"
            },
            {
              begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b"
            },
            {
              begin: "\\b0(_?[0-7])+r?i?\\b"
            }
          ]
        };
        const PARAMS = {
          className: "params",
          begin: "\\(",
          end: "\\)",
          endsParent: true,
          keywords: RUBY_KEYWORDS
        };
        const RUBY_DEFAULT_CONTAINS = [
          STRING,
          {
            className: "class",
            beginKeywords: "class module",
            end: "$|;",
            illegal: /=/,
            contains: [
              hljs.inherit(hljs.TITLE_MODE, {
                begin: "[A-Za-z_]\\w*(::\\w+)*(\\?|!)?"
              }),
              {
                begin: "<\\s*",
                contains: [
                  {
                    begin: "(" + hljs.IDENT_RE + "::)?" + hljs.IDENT_RE,
                    relevance: 0
                  }
                ]
              }
            ].concat(COMMENT_MODES)
          },
          {
            className: "function",
            begin: concat2(/def\s+/, lookahead(RUBY_METHOD_RE + "\\s*(\\(|;|$)")),
            relevance: 0,
            keywords: "def",
            end: "$|;",
            contains: [
              hljs.inherit(hljs.TITLE_MODE, {
                begin: RUBY_METHOD_RE
              }),
              PARAMS
            ].concat(COMMENT_MODES)
          },
          {
            begin: hljs.IDENT_RE + "::"
          },
          {
            className: "symbol",
            begin: hljs.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
            relevance: 0
          },
          {
            className: "symbol",
            begin: ":(?!\\s)",
            contains: [
              STRING,
              {
                begin: RUBY_METHOD_RE
              }
            ],
            relevance: 0
          },
          NUMBER,
          {
            className: "variable",
            begin: `(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])`
          },
          {
            className: "params",
            begin: /\|/,
            end: /\|/,
            relevance: 0,
            keywords: RUBY_KEYWORDS
          },
          {
            begin: "(" + hljs.RE_STARTERS_RE + "|unless)\\s*",
            keywords: "unless",
            contains: [
              {
                className: "regexp",
                contains: [
                  hljs.BACKSLASH_ESCAPE,
                  SUBST
                ],
                illegal: /\n/,
                variants: [
                  {
                    begin: "/",
                    end: "/[a-z]*"
                  },
                  {
                    begin: /%r\{/,
                    end: /\}[a-z]*/
                  },
                  {
                    begin: "%r\\(",
                    end: "\\)[a-z]*"
                  },
                  {
                    begin: "%r!",
                    end: "![a-z]*"
                  },
                  {
                    begin: "%r\\[",
                    end: "\\][a-z]*"
                  }
                ]
              }
            ].concat(IRB_OBJECT, COMMENT_MODES),
            relevance: 0
          }
        ].concat(IRB_OBJECT, COMMENT_MODES);
        SUBST.contains = RUBY_DEFAULT_CONTAINS;
        PARAMS.contains = RUBY_DEFAULT_CONTAINS;
        const SIMPLE_PROMPT = "[>?]>";
        const DEFAULT_PROMPT = "[\\w#]+\\(\\w+\\):\\d+:\\d+>";
        const RVM_PROMPT = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>";
        const IRB_DEFAULT = [
          {
            begin: /^\s*=>/,
            starts: {
              end: "$",
              contains: RUBY_DEFAULT_CONTAINS
            }
          },
          {
            className: "meta",
            begin: "^(" + SIMPLE_PROMPT + "|" + DEFAULT_PROMPT + "|" + RVM_PROMPT + ")(?=[ ])",
            starts: {
              end: "$",
              contains: RUBY_DEFAULT_CONTAINS
            }
          }
        ];
        COMMENT_MODES.unshift(IRB_OBJECT);
        return {
          name: "Ruby",
          aliases: [
            "rb",
            "gemspec",
            "podspec",
            "thor",
            "irb"
          ],
          keywords: RUBY_KEYWORDS,
          illegal: /\/\*/,
          contains: [
            hljs.SHEBANG({
              binary: "ruby"
            })
          ].concat(IRB_DEFAULT).concat(COMMENT_MODES).concat(RUBY_DEFAULT_CONTAINS)
        };
      }
      module2.exports = ruby2;
    }
  });

  // node_modules/highlight.js/lib/languages/scss.js
  var require_scss = __commonJS({
    "node_modules/highlight.js/lib/languages/scss.js"(exports2, module2) {
      var MODES2 = (hljs) => {
        return {
          IMPORTANT: {
            className: "meta",
            begin: "!important"
          },
          HEXCOLOR: {
            className: "number",
            begin: "#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})"
          },
          ATTRIBUTE_SELECTOR_MODE: {
            className: "selector-attr",
            begin: /\[/,
            end: /\]/,
            illegal: "$",
            contains: [
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE
            ]
          }
        };
      };
      var TAGS = [
        "a",
        "abbr",
        "address",
        "article",
        "aside",
        "audio",
        "b",
        "blockquote",
        "body",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "dd",
        "del",
        "details",
        "dfn",
        "div",
        "dl",
        "dt",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "mark",
        "menu",
        "nav",
        "object",
        "ol",
        "p",
        "q",
        "quote",
        "samp",
        "section",
        "span",
        "strong",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "ul",
        "var",
        "video"
      ];
      var MEDIA_FEATURES = [
        "any-hover",
        "any-pointer",
        "aspect-ratio",
        "color",
        "color-gamut",
        "color-index",
        "device-aspect-ratio",
        "device-height",
        "device-width",
        "display-mode",
        "forced-colors",
        "grid",
        "height",
        "hover",
        "inverted-colors",
        "monochrome",
        "orientation",
        "overflow-block",
        "overflow-inline",
        "pointer",
        "prefers-color-scheme",
        "prefers-contrast",
        "prefers-reduced-motion",
        "prefers-reduced-transparency",
        "resolution",
        "scan",
        "scripting",
        "update",
        "width",
        "min-width",
        "max-width",
        "min-height",
        "max-height"
      ];
      var PSEUDO_CLASSES = [
        "active",
        "any-link",
        "blank",
        "checked",
        "current",
        "default",
        "defined",
        "dir",
        "disabled",
        "drop",
        "empty",
        "enabled",
        "first",
        "first-child",
        "first-of-type",
        "fullscreen",
        "future",
        "focus",
        "focus-visible",
        "focus-within",
        "has",
        "host",
        "host-context",
        "hover",
        "indeterminate",
        "in-range",
        "invalid",
        "is",
        "lang",
        "last-child",
        "last-of-type",
        "left",
        "link",
        "local-link",
        "not",
        "nth-child",
        "nth-col",
        "nth-last-child",
        "nth-last-col",
        "nth-last-of-type",
        "nth-of-type",
        "only-child",
        "only-of-type",
        "optional",
        "out-of-range",
        "past",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "right",
        "root",
        "scope",
        "target",
        "target-within",
        "user-invalid",
        "valid",
        "visited",
        "where"
      ];
      var PSEUDO_ELEMENTS = [
        "after",
        "backdrop",
        "before",
        "cue",
        "cue-region",
        "first-letter",
        "first-line",
        "grammar-error",
        "marker",
        "part",
        "placeholder",
        "selection",
        "slotted",
        "spelling-error"
      ];
      var ATTRIBUTES = [
        "align-content",
        "align-items",
        "align-self",
        "animation",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "auto",
        "backface-visibility",
        "background",
        "background-attachment",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "border",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "bottom",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "break-after",
        "break-before",
        "break-inside",
        "caption-side",
        "clear",
        "clip",
        "clip-path",
        "color",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columns",
        "content",
        "counter-increment",
        "counter-reset",
        "cursor",
        "direction",
        "display",
        "empty-cells",
        "filter",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "float",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-size",
        "font-size-adjust",
        "font-smoothing",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-variant-ligatures",
        "font-variation-settings",
        "font-weight",
        "height",
        "hyphens",
        "icon",
        "image-orientation",
        "image-rendering",
        "image-resolution",
        "ime-mode",
        "inherit",
        "initial",
        "justify-content",
        "left",
        "letter-spacing",
        "line-height",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-bottom",
        "margin-left",
        "margin-right",
        "margin-top",
        "marks",
        "mask",
        "max-height",
        "max-width",
        "min-height",
        "min-width",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "none",
        "normal",
        "object-fit",
        "object-position",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "overflow",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "padding",
        "padding-bottom",
        "padding-left",
        "padding-right",
        "padding-top",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "perspective",
        "perspective-origin",
        "pointer-events",
        "position",
        "quotes",
        "resize",
        "right",
        "src",
        "tab-size",
        "table-layout",
        "text-align",
        "text-align-last",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-style",
        "text-indent",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-position",
        "top",
        "transform",
        "transform-origin",
        "transform-style",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "unicode-bidi",
        "vertical-align",
        "visibility",
        "white-space",
        "widows",
        "width",
        "word-break",
        "word-spacing",
        "word-wrap",
        "z-index"
      ].reverse();
      function scss2(hljs) {
        const modes = MODES2(hljs);
        const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;
        const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;
        const AT_IDENTIFIER = "@[a-z-]+";
        const AT_MODIFIERS = "and or not only";
        const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
        const VARIABLE = {
          className: "variable",
          begin: "(\\$" + IDENT_RE2 + ")\\b"
        };
        return {
          name: "SCSS",
          case_insensitive: true,
          illegal: "[=/|']",
          contains: [
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            {
              className: "selector-id",
              begin: "#[A-Za-z0-9_-]+",
              relevance: 0
            },
            {
              className: "selector-class",
              begin: "\\.[A-Za-z0-9_-]+",
              relevance: 0
            },
            modes.ATTRIBUTE_SELECTOR_MODE,
            {
              className: "selector-tag",
              begin: "\\b(" + TAGS.join("|") + ")\\b",
              relevance: 0
            },
            {
              className: "selector-pseudo",
              begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
            },
            {
              className: "selector-pseudo",
              begin: "::(" + PSEUDO_ELEMENTS$1.join("|") + ")"
            },
            VARIABLE,
            {
              begin: /\(/,
              end: /\)/,
              contains: [hljs.CSS_NUMBER_MODE]
            },
            {
              className: "attribute",
              begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
            },
            {
              begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"
            },
            {
              begin: ":",
              end: ";",
              contains: [
                VARIABLE,
                modes.HEXCOLOR,
                hljs.CSS_NUMBER_MODE,
                hljs.QUOTE_STRING_MODE,
                hljs.APOS_STRING_MODE,
                modes.IMPORTANT
              ]
            },
            {
              begin: "@(page|font-face)",
              lexemes: AT_IDENTIFIER,
              keywords: "@page @font-face"
            },
            {
              begin: "@",
              end: "[{;]",
              returnBegin: true,
              keywords: {
                $pattern: /[a-z-]+/,
                keyword: AT_MODIFIERS,
                attribute: MEDIA_FEATURES.join(" ")
              },
              contains: [
                {
                  begin: AT_IDENTIFIER,
                  className: "keyword"
                },
                {
                  begin: /[a-z-]+(?=:)/,
                  className: "attribute"
                },
                VARIABLE,
                hljs.QUOTE_STRING_MODE,
                hljs.APOS_STRING_MODE,
                modes.HEXCOLOR,
                hljs.CSS_NUMBER_MODE
              ]
            }
          ]
        };
      }
      module2.exports = scss2;
    }
  });

  // node_modules/highlight.js/lib/languages/sql.js
  var require_sql = __commonJS({
    "node_modules/highlight.js/lib/languages/sql.js"(exports2, module2) {
      function source2(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function concat2(...args) {
        const joined = args.map((x) => source2(x)).join("");
        return joined;
      }
      function either2(...args) {
        const joined = "(" + args.map((x) => source2(x)).join("|") + ")";
        return joined;
      }
      function sql2(hljs) {
        const COMMENT_MODE = hljs.COMMENT("--", "$");
        const STRING = {
          className: "string",
          variants: [
            {
              begin: /'/,
              end: /'/,
              contains: [
                { begin: /''/ }
              ]
            }
          ]
        };
        const QUOTED_IDENTIFIER = {
          begin: /"/,
          end: /"/,
          contains: [{ begin: /""/ }]
        };
        const LITERALS = [
          "true",
          "false",
          "unknown"
        ];
        const MULTI_WORD_TYPES = [
          "double precision",
          "large object",
          "with timezone",
          "without timezone"
        ];
        const TYPES = [
          "bigint",
          "binary",
          "blob",
          "boolean",
          "char",
          "character",
          "clob",
          "date",
          "dec",
          "decfloat",
          "decimal",
          "float",
          "int",
          "integer",
          "interval",
          "nchar",
          "nclob",
          "national",
          "numeric",
          "real",
          "row",
          "smallint",
          "time",
          "timestamp",
          "varchar",
          "varying",
          "varbinary"
        ];
        const NON_RESERVED_WORDS = [
          "add",
          "asc",
          "collation",
          "desc",
          "final",
          "first",
          "last",
          "view"
        ];
        const RESERVED_WORDS = [
          "abs",
          "acos",
          "all",
          "allocate",
          "alter",
          "and",
          "any",
          "are",
          "array",
          "array_agg",
          "array_max_cardinality",
          "as",
          "asensitive",
          "asin",
          "asymmetric",
          "at",
          "atan",
          "atomic",
          "authorization",
          "avg",
          "begin",
          "begin_frame",
          "begin_partition",
          "between",
          "bigint",
          "binary",
          "blob",
          "boolean",
          "both",
          "by",
          "call",
          "called",
          "cardinality",
          "cascaded",
          "case",
          "cast",
          "ceil",
          "ceiling",
          "char",
          "char_length",
          "character",
          "character_length",
          "check",
          "classifier",
          "clob",
          "close",
          "coalesce",
          "collate",
          "collect",
          "column",
          "commit",
          "condition",
          "connect",
          "constraint",
          "contains",
          "convert",
          "copy",
          "corr",
          "corresponding",
          "cos",
          "cosh",
          "count",
          "covar_pop",
          "covar_samp",
          "create",
          "cross",
          "cube",
          "cume_dist",
          "current",
          "current_catalog",
          "current_date",
          "current_default_transform_group",
          "current_path",
          "current_role",
          "current_row",
          "current_schema",
          "current_time",
          "current_timestamp",
          "current_path",
          "current_role",
          "current_transform_group_for_type",
          "current_user",
          "cursor",
          "cycle",
          "date",
          "day",
          "deallocate",
          "dec",
          "decimal",
          "decfloat",
          "declare",
          "default",
          "define",
          "delete",
          "dense_rank",
          "deref",
          "describe",
          "deterministic",
          "disconnect",
          "distinct",
          "double",
          "drop",
          "dynamic",
          "each",
          "element",
          "else",
          "empty",
          "end",
          "end_frame",
          "end_partition",
          "end-exec",
          "equals",
          "escape",
          "every",
          "except",
          "exec",
          "execute",
          "exists",
          "exp",
          "external",
          "extract",
          "false",
          "fetch",
          "filter",
          "first_value",
          "float",
          "floor",
          "for",
          "foreign",
          "frame_row",
          "free",
          "from",
          "full",
          "function",
          "fusion",
          "get",
          "global",
          "grant",
          "group",
          "grouping",
          "groups",
          "having",
          "hold",
          "hour",
          "identity",
          "in",
          "indicator",
          "initial",
          "inner",
          "inout",
          "insensitive",
          "insert",
          "int",
          "integer",
          "intersect",
          "intersection",
          "interval",
          "into",
          "is",
          "join",
          "json_array",
          "json_arrayagg",
          "json_exists",
          "json_object",
          "json_objectagg",
          "json_query",
          "json_table",
          "json_table_primitive",
          "json_value",
          "lag",
          "language",
          "large",
          "last_value",
          "lateral",
          "lead",
          "leading",
          "left",
          "like",
          "like_regex",
          "listagg",
          "ln",
          "local",
          "localtime",
          "localtimestamp",
          "log",
          "log10",
          "lower",
          "match",
          "match_number",
          "match_recognize",
          "matches",
          "max",
          "member",
          "merge",
          "method",
          "min",
          "minute",
          "mod",
          "modifies",
          "module",
          "month",
          "multiset",
          "national",
          "natural",
          "nchar",
          "nclob",
          "new",
          "no",
          "none",
          "normalize",
          "not",
          "nth_value",
          "ntile",
          "null",
          "nullif",
          "numeric",
          "octet_length",
          "occurrences_regex",
          "of",
          "offset",
          "old",
          "omit",
          "on",
          "one",
          "only",
          "open",
          "or",
          "order",
          "out",
          "outer",
          "over",
          "overlaps",
          "overlay",
          "parameter",
          "partition",
          "pattern",
          "per",
          "percent",
          "percent_rank",
          "percentile_cont",
          "percentile_disc",
          "period",
          "portion",
          "position",
          "position_regex",
          "power",
          "precedes",
          "precision",
          "prepare",
          "primary",
          "procedure",
          "ptf",
          "range",
          "rank",
          "reads",
          "real",
          "recursive",
          "ref",
          "references",
          "referencing",
          "regr_avgx",
          "regr_avgy",
          "regr_count",
          "regr_intercept",
          "regr_r2",
          "regr_slope",
          "regr_sxx",
          "regr_sxy",
          "regr_syy",
          "release",
          "result",
          "return",
          "returns",
          "revoke",
          "right",
          "rollback",
          "rollup",
          "row",
          "row_number",
          "rows",
          "running",
          "savepoint",
          "scope",
          "scroll",
          "search",
          "second",
          "seek",
          "select",
          "sensitive",
          "session_user",
          "set",
          "show",
          "similar",
          "sin",
          "sinh",
          "skip",
          "smallint",
          "some",
          "specific",
          "specifictype",
          "sql",
          "sqlexception",
          "sqlstate",
          "sqlwarning",
          "sqrt",
          "start",
          "static",
          "stddev_pop",
          "stddev_samp",
          "submultiset",
          "subset",
          "substring",
          "substring_regex",
          "succeeds",
          "sum",
          "symmetric",
          "system",
          "system_time",
          "system_user",
          "table",
          "tablesample",
          "tan",
          "tanh",
          "then",
          "time",
          "timestamp",
          "timezone_hour",
          "timezone_minute",
          "to",
          "trailing",
          "translate",
          "translate_regex",
          "translation",
          "treat",
          "trigger",
          "trim",
          "trim_array",
          "true",
          "truncate",
          "uescape",
          "union",
          "unique",
          "unknown",
          "unnest",
          "update   ",
          "upper",
          "user",
          "using",
          "value",
          "values",
          "value_of",
          "var_pop",
          "var_samp",
          "varbinary",
          "varchar",
          "varying",
          "versioning",
          "when",
          "whenever",
          "where",
          "width_bucket",
          "window",
          "with",
          "within",
          "without",
          "year"
        ];
        const RESERVED_FUNCTIONS = [
          "abs",
          "acos",
          "array_agg",
          "asin",
          "atan",
          "avg",
          "cast",
          "ceil",
          "ceiling",
          "coalesce",
          "corr",
          "cos",
          "cosh",
          "count",
          "covar_pop",
          "covar_samp",
          "cume_dist",
          "dense_rank",
          "deref",
          "element",
          "exp",
          "extract",
          "first_value",
          "floor",
          "json_array",
          "json_arrayagg",
          "json_exists",
          "json_object",
          "json_objectagg",
          "json_query",
          "json_table",
          "json_table_primitive",
          "json_value",
          "lag",
          "last_value",
          "lead",
          "listagg",
          "ln",
          "log",
          "log10",
          "lower",
          "max",
          "min",
          "mod",
          "nth_value",
          "ntile",
          "nullif",
          "percent_rank",
          "percentile_cont",
          "percentile_disc",
          "position",
          "position_regex",
          "power",
          "rank",
          "regr_avgx",
          "regr_avgy",
          "regr_count",
          "regr_intercept",
          "regr_r2",
          "regr_slope",
          "regr_sxx",
          "regr_sxy",
          "regr_syy",
          "row_number",
          "sin",
          "sinh",
          "sqrt",
          "stddev_pop",
          "stddev_samp",
          "substring",
          "substring_regex",
          "sum",
          "tan",
          "tanh",
          "translate",
          "translate_regex",
          "treat",
          "trim",
          "trim_array",
          "unnest",
          "upper",
          "value_of",
          "var_pop",
          "var_samp",
          "width_bucket"
        ];
        const POSSIBLE_WITHOUT_PARENS = [
          "current_catalog",
          "current_date",
          "current_default_transform_group",
          "current_path",
          "current_role",
          "current_schema",
          "current_transform_group_for_type",
          "current_user",
          "session_user",
          "system_time",
          "system_user",
          "current_time",
          "localtime",
          "current_timestamp",
          "localtimestamp"
        ];
        const COMBOS = [
          "create table",
          "insert into",
          "primary key",
          "foreign key",
          "not null",
          "alter table",
          "add constraint",
          "grouping sets",
          "on overflow",
          "character set",
          "respect nulls",
          "ignore nulls",
          "nulls first",
          "nulls last",
          "depth first",
          "breadth first"
        ];
        const FUNCTIONS = RESERVED_FUNCTIONS;
        const KEYWORDS = [...RESERVED_WORDS, ...NON_RESERVED_WORDS].filter((keyword) => {
          return !RESERVED_FUNCTIONS.includes(keyword);
        });
        const VARIABLE = {
          className: "variable",
          begin: /@[a-z0-9]+/
        };
        const OPERATOR = {
          className: "operator",
          begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
          relevance: 0
        };
        const FUNCTION_CALL = {
          begin: concat2(/\b/, either2(...FUNCTIONS), /\s*\(/),
          keywords: {
            built_in: FUNCTIONS
          }
        };
        function reduceRelevancy(list, { exceptions, when } = {}) {
          const qualifyFn = when;
          exceptions = exceptions || [];
          return list.map((item) => {
            if (item.match(/\|\d+$/) || exceptions.includes(item)) {
              return item;
            } else if (qualifyFn(item)) {
              return `${item}|0`;
            } else {
              return item;
            }
          });
        }
        return {
          name: "SQL",
          case_insensitive: true,
          illegal: /[{}]|<\//,
          keywords: {
            $pattern: /\b[\w\.]+/,
            keyword: reduceRelevancy(KEYWORDS, { when: (x) => x.length < 3 }),
            literal: LITERALS,
            type: TYPES,
            built_in: POSSIBLE_WITHOUT_PARENS
          },
          contains: [
            {
              begin: either2(...COMBOS),
              keywords: {
                $pattern: /[\w\.]+/,
                keyword: KEYWORDS.concat(COMBOS),
                literal: LITERALS,
                type: TYPES
              }
            },
            {
              className: "type",
              begin: either2(...MULTI_WORD_TYPES)
            },
            FUNCTION_CALL,
            VARIABLE,
            STRING,
            QUOTED_IDENTIFIER,
            hljs.C_NUMBER_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            COMMENT_MODE,
            OPERATOR
          ]
        };
      }
      module2.exports = sql2;
    }
  });

  // node_modules/highlight.js/lib/languages/xml.js
  var require_xml = __commonJS({
    "node_modules/highlight.js/lib/languages/xml.js"(exports2, module2) {
      function source2(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function lookahead(re) {
        return concat2("(?=", re, ")");
      }
      function optional(re) {
        return concat2("(", re, ")?");
      }
      function concat2(...args) {
        const joined = args.map((x) => source2(x)).join("");
        return joined;
      }
      function either2(...args) {
        const joined = "(" + args.map((x) => source2(x)).join("|") + ")";
        return joined;
      }
      function xml2(hljs) {
        const TAG_NAME_RE = concat2(/[A-Z_]/, optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
        const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
        const XML_ENTITIES = {
          className: "symbol",
          begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
        };
        const XML_META_KEYWORDS = {
          begin: /\s/,
          contains: [
            {
              className: "meta-keyword",
              begin: /#?[a-z_][a-z1-9_-]+/,
              illegal: /\n/
            }
          ]
        };
        const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
          begin: /\(/,
          end: /\)/
        });
        const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
          className: "meta-string"
        });
        const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
          className: "meta-string"
        });
        const TAG_INTERNALS = {
          endsWithParent: true,
          illegal: /</,
          relevance: 0,
          contains: [
            {
              className: "attr",
              begin: XML_IDENT_RE,
              relevance: 0
            },
            {
              begin: /=\s*/,
              relevance: 0,
              contains: [
                {
                  className: "string",
                  endsParent: true,
                  variants: [
                    {
                      begin: /"/,
                      end: /"/,
                      contains: [XML_ENTITIES]
                    },
                    {
                      begin: /'/,
                      end: /'/,
                      contains: [XML_ENTITIES]
                    },
                    {
                      begin: /[^\s"'=<>`]+/
                    }
                  ]
                }
              ]
            }
          ]
        };
        return {
          name: "HTML, XML",
          aliases: [
            "html",
            "xhtml",
            "rss",
            "atom",
            "xjb",
            "xsd",
            "xsl",
            "plist",
            "wsf",
            "svg"
          ],
          case_insensitive: true,
          contains: [
            {
              className: "meta",
              begin: /<![a-z]/,
              end: />/,
              relevance: 10,
              contains: [
                XML_META_KEYWORDS,
                QUOTE_META_STRING_MODE,
                APOS_META_STRING_MODE,
                XML_META_PAR_KEYWORDS,
                {
                  begin: /\[/,
                  end: /\]/,
                  contains: [
                    {
                      className: "meta",
                      begin: /<![a-z]/,
                      end: />/,
                      contains: [
                        XML_META_KEYWORDS,
                        XML_META_PAR_KEYWORDS,
                        QUOTE_META_STRING_MODE,
                        APOS_META_STRING_MODE
                      ]
                    }
                  ]
                }
              ]
            },
            hljs.COMMENT(/<!--/, /-->/, {
              relevance: 10
            }),
            {
              begin: /<!\[CDATA\[/,
              end: /\]\]>/,
              relevance: 10
            },
            XML_ENTITIES,
            {
              className: "meta",
              begin: /<\?xml/,
              end: /\?>/,
              relevance: 10
            },
            {
              className: "tag",
              begin: /<style(?=\s|>)/,
              end: />/,
              keywords: {
                name: "style"
              },
              contains: [TAG_INTERNALS],
              starts: {
                end: /<\/style>/,
                returnEnd: true,
                subLanguage: [
                  "css",
                  "xml"
                ]
              }
            },
            {
              className: "tag",
              begin: /<script(?=\s|>)/,
              end: />/,
              keywords: {
                name: "script"
              },
              contains: [TAG_INTERNALS],
              starts: {
                end: /<\/script>/,
                returnEnd: true,
                subLanguage: [
                  "javascript",
                  "handlebars",
                  "xml"
                ]
              }
            },
            {
              className: "tag",
              begin: /<>|<\/>/
            },
            {
              className: "tag",
              begin: concat2(/</, lookahead(concat2(TAG_NAME_RE, either2(/\/>/, />/, /\s/)))),
              end: /\/?>/,
              contains: [
                {
                  className: "name",
                  begin: TAG_NAME_RE,
                  relevance: 0,
                  starts: TAG_INTERNALS
                }
              ]
            },
            {
              className: "tag",
              begin: concat2(/<\//, lookahead(concat2(TAG_NAME_RE, />/))),
              contains: [
                {
                  className: "name",
                  begin: TAG_NAME_RE,
                  relevance: 0
                },
                {
                  begin: />/,
                  relevance: 0,
                  endsParent: true
                }
              ]
            }
          ]
        };
      }
      module2.exports = xml2;
    }
  });

  // node_modules/highlight.js/lib/languages/yaml.js
  var require_yaml = __commonJS({
    "node_modules/highlight.js/lib/languages/yaml.js"(exports2, module2) {
      function yaml2(hljs) {
        var LITERALS = "true false yes no null";
        var URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
        var KEY = {
          className: "attr",
          variants: [
            { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
            { begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)' },
            { begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)" }
          ]
        };
        var TEMPLATE_VARIABLES = {
          className: "template-variable",
          variants: [
            { begin: /\{\{/, end: /\}\}/ },
            { begin: /%\{/, end: /\}/ }
          ]
        };
        var STRING = {
          className: "string",
          relevance: 0,
          variants: [
            { begin: /'/, end: /'/ },
            { begin: /"/, end: /"/ },
            { begin: /\S+/ }
          ],
          contains: [
            hljs.BACKSLASH_ESCAPE,
            TEMPLATE_VARIABLES
          ]
        };
        var CONTAINER_STRING = hljs.inherit(STRING, {
          variants: [
            { begin: /'/, end: /'/ },
            { begin: /"/, end: /"/ },
            { begin: /[^\s,{}[\]]+/ }
          ]
        });
        var DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
        var TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
        var FRACTION_RE = "(\\.[0-9]*)?";
        var ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
        var TIMESTAMP = {
          className: "number",
          begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b"
        };
        var VALUE_CONTAINER = {
          end: ",",
          endsWithParent: true,
          excludeEnd: true,
          keywords: LITERALS,
          relevance: 0
        };
        var OBJECT = {
          begin: /\{/,
          end: /\}/,
          contains: [VALUE_CONTAINER],
          illegal: "\\n",
          relevance: 0
        };
        var ARRAY = {
          begin: "\\[",
          end: "\\]",
          contains: [VALUE_CONTAINER],
          illegal: "\\n",
          relevance: 0
        };
        var MODES2 = [
          KEY,
          {
            className: "meta",
            begin: "^---\\s*$",
            relevance: 10
          },
          {
            className: "string",
            begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
          },
          {
            begin: "<%[%=-]?",
            end: "[%-]?%>",
            subLanguage: "ruby",
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0
          },
          {
            className: "type",
            begin: "!\\w+!" + URI_CHARACTERS
          },
          {
            className: "type",
            begin: "!<" + URI_CHARACTERS + ">"
          },
          {
            className: "type",
            begin: "!" + URI_CHARACTERS
          },
          {
            className: "type",
            begin: "!!" + URI_CHARACTERS
          },
          {
            className: "meta",
            begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
          },
          {
            className: "meta",
            begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
          },
          {
            className: "bullet",
            begin: "-(?=[ ]|$)",
            relevance: 0
          },
          hljs.HASH_COMMENT_MODE,
          {
            beginKeywords: LITERALS,
            keywords: { literal: LITERALS }
          },
          TIMESTAMP,
          {
            className: "number",
            begin: hljs.C_NUMBER_RE + "\\b",
            relevance: 0
          },
          OBJECT,
          ARRAY,
          STRING
        ];
        var VALUE_MODES = [...MODES2];
        VALUE_MODES.pop();
        VALUE_MODES.push(CONTAINER_STRING);
        VALUE_CONTAINER.contains = VALUE_MODES;
        return {
          name: "YAML",
          case_insensitive: true,
          aliases: ["yml"],
          contains: MODES2
        };
      }
      module2.exports = yaml2;
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  (function() {
    if (window.Reflect === void 0 || window.customElements === void 0 || window.customElements.polyfillWrapFlushCallback) {
      return;
    }
    const BuiltInHTMLElement = HTMLElement;
    const wrapperForTheName = {
      "HTMLElement": function HTMLElement2() {
        return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
      }
    };
    window.HTMLElement = wrapperForTheName["HTMLElement"];
    HTMLElement.prototype = BuiltInHTMLElement.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
  })();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype;
    if ("SubmitEvent" in window && /Apple Computer/.test(navigator.vendor)) {
      prototype = window.SubmitEvent.prototype;
    } else if ("SubmitEvent" in window) {
      return;
    } else {
      prototype = window.Event.prototype;
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle;
  (function(FrameLoadingStyle2) {
    FrameLoadingStyle2["eager"] = "eager";
    FrameLoadingStyle2["lazy"] = "lazy";
  })(FrameLoadingStyle || (FrameLoadingStyle = {}));
  var FrameElement = class extends HTMLElement {
    constructor() {
      super();
      this.loaded = Promise.resolve();
      this.delegate = new FrameElement.delegateConstructor(this);
    }
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      const { src } = this;
      this.src = null;
      this.src = src;
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else {
        this.delegate.disabledChanged();
      }
    }
    get src() {
      return this.getAttribute("src");
    }
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    get complete() {
      return !this.delegate.isLoading;
    }
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    get isPreview() {
      var _a, _b;
      return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style2) {
    switch (style2.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction(form, submitter) {
    const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formaction")) || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, { cancelable, bubbles: true, detail });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextAnimationFrame() {
    return new Promise((resolve14) => requestAnimationFrame(() => resolve14()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve14) => setTimeout(() => resolve14(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result2, string, i) => {
      const value = values[i] == void 0 ? "" : values[i];
      return result2 + string + value;
    }, "");
  }
  function uuid() {
    return Array.apply(null, { length: 36 }).map((_, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-";
      } else if (i == 14) {
        return "4";
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  var FetchMethod;
  (function(FetchMethod2) {
    FetchMethod2[FetchMethod2["get"] = 0] = "get";
    FetchMethod2[FetchMethod2["post"] = 1] = "post";
    FetchMethod2[FetchMethod2["put"] = 2] = "put";
    FetchMethod2[FetchMethod2["patch"] = 3] = "patch";
    FetchMethod2[FetchMethod2["delete"] = 4] = "delete";
  })(FetchMethod || (FetchMethod = {}));
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchRequest = class {
    constructor(delegate, method, location2, body = new URLSearchParams(), target = null) {
      this.abortController = new AbortController();
      this.resolveRequestPromise = (value) => {
      };
      this.delegate = delegate;
      this.method = method;
      this.headers = this.defaultHeaders;
      this.body = body;
      this.url = location2;
      this.target = target;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      var _a, _b;
      const { fetchOptions } = this;
      (_b = (_a = this.delegate).prepareHeadersForRequest) === null || _b === void 0 ? void 0 : _b.call(_a, this.headers, this);
      await this.allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        const response = await fetch(this.url.href, fetchOptions);
        return await this.receive(response);
      } catch (error3) {
        if (error3.name !== "AbortError") {
          this.delegate.requestErrored(this, error3);
          throw error3;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", { cancelable: true, detail: { fetchResponse }, target: this.target });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get fetchOptions() {
      var _a;
      return {
        method: FetchMethod[this.method].toUpperCase(),
        credentials: "same-origin",
        headers: this.headers,
        redirect: "follow",
        body: this.isIdempotent ? null : this.body,
        signal: this.abortSignal,
        referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
      };
    }
    get defaultHeaders() {
      return {
        "Accept": "text/html, application/xhtml+xml"
      };
    }
    get isIdempotent() {
      return this.method == FetchMethod.get;
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    async allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve14) => this.resolveRequestPromise = resolve14);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.resolveRequestPromise
        },
        target: this.target
      });
      if (event.defaultPrevented)
        await requestInterception;
    }
  };
  var AppearanceObserver = class {
    constructor(delegate, element) {
      this.started = false;
      this.intersect = (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      };
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    constructor(html) {
      this.templateElement = document.createElement("template");
      this.templateElement.innerHTML = html;
    }
    static wrap(message) {
      if (typeof message == "string") {
        return new this(message);
      } else {
        return message;
      }
    }
    get fragment() {
      const fragment = document.createDocumentFragment();
      for (const element of this.foreignElements) {
        fragment.appendChild(document.importNode(element, true));
      }
      return fragment;
    }
    get foreignElements() {
      return this.templateChildren.reduce((streamElements, child5) => {
        if (child5.tagName.toLowerCase() == "turbo-stream") {
          return [...streamElements, child5];
        } else {
          return streamElements;
        }
      }, []);
    }
    get templateChildren() {
      return Array.from(this.templateElement.content.children);
    }
  };
  StreamMessage.contentType = "text/vnd.turbo-stream.html";
  var FormSubmissionState;
  (function(FormSubmissionState2) {
    FormSubmissionState2[FormSubmissionState2["initialized"] = 0] = "initialized";
    FormSubmissionState2[FormSubmissionState2["requesting"] = 1] = "requesting";
    FormSubmissionState2[FormSubmissionState2["waiting"] = 2] = "waiting";
    FormSubmissionState2[FormSubmissionState2["receiving"] = 3] = "receiving";
    FormSubmissionState2[FormSubmissionState2["stopping"] = 4] = "stopping";
    FormSubmissionState2[FormSubmissionState2["stopped"] = 5] = "stopped";
  })(FormSubmissionState || (FormSubmissionState = {}));
  var FormEnctype;
  (function(FormEnctype2) {
    FormEnctype2["urlEncoded"] = "application/x-www-form-urlencoded";
    FormEnctype2["multipart"] = "multipart/form-data";
    FormEnctype2["plain"] = "text/plain";
  })(FormEnctype || (FormEnctype = {}));
  function formEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FormEnctype.multipart:
        return FormEnctype.multipart;
      case FormEnctype.plain:
        return FormEnctype.plain;
      default:
        return FormEnctype.urlEncoded;
    }
  }
  var FormSubmission = class {
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      this.state = FormSubmissionState.initialized;
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.formData = buildFormData(formElement, submitter);
      this.location = expandURL(this.action);
      if (this.method == FetchMethod.get) {
        mergeFormDataEntries(this.location, [...this.body.entries()]);
      }
      this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
      this.mustRedirect = mustRedirect;
    }
    static confirmMethod(message, element) {
      return confirm(message);
    }
    get method() {
      var _a;
      const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formmethod")) || this.formElement.getAttribute("method") || "";
      return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
    }
    get action() {
      var _a;
      const formElementAction = typeof this.formElement.action === "string" ? this.formElement.action : null;
      return ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formaction")) || this.formElement.getAttribute("action") || formElementAction || "";
    }
    get body() {
      if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
        return new URLSearchParams(this.stringFormData);
      } else {
        return this.formData;
      }
    }
    get enctype() {
      var _a;
      return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formenctype")) || this.formElement.enctype);
    }
    get isIdempotent() {
      return this.fetchRequest.isIdempotent;
    }
    get stringFormData() {
      return [...this.formData].reduce((entries, [name, value]) => {
        return entries.concat(typeof value == "string" ? [[name, value]] : []);
      }, []);
    }
    get confirmationMessage() {
      return this.formElement.getAttribute("data-turbo-confirm");
    }
    get needsConfirmation() {
      return this.confirmationMessage !== null;
    }
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      if (this.needsConfirmation) {
        const answer = FormSubmission.confirmMethod(this.confirmationMessage, this.formElement);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    prepareHeadersForRequest(headers, request) {
      if (!request.isIdempotent) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          headers["X-CSRF-Token"] = token;
        }
        headers["Accept"] = [StreamMessage.contentType, headers["Accept"]].join(", ");
      }
    }
    requestStarted(request) {
      var _a;
      this.state = FormSubmissionState.waiting;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute("disabled", "");
      dispatch("turbo:submit-start", { target: this.formElement, detail: { formSubmission: this } });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
      } else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error3 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error3);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error3) {
      this.result = { success: false, error: error3 };
      this.delegate.formSubmissionErrored(this, error3);
    }
    requestFinished(request) {
      var _a;
      this.state = FormSubmissionState.stopped;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
      dispatch("turbo:submit-end", { target: this.formElement, detail: Object.assign({ formSubmission: this }, this.result) });
      this.delegate.formSubmissionFinished(this);
    }
    requestMustRedirect(request) {
      return !request.isIdempotent && this.mustRedirect;
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("name");
    const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("value");
    if (name && value != null && formData.get(name) != value) {
      formData.append(name, value);
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function getMetaContent(name) {
    const element = document.querySelector(`meta[name="${name}"]`);
    return element && element.content;
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function mergeFormDataEntries(url, entries) {
    const searchParams = new URLSearchParams();
    for (const [name, value] of entries) {
      if (value instanceof File)
        continue;
      searchParams.append(name, value);
    }
    url.search = searchParams.toString();
    return url;
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return this.element.querySelector("[autofocus]");
    }
    get permanentElements() {
      return [...this.element.querySelectorAll("[id][data-turbo-permanent]")];
    }
    getPermanentElementById(id) {
      return this.element.querySelector(`#${id}[data-turbo-permanent]`);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  var FormInterceptor = class {
    constructor(delegate, element) {
      this.submitBubbled = (event) => {
        const form = event.target;
        if (!event.defaultPrevented && form instanceof HTMLFormElement && form.closest("turbo-frame, html") == this.element) {
          const submitter = event.submitter || void 0;
          const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.method;
          if (method != "dialog" && this.delegate.shouldInterceptFormSubmission(form, submitter)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.delegate.formSubmissionIntercepted(form, submitter);
          }
        }
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("submit", this.submitBubbled);
    }
    stop() {
      this.element.removeEventListener("submit", this.submitBubbled);
    }
  };
  var View = class {
    constructor(delegate, element) {
      this.resolveRenderPromise = (value) => {
      };
      this.resolveInterceptionPromise = (value) => {
      };
      this.delegate = delegate;
      this.element = element;
    }
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x, y }) {
      this.scrollRoot.scrollTo(x, y);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    async render(renderer) {
      const { isPreview, shouldRender, newSnapshot: snapshot } = renderer;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve14) => this.resolveRenderPromise = resolve14);
          this.renderer = renderer;
          this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve14) => this.resolveInterceptionPromise = resolve14);
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, this.resolveInterceptionPromise);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else {
        this.invalidate();
      }
    }
    invalidate() {
      this.delegate.viewInvalidated();
    }
    prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    invalidate() {
      this.element.innerHTML = "";
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.clickBubbled = (event) => {
        if (this.respondsToEventTarget(event.target)) {
          this.clickEvent = event;
        } else {
          delete this.clickEvent;
        }
      };
      this.linkClicked = (event) => {
        if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
          if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url)) {
            this.clickEvent.preventDefault();
            event.preventDefault();
            this.delegate.linkClickIntercepted(event.target, event.detail.url);
          }
        }
        delete this.clickEvent;
      };
      this.willVisit = () => {
        delete this.clickEvent;
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var Bardo = class {
    constructor(permanentElementMap) {
      this.permanentElementMap = permanentElementMap;
    }
    static preservingPermanentElements(permanentElementMap, callback) {
      const bardo = new this(permanentElementMap);
      bardo.enter();
      callback();
      bardo.leave();
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [, newPermanentElement] = this.permanentElementMap[id];
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.promise = new Promise((resolve14, reject) => this.resolvingFunctions = { resolve: resolve14, reject });
    }
    get shouldRender() {
      return true;
    }
    prepareToRender() {
      return;
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    createScriptElement(element) {
      if (element.getAttribute("data-turbo-eval") == "false") {
        return element;
      } else {
        const createdScriptElement = document.createElement("script");
        if (this.cspNonce) {
          createdScriptElement.nonce = this.cspNonce;
        }
        createdScriptElement.textContent = element.textContent;
        createdScriptElement.async = false;
        copyElementAttributes(createdScriptElement, element);
        return createdScriptElement;
      }
    }
    preservingPermanentElements(callback) {
      Bardo.preservingPermanentElements(this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (elementIsFocusable(element)) {
        element.focus();
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get cspNonce() {
      var _a;
      return (_a = document.head.querySelector('meta[name="csp-nonce"]')) === null || _a === void 0 ? void 0 : _a.getAttribute("content");
    }
  };
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of [...sourceElement.attributes]) {
      destinationElement.setAttribute(name, value);
    }
  }
  function elementIsFocusable(element) {
    return element && typeof element.focus == "function";
  }
  var FrameRenderer = class extends Renderer {
    get shouldRender() {
      return true;
    }
    async render() {
      await nextAnimationFrame();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextAnimationFrame();
      this.focusFirstAutofocusableElement();
      await nextAnimationFrame();
      this.activateScriptElements();
    }
    loadFrameElement() {
      var _a;
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(this.currentElement);
      destinationRange.deleteContents();
      const frameElement = this.newElement;
      const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        this.currentElement.appendChild(sourceRange.extractContents());
      }
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        if (element) {
          element.scrollIntoView({ block });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = this.createScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var ProgressBar = class {
    constructor() {
      this.hiding = false;
      this.value = 0;
      this.visible = false;
      this.trickle = () => {
        this.setValue(this.value + Math.random() / 100);
      };
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 9999;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = ProgressBar.defaultCSS;
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
  };
  ProgressBar.animationDuration = 300;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      this.detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result2, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result2 ? result2[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return Object.assign(Object.assign({}, result2), { [outerHTML]: Object.assign(Object.assign({}, details), { elements: [...details.elements, element] }) });
      }, {});
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result2, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result2, ...elements];
        } else if (elements.length > 1) {
          return [...result2, ...elements.slice(1)];
        } else {
          return result2;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result2, outerHTML) => {
        const { elements: [element] } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result2;
      }, void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class extends Snapshot {
    constructor(element, headSnapshot) {
      super(element);
      this.headSnapshot = headSnapshot;
    }
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ head, body }) {
      return new this(body, new HeadSnapshot(head));
    }
    clone() {
      return new PageSnapshot(this.element.cloneNode(true), this.headSnapshot);
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      var _a;
      const root = (_a = this.getSetting("root")) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var TimingMetric;
  (function(TimingMetric2) {
    TimingMetric2["visitStart"] = "visitStart";
    TimingMetric2["requestStart"] = "requestStart";
    TimingMetric2["requestEnd"] = "requestEnd";
    TimingMetric2["visitEnd"] = "visitEnd";
  })(TimingMetric || (TimingMetric = {}));
  var VisitState;
  (function(VisitState2) {
    VisitState2["initialized"] = "initialized";
    VisitState2["started"] = "started";
    VisitState2["canceled"] = "canceled";
    VisitState2["failed"] = "failed";
    VisitState2["completed"] = "completed";
  })(VisitState || (VisitState = {}));
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true
  };
  var SystemStatusCode;
  (function(SystemStatusCode2) {
    SystemStatusCode2[SystemStatusCode2["networkFailure"] = 0] = "networkFailure";
    SystemStatusCode2[SystemStatusCode2["timeoutFailure"] = -1] = "timeoutFailure";
    SystemStatusCode2[SystemStatusCode2["contentTypeMismatch"] = -2] = "contentTypeMismatch";
  })(SystemStatusCode || (SystemStatusCode = {}));
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.identifier = uuid();
      this.timingMetrics = {};
      this.followedRedirect = false;
      this.historyChanged = false;
      this.scrolled = false;
      this.snapshotCached = false;
      this.state = VisitState.initialized;
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const { action, historyChanged, referrer, snapshotHTML, response, visitCachedSnapshot, willRender } = Object.assign(Object.assign({}, defaultOptions), options);
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.scrolled = !willRender;
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.state = VisitState.completed;
        this.adapter.visitCompleted(this);
        this.delegate.visitCompleted(this);
        this.followRedirect();
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
      }
    }
    changeHistory() {
      var _a;
      if (!this.historyChanged) {
        const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? "replace" : this.action;
        const method = this.getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML));
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.view.renderPage(snapshot, isPreview, this.willRender);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      var _a;
      if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.adapter.visitRendered(this);
        });
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(request, response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(request, error3) {
      this.recordResponse({ statusCode: SystemStatusCode.networkFailure, redirected: false });
    }
    requestFinished() {
      this.finishRequest();
    }
    performScroll() {
      if (!this.scrolled) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = new Date().getTime();
    }
    getTimingMetrics() {
      return Object.assign({}, this.timingMetrics);
    }
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot().then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      await new Promise((resolve14) => {
        this.frame = requestAnimationFrame(() => resolve14());
      });
      await callback();
      delete this.frame;
      this.performScroll();
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      this.progressBar = new ProgressBar();
      this.showProgressBar = () => {
        this.progressBar.show();
      };
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      this.navigator.startVisit(location2, uuid(), options);
    }
    visitStarted(visit2) {
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.changeHistory();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload();
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(visit2) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitCompleted(visit2) {
    }
    pageInvalidated() {
      this.reload();
    }
    visitFailed(visit2) {
    }
    visitRendered(visit2) {
    }
    formSubmissionStarted(formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload() {
      window.location.reload();
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeStaleElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeStaleElements, false);
      }
    }
    removeStaleElements() {
      const staleElements = [...document.querySelectorAll('[data-turbo-cache="false"]')];
      for (const element of staleElements) {
        element.remove();
      }
    }
  };
  var FormSubmitObserver = class {
    constructor(delegate) {
      this.started = false;
      this.submitCaptured = () => {
        removeEventListener("submit", this.submitBubbled, false);
        addEventListener("submit", this.submitBubbled, false);
      };
      this.submitBubbled = (event) => {
        if (!event.defaultPrevented) {
          const form = event.target instanceof HTMLFormElement ? event.target : void 0;
          const submitter = event.submitter || void 0;
          if (form) {
            const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.getAttribute("method");
            if (method != "dialog" && this.delegate.willSubmitForm(form, submitter)) {
              event.preventDefault();
              this.delegate.formSubmitted(form, submitter);
            }
          }
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  var FrameRedirector = class {
    constructor(element) {
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formInterceptor = new FormInterceptor(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formInterceptor.stop();
    }
    shouldInterceptLinkClick(element, url) {
      return this.shouldRedirect(element);
    }
    linkClickIntercepted(element, url) {
      const frame = this.findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url);
      }
    }
    shouldInterceptFormSubmission(element, submitter) {
      return this.shouldSubmit(element, submitter);
    }
    formSubmissionIntercepted(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      if (frame) {
        frame.removeAttribute("reloadable");
        frame.delegate.formSubmissionIntercepted(element, submitter);
      }
    }
    shouldSubmit(form, submitter) {
      var _a;
      const action = getAction(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/");
      return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    shouldRedirect(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      return frame ? frame != element.closest("turbo-frame") : false;
    }
    findFrameElement(element, submitter) {
      const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    constructor(delegate) {
      this.restorationIdentifier = uuid();
      this.restorationData = {};
      this.started = false;
      this.pageLoaded = false;
      this.onPopState = (event) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
          }
        }
      };
      this.onPageLoad = async (event) => {
        await nextMicrotask();
        this.pageLoaded = true;
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      const state = { turbo: { restorationIdentifier } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
    }
    assumeControlOfScrollRestoration() {
      var _a;
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkClickObserver = class {
    constructor(delegate) {
      this.started = false;
      this.clickCaptured = () => {
        removeEventListener("click", this.clickBubbled, false);
        addEventListener("click", this.clickBubbled, false);
      };
      this.clickBubbled = (event) => {
        if (this.clickEventIsSignificant(event)) {
          const target = event.composedPath && event.composedPath()[0] || event.target;
          const link = this.findLinkFromClickTarget(target);
          if (link) {
            const location2 = this.getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2)) {
              event.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
    findLinkFromClickTarget(target) {
      if (target instanceof Element) {
        return target.closest("a[href]:not([target^=_]):not([download])");
      }
    }
    getLocationForLink(link) {
      return expandURL(link.getAttribute("href") || "");
    }
  };
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        if (locationIsVisitable(location2, this.view.snapshot.rootLocation)) {
          this.delegate.visitProposedToLocation(location2, options);
        } else {
          window.location.href = location2.toString();
        }
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({ referrer: this.location }, options));
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          if (formSubmission.method != FetchMethod.get) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.getActionForFormSubmission(formSubmission);
          const visitOptions = { action, response: { statusCode, responseHTML, redirected } };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot);
        } else {
          await this.view.renderPage(snapshot);
        }
        this.view.scrollToTop();
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error3) {
      console.error(error3);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    getActionForFormSubmission(formSubmission) {
      const { formElement, submitter } = formSubmission;
      const action = getAttribute("data-turbo-action", submitter, formElement);
      return isAction(action) ? action : "advance";
    }
  };
  var PageStage;
  (function(PageStage2) {
    PageStage2[PageStage2["initial"] = 0] = "initial";
    PageStage2[PageStage2["loading"] = 1] = "loading";
    PageStage2[PageStage2["interactive"] = 2] = "interactive";
    PageStage2[PageStage2["complete"] = 3] = "complete";
  })(PageStage || (PageStage = {}));
  var PageObserver = class {
    constructor(delegate) {
      this.stage = PageStage.initial;
      this.started = false;
      this.interpretReadyState = () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      };
      this.pageWillUnload = () => {
        this.delegate.pageWillUnload();
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      this.started = false;
      this.onScroll = () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamObserver = class {
    constructor(delegate) {
      this.sources = /* @__PURE__ */ new Set();
      this.started = false;
      this.inspectFetchResponse = (event) => {
        const response = fetchResponseFromEvent(event);
        if (response && fetchResponseIsStream(response)) {
          event.preventDefault();
          this.receiveMessageResponse(response);
        }
      };
      this.receiveMessageEvent = (event) => {
        if (this.started && typeof event.data == "string") {
          this.receiveMessageHTML(event.data);
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source2) {
      if (!this.streamSourceIsConnected(source2)) {
        this.sources.add(source2);
        source2.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source2) {
      if (this.streamSourceIsConnected(source2)) {
        this.sources.delete(source2);
        source2.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source2) {
      return this.sources.has(source2);
    }
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(new StreamMessage(html));
    }
  };
  function fetchResponseFromEvent(event) {
    var _a;
    const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    var _a;
    const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head, body } = document;
      documentElement.replaceChild(this.newHead, head);
      documentElement.replaceChild(this.newElement, body);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode2 = replaceableElement.parentNode;
        if (parentNode2) {
          const element = this.createScriptElement(replaceableElement);
          parentNode2.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return [...document.documentElement.querySelectorAll("script")];
    }
  };
  var PageRenderer = class extends Renderer {
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    prepareToRender() {
      this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    mergeHead() {
      this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      this.removeCurrentHeadProvisionalElements();
      this.copyNewHeadProvisionalElements();
    }
    replaceBody() {
      this.preservingPermanentElements(() => {
        this.activateNewBody();
        this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    copyNewHeadStylesheetElements() {
      for (const element of this.newHeadStylesheetElements) {
        document.head.appendChild(element);
      }
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(this.createScriptElement(element));
      }
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = this.createScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    assignNewBody() {
      if (document.body && this.newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(this.newElement);
      } else {
        document.documentElement.appendChild(this.newElement);
      }
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var SnapshotCache = class {
    constructor(size) {
      this.keys = [];
      this.snapshots = {};
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key2 = toCacheKey(location2);
      const index3 = this.keys.indexOf(key2);
      if (index3 > -1)
        this.keys.splice(index3, 1);
      this.keys.unshift(key2);
      this.trim();
    }
    trim() {
      for (const key2 of this.keys.splice(this.size)) {
        delete this.snapshots[key2];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      this.snapshotCache = new SnapshotCache(10);
      this.lastRenderedLocation = new URL(location.href);
    }
    renderPage(snapshot, isPreview = false, willRender = true) {
      const renderer = new PageRenderer(this.snapshot, snapshot, isPreview, willRender);
      return this.render(renderer);
    }
    renderError(snapshot) {
      const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot() {
      if (this.shouldCacheSnapshot) {
        this.delegate.viewWillCacheSnapshot();
        const { snapshot, lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
    get shouldCacheSnapshot() {
      return this.snapshot.isCacheable;
    }
  };
  var Session = class {
    constructor() {
      this.navigator = new Navigator(this);
      this.history = new History(this);
      this.view = new PageView(this, document.documentElement);
      this.adapter = new BrowserAdapter(this);
      this.pageObserver = new PageObserver(this);
      this.cacheObserver = new CacheObserver();
      this.linkClickObserver = new LinkClickObserver(this);
      this.formSubmitObserver = new FormSubmitObserver(this);
      this.scrollObserver = new ScrollObserver(this);
      this.streamObserver = new StreamObserver(this);
      this.frameRedirector = new FrameRedirector(document.documentElement);
      this.drive = true;
      this.enabled = true;
      this.progressBarDelay = 500;
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      this.navigator.proposeVisit(expandURL(location2), options);
    }
    connectStreamSource(source2) {
      this.streamObserver.connectStreamSource(source2);
    }
    disconnectStreamSource(source2) {
      this.streamObserver.disconnectStreamSource(source2);
    }
    renderStreamMessage(message) {
      document.documentElement.appendChild(StreamMessage.wrap(message).fragment);
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    historyPoppedToLocationWithRestorationIdentifier(location2, restorationIdentifier) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, { action: "restore", historyChanged: true });
      } else {
        this.adapter.pageInvalidated();
      }
    }
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    willFollowLinkToLocation(link, location2) {
      return this.elementDriveEnabled(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      this.convertLinkWithMethodClickToFormSubmission(link) || this.visit(location2.href, { action });
    }
    convertLinkWithMethodClickToFormSubmission(link) {
      const linkMethod = link.getAttribute("data-turbo-method");
      if (linkMethod) {
        const form = document.createElement("form");
        form.method = linkMethod;
        form.action = link.getAttribute("href") || "undefined";
        form.hidden = true;
        if (link.hasAttribute("data-turbo-confirm")) {
          form.setAttribute("data-turbo-confirm", link.getAttribute("data-turbo-confirm"));
        }
        const frame = this.getTargetFrameForLink(link);
        if (frame) {
          form.setAttribute("data-turbo-frame", frame);
          form.addEventListener("turbo:submit-start", () => form.remove());
        } else {
          form.addEventListener("submit", () => form.remove());
        }
        document.body.appendChild(form);
        return dispatch("submit", { cancelable: true, target: form });
      } else {
        return false;
      }
    }
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    visitStarted(visit2) {
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    willSubmitForm(form, submitter) {
      const action = getAction(form, submitter);
      return this.elementDriveEnabled(form) && (!submitter || this.elementDriveEnabled(submitter)) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    viewWillCacheSnapshot() {
      var _a;
      if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, resume) {
      const event = this.notifyApplicationBeforeRender(element, resume);
      return !event.defaultPrevented;
    }
    viewRenderedSnapshot(snapshot, isPreview) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender();
    }
    viewInvalidated() {
      this.adapter.pageInvalidated();
    }
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    applicationAllowsFollowingLinkToLocation(link, location2) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2) {
      return dispatch("turbo:click", { target: link, detail: { url: location2.href }, cancelable: true });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", { detail: { url: location2.href }, cancelable: true });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      markAsBusy(document.documentElement);
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, resume) {
      return dispatch("turbo:before-render", { detail: { newBody, resume }, cancelable: true });
    }
    notifyApplicationAfterRender() {
      return dispatch("turbo:render");
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      clearBusyState(document.documentElement);
      return dispatch("turbo:load", { detail: { url: this.location.href, timing } });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(new HashChangeEvent("hashchange", { oldURL: oldURL.toString(), newURL: newURL.toString() }));
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", { detail: { fetchResponse }, target: frame, cancelable: true });
    }
    elementDriveEnabled(element) {
      const container = element === null || element === void 0 ? void 0 : element.closest("[data-turbo]");
      if (this.drive) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    getActionForLink(link) {
      const action = link.getAttribute("data-turbo-action");
      return isAction(action) ? action : "advance";
    }
    getTargetFrameForLink(link) {
      const frame = link.getAttribute("data-turbo-frame");
      if (frame) {
        return frame;
      } else {
        const container = link.closest("turbo-frame");
        if (container) {
          return container.id;
        }
      }
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session();
  var { navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source2) {
    session.connectStreamSource(source2);
  }
  function disconnectStreamSource(source2) {
    session.disconnectStreamSource(source2);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    PageRenderer,
    PageSnapshot,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod
  });
  var FrameController = class {
    constructor(element) {
      this.fetchResponseLoaded = (fetchResponse) => {
      };
      this.currentFetchRequest = null;
      this.resolveVisitPromise = () => {
      };
      this.connected = false;
      this.hasBeenLoaded = false;
      this.settingSourceURL = false;
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.formInterceptor = new FormInterceptor(this, this.element);
    }
    connect() {
      if (!this.connected) {
        this.connected = true;
        this.reloadable = false;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        }
        this.linkInterceptor.start();
        this.formInterceptor.start();
        this.sourceURLChanged();
      }
    }
    disconnect() {
      if (this.connected) {
        this.connected = false;
        this.appearanceObserver.stop();
        this.linkInterceptor.stop();
        this.formInterceptor.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
        this.loadSourceURL();
      }
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.loadSourceURL();
      }
    }
    async loadSourceURL() {
      if (!this.settingSourceURL && this.enabled && this.isActive && (this.reloadable || this.sourceURL != this.currentURL)) {
        const previousURL = this.currentURL;
        this.currentURL = this.sourceURL;
        if (this.sourceURL) {
          try {
            this.element.loaded = this.visit(expandURL(this.sourceURL));
            this.appearanceObserver.stop();
            await this.element.loaded;
            this.hasBeenLoaded = true;
          } catch (error3) {
            this.currentURL = previousURL;
            throw error3;
          }
        }
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const { body } = parseHTMLDocument(html);
          const snapshot = new Snapshot(await this.extractForeignFrameElement(body));
          const renderer = new FrameRenderer(this.view.snapshot, snapshot, false, false);
          if (this.view.renderPromise)
            await this.view.renderPromise;
          await this.view.render(renderer);
          session.frameRendered(fetchResponse, this.element);
          session.frameLoaded(this.element);
          this.fetchResponseLoaded(fetchResponse);
        }
      } catch (error3) {
        console.error(error3);
        this.view.invalidate();
      } finally {
        this.fetchResponseLoaded = () => {
        };
      }
    }
    elementAppearedInViewport(element) {
      this.loadSourceURL();
    }
    shouldInterceptLinkClick(element, url) {
      if (element.hasAttribute("data-turbo-method")) {
        return false;
      } else {
        return this.shouldInterceptNavigation(element);
      }
    }
    linkClickIntercepted(element, url) {
      this.reloadable = true;
      this.navigateFrame(element, url);
    }
    shouldInterceptFormSubmission(element, submitter) {
      return this.shouldInterceptNavigation(element, submitter);
    }
    formSubmissionIntercepted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.reloadable = false;
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareHeadersForRequest(fetchRequest.headers, fetchRequest);
      this.formSubmission.start();
    }
    prepareHeadersForRequest(headers, request) {
      headers["Turbo-Frame"] = this.id;
    }
    requestStarted(request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(request, response) {
      this.resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    requestFailedWithResponse(request, response) {
      console.error(response);
      this.resolveVisitPromise();
    }
    requestErrored(request, error3) {
      console.error(error3);
      this.resolveVisitPromise();
    }
    requestFinished(request) {
      clearBusyState(this.element);
    }
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
      this.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.loadResponse(response);
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
    }
    formSubmissionErrored(formSubmission, error3) {
      console.error(error3);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.findFrameElement(formElement));
    }
    allowsImmediateRender(snapshot, resume) {
      return true;
    }
    viewRenderedSnapshot(snapshot, isPreview) {
    }
    viewInvalidated() {
    }
    async visit(url) {
      var _a;
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
      this.currentFetchRequest = request;
      return new Promise((resolve14) => {
        this.resolveVisitPromise = () => {
          this.resolveVisitPromise = () => {
          };
          this.currentFetchRequest = null;
          resolve14();
        };
        request.perform();
      });
    }
    navigateFrame(element, url, submitter) {
      const frame = this.findFrameElement(element, submitter);
      this.proposeVisitIfNavigatedWithAction(frame, element, submitter);
      frame.setAttribute("reloadable", "");
      frame.src = url;
    }
    proposeVisitIfNavigatedWithAction(frame, element, submitter) {
      const action = getAttribute("data-turbo-action", submitter, element, frame);
      if (isAction(action)) {
        const { visitCachedSnapshot } = new SnapshotSubstitution(frame);
        frame.delegate.fetchResponseLoaded = (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = frame.ownerDocument.documentElement.outerHTML;
            const response = { statusCode, redirected, responseHTML };
            session.visit(frame.src, { action, response, visitCachedSnapshot, willRender: false });
          }
        };
      }
    }
    findFrameElement(element, submitter) {
      var _a;
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        if (element = activateElement(container.querySelector(`turbo-frame#${id}`), this.currentURL)) {
          return element;
        }
        if (element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.currentURL)) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
        console.error(`Response has no matching <turbo-frame id="${id}"> element`);
      } catch (error3) {
        console.error(error3);
      }
      return new FrameElement();
    }
    formActionIsVisitable(form, submitter) {
      const action = getAction(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementDriveEnabled(element)) {
        return false;
      }
      if (submitter && !session.elementDriveEnabled(submitter)) {
        return false;
      }
      return true;
    }
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    get reloadable() {
      const frame = this.findFrameElement(this.element);
      return frame.hasAttribute("reloadable");
    }
    set reloadable(value) {
      const frame = this.findFrameElement(this.element);
      if (value) {
        frame.setAttribute("reloadable", "");
      } else {
        frame.removeAttribute("reloadable");
      }
    }
    set sourceURL(sourceURL) {
      this.settingSourceURL = true;
      this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;
      this.currentURL = this.element.src;
      this.settingSourceURL = false;
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.resolveVisitPromise() !== void 0;
    }
    get isActive() {
      return this.element.isActive && this.connected;
    }
    get rootLocation() {
      var _a;
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
  };
  var SnapshotSubstitution = class {
    constructor(element) {
      this.visitCachedSnapshot = ({ element: element2 }) => {
        var _a;
        const { id, clone } = this;
        (_a = element2.querySelector("#" + id)) === null || _a === void 0 ? void 0 : _a.replaceWith(clone);
      };
      this.clone = element.cloneNode(true);
      this.id = element.id;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e) => {
        var _a;
        return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e.nextSibling);
      });
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e) => {
        var _a;
        return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e);
      });
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e) => e.remove());
    },
    replace() {
      this.targetElements.forEach((e) => e.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((e) => {
        e.innerHTML = "";
        e.append(this.templateContent);
      });
    }
  };
  var StreamElement = class extends HTMLElement {
    async connectedCallback() {
      try {
        await this.render();
      } catch (error3) {
        console.error(error3);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      var _a;
      return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : this.renderPromise = (async () => {
        if (this.dispatchEvent(this.beforeRenderEvent)) {
          await nextAnimationFrame();
          this.performAction();
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch (_a) {
      }
    }
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c) => c.remove());
    }
    get duplicateChildren() {
      var _a;
      const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.id);
      const newChildrenIds = [...(_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children].filter((c) => !!c.id).map((c) => c.id);
      return existingChildren.filter((c) => newChildrenIds.includes(c.id));
    }
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.raise("unknown action");
      }
      this.raise("action attribute is missing");
    }
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.raise("target or targets attribute is missing");
      }
    }
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    get templateElement() {
      if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.raise("first child element must be a <template> element");
    }
    get action() {
      return this.getAttribute("action");
    }
    get target() {
      return this.getAttribute("target");
    }
    get targets() {
      return this.getAttribute("targets");
    }
    raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      var _a, _b;
      return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", { bubbles: true, cancelable: true });
    }
    get targetElementsById() {
      var _a;
      const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      var _a;
      const elements = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  FrameElement.delegateConstructor = FrameController;
  customElements.define("turbo-frame", FrameElement);
  customElements.define("turbo-stream", StreamElement);
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    while (element = element.parentElement) {
      if (element == document.body) {
        return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
      }
    }
  })();
  window.Turbo = Turbo;
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, { received: this.dispatchMessageEvent.bind(this) });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name };
    }
  };
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map22) => listeners.concat(Array.from(map22.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    }
    handleError(error3, message, detail = {}) {
      this.application.handleError(error3, `Error ${message}`, detail);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key2) => {
        parts.push(`${eventOptions[key2] ? "" : "!"}${key2}`);
      });
      return parts.join(":");
    }
  };
  var descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source2 = descriptorString.trim();
    const matches2 = source2.match(descriptorPattern) || [];
    return {
      eventTarget: parseEventTarget(matches2[4]),
      eventName: matches2[2],
      eventOptions: matches2[9] ? parseEventOptions(matches2[9]) : {},
      identifier: matches2[5],
      methodName: matches2[7]
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  var Action = class {
    constructor(element, index3, descriptor) {
      this.element = element;
      this.index = index3;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
    }
    static forToken(token) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content));
    }
    toString() {
      const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`;
    }
    get params() {
      if (this.eventTarget instanceof Element) {
        return this.getParamsFromEventTargetAttributes(this.eventTarget);
      } else {
        return {};
      }
    }
    getParamsFromEventTargetAttributes(eventTarget) {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`);
      const attributes = Array.from(eventTarget.attributes);
      attributes.forEach(({ name, value }) => {
        const match = name.match(pattern);
        const key2 = match && match[1];
        if (key2) {
          Object.assign(params, { [camelize(key2)]: typecast(value) });
        }
      });
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
  };
  var defaultEventNames = {
    "a": (e) => "click",
    "button": (e) => "click",
    "form": (e) => "submit",
    "details": (e) => "toggle",
    "input": (e) => e.getAttribute("type") == "submit" ? "click" : "input",
    "select": (e) => "change",
    "textarea": (e) => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      if (this.willBeInvokedByEvent(event)) {
        this.invokeWithEvent(event);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        const { params } = this.action;
        const actionEvent = Object.assign(event, { params });
        this.method.call(this.controller, actionEvent);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error3) {
        const { identifier, controller, element, index: index3 } = this;
        const detail = { identifier, controller, element, index: index3, event };
        this.context.handleError(error3, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches2 = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches2.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches2)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(node5, attributeName) {
      const element = node5;
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node5 of Array.from(nodes)) {
        const element = this.elementFromNode(node5);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node5 of Array.from(nodes)) {
        const element = this.elementFromNode(node5);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node5) {
      if (node5.nodeType == Node.ELEMENT_NODE) {
        return node5;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches2 = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches2);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key2 = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key2 != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key2, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key2, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key2, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key2, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key2, attributeName);
      }
    }
    stringMapValueChanged(value, key2, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key2, oldValue);
      }
    }
    stringMapKeyRemoved(key2, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key2, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  function add(map22, key2, value) {
    fetch2(map22, key2).add(value);
  }
  function del(map22, key2, value) {
    fetch2(map22, key2).delete(value);
    prune(map22, key2);
  }
  function fetch2(map22, key2) {
    let values = map22.get(key2);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map22.set(key2, values);
    }
    return values;
  }
  function prune(map22, key2) {
    const values = map22.get(key2);
    if (values != null && values.size == 0) {
      map22.delete(key2);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set2) => values.concat(Array.from(set2)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set2) => size + set2.size, 0);
    }
    add(key2, value) {
      add(this.valuesByKey, key2, value);
    }
    delete(key2, value) {
      del(this.valuesByKey, key2, value);
    }
    has(key2, value) {
      const values = this.valuesByKey.get(key2);
      return values != null && values.has(value);
    }
    hasKey(key2) {
      return this.valuesByKey.has(key2);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set2) => set2.has(value));
    }
    getValuesForKey(key2) {
      const values = this.valuesByKey.get(key2);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([key2, values]) => values.has(value)).map(([key2, values]) => key2);
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content3) => content3.length).map((content3, index3) => ({ element, attributeName, content: content3, index: index3 }));
  }
  function zip(left2, right2) {
    const length = Math.max(left2.length, right2.length);
    return Array.from({ length }, (_, index3) => [left2[index3], right2[index3]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error3) {
        return { error: error3 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
      this.invokeChangedCallbacksForDefaultValues();
    }
    start() {
      this.stringMapObserver.start();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key2, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key2)) {
        this.invokeChangedCallback(key2, descriptor.writer(this.receiver[key2]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key2, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key2];
      if (this.hasValue(key2)) {
        this.invokeChangedCallback(key2, descriptor.writer(this.receiver[key2]), oldValue);
      } else {
        this.invokeChangedCallback(key2, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key: key2, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key2)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key2) => valueDescriptorMap[key2]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key2) => {
        const descriptor = this.valueDescriptorMap[key2];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var Context = class {
    constructor(module2, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module2;
      this.scope = scope;
      this.controller = new module2.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error3) {
        this.handleError(error3, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error3) {
        this.handleError(error3, "connecting controller");
      }
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error3) {
        this.handleError(error3, "disconnecting controller");
      }
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error3, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error3, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key2) => [key2, definition[key2]]) : [];
  }
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key2 in properties) {
        const descriptor = blessedProperties[key2] || {};
        blessedProperties[key2] = Object.assign(descriptor, properties[key2]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key2) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key2);
      if (descriptor) {
        Object.assign(shadowProperties, { [key2]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key2) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key2);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key2).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [
        ...Object.getOwnPropertyNames(object),
        ...Object.getOwnPropertySymbols(object)
      ];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a = function() {
        this.a.call(this);
      };
      const b = extendWithReflect(a);
      b.prototype.a = function() {
      };
      return new b();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error3) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key2) {
      const name = this.getAttributeNameForKey(key2);
      return this.element.getAttribute(name);
    }
    set(key2, value) {
      const name = this.getAttributeNameForKey(key2);
      this.element.setAttribute(name, value);
      return this.get(key2);
    }
    has(key2) {
      const name = this.getAttributeNameForKey(key2);
      return this.element.hasAttribute(name);
    }
    delete(key2) {
      if (this.has(key2)) {
        const name = this.getAttributeNameForKey(key2);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key2) {
      return `data-${this.identifier}-${dasherize(key2)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key2, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key2)) {
        warnedKeys.add(key2);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var Scope = class {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module2) => contexts.concat(module2.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module2 = new Module(this.application, definition);
      this.connectModule(module2);
    }
    unloadIdentifier(identifier) {
      const module2 = this.modulesByIdentifier.get(identifier);
      if (module2) {
        this.disconnectModule(module2);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module2 = this.modulesByIdentifier.get(identifier);
      if (module2) {
        return module2.contexts.find((context) => context.element == element);
      }
    }
    handleError(error3, message, detail) {
      this.application.handleError(error3, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module2 = this.modulesByIdentifier.get(scope.identifier);
      if (module2) {
        module2.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module2 = this.modulesByIdentifier.get(scope.identifier);
      if (module2) {
        module2.disconnectContextForScope(scope);
      }
    }
    connectModule(module2) {
      this.modulesByIdentifier.set(module2.identifier, module2);
      const scopes = this.scopesByIdentifier.getValuesForKey(module2.identifier);
      scopes.forEach((scope) => module2.connectContextForScope(scope));
    }
    disconnectModule(module2) {
      this.modulesByIdentifier.delete(module2.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module2.identifier);
      scopes.forEach((scope) => module2.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`
  };
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
    }
    static start(element, schema) {
      const application2 = new Application(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      if (controllerConstructor.shouldLoad) {
        this.load({ identifier, controllerConstructor });
      }
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => this.router.loadDefinition(definition));
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error3, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error3, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error3);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve14) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve14());
      } else {
        resolve14();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key2) {
    return {
      [`${key2}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key2)) {
            return classes.get(key2);
          } else {
            const attribute = classes.getAttributeName(key2);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key2}Classes`]: {
        get() {
          return this.classes.getAll(key2);
        }
      },
      [`has${capitalize(key2)}Class`]: {
        get() {
          return this.classes.has(key2);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result2, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result2, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair) {
    const definition = parseValueDefinitionPair(valueDefinitionPair);
    const { key: key2, name, reader: read2, writer: write2 } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key2);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key2);
          } else {
            this.data.set(key2, write2(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key2) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition]) {
    return valueDescriptorForTokenAndTypeDefinition(token, typeDefinition);
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(typeObject) {
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    if (typeFromObject) {
      const defaultValueType = parseValueTypeDefault(typeObject.default);
      if (typeFromObject !== defaultValueType) {
        throw new Error(`Type "${typeFromObject}" must match the type of the default value. Given default value: "${typeObject.default}" as "${defaultValueType}"`);
      }
      return typeFromObject;
    }
  }
  function parseValueTypeDefinition(typeDefinition) {
    const typeFromObject = parseValueTypeObject(typeDefinition);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    throw new Error(`Unknown value type "${typeDefinition}"`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const defaultValue = typeDefinition.default;
    if (defaultValue !== void 0)
      return defaultValue;
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(token, typeDefinition) {
    const key2 = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(typeDefinition);
    return {
      type,
      key: key2,
      name: camelize(key2),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError("Expected array");
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || value == "false");
    },
    number(value) {
      return Number(value);
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError("Expected object");
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];
  Controller.targets = [];
  Controller.values = {};

  // node_modules/@rails/request.js/src/fetch_response.js
  var FetchResponse2 = class {
    constructor(response) {
      this.response = response;
    }
    get statusCode() {
      return this.response.status;
    }
    get redirected() {
      return this.response.redirected;
    }
    get ok() {
      return this.response.ok;
    }
    get unauthenticated() {
      return this.statusCode === 401;
    }
    get unprocessableEntity() {
      return this.statusCode === 422;
    }
    get authenticationURL() {
      return this.response.headers.get("WWW-Authenticate");
    }
    get contentType() {
      const contentType = this.response.headers.get("Content-Type") || "";
      return contentType.replace(/;.*$/, "");
    }
    get headers() {
      return this.response.headers;
    }
    get html() {
      if (this.contentType.match(/^(application|text)\/(html|xhtml\+xml)$/)) {
        return this.text;
      }
      return Promise.reject(new Error(`Expected an HTML response but got "${this.contentType}" instead`));
    }
    get json() {
      if (this.contentType.match(/^application\/.*json$/)) {
        return this.responseJson || (this.responseJson = this.response.json());
      }
      return Promise.reject(new Error(`Expected a JSON response but got "${this.contentType}" instead`));
    }
    get text() {
      return this.responseText || (this.responseText = this.response.text());
    }
    get isTurboStream() {
      return this.contentType.match(/^text\/vnd\.turbo-stream\.html/);
    }
    async renderTurboStream() {
      if (this.isTurboStream) {
        if (window.Turbo) {
          await window.Turbo.renderStreamMessage(await this.text);
        } else {
          console.warn("You must set `window.Turbo = Turbo` to automatically process Turbo Stream events with request.js");
        }
      } else {
        return Promise.reject(new Error(`Expected a Turbo Stream response but got "${this.contentType}" instead`));
      }
    }
  };

  // node_modules/@rails/request.js/src/request_interceptor.js
  var RequestInterceptor = class {
    static register(interceptor) {
      this.interceptor = interceptor;
    }
    static get() {
      return this.interceptor;
    }
    static reset() {
      this.interceptor = void 0;
    }
  };

  // node_modules/@rails/request.js/src/lib/utils.js
  function getCookie(name) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const prefix = `${encodeURIComponent(name)}=`;
    const cookie = cookies.find((cookie2) => cookie2.startsWith(prefix));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      if (value) {
        return decodeURIComponent(value);
      }
    }
  }
  function compact(object) {
    const result2 = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value !== void 0) {
        result2[key2] = value;
      }
    }
    return result2;
  }
  function metaContent(name) {
    const element = document.head.querySelector(`meta[name="${name}"]`);
    return element && element.content;
  }
  function stringEntriesFromFormData(formData) {
    return [...formData].reduce((entries, [name, value]) => {
      return entries.concat(typeof value === "string" ? [[name, value]] : []);
    }, []);
  }
  function mergeEntries(searchParams, entries) {
    for (const [name, value] of entries) {
      if (value instanceof window.File)
        continue;
      if (searchParams.has(name)) {
        searchParams.delete(name);
        searchParams.set(name, value);
      } else {
        searchParams.append(name, value);
      }
    }
  }

  // node_modules/@rails/request.js/src/fetch_request.js
  var FetchRequest2 = class {
    constructor(method, url, options = {}) {
      this.method = method;
      this.options = options;
      this.originalUrl = url.toString();
    }
    async perform() {
      try {
        const requestInterceptor = RequestInterceptor.get();
        if (requestInterceptor) {
          await requestInterceptor(this);
        }
      } catch (error3) {
        console.error(error3);
      }
      const response = new FetchResponse2(await window.fetch(this.url, this.fetchOptions));
      if (response.unauthenticated && response.authenticationURL) {
        return Promise.reject(window.location.href = response.authenticationURL);
      }
      if (response.ok && response.isTurboStream) {
        await response.renderTurboStream();
      }
      return response;
    }
    addHeader(key2, value) {
      const headers = this.additionalHeaders;
      headers[key2] = value;
      this.options.headers = headers;
    }
    get fetchOptions() {
      return {
        method: this.method.toUpperCase(),
        headers: this.headers,
        body: this.formattedBody,
        signal: this.signal,
        credentials: "same-origin",
        redirect: this.redirect
      };
    }
    get headers() {
      return compact(Object.assign({
        "X-Requested-With": "XMLHttpRequest",
        "X-CSRF-Token": this.csrfToken,
        "Content-Type": this.contentType,
        Accept: this.accept
      }, this.additionalHeaders));
    }
    get csrfToken() {
      return getCookie(metaContent("csrf-param")) || metaContent("csrf-token");
    }
    get contentType() {
      if (this.options.contentType) {
        return this.options.contentType;
      } else if (this.body == null || this.body instanceof window.FormData) {
        return void 0;
      } else if (this.body instanceof window.File) {
        return this.body.type;
      }
      return "application/json";
    }
    get accept() {
      switch (this.responseKind) {
        case "html":
          return "text/html, application/xhtml+xml";
        case "turbo-stream":
          return "text/vnd.turbo-stream.html, text/html, application/xhtml+xml";
        case "json":
          return "application/json, application/vnd.api+json";
        default:
          return "*/*";
      }
    }
    get body() {
      return this.options.body;
    }
    get query() {
      const originalQuery = (this.originalUrl.split("?")[1] || "").split("#")[0];
      const params = new URLSearchParams(originalQuery);
      let requestQuery = this.options.query;
      if (requestQuery instanceof window.FormData) {
        requestQuery = stringEntriesFromFormData(requestQuery);
      } else if (requestQuery instanceof window.URLSearchParams) {
        requestQuery = requestQuery.entries();
      } else {
        requestQuery = Object.entries(requestQuery || {});
      }
      mergeEntries(params, requestQuery);
      const query = params.toString();
      return query.length > 0 ? `?${query}` : "";
    }
    get url() {
      return this.originalUrl.split("?")[0].split("#")[0] + this.query;
    }
    get responseKind() {
      return this.options.responseKind || "html";
    }
    get signal() {
      return this.options.signal;
    }
    get redirect() {
      return this.options.redirect || "follow";
    }
    get additionalHeaders() {
      return this.options.headers || {};
    }
    get formattedBody() {
      const bodyIsAString = Object.prototype.toString.call(this.body) === "[object String]";
      const contentTypeIsJson = this.headers["Content-Type"] === "application/json";
      if (contentTypeIsJson && !bodyIsAString) {
        return JSON.stringify(this.body);
      }
      return this.body;
    }
  };

  // node_modules/@rails/request.js/src/verbs.js
  async function get(url, options) {
    const request = new FetchRequest2("get", url, options);
    return request.perform();
  }

  // node_modules/frontend-helpers/javascript/src/controllers/disappear-controller.js
  var DisappearController = class extends Controller {
    connect() {
      this.closed = false;
      setTimeout(() => this.close(), this.delayValue);
    }
    disconnect() {
      if (this.closed)
        return;
      this.removeElement();
    }
    close() {
      const animationClass = this.hasAnimationClass ? this.animationClass : "fadeOutRight";
      this.element.classList.add(animationClass);
      this.element.addEventListener("animationend", () => {
        this.closed = true;
        this.removeElement();
      });
    }
    removeElement() {
      if (!this.hasRemoveValue) {
        this.element.remove();
      }
    }
  };
  __publicField(DisappearController, "classes", ["animation"]);
  __publicField(DisappearController, "values", {
    delay: { type: Number, default: 3e3 },
    remove: Boolean
  });

  // node_modules/frontend-helpers/javascript/src/controllers/notification-controller.js
  var NotificationController = class extends DisappearController {
    connect() {
      this.closed = false;
      if (!this.hasDelayValue) {
        return;
      }
      setTimeout(() => this.close(), this.delayValue);
    }
  };
  __publicField(NotificationController, "values", {
    delay: Number,
    remove: Boolean
  });

  // node_modules/frontend-helpers/javascript/src/controllers/slim-select-controller.js
  var SlimSelectController = class extends Controller {
    async connect() {
      const { default: SlimSelect } = await Promise.resolve().then(() => (init_slimselect_min(), slimselect_min_exports));
      const options = {
        select: this.selectTarget,
        placeholder: this.hasPlaceholderValue && this.placeholderValue,
        showContent: this.showContentValue === "undefined" ? "down" : this.showContentValue,
        showSearch: this.showSearchValue,
        searchPlaceholder: this.searchPlaceholderValue,
        addToBody: this.addToBodyValue,
        closeOnSelect: this.closeOnSelectValue,
        allowDeselectOption: this.allowDeselectOptionValue,
        addable: this.addable()
      };
      if (this.hasInnerHTML()) {
        options.data = this.dataWithHTML();
      }
      this.select = new SlimSelect(options);
    }
    disconnect() {
      this.select.destroy();
    }
    addable() {
      if (!this.addItemsValue)
        return;
      return function(value) {
        return value;
      };
    }
    dataWithHTML() {
      return Array.from(this.selectTarget.children).map((option) => {
        return {
          text: option.text,
          value: option.value,
          innerHTML: option.dataset.innerHtml,
          selected: option.selected,
          disabled: option.disabled
        };
      });
    }
    hasInnerHTML() {
      const firstOption = this.selectTarget.children[0];
      return firstOption && !!firstOption.dataset.innerHtml;
    }
    selectAll() {
      const allValues = Array.from(this.selectTarget.children).map((option) => option.value);
      this.select.set(allValues);
      this.selectAllButtonTarget.style.display = "none";
      this.deselectAllButtonTarget.style.display = "block";
    }
    deselectAll() {
      this.select.set([]);
      this.deselectAllButtonTarget.style.display = "none";
      this.selectAllButtonTarget.style.display = "block";
    }
  };
  __publicField(SlimSelectController, "values", {
    placeholder: String,
    addItems: Boolean,
    showContent: String,
    showSearch: Boolean,
    searchPlaceholder: String,
    addToBody: Boolean,
    closeOnSelect: Boolean,
    allowDeselectOption: Boolean
  });
  __publicField(SlimSelectController, "targets", ["select", "selectAllButton", "deselectAllButton"]);

  // node_modules/bali-view-components/app/components/bali/tabs/index.js
  var TabsController = class extends Controller {
    open(event) {
      event.preventDefault();
      const index3 = event.currentTarget.getAttribute("data-tab-index");
      this._hideAllTabs();
      this._openTab(index3);
    }
    _hideAllTabs() {
      const allContents = this.element.querySelectorAll("[data-content-index]");
      Array.from(allContents).forEach((t) => t.classList.add("is-hidden"));
      const allTabs = this.element.querySelectorAll("[data-tab-index]");
      Array.from(allTabs).forEach((t) => t.classList.remove("is-active"));
    }
    _openTab(index3) {
      const contentDiv = this.element.querySelector(`[data-content-index="${index3}"]`);
      contentDiv.classList.remove("is-hidden");
      const tabLi = this.element.querySelector(`[data-tab-index="${index3}"]`);
      tabLi.classList.add("is-active");
    }
  };

  // node_modules/bali-view-components/app/components/bali/dropdown/index.js
  var DropdownController = class extends Controller {
    connect() {
      if (this.closeOnClickValue) {
        document.addEventListener("click", this.closeDropdowns);
      }
      if (!this.hoverableValue)
        return;
      this.element.addEventListener("mouseenter", (event) => this.toggleMenu(event));
      this.element.addEventListener("mouseleave", this.closeDropdowns);
    }
    disconnect() {
      if (this.closeOnClickValue) {
        document.removeEventListener("click", this.closeDropdowns);
      }
      if (!this.hoverableValue)
        return;
      this.element.removeEventListener("mouseenter", this.closeDropdowns);
      this.element.removeEventListener("mouseleave", this.closeDropdowns);
    }
    toggleMenu(e) {
      e.stopPropagation();
      e.preventDefault();
      this.element.classList.toggle("is-active");
    }
    closeDropdowns = () => {
      this.element.classList.remove("is-active");
    };
  };
  __publicField(DropdownController, "values", {
    hoverable: { type: Boolean, default: false },
    closeOnClick: { type: Boolean, default: true }
  });

  // node_modules/orderedmap/index.es.js
  function OrderedMap(content3) {
    this.content = content3;
  }
  OrderedMap.prototype = {
    constructor: OrderedMap,
    find: function(key2) {
      for (var i = 0; i < this.content.length; i += 2)
        if (this.content[i] === key2)
          return i;
      return -1;
    },
    get: function(key2) {
      var found3 = this.find(key2);
      return found3 == -1 ? void 0 : this.content[found3 + 1];
    },
    update: function(key2, value, newKey) {
      var self2 = newKey && newKey != key2 ? this.remove(newKey) : this;
      var found3 = self2.find(key2), content3 = self2.content.slice();
      if (found3 == -1) {
        content3.push(newKey || key2, value);
      } else {
        content3[found3 + 1] = value;
        if (newKey)
          content3[found3] = newKey;
      }
      return new OrderedMap(content3);
    },
    remove: function(key2) {
      var found3 = this.find(key2);
      if (found3 == -1)
        return this;
      var content3 = this.content.slice();
      content3.splice(found3, 2);
      return new OrderedMap(content3);
    },
    addToStart: function(key2, value) {
      return new OrderedMap([key2, value].concat(this.remove(key2).content));
    },
    addToEnd: function(key2, value) {
      var content3 = this.remove(key2).content.slice();
      content3.push(key2, value);
      return new OrderedMap(content3);
    },
    addBefore: function(place, key2, value) {
      var without = this.remove(key2), content3 = without.content.slice();
      var found3 = without.find(place);
      content3.splice(found3 == -1 ? content3.length : found3, 0, key2, value);
      return new OrderedMap(content3);
    },
    forEach: function(f) {
      for (var i = 0; i < this.content.length; i += 2)
        f(this.content[i], this.content[i + 1]);
    },
    prepend: function(map22) {
      map22 = OrderedMap.from(map22);
      if (!map22.size)
        return this;
      return new OrderedMap(map22.content.concat(this.subtract(map22).content));
    },
    append: function(map22) {
      map22 = OrderedMap.from(map22);
      if (!map22.size)
        return this;
      return new OrderedMap(this.subtract(map22).content.concat(map22.content));
    },
    subtract: function(map22) {
      var result2 = this;
      map22 = OrderedMap.from(map22);
      for (var i = 0; i < map22.content.length; i += 2)
        result2 = result2.remove(map22.content[i]);
      return result2;
    },
    get size() {
      return this.content.length >> 1;
    }
  };
  OrderedMap.from = function(value) {
    if (value instanceof OrderedMap)
      return value;
    var content3 = [];
    if (value)
      for (var prop in value)
        content3.push(prop, value[prop]);
    return new OrderedMap(content3);
  };
  var orderedmap = OrderedMap;
  var index_es_default = orderedmap;

  // node_modules/prosemirror-model/dist/index.es.js
  function findDiffStart(a, b, pos) {
    for (var i = 0; ; i++) {
      if (i == a.childCount || i == b.childCount) {
        return a.childCount == b.childCount ? null : pos;
      }
      var childA = a.child(i), childB = b.child(i);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB)) {
        return pos;
      }
      if (childA.isText && childA.text != childB.text) {
        for (var j = 0; childA.text[j] == childB.text[j]; j++) {
          pos++;
        }
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        var inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null) {
          return inner;
        }
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a, b, posA, posB) {
    for (var iA = a.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0) {
        return iA == iB ? null : { a: posA, b: posB };
      }
      var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB)) {
        return { a: posA, b: posB };
      }
      if (childA.isText && childA.text != childB.text) {
        var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner) {
          return inner;
        }
      }
      posA -= size;
      posB -= size;
    }
  }
  var Fragment = function Fragment2(content3, size) {
    this.content = content3;
    this.size = size || 0;
    if (size == null) {
      for (var i = 0; i < content3.length; i++) {
        this.size += content3[i].nodeSize;
      }
    }
  };
  var prototypeAccessors = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
  Fragment.prototype.nodesBetween = function nodesBetween(from5, to, f, nodeStart, parent) {
    if (nodeStart === void 0)
      nodeStart = 0;
    for (var i = 0, pos = 0; pos < to; i++) {
      var child5 = this.content[i], end4 = pos + child5.nodeSize;
      if (end4 > from5 && f(child5, nodeStart + pos, parent, i) !== false && child5.content.size) {
        var start6 = pos + 1;
        child5.nodesBetween(Math.max(0, from5 - start6), Math.min(child5.content.size, to - start6), f, nodeStart + start6);
      }
      pos = end4;
    }
  };
  Fragment.prototype.descendants = function descendants(f) {
    this.nodesBetween(0, this.size, f);
  };
  Fragment.prototype.textBetween = function textBetween(from5, to, blockSeparator, leafText) {
    var text4 = "", separated = true;
    this.nodesBetween(from5, to, function(node5, pos) {
      if (node5.isText) {
        text4 += node5.text.slice(Math.max(from5, pos) - pos, to - pos);
        separated = !blockSeparator;
      } else if (node5.isLeaf && leafText) {
        text4 += typeof leafText === "function" ? leafText(node5) : leafText;
        separated = !blockSeparator;
      } else if (!separated && node5.isBlock) {
        text4 += blockSeparator;
        separated = true;
      }
    }, 0);
    return text4;
  };
  Fragment.prototype.append = function append(other) {
    if (!other.size) {
      return this;
    }
    if (!this.size) {
      return other;
    }
    var last = this.lastChild, first2 = other.firstChild, content3 = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content3[content3.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++) {
      content3.push(other.content[i]);
    }
    return new Fragment(content3, this.size + other.size);
  };
  Fragment.prototype.cut = function cut(from5, to) {
    if (to == null) {
      to = this.size;
    }
    if (from5 == 0 && to == this.size) {
      return this;
    }
    var result2 = [], size = 0;
    if (to > from5) {
      for (var i = 0, pos = 0; pos < to; i++) {
        var child5 = this.content[i], end4 = pos + child5.nodeSize;
        if (end4 > from5) {
          if (pos < from5 || end4 > to) {
            if (child5.isText) {
              child5 = child5.cut(Math.max(0, from5 - pos), Math.min(child5.text.length, to - pos));
            } else {
              child5 = child5.cut(Math.max(0, from5 - pos - 1), Math.min(child5.content.size, to - pos - 1));
            }
          }
          result2.push(child5);
          size += child5.nodeSize;
        }
        pos = end4;
      }
    }
    return new Fragment(result2, size);
  };
  Fragment.prototype.cutByIndex = function cutByIndex(from5, to) {
    if (from5 == to) {
      return Fragment.empty;
    }
    if (from5 == 0 && to == this.content.length) {
      return this;
    }
    return new Fragment(this.content.slice(from5, to));
  };
  Fragment.prototype.replaceChild = function replaceChild(index3, node5) {
    var current = this.content[index3];
    if (current == node5) {
      return this;
    }
    var copy7 = this.content.slice();
    var size = this.size + node5.nodeSize - current.nodeSize;
    copy7[index3] = node5;
    return new Fragment(copy7, size);
  };
  Fragment.prototype.addToStart = function addToStart(node5) {
    return new Fragment([node5].concat(this.content), this.size + node5.nodeSize);
  };
  Fragment.prototype.addToEnd = function addToEnd(node5) {
    return new Fragment(this.content.concat(node5), this.size + node5.nodeSize);
  };
  Fragment.prototype.eq = function eq(other) {
    if (this.content.length != other.content.length) {
      return false;
    }
    for (var i = 0; i < this.content.length; i++) {
      if (!this.content[i].eq(other.content[i])) {
        return false;
      }
    }
    return true;
  };
  prototypeAccessors.firstChild.get = function() {
    return this.content.length ? this.content[0] : null;
  };
  prototypeAccessors.lastChild.get = function() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  };
  prototypeAccessors.childCount.get = function() {
    return this.content.length;
  };
  Fragment.prototype.child = function child(index3) {
    var found3 = this.content[index3];
    if (!found3) {
      throw new RangeError("Index " + index3 + " out of range for " + this);
    }
    return found3;
  };
  Fragment.prototype.maybeChild = function maybeChild(index3) {
    return this.content[index3];
  };
  Fragment.prototype.forEach = function forEach(f) {
    for (var i = 0, p = 0; i < this.content.length; i++) {
      var child5 = this.content[i];
      f(child5, p, i);
      p += child5.nodeSize;
    }
  };
  Fragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {
    if (pos === void 0)
      pos = 0;
    return findDiffStart(this, other, pos);
  };
  Fragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
    if (pos === void 0)
      pos = this.size;
    if (otherPos === void 0)
      otherPos = other.size;
    return findDiffEnd(this, other, pos, otherPos);
  };
  Fragment.prototype.findIndex = function findIndex(pos, round2) {
    if (round2 === void 0)
      round2 = -1;
    if (pos == 0) {
      return retIndex(0, pos);
    }
    if (pos == this.size) {
      return retIndex(this.content.length, pos);
    }
    if (pos > this.size || pos < 0) {
      throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
    }
    for (var i = 0, curPos = 0; ; i++) {
      var cur = this.child(i), end4 = curPos + cur.nodeSize;
      if (end4 >= pos) {
        if (end4 == pos || round2 > 0) {
          return retIndex(i + 1, end4);
        }
        return retIndex(i, curPos);
      }
      curPos = end4;
    }
  };
  Fragment.prototype.toString = function toString() {
    return "<" + this.toStringInner() + ">";
  };
  Fragment.prototype.toStringInner = function toStringInner() {
    return this.content.join(", ");
  };
  Fragment.prototype.toJSON = function toJSON() {
    return this.content.length ? this.content.map(function(n) {
      return n.toJSON();
    }) : null;
  };
  Fragment.fromJSON = function fromJSON(schema, value) {
    if (!value) {
      return Fragment.empty;
    }
    if (!Array.isArray(value)) {
      throw new RangeError("Invalid input for Fragment.fromJSON");
    }
    return new Fragment(value.map(schema.nodeFromJSON));
  };
  Fragment.fromArray = function fromArray(array) {
    if (!array.length) {
      return Fragment.empty;
    }
    var joined, size = 0;
    for (var i = 0; i < array.length; i++) {
      var node5 = array[i];
      size += node5.nodeSize;
      if (i && node5.isText && array[i - 1].sameMarkup(node5)) {
        if (!joined) {
          joined = array.slice(0, i);
        }
        joined[joined.length - 1] = node5.withText(joined[joined.length - 1].text + node5.text);
      } else if (joined) {
        joined.push(node5);
      }
    }
    return new Fragment(joined || array, size);
  };
  Fragment.from = function from(nodes) {
    if (!nodes) {
      return Fragment.empty;
    }
    if (nodes instanceof Fragment) {
      return nodes;
    }
    if (Array.isArray(nodes)) {
      return this.fromArray(nodes);
    }
    if (nodes.attrs) {
      return new Fragment([nodes], nodes.nodeSize);
    }
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  };
  Object.defineProperties(Fragment.prototype, prototypeAccessors);
  var found = { index: 0, offset: 0 };
  function retIndex(index3, offset4) {
    found.index = index3;
    found.offset = offset4;
    return found;
  }
  Fragment.empty = new Fragment([], 0);
  function compareDeep(a, b) {
    if (a === b) {
      return true;
    }
    if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
      return false;
    }
    var array = Array.isArray(a);
    if (Array.isArray(b) != array) {
      return false;
    }
    if (array) {
      if (a.length != b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!compareDeep(a[i], b[i])) {
          return false;
        }
      }
    } else {
      for (var p in a) {
        if (!(p in b) || !compareDeep(a[p], b[p])) {
          return false;
        }
      }
      for (var p$1 in b) {
        if (!(p$1 in a)) {
          return false;
        }
      }
    }
    return true;
  }
  var Mark = function Mark2(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  };
  Mark.prototype.addToSet = function addToSet(set2) {
    var copy7, placed = false;
    for (var i = 0; i < set2.length; i++) {
      var other = set2[i];
      if (this.eq(other)) {
        return set2;
      }
      if (this.type.excludes(other.type)) {
        if (!copy7) {
          copy7 = set2.slice(0, i);
        }
      } else if (other.type.excludes(this.type)) {
        return set2;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy7) {
            copy7 = set2.slice(0, i);
          }
          copy7.push(this);
          placed = true;
        }
        if (copy7) {
          copy7.push(other);
        }
      }
    }
    if (!copy7) {
      copy7 = set2.slice();
    }
    if (!placed) {
      copy7.push(this);
    }
    return copy7;
  };
  Mark.prototype.removeFromSet = function removeFromSet(set2) {
    for (var i = 0; i < set2.length; i++) {
      if (this.eq(set2[i])) {
        return set2.slice(0, i).concat(set2.slice(i + 1));
      }
    }
    return set2;
  };
  Mark.prototype.isInSet = function isInSet(set2) {
    for (var i = 0; i < set2.length; i++) {
      if (this.eq(set2[i])) {
        return true;
      }
    }
    return false;
  };
  Mark.prototype.eq = function eq2(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  };
  Mark.prototype.toJSON = function toJSON2() {
    var obj = { type: this.type.name };
    for (var _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  };
  Mark.fromJSON = function fromJSON2(schema, json2) {
    if (!json2) {
      throw new RangeError("Invalid input for Mark.fromJSON");
    }
    var type = schema.marks[json2.type];
    if (!type) {
      throw new RangeError("There is no mark type " + json2.type + " in this schema");
    }
    return type.create(json2.attrs);
  };
  Mark.sameSet = function sameSet(a, b) {
    if (a == b) {
      return true;
    }
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!a[i].eq(b[i])) {
        return false;
      }
    }
    return true;
  };
  Mark.setFrom = function setFrom(marks3) {
    if (!marks3 || marks3.length == 0) {
      return Mark.none;
    }
    if (marks3 instanceof Mark) {
      return [marks3];
    }
    var copy7 = marks3.slice();
    copy7.sort(function(a, b) {
      return a.type.rank - b.type.rank;
    });
    return copy7;
  };
  Mark.none = [];
  function ReplaceError(message) {
    var err3 = Error.call(this, message);
    err3.__proto__ = ReplaceError.prototype;
    return err3;
  }
  ReplaceError.prototype = Object.create(Error.prototype);
  ReplaceError.prototype.constructor = ReplaceError;
  ReplaceError.prototype.name = "ReplaceError";
  var Slice = function Slice2(content3, openStart, openEnd) {
    this.content = content3;
    this.openStart = openStart;
    this.openEnd = openEnd;
  };
  var prototypeAccessors$1 = { size: { configurable: true } };
  prototypeAccessors$1.size.get = function() {
    return this.content.size - this.openStart - this.openEnd;
  };
  Slice.prototype.insertAt = function insertAt(pos, fragment) {
    var content3 = insertInto(this.content, pos + this.openStart, fragment, null);
    return content3 && new Slice(content3, this.openStart, this.openEnd);
  };
  Slice.prototype.removeBetween = function removeBetween(from5, to) {
    return new Slice(removeRange(this.content, from5 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  };
  Slice.prototype.eq = function eq3(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  };
  Slice.prototype.toString = function toString2() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  };
  Slice.prototype.toJSON = function toJSON3() {
    if (!this.content.size) {
      return null;
    }
    var json2 = { content: this.content.toJSON() };
    if (this.openStart > 0) {
      json2.openStart = this.openStart;
    }
    if (this.openEnd > 0) {
      json2.openEnd = this.openEnd;
    }
    return json2;
  };
  Slice.fromJSON = function fromJSON3(schema, json2) {
    if (!json2) {
      return Slice.empty;
    }
    var openStart = json2.openStart || 0, openEnd = json2.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number") {
      throw new RangeError("Invalid input for Slice.fromJSON");
    }
    return new Slice(Fragment.fromJSON(schema, json2.content), openStart, openEnd);
  };
  Slice.maxOpen = function maxOpen(fragment, openIsolating) {
    if (openIsolating === void 0)
      openIsolating = true;
    var openStart = 0, openEnd = 0;
    for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
      openStart++;
    }
    for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
      openEnd++;
    }
    return new Slice(fragment, openStart, openEnd);
  };
  Object.defineProperties(Slice.prototype, prototypeAccessors$1);
  function removeRange(content3, from5, to) {
    var ref = content3.findIndex(from5);
    var index3 = ref.index;
    var offset4 = ref.offset;
    var child5 = content3.maybeChild(index3);
    var ref$1 = content3.findIndex(to);
    var indexTo = ref$1.index;
    var offsetTo = ref$1.offset;
    if (offset4 == from5 || child5.isText) {
      if (offsetTo != to && !content3.child(indexTo).isText) {
        throw new RangeError("Removing non-flat range");
      }
      return content3.cut(0, from5).append(content3.cut(to));
    }
    if (index3 != indexTo) {
      throw new RangeError("Removing non-flat range");
    }
    return content3.replaceChild(index3, child5.copy(removeRange(child5.content, from5 - offset4 - 1, to - offset4 - 1)));
  }
  function insertInto(content3, dist, insert, parent) {
    var ref = content3.findIndex(dist);
    var index3 = ref.index;
    var offset4 = ref.offset;
    var child5 = content3.maybeChild(index3);
    if (offset4 == dist || child5.isText) {
      if (parent && !parent.canReplace(index3, index3, insert)) {
        return null;
      }
      return content3.cut(0, dist).append(insert).append(content3.cut(dist));
    }
    var inner = insertInto(child5.content, dist - offset4 - 1, insert);
    return inner && content3.replaceChild(index3, child5.copy(inner));
  }
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function replace($from, $to, slice6) {
    if (slice6.openStart > $from.depth) {
      throw new ReplaceError("Inserted content deeper than insertion position");
    }
    if ($from.depth - slice6.openStart != $to.depth - slice6.openEnd) {
      throw new ReplaceError("Inconsistent open depths");
    }
    return replaceOuter($from, $to, slice6, 0);
  }
  function replaceOuter($from, $to, slice6, depth) {
    var index3 = $from.index(depth), node5 = $from.node(depth);
    if (index3 == $to.index(depth) && depth < $from.depth - slice6.openStart) {
      var inner = replaceOuter($from, $to, slice6, depth + 1);
      return node5.copy(node5.content.replaceChild(index3, inner));
    } else if (!slice6.content.size) {
      return close(node5, replaceTwoWay($from, $to, depth));
    } else if (!slice6.openStart && !slice6.openEnd && $from.depth == depth && $to.depth == depth) {
      var parent = $from.parent, content3 = parent.content;
      return close(parent, content3.cut(0, $from.parentOffset).append(slice6.content).append(content3.cut($to.parentOffset)));
    } else {
      var ref = prepareSliceForReplace(slice6, $from);
      var start6 = ref.start;
      var end4 = ref.end;
      return close(node5, replaceThreeWay($from, start6, end4, $to, depth));
    }
  }
  function checkJoin(main2, sub) {
    if (!sub.type.compatibleContent(main2.type)) {
      throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
    }
  }
  function joinable($before, $after, depth) {
    var node5 = $before.node(depth);
    checkJoin(node5, $after.node(depth));
    return node5;
  }
  function addNode(child5, target) {
    var last = target.length - 1;
    if (last >= 0 && child5.isText && child5.sameMarkup(target[last])) {
      target[last] = child5.withText(target[last].text + child5.text);
    } else {
      target.push(child5);
    }
  }
  function addRange($start, $end, depth, target) {
    var node5 = ($end || $start).node(depth);
    var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node5.childCount;
    if ($start) {
      startIndex2 = $start.index(depth);
      if ($start.depth > depth) {
        startIndex2++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex2++;
      }
    }
    for (var i = startIndex2; i < endIndex2; i++) {
      addNode(node5.child(i), target);
    }
    if ($end && $end.depth == depth && $end.textOffset) {
      addNode($end.nodeBefore, target);
    }
  }
  function close(node5, content3) {
    if (!node5.type.validContent(content3)) {
      throw new ReplaceError("Invalid content for node " + node5.type.name);
    }
    return node5.copy(content3);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
    var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
    var content3 = [];
    addRange(null, $from, depth, content3);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content3);
    } else {
      if (openStart) {
        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content3);
      }
      addRange($start, $end, depth, content3);
      if (openEnd) {
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content3);
      }
    }
    addRange($to, null, depth, content3);
    return new Fragment(content3);
  }
  function replaceTwoWay($from, $to, depth) {
    var content3 = [];
    addRange(null, $from, depth, content3);
    if ($from.depth > depth) {
      var type = joinable($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content3);
    }
    addRange($to, null, depth, content3);
    return new Fragment(content3);
  }
  function prepareSliceForReplace(slice6, $along) {
    var extra = $along.depth - slice6.openStart, parent = $along.node(extra);
    var node5 = parent.copy(slice6.content);
    for (var i = extra - 1; i >= 0; i--) {
      node5 = $along.node(i).copy(Fragment.from(node5));
    }
    return {
      start: node5.resolveNoCache(slice6.openStart + extra),
      end: node5.resolveNoCache(node5.content.size - slice6.openEnd - extra)
    };
  }
  var ResolvedPos = function ResolvedPos2(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.depth = path.length / 3 - 1;
    this.parentOffset = parentOffset;
  };
  var prototypeAccessors$2 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
  ResolvedPos.prototype.resolveDepth = function resolveDepth(val) {
    if (val == null) {
      return this.depth;
    }
    if (val < 0) {
      return this.depth + val;
    }
    return val;
  };
  prototypeAccessors$2.parent.get = function() {
    return this.node(this.depth);
  };
  prototypeAccessors$2.doc.get = function() {
    return this.node(0);
  };
  ResolvedPos.prototype.node = function node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  };
  ResolvedPos.prototype.index = function index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  };
  ResolvedPos.prototype.indexAfter = function indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  };
  ResolvedPos.prototype.start = function start2(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  };
  ResolvedPos.prototype.end = function end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  };
  ResolvedPos.prototype.before = function before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth) {
      throw new RangeError("There is no position before the top-level node");
    }
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  };
  ResolvedPos.prototype.after = function after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth) {
      throw new RangeError("There is no position after the top-level node");
    }
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  };
  prototypeAccessors$2.textOffset.get = function() {
    return this.pos - this.path[this.path.length - 1];
  };
  prototypeAccessors$2.nodeAfter.get = function() {
    var parent = this.parent, index3 = this.index(this.depth);
    if (index3 == parent.childCount) {
      return null;
    }
    var dOff = this.pos - this.path[this.path.length - 1], child5 = parent.child(index3);
    return dOff ? parent.child(index3).cut(dOff) : child5;
  };
  prototypeAccessors$2.nodeBefore.get = function() {
    var index3 = this.index(this.depth);
    var dOff = this.pos - this.path[this.path.length - 1];
    if (dOff) {
      return this.parent.child(index3).cut(0, dOff);
    }
    return index3 == 0 ? null : this.parent.child(index3 - 1);
  };
  ResolvedPos.prototype.posAtIndex = function posAtIndex(index3, depth) {
    depth = this.resolveDepth(depth);
    var node5 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (var i = 0; i < index3; i++) {
      pos += node5.child(i).nodeSize;
    }
    return pos;
  };
  ResolvedPos.prototype.marks = function marks() {
    var parent = this.parent, index3 = this.index();
    if (parent.content.size == 0) {
      return Mark.none;
    }
    if (this.textOffset) {
      return parent.child(index3).marks;
    }
    var main2 = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
    if (!main2) {
      var tmp = main2;
      main2 = other;
      other = tmp;
    }
    var marks3 = main2.marks;
    for (var i = 0; i < marks3.length; i++) {
      if (marks3[i].type.spec.inclusive === false && (!other || !marks3[i].isInSet(other.marks))) {
        marks3 = marks3[i--].removeFromSet(marks3);
      }
    }
    return marks3;
  };
  ResolvedPos.prototype.marksAcross = function marksAcross($end) {
    var after3 = this.parent.maybeChild(this.index());
    if (!after3 || !after3.isInline) {
      return null;
    }
    var marks3 = after3.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks3.length; i++) {
      if (marks3[i].type.spec.inclusive === false && (!next || !marks3[i].isInSet(next.marks))) {
        marks3 = marks3[i--].removeFromSet(marks3);
      }
    }
    return marks3;
  };
  ResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {
    for (var depth = this.depth; depth > 0; depth--) {
      if (this.start(depth) <= pos && this.end(depth) >= pos) {
        return depth;
      }
    }
    return 0;
  };
  ResolvedPos.prototype.blockRange = function blockRange(other, pred) {
    if (other === void 0)
      other = this;
    if (other.pos < this.pos) {
      return other.blockRange(this);
    }
    for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
        return new NodeRange(this, other, d);
      }
    }
  };
  ResolvedPos.prototype.sameParent = function sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  };
  ResolvedPos.prototype.max = function max(other) {
    return other.pos > this.pos ? other : this;
  };
  ResolvedPos.prototype.min = function min(other) {
    return other.pos < this.pos ? other : this;
  };
  ResolvedPos.prototype.toString = function toString3() {
    var str = "";
    for (var i = 1; i <= this.depth; i++) {
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    }
    return str + ":" + this.parentOffset;
  };
  ResolvedPos.resolve = function resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size)) {
      throw new RangeError("Position " + pos + " out of range");
    }
    var path = [];
    var start6 = 0, parentOffset = pos;
    for (var node5 = doc2; ; ) {
      var ref = node5.content.findIndex(parentOffset);
      var index3 = ref.index;
      var offset4 = ref.offset;
      var rem = parentOffset - offset4;
      path.push(node5, index3, start6 + offset4);
      if (!rem) {
        break;
      }
      node5 = node5.child(index3);
      if (node5.isText) {
        break;
      }
      parentOffset = rem - 1;
      start6 += offset4 + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  };
  ResolvedPos.resolveCached = function resolveCached(doc2, pos) {
    for (var i = 0; i < resolveCache.length; i++) {
      var cached = resolveCache[i];
      if (cached.pos == pos && cached.doc == doc2) {
        return cached;
      }
    }
    var result2 = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result2;
  };
  Object.defineProperties(ResolvedPos.prototype, prototypeAccessors$2);
  var resolveCache = [];
  var resolveCachePos = 0;
  var resolveCacheSize = 12;
  var NodeRange = function NodeRange2($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  };
  var prototypeAccessors$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
  prototypeAccessors$1$1.start.get = function() {
    return this.$from.before(this.depth + 1);
  };
  prototypeAccessors$1$1.end.get = function() {
    return this.$to.after(this.depth + 1);
  };
  prototypeAccessors$1$1.parent.get = function() {
    return this.$from.node(this.depth);
  };
  prototypeAccessors$1$1.startIndex.get = function() {
    return this.$from.index(this.depth);
  };
  prototypeAccessors$1$1.endIndex.get = function() {
    return this.$to.indexAfter(this.depth);
  };
  Object.defineProperties(NodeRange.prototype, prototypeAccessors$1$1);
  var emptyAttrs = /* @__PURE__ */ Object.create(null);
  var Node2 = function Node3(type, attrs, content3, marks3) {
    this.type = type;
    this.attrs = attrs;
    this.content = content3 || Fragment.empty;
    this.marks = marks3 || Mark.none;
  };
  var prototypeAccessors$3 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
  prototypeAccessors$3.nodeSize.get = function() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  };
  prototypeAccessors$3.childCount.get = function() {
    return this.content.childCount;
  };
  Node2.prototype.child = function child2(index3) {
    return this.content.child(index3);
  };
  Node2.prototype.maybeChild = function maybeChild2(index3) {
    return this.content.maybeChild(index3);
  };
  Node2.prototype.forEach = function forEach2(f) {
    this.content.forEach(f);
  };
  Node2.prototype.nodesBetween = function nodesBetween2(from5, to, f, startPos) {
    if (startPos === void 0)
      startPos = 0;
    this.content.nodesBetween(from5, to, f, startPos, this);
  };
  Node2.prototype.descendants = function descendants2(f) {
    this.nodesBetween(0, this.content.size, f);
  };
  prototypeAccessors$3.textContent.get = function() {
    return this.textBetween(0, this.content.size, "");
  };
  Node2.prototype.textBetween = function textBetween2(from5, to, blockSeparator, leafText) {
    return this.content.textBetween(from5, to, blockSeparator, leafText);
  };
  prototypeAccessors$3.firstChild.get = function() {
    return this.content.firstChild;
  };
  prototypeAccessors$3.lastChild.get = function() {
    return this.content.lastChild;
  };
  Node2.prototype.eq = function eq4(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  };
  Node2.prototype.sameMarkup = function sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  };
  Node2.prototype.hasMarkup = function hasMarkup(type, attrs, marks3) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks3 || Mark.none);
  };
  Node2.prototype.copy = function copy(content3) {
    if (content3 === void 0)
      content3 = null;
    if (content3 == this.content) {
      return this;
    }
    return new this.constructor(this.type, this.attrs, content3, this.marks);
  };
  Node2.prototype.mark = function mark(marks3) {
    return marks3 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks3);
  };
  Node2.prototype.cut = function cut2(from5, to) {
    if (from5 == 0 && to == this.content.size) {
      return this;
    }
    return this.copy(this.content.cut(from5, to));
  };
  Node2.prototype.slice = function slice(from5, to, includeParents) {
    if (to === void 0)
      to = this.content.size;
    if (includeParents === void 0)
      includeParents = false;
    if (from5 == to) {
      return Slice.empty;
    }
    var $from = this.resolve(from5), $to = this.resolve(to);
    var depth = includeParents ? 0 : $from.sharedDepth(to);
    var start6 = $from.start(depth), node5 = $from.node(depth);
    var content3 = node5.content.cut($from.pos - start6, $to.pos - start6);
    return new Slice(content3, $from.depth - depth, $to.depth - depth);
  };
  Node2.prototype.replace = function replace$1(from5, to, slice6) {
    return replace(this.resolve(from5), this.resolve(to), slice6);
  };
  Node2.prototype.nodeAt = function nodeAt(pos) {
    for (var node5 = this; ; ) {
      var ref = node5.content.findIndex(pos);
      var index3 = ref.index;
      var offset4 = ref.offset;
      node5 = node5.maybeChild(index3);
      if (!node5) {
        return null;
      }
      if (offset4 == pos || node5.isText) {
        return node5;
      }
      pos -= offset4 + 1;
    }
  };
  Node2.prototype.childAfter = function childAfter(pos) {
    var ref = this.content.findIndex(pos);
    var index3 = ref.index;
    var offset4 = ref.offset;
    return { node: this.content.maybeChild(index3), index: index3, offset: offset4 };
  };
  Node2.prototype.childBefore = function childBefore(pos) {
    if (pos == 0) {
      return { node: null, index: 0, offset: 0 };
    }
    var ref = this.content.findIndex(pos);
    var index3 = ref.index;
    var offset4 = ref.offset;
    if (offset4 < pos) {
      return { node: this.content.child(index3), index: index3, offset: offset4 };
    }
    var node5 = this.content.child(index3 - 1);
    return { node: node5, index: index3 - 1, offset: offset4 - node5.nodeSize };
  };
  Node2.prototype.resolve = function resolve2(pos) {
    return ResolvedPos.resolveCached(this, pos);
  };
  Node2.prototype.resolveNoCache = function resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  };
  Node2.prototype.rangeHasMark = function rangeHasMark(from5, to, type) {
    var found3 = false;
    if (to > from5) {
      this.nodesBetween(from5, to, function(node5) {
        if (type.isInSet(node5.marks)) {
          found3 = true;
        }
        return !found3;
      });
    }
    return found3;
  };
  prototypeAccessors$3.isBlock.get = function() {
    return this.type.isBlock;
  };
  prototypeAccessors$3.isTextblock.get = function() {
    return this.type.isTextblock;
  };
  prototypeAccessors$3.inlineContent.get = function() {
    return this.type.inlineContent;
  };
  prototypeAccessors$3.isInline.get = function() {
    return this.type.isInline;
  };
  prototypeAccessors$3.isText.get = function() {
    return this.type.isText;
  };
  prototypeAccessors$3.isLeaf.get = function() {
    return this.type.isLeaf;
  };
  prototypeAccessors$3.isAtom.get = function() {
    return this.type.isAtom;
  };
  Node2.prototype.toString = function toString4() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    var name = this.type.name;
    if (this.content.size) {
      name += "(" + this.content.toStringInner() + ")";
    }
    return wrapMarks(this.marks, name);
  };
  Node2.prototype.contentMatchAt = function contentMatchAt(index3) {
    var match = this.type.contentMatch.matchFragment(this.content, 0, index3);
    if (!match) {
      throw new Error("Called contentMatchAt on a node with invalid content");
    }
    return match;
  };
  Node2.prototype.canReplace = function canReplace(from5, to, replacement, start6, end4) {
    if (replacement === void 0)
      replacement = Fragment.empty;
    if (start6 === void 0)
      start6 = 0;
    if (end4 === void 0)
      end4 = replacement.childCount;
    var one = this.contentMatchAt(from5).matchFragment(replacement, start6, end4);
    var two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd) {
      return false;
    }
    for (var i = start6; i < end4; i++) {
      if (!this.type.allowsMarks(replacement.child(i).marks)) {
        return false;
      }
    }
    return true;
  };
  Node2.prototype.canReplaceWith = function canReplaceWith(from5, to, type, marks3) {
    if (marks3 && !this.type.allowsMarks(marks3)) {
      return false;
    }
    var start6 = this.contentMatchAt(from5).matchType(type);
    var end4 = start6 && start6.matchFragment(this.content, to);
    return end4 ? end4.validEnd : false;
  };
  Node2.prototype.canAppend = function canAppend(other) {
    if (other.content.size) {
      return this.canReplace(this.childCount, this.childCount, other.content);
    } else {
      return this.type.compatibleContent(other.type);
    }
  };
  Node2.prototype.check = function check() {
    if (!this.type.validContent(this.content)) {
      throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
    }
    var copy7 = Mark.none;
    for (var i = 0; i < this.marks.length; i++) {
      copy7 = this.marks[i].addToSet(copy7);
    }
    if (!Mark.sameSet(copy7, this.marks)) {
      throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
        return m.type.name;
      }));
    }
    this.content.forEach(function(node5) {
      return node5.check();
    });
  };
  Node2.prototype.toJSON = function toJSON4() {
    var obj = { type: this.type.name };
    for (var _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size) {
      obj.content = this.content.toJSON();
    }
    if (this.marks.length) {
      obj.marks = this.marks.map(function(n) {
        return n.toJSON();
      });
    }
    return obj;
  };
  Node2.fromJSON = function fromJSON4(schema, json2) {
    if (!json2) {
      throw new RangeError("Invalid input for Node.fromJSON");
    }
    var marks3 = null;
    if (json2.marks) {
      if (!Array.isArray(json2.marks)) {
        throw new RangeError("Invalid mark data for Node.fromJSON");
      }
      marks3 = json2.marks.map(schema.markFromJSON);
    }
    if (json2.type == "text") {
      if (typeof json2.text != "string") {
        throw new RangeError("Invalid text node in JSON");
      }
      return schema.text(json2.text, marks3);
    }
    var content3 = Fragment.fromJSON(schema, json2.content);
    return schema.nodeType(json2.type).create(json2.attrs, content3, marks3);
  };
  Object.defineProperties(Node2.prototype, prototypeAccessors$3);
  var TextNode = /* @__PURE__ */ function(Node7) {
    function TextNode2(type, attrs, content3, marks3) {
      Node7.call(this, type, attrs, null, marks3);
      if (!content3) {
        throw new RangeError("Empty text nodes are not allowed");
      }
      this.text = content3;
    }
    if (Node7)
      TextNode2.__proto__ = Node7;
    TextNode2.prototype = Object.create(Node7 && Node7.prototype);
    TextNode2.prototype.constructor = TextNode2;
    var prototypeAccessors$16 = { textContent: { configurable: true }, nodeSize: { configurable: true } };
    TextNode2.prototype.toString = function toString14() {
      if (this.type.spec.toDebugString) {
        return this.type.spec.toDebugString(this);
      }
      return wrapMarks(this.marks, JSON.stringify(this.text));
    };
    prototypeAccessors$16.textContent.get = function() {
      return this.text;
    };
    TextNode2.prototype.textBetween = function textBetween5(from5, to) {
      return this.text.slice(from5, to);
    };
    prototypeAccessors$16.nodeSize.get = function() {
      return this.text.length;
    };
    TextNode2.prototype.mark = function mark4(marks3) {
      return marks3 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks3);
    };
    TextNode2.prototype.withText = function withText(text4) {
      if (text4 == this.text) {
        return this;
      }
      return new TextNode2(this.type, this.attrs, text4, this.marks);
    };
    TextNode2.prototype.cut = function cut5(from5, to) {
      if (from5 === void 0)
        from5 = 0;
      if (to === void 0)
        to = this.text.length;
      if (from5 == 0 && to == this.text.length) {
        return this;
      }
      return this.withText(this.text.slice(from5, to));
    };
    TextNode2.prototype.eq = function eq16(other) {
      return this.sameMarkup(other) && this.text == other.text;
    };
    TextNode2.prototype.toJSON = function toJSON13() {
      var base2 = Node7.prototype.toJSON.call(this);
      base2.text = this.text;
      return base2;
    };
    Object.defineProperties(TextNode2.prototype, prototypeAccessors$16);
    return TextNode2;
  }(Node2);
  function wrapMarks(marks3, str) {
    for (var i = marks3.length - 1; i >= 0; i--) {
      str = marks3[i].type.name + "(" + str + ")";
    }
    return str;
  }
  var ContentMatch = function ContentMatch2(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  };
  var prototypeAccessors$4 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
  ContentMatch.parse = function parse(string, nodeTypes) {
    var stream = new TokenStream(string, nodeTypes);
    if (stream.next == null) {
      return ContentMatch.empty;
    }
    var expr = parseExpr(stream);
    if (stream.next) {
      stream.err("Unexpected trailing text");
    }
    var match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  };
  ContentMatch.prototype.matchType = function matchType(type) {
    for (var i = 0; i < this.next.length; i += 2) {
      if (this.next[i] == type) {
        return this.next[i + 1];
      }
    }
    return null;
  };
  ContentMatch.prototype.matchFragment = function matchFragment(frag, start6, end4) {
    if (start6 === void 0)
      start6 = 0;
    if (end4 === void 0)
      end4 = frag.childCount;
    var cur = this;
    for (var i = start6; cur && i < end4; i++) {
      cur = cur.matchType(frag.child(i).type);
    }
    return cur;
  };
  prototypeAccessors$4.inlineContent.get = function() {
    var first2 = this.next[0];
    return first2 ? first2.isInline : false;
  };
  prototypeAccessors$4.defaultType.get = function() {
    for (var i = 0; i < this.next.length; i += 2) {
      var type = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs())) {
        return type;
      }
    }
  };
  ContentMatch.prototype.compatible = function compatible(other) {
    for (var i = 0; i < this.next.length; i += 2) {
      for (var j = 0; j < other.next.length; j += 2) {
        if (this.next[i] == other.next[j]) {
          return true;
        }
      }
    }
    return false;
  };
  ContentMatch.prototype.fillBefore = function fillBefore(after3, toEnd, startIndex2) {
    if (toEnd === void 0)
      toEnd = false;
    if (startIndex2 === void 0)
      startIndex2 = 0;
    var seen = [this];
    function search(match, types) {
      var finished = match.matchFragment(after3, startIndex2);
      if (finished && (!toEnd || finished.validEnd)) {
        return Fragment.from(types.map(function(tp) {
          return tp.createAndFill();
        }));
      }
      for (var i = 0; i < match.next.length; i += 2) {
        var type = match.next[i], next = match.next[i + 1];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          var found3 = search(next, types.concat(type));
          if (found3) {
            return found3;
          }
        }
      }
    }
    return search(this, []);
  };
  ContentMatch.prototype.findWrapping = function findWrapping(target) {
    for (var i = 0; i < this.wrapCache.length; i += 2) {
      if (this.wrapCache[i] == target) {
        return this.wrapCache[i + 1];
      }
    }
    var computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  };
  ContentMatch.prototype.computeWrapping = function computeWrapping(target) {
    var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      var current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        var result2 = [];
        for (var obj = current; obj.type; obj = obj.via) {
          result2.push(obj.type);
        }
        return result2.reverse();
      }
      for (var i = 0; i < match.next.length; i += 2) {
        var type = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
  };
  prototypeAccessors$4.edgeCount.get = function() {
    return this.next.length >> 1;
  };
  ContentMatch.prototype.edge = function edge(n) {
    var i = n << 1;
    if (i >= this.next.length) {
      throw new RangeError("There's no " + n + "th edge in this content match");
    }
    return { type: this.next[i], next: this.next[i + 1] };
  };
  ContentMatch.prototype.toString = function toString5() {
    var seen = [];
    function scan(m) {
      seen.push(m);
      for (var i = 1; i < m.next.length; i += 2) {
        if (seen.indexOf(m.next[i]) == -1) {
          scan(m.next[i]);
        }
      }
    }
    scan(this);
    return seen.map(function(m, i) {
      var out = i + (m.validEnd ? "*" : " ") + " ";
      for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
        out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
      }
      return out;
    }).join("\n");
  };
  Object.defineProperties(ContentMatch.prototype, prototypeAccessors$4);
  ContentMatch.empty = new ContentMatch(true);
  var TokenStream = function TokenStream2(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "") {
      this.tokens.pop();
    }
    if (this.tokens[0] == "") {
      this.tokens.shift();
    }
  };
  var prototypeAccessors$1$2 = { next: { configurable: true } };
  prototypeAccessors$1$2.next.get = function() {
    return this.tokens[this.pos];
  };
  TokenStream.prototype.eat = function eat(tok) {
    return this.next == tok && (this.pos++ || true);
  };
  TokenStream.prototype.err = function err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  };
  Object.defineProperties(TokenStream.prototype, prototypeAccessors$1$2);
  function parseExpr(stream) {
    var exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    var exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    var expr = parseExprAtom(stream);
    for (; ; ) {
      if (stream.eat("+")) {
        expr = { type: "plus", expr };
      } else if (stream.eat("*")) {
        expr = { type: "star", expr };
      } else if (stream.eat("?")) {
        expr = { type: "opt", expr };
      } else if (stream.eat("{")) {
        expr = parseExprRange(stream, expr);
      } else {
        break;
      }
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next)) {
      stream.err("Expected number, got '" + stream.next + "'");
    }
    var result2 = Number(stream.next);
    stream.pos++;
    return result2;
  }
  function parseExprRange(stream, expr) {
    var min4 = parseNum(stream), max4 = min4;
    if (stream.eat(",")) {
      if (stream.next != "}") {
        max4 = parseNum(stream);
      } else {
        max4 = -1;
      }
    }
    if (!stream.eat("}")) {
      stream.err("Unclosed braced range");
    }
    return { type: "range", min: min4, max: max4, expr };
  }
  function resolveName(stream, name) {
    var types = stream.nodeTypes, type = types[name];
    if (type) {
      return [type];
    }
    var result2 = [];
    for (var typeName in types) {
      var type$1 = types[typeName];
      if (type$1.groups.indexOf(name) > -1) {
        result2.push(type$1);
      }
    }
    if (result2.length == 0) {
      stream.err("No node type or group '" + name + "' found");
    }
    return result2;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      var expr = parseExpr(stream);
      if (!stream.eat(")")) {
        stream.err("Missing closing paren");
      }
      return expr;
    } else if (!/\W/.test(stream.next)) {
      var exprs = resolveName(stream, stream.next).map(function(type) {
        if (stream.inline == null) {
          stream.inline = type.isInline;
        } else if (stream.inline != type.isInline) {
          stream.err("Mixing inline and block content");
        }
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    var nfa3 = [[]];
    connect(compile5(expr, 0), node5());
    return nfa3;
    function node5() {
      return nfa3.push([]) - 1;
    }
    function edge3(from5, to, term) {
      var edge4 = { term, to };
      nfa3[from5].push(edge4);
      return edge4;
    }
    function connect(edges, to) {
      edges.forEach(function(edge4) {
        return edge4.to = to;
      });
    }
    function compile5(expr2, from5) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce(function(out, expr3) {
          return out.concat(compile5(expr3, from5));
        }, []);
      } else if (expr2.type == "seq") {
        for (var i = 0; ; i++) {
          var next = compile5(expr2.exprs[i], from5);
          if (i == expr2.exprs.length - 1) {
            return next;
          }
          connect(next, from5 = node5());
        }
      } else if (expr2.type == "star") {
        var loop = node5();
        edge3(from5, loop);
        connect(compile5(expr2.expr, loop), loop);
        return [edge3(loop)];
      } else if (expr2.type == "plus") {
        var loop$1 = node5();
        connect(compile5(expr2.expr, from5), loop$1);
        connect(compile5(expr2.expr, loop$1), loop$1);
        return [edge3(loop$1)];
      } else if (expr2.type == "opt") {
        return [edge3(from5)].concat(compile5(expr2.expr, from5));
      } else if (expr2.type == "range") {
        var cur = from5;
        for (var i$1 = 0; i$1 < expr2.min; i$1++) {
          var next$1 = node5();
          connect(compile5(expr2.expr, cur), next$1);
          cur = next$1;
        }
        if (expr2.max == -1) {
          connect(compile5(expr2.expr, cur), cur);
        } else {
          for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
            var next$2 = node5();
            edge3(cur, next$2);
            connect(compile5(expr2.expr, cur), next$2);
            cur = next$2;
          }
        }
        return [edge3(cur)];
      } else if (expr2.type == "name") {
        return [edge3(from5, null, expr2.value)];
      }
    }
  }
  function cmp(a, b) {
    return b - a;
  }
  function nullFrom(nfa3, node5) {
    var result2 = [];
    scan(node5);
    return result2.sort(cmp);
    function scan(node6) {
      var edges = nfa3[node6];
      if (edges.length == 1 && !edges[0].term) {
        return scan(edges[0].to);
      }
      result2.push(node6);
      for (var i = 0; i < edges.length; i++) {
        var ref = edges[i];
        var term = ref.term;
        var to = ref.to;
        if (!term && result2.indexOf(to) == -1) {
          scan(to);
        }
      }
    }
  }
  function dfa(nfa3) {
    var labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa3, 0));
    function explore(states) {
      var out = [];
      states.forEach(function(node5) {
        nfa3[node5].forEach(function(ref) {
          var term = ref.term;
          var to = ref.to;
          if (!term) {
            return;
          }
          var known = out.indexOf(term), set2 = known > -1 && out[known + 1];
          nullFrom(nfa3, to).forEach(function(node6) {
            if (!set2) {
              out.push(term, set2 = []);
            }
            if (set2.indexOf(node6) == -1) {
              set2.push(node6);
            }
          });
        });
      });
      var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa3.length - 1) > -1);
      for (var i = 0; i < out.length; i += 2) {
        var states$1 = out[i + 1].sort(cmp);
        state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (var i = 0, work = [match]; i < work.length; i++) {
      var state = work[i], dead = !state.validEnd, nodes = [];
      for (var j = 0; j < state.next.length; j += 2) {
        var node5 = state.next[j], next = state.next[j + 1];
        nodes.push(node5.name);
        if (dead && !(node5.isText || node5.hasRequiredAttrs())) {
          dead = false;
        }
        if (work.indexOf(next) == -1) {
          work.push(next);
        }
      }
      if (dead) {
        stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
  }
  function defaultAttrs(attrs) {
    var defaults2 = /* @__PURE__ */ Object.create(null);
    for (var attrName in attrs) {
      var attr = attrs[attrName];
      if (!attr.hasDefault) {
        return null;
      }
      defaults2[attrName] = attr.default;
    }
    return defaults2;
  }
  function computeAttrs(attrs, value) {
    var built = /* @__PURE__ */ Object.create(null);
    for (var name in attrs) {
      var given = value && value[name];
      if (given === void 0) {
        var attr = attrs[name];
        if (attr.hasDefault) {
          given = attr.default;
        } else {
          throw new RangeError("No value supplied for attribute " + name);
        }
      }
      built[name] = given;
    }
    return built;
  }
  function initAttrs(attrs) {
    var result2 = /* @__PURE__ */ Object.create(null);
    if (attrs) {
      for (var name in attrs) {
        result2[name] = new Attribute(attrs[name]);
      }
    }
    return result2;
  }
  var NodeType = function NodeType2(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.markSet = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  };
  var prototypeAccessors$5 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
  prototypeAccessors$5.isInline.get = function() {
    return !this.isBlock;
  };
  prototypeAccessors$5.isTextblock.get = function() {
    return this.isBlock && this.inlineContent;
  };
  prototypeAccessors$5.isLeaf.get = function() {
    return this.contentMatch == ContentMatch.empty;
  };
  prototypeAccessors$5.isAtom.get = function() {
    return this.isLeaf || this.spec.atom;
  };
  prototypeAccessors$5.whitespace.get = function() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  };
  NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs() {
    for (var n in this.attrs) {
      if (this.attrs[n].isRequired) {
        return true;
      }
    }
    return false;
  };
  NodeType.prototype.compatibleContent = function compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  };
  NodeType.prototype.computeAttrs = function computeAttrs$1(attrs) {
    if (!attrs && this.defaultAttrs) {
      return this.defaultAttrs;
    } else {
      return computeAttrs(this.attrs, attrs);
    }
  };
  NodeType.prototype.create = function create(attrs, content3, marks3) {
    if (this.isText) {
      throw new Error("NodeType.create can't construct text nodes");
    }
    return new Node2(this, this.computeAttrs(attrs), Fragment.from(content3), Mark.setFrom(marks3));
  };
  NodeType.prototype.createChecked = function createChecked(attrs, content3, marks3) {
    content3 = Fragment.from(content3);
    if (!this.validContent(content3)) {
      throw new RangeError("Invalid content for node " + this.name);
    }
    return new Node2(this, this.computeAttrs(attrs), content3, Mark.setFrom(marks3));
  };
  NodeType.prototype.createAndFill = function createAndFill(attrs, content3, marks3) {
    attrs = this.computeAttrs(attrs);
    content3 = Fragment.from(content3);
    if (content3.size) {
      var before3 = this.contentMatch.fillBefore(content3);
      if (!before3) {
        return null;
      }
      content3 = before3.append(content3);
    }
    var after3 = this.contentMatch.matchFragment(content3).fillBefore(Fragment.empty, true);
    if (!after3) {
      return null;
    }
    return new Node2(this, attrs, content3.append(after3), Mark.setFrom(marks3));
  };
  NodeType.prototype.validContent = function validContent(content3) {
    var result2 = this.contentMatch.matchFragment(content3);
    if (!result2 || !result2.validEnd) {
      return false;
    }
    for (var i = 0; i < content3.childCount; i++) {
      if (!this.allowsMarks(content3.child(i).marks)) {
        return false;
      }
    }
    return true;
  };
  NodeType.prototype.allowsMarkType = function allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  };
  NodeType.prototype.allowsMarks = function allowsMarks(marks3) {
    if (this.markSet == null) {
      return true;
    }
    for (var i = 0; i < marks3.length; i++) {
      if (!this.allowsMarkType(marks3[i].type)) {
        return false;
      }
    }
    return true;
  };
  NodeType.prototype.allowedMarks = function allowedMarks(marks3) {
    if (this.markSet == null) {
      return marks3;
    }
    var copy7;
    for (var i = 0; i < marks3.length; i++) {
      if (!this.allowsMarkType(marks3[i].type)) {
        if (!copy7) {
          copy7 = marks3.slice(0, i);
        }
      } else if (copy7) {
        copy7.push(marks3[i]);
      }
    }
    return !copy7 ? marks3 : copy7.length ? copy7 : Mark.empty;
  };
  NodeType.compile = function compile(nodes, schema) {
    var result2 = /* @__PURE__ */ Object.create(null);
    nodes.forEach(function(name, spec) {
      return result2[name] = new NodeType(name, schema, spec);
    });
    var topType = schema.spec.topNode || "doc";
    if (!result2[topType]) {
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    }
    if (!result2.text) {
      throw new RangeError("Every schema needs a 'text' type");
    }
    for (var _ in result2.text.attrs) {
      throw new RangeError("The text node type should not have attributes");
    }
    return result2;
  };
  Object.defineProperties(NodeType.prototype, prototypeAccessors$5);
  var Attribute = function Attribute2(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  };
  var prototypeAccessors$1$3 = { isRequired: { configurable: true } };
  prototypeAccessors$1$3.isRequired.get = function() {
    return !this.hasDefault;
  };
  Object.defineProperties(Attribute.prototype, prototypeAccessors$1$3);
  var MarkType = function MarkType2(name, rank, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.rank = rank;
    this.excluded = null;
    var defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 && new Mark(this, defaults2);
  };
  MarkType.prototype.create = function create2(attrs) {
    if (!attrs && this.instance) {
      return this.instance;
    }
    return new Mark(this, computeAttrs(this.attrs, attrs));
  };
  MarkType.compile = function compile2(marks3, schema) {
    var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
    marks3.forEach(function(name, spec) {
      return result2[name] = new MarkType(name, rank++, schema, spec);
    });
    return result2;
  };
  MarkType.prototype.removeFromSet = function removeFromSet2(set2) {
    for (var i = 0; i < set2.length; i++) {
      if (set2[i].type == this) {
        set2 = set2.slice(0, i).concat(set2.slice(i + 1));
        i--;
      }
    }
    return set2;
  };
  MarkType.prototype.isInSet = function isInSet2(set2) {
    for (var i = 0; i < set2.length; i++) {
      if (set2[i].type == this) {
        return set2[i];
      }
    }
  };
  MarkType.prototype.excludes = function excludes(other) {
    return this.excluded.indexOf(other) > -1;
  };
  var Schema = function Schema2(spec) {
    this.spec = {};
    for (var prop in spec) {
      this.spec[prop] = spec[prop];
    }
    this.spec.nodes = index_es_default.from(spec.nodes);
    this.spec.marks = index_es_default.from(spec.marks);
    this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    var contentExprCache = /* @__PURE__ */ Object.create(null);
    for (var prop$1 in this.nodes) {
      if (prop$1 in this.marks) {
        throw new RangeError(prop$1 + " can not be both a node and a mark");
      }
      var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (var prop$2 in this.marks) {
      var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
      type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached = /* @__PURE__ */ Object.create(null);
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  };
  Schema.prototype.node = function node2(type, attrs, content3, marks3) {
    if (typeof type == "string") {
      type = this.nodeType(type);
    } else if (!(type instanceof NodeType)) {
      throw new RangeError("Invalid node type: " + type);
    } else if (type.schema != this) {
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    }
    return type.createChecked(attrs, content3, marks3);
  };
  Schema.prototype.text = function text(text$1, marks3) {
    var type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks3));
  };
  Schema.prototype.mark = function mark2(type, attrs) {
    if (typeof type == "string") {
      type = this.marks[type];
    }
    return type.create(attrs);
  };
  Schema.prototype.nodeFromJSON = function nodeFromJSON(json2) {
    return Node2.fromJSON(this, json2);
  };
  Schema.prototype.markFromJSON = function markFromJSON(json2) {
    return Mark.fromJSON(this, json2);
  };
  Schema.prototype.nodeType = function nodeType(name) {
    var found3 = this.nodes[name];
    if (!found3) {
      throw new RangeError("Unknown node type: " + name);
    }
    return found3;
  };
  function gatherMarks(schema, marks3) {
    var found3 = [];
    for (var i = 0; i < marks3.length; i++) {
      var name = marks3[i], mark4 = schema.marks[name], ok3 = mark4;
      if (mark4) {
        found3.push(mark4);
      } else {
        for (var prop in schema.marks) {
          var mark$1 = schema.marks[prop];
          if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
            found3.push(ok3 = mark$1);
          }
        }
      }
      if (!ok3) {
        throw new SyntaxError("Unknown mark type: '" + marks3[i] + "'");
      }
    }
    return found3;
  }
  var DOMParser2 = function DOMParser3(schema, rules) {
    var this$1 = this;
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach(function(rule) {
      if (rule.tag) {
        this$1.tags.push(rule);
      } else if (rule.style) {
        this$1.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some(function(r) {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node) {
        return false;
      }
      var node5 = schema.nodes[r.node];
      return node5.contentMatch.matchType(node5);
    });
  };
  DOMParser2.prototype.parse = function parse2(dom, options) {
    if (options === void 0)
      options = {};
    var context = new ParseContext(this, options, false);
    context.addAll(dom, null, options.from, options.to);
    return context.finish();
  };
  DOMParser2.prototype.parseSlice = function parseSlice(dom, options) {
    if (options === void 0)
      options = {};
    var context = new ParseContext(this, options, true);
    context.addAll(dom, null, options.from, options.to);
    return Slice.maxOpen(context.finish());
  };
  DOMParser2.prototype.matchTag = function matchTag(dom, context, after3) {
    for (var i = after3 ? this.tags.indexOf(after3) + 1 : 0; i < this.tags.length; i++) {
      var rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          var result2 = rule.getAttrs(dom);
          if (result2 === false) {
            continue;
          }
          rule.attrs = result2;
        }
        return rule;
      }
    }
  };
  DOMParser2.prototype.matchStyle = function matchStyle(prop, value, context, after3) {
    for (var i = after3 ? this.styles.indexOf(after3) + 1 : 0; i < this.styles.length; i++) {
      var rule = this.styles[i];
      if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
        continue;
      }
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(value);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  };
  DOMParser2.schemaRules = function schemaRules(schema) {
    var result2 = [];
    function insert(rule) {
      var priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result2.length; i++) {
        var next = result2[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority) {
          break;
        }
      }
      result2.splice(i, 0, rule);
    }
    var loop = function(name2) {
      var rules = schema.marks[name2].spec.parseDOM;
      if (rules) {
        rules.forEach(function(rule) {
          insert(rule = copy2(rule));
          rule.mark = name2;
        });
      }
    };
    for (var name in schema.marks)
      loop(name);
    var loop$1 = function(name2) {
      var rules$1 = schema.nodes[name$1].spec.parseDOM;
      if (rules$1) {
        rules$1.forEach(function(rule) {
          insert(rule = copy2(rule));
          rule.node = name$1;
        });
      }
    };
    for (var name$1 in schema.nodes)
      loop$1();
    return result2;
  };
  DOMParser2.fromSchema = function fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
  };
  var blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  var ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  var listTags = { ol: true, ul: true };
  var OPT_PRESERVE_WS = 1;
  var OPT_PRESERVE_WS_FULL = 2;
  var OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base2) {
    if (preserveWhitespace != null) {
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    }
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
  }
  var NodeContext = function NodeContext2(type, attrs, marks3, pendingMarks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.solid = solid;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    this.options = options;
    this.content = [];
    this.marks = marks3;
    this.activeMarks = Mark.none;
    this.pendingMarks = pendingMarks;
    this.stashMarks = [];
  };
  NodeContext.prototype.findWrapping = function findWrapping2(node5) {
    if (!this.match) {
      if (!this.type) {
        return [];
      }
      var fill = this.type.contentMatch.fillBefore(Fragment.from(node5));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        var start6 = this.type.contentMatch, wrap;
        if (wrap = start6.findWrapping(node5.type)) {
          this.match = start6;
          return wrap;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node5.type);
  };
  NodeContext.prototype.finish = function finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      var last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        if (last.text.length == m[0].length) {
          this.content.pop();
        } else {
          this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
        }
      }
    }
    var content3 = Fragment.from(this.content);
    if (!openEnd && this.match) {
      content3 = content3.append(this.match.fillBefore(Fragment.empty, true));
    }
    return this.type ? this.type.create(this.attrs, content3, this.marks) : content3;
  };
  NodeContext.prototype.popFromStashMark = function popFromStashMark(mark4) {
    for (var i = this.stashMarks.length - 1; i >= 0; i--) {
      if (mark4.eq(this.stashMarks[i])) {
        return this.stashMarks.splice(i, 1)[0];
      }
    }
  };
  NodeContext.prototype.applyPending = function applyPending(nextType) {
    for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
      var mark4 = pending[i];
      if ((this.type ? this.type.allowsMarkType(mark4.type) : markMayApply(mark4.type, nextType)) && !mark4.isInSet(this.activeMarks)) {
        this.activeMarks = mark4.addToSet(this.activeMarks);
        this.pendingMarks = mark4.removeFromSet(this.pendingMarks);
      }
    }
  };
  NodeContext.prototype.inlineContext = function inlineContext(node5) {
    if (this.type) {
      return this.type.inlineContent;
    }
    if (this.content.length) {
      return this.content[0].isInline;
    }
    return node5.parentNode && !blockTags.hasOwnProperty(node5.parentNode.nodeName.toLowerCase());
  };
  var ParseContext = function ParseContext2(parser, options, open2) {
    this.parser = parser;
    this.options = options;
    this.isOpen = open2;
    var topNode = options.topNode, topContext;
    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open2 ? OPT_OPEN_LEFT : 0);
    if (topNode) {
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    } else if (open2) {
      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
    } else {
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    }
    this.nodes = [topContext];
    this.open = 0;
    this.find = options.findPositions;
    this.needsBlock = false;
  };
  var prototypeAccessors$6 = { top: { configurable: true }, currentPos: { configurable: true } };
  prototypeAccessors$6.top.get = function() {
    return this.nodes[this.open];
  };
  ParseContext.prototype.addDOM = function addDOM(dom) {
    if (dom.nodeType == 3) {
      this.addTextNode(dom);
    } else if (dom.nodeType == 1) {
      var style2 = dom.getAttribute("style");
      var marks3 = style2 ? this.readStyles(parseStyles(style2)) : null, top2 = this.top;
      if (marks3 != null) {
        for (var i = 0; i < marks3.length; i++) {
          this.addPendingMark(marks3[i]);
        }
      }
      this.addElement(dom);
      if (marks3 != null) {
        for (var i$1 = 0; i$1 < marks3.length; i$1++) {
          this.removePendingMark(marks3[i$1], top2);
        }
      }
    }
  };
  ParseContext.prototype.addTextNode = function addTextNode(dom) {
    var value = dom.nodeValue;
    var top2 = this.top;
    if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top2.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          var nodeBefore = top2.content[top2.content.length - 1];
          var domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
            value = value.slice(1);
          }
        }
      } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value) {
        this.insertNode(this.parser.schema.text(value));
      }
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  };
  ParseContext.prototype.addElement = function addElement(dom, matchAfter) {
    var name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {
      normalizeList(dom);
    }
    var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent) {
        this.open = Math.max(0, this.open - 1);
      } else if (rule && rule.skip.nodeType) {
        dom = rule.skip;
      }
      var sync3, top2 = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        sync3 = true;
        if (!top2.type) {
          this.needsBlock = true;
        }
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      this.addAll(dom);
      if (sync3) {
        this.sync(top2);
      }
      this.needsBlock = oldNeedsBlock;
    } else {
      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
    }
  };
  ParseContext.prototype.leafFallback = function leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
  };
  ParseContext.prototype.ignoreFallback = function ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
      this.findPlace(this.parser.schema.text("-"));
    }
  };
  ParseContext.prototype.readStyles = function readStyles(styles) {
    var marks3 = Mark.none;
    style:
      for (var i = 0; i < styles.length; i += 2) {
        for (var after3 = null; ; ) {
          var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after3);
          if (!rule) {
            continue style;
          }
          if (rule.ignore) {
            return null;
          }
          marks3 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks3);
          if (rule.consuming === false) {
            after3 = rule;
          } else {
            break;
          }
        }
      }
    return marks3;
  };
  ParseContext.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
    var this$1 = this;
    var sync3, nodeType2, markType, mark4;
    if (rule.node) {
      nodeType2 = this.parser.schema.nodes[rule.node];
      if (!nodeType2.isLeaf) {
        sync3 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      markType = this.parser.schema.marks[rule.mark];
      mark4 = markType.create(rule.attrs);
      this.addPendingMark(mark4);
    }
    var startIn = this.top;
    if (nodeType2 && nodeType2.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach(function(node5) {
        return this$1.insertNode(node5);
      });
    } else {
      var contentDOM = rule.contentElement;
      if (typeof contentDOM == "string") {
        contentDOM = dom.querySelector(contentDOM);
      } else if (typeof contentDOM == "function") {
        contentDOM = contentDOM(dom);
      }
      if (!contentDOM) {
        contentDOM = dom;
      }
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, sync3);
    }
    if (sync3) {
      this.sync(startIn);
      this.open--;
    }
    if (mark4) {
      this.removePendingMark(mark4, startIn);
    }
  };
  ParseContext.prototype.addAll = function addAll(parent, sync3, startIndex2, endIndex2) {
    var index3 = startIndex2 || 0;
    for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end4 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end4; dom = dom.nextSibling, ++index3) {
      this.findAtPoint(parent, index3);
      this.addDOM(dom);
      if (sync3 && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
        this.sync(sync3);
      }
    }
    this.findAtPoint(parent, index3);
  };
  ParseContext.prototype.findPlace = function findPlace(node5) {
    var route, sync3;
    for (var depth = this.open; depth >= 0; depth--) {
      var cx = this.nodes[depth];
      var found3 = cx.findWrapping(node5);
      if (found3 && (!route || route.length > found3.length)) {
        route = found3;
        sync3 = cx;
        if (!found3.length) {
          break;
        }
      }
      if (cx.solid) {
        break;
      }
    }
    if (!route) {
      return false;
    }
    this.sync(sync3);
    for (var i = 0; i < route.length; i++) {
      this.enterInner(route[i], null, false);
    }
    return true;
  };
  ParseContext.prototype.insertNode = function insertNode(node5) {
    if (node5.isInline && this.needsBlock && !this.top.type) {
      var block = this.textblockFromContext();
      if (block) {
        this.enterInner(block);
      }
    }
    if (this.findPlace(node5)) {
      this.closeExtra();
      var top2 = this.top;
      top2.applyPending(node5.type);
      if (top2.match) {
        top2.match = top2.match.matchType(node5.type);
      }
      var marks3 = top2.activeMarks;
      for (var i = 0; i < node5.marks.length; i++) {
        if (!top2.type || top2.type.allowsMarkType(node5.marks[i].type)) {
          marks3 = node5.marks[i].addToSet(marks3);
        }
      }
      top2.content.push(node5.mark(marks3));
      return true;
    }
    return false;
  };
  ParseContext.prototype.enter = function enter(type, attrs, preserveWS) {
    var ok3 = this.findPlace(type.create(attrs));
    if (ok3) {
      this.enterInner(type, attrs, true, preserveWS);
    }
    return ok3;
  };
  ParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(type);
    top2.match = top2.match && top2.match.matchType(type, attrs);
    var options = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0) {
      options |= OPT_OPEN_LEFT;
    }
    this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
    this.open++;
  };
  ParseContext.prototype.closeExtra = function closeExtra(openEnd) {
    var i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--) {
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      }
      this.nodes.length = this.open + 1;
    }
  };
  ParseContext.prototype.finish = function finish2() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  };
  ParseContext.prototype.sync = function sync(to) {
    for (var i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return;
      }
    }
  };
  prototypeAccessors$6.currentPos.get = function() {
    this.closeExtra();
    var pos = 0;
    for (var i = this.open; i >= 0; i--) {
      var content3 = this.nodes[i].content;
      for (var j = content3.length - 1; j >= 0; j--) {
        pos += content3[j].nodeSize;
      }
      if (i) {
        pos++;
      }
    }
    return pos;
  };
  ParseContext.prototype.findAtPoint = function findAtPoint(parent, offset4) {
    if (this.find) {
      for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset4) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  };
  ParseContext.prototype.findInside = function findInside(parent) {
    if (this.find) {
      for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  };
  ParseContext.prototype.findAround = function findAround(parent, content3, before3) {
    if (parent != content3 && this.find) {
      for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          var pos = content3.compareDocumentPosition(this.find[i].node);
          if (pos & (before3 ? 2 : 4)) {
            this.find[i].pos = this.currentPos;
          }
        }
      }
    }
  };
  ParseContext.prototype.findInText = function findInText(textNode) {
    if (this.find) {
      for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode) {
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
        }
      }
    }
  };
  ParseContext.prototype.matchesContext = function matchesContext(context) {
    var this$1 = this;
    if (context.indexOf("|") > -1) {
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    }
    var parts = context.split("/");
    var option = this.options.context;
    var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    var match = function(i, depth) {
      for (; i >= 0; i--) {
        var part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0) {
            continue;
          }
          for (; depth >= minDepth; depth--) {
            if (match(i - 1, depth)) {
              return true;
            }
          }
          return false;
        } else {
          var next = depth > 0 || depth == 0 && useRoot ? this$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && next.groups.indexOf(part) == -1) {
            return false;
          }
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  };
  ParseContext.prototype.textblockFromContext = function textblockFromContext() {
    var $context = this.options.context;
    if ($context) {
      for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
          return deflt;
        }
      }
    }
    for (var name in this.parser.schema.nodes) {
      var type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs) {
        return type;
      }
    }
  };
  ParseContext.prototype.addPendingMark = function addPendingMark(mark4) {
    var found3 = findSameMarkInSet(mark4, this.top.pendingMarks);
    if (found3) {
      this.top.stashMarks.push(found3);
    }
    this.top.pendingMarks = mark4.addToSet(this.top.pendingMarks);
  };
  ParseContext.prototype.removePendingMark = function removePendingMark(mark4, upto) {
    for (var depth = this.open; depth >= 0; depth--) {
      var level = this.nodes[depth];
      var found3 = level.pendingMarks.lastIndexOf(mark4);
      if (found3 > -1) {
        level.pendingMarks = mark4.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark4.removeFromSet(level.activeMarks);
        var stashMark = level.popFromStashMark(mark4);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
          level.activeMarks = stashMark.addToSet(level.activeMarks);
        }
      }
      if (level == upto) {
        break;
      }
    }
  };
  Object.defineProperties(ParseContext.prototype, prototypeAccessors$6);
  function normalizeList(dom) {
    for (var child5 = dom.firstChild, prevItem = null; child5; child5 = child5.nextSibling) {
      var name = child5.nodeType == 1 ? child5.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child5);
        child5 = prevItem;
      } else if (name == "li") {
        prevItem = child5;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
  }
  function parseStyles(style2) {
    var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result2 = [];
    while (m = re.exec(style2)) {
      result2.push(m[1], m[2].trim());
    }
    return result2;
  }
  function copy2(obj) {
    var copy7 = {};
    for (var prop in obj) {
      copy7[prop] = obj[prop];
    }
    return copy7;
  }
  function markMayApply(markType, nodeType2) {
    var nodes = nodeType2.schema.nodes;
    var loop = function(name2) {
      var parent = nodes[name2];
      if (!parent.allowsMarkType(markType)) {
        return;
      }
      var seen = [], scan = function(match) {
        seen.push(match);
        for (var i = 0; i < match.edgeCount; i++) {
          var ref = match.edge(i);
          var type = ref.type;
          var next = ref.next;
          if (type == nodeType2) {
            return true;
          }
          if (seen.indexOf(next) < 0 && scan(next)) {
            return true;
          }
        }
      };
      if (scan(parent.contentMatch)) {
        return { v: true };
      }
    };
    for (var name in nodes) {
      var returned = loop(name);
      if (returned)
        return returned.v;
    }
  }
  function findSameMarkInSet(mark4, set2) {
    for (var i = 0; i < set2.length; i++) {
      if (mark4.eq(set2[i])) {
        return set2[i];
      }
    }
  }
  var DOMSerializer = function DOMSerializer2(nodes, marks3) {
    this.nodes = nodes || {};
    this.marks = marks3 || {};
  };
  DOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target) {
    var this$1 = this;
    if (options === void 0)
      options = {};
    if (!target) {
      target = doc(options).createDocumentFragment();
    }
    var top2 = target, active = null;
    fragment.forEach(function(node5) {
      if (active || node5.marks.length) {
        if (!active) {
          active = [];
        }
        var keep = 0, rendered = 0;
        while (keep < active.length && rendered < node5.marks.length) {
          var next = node5.marks[rendered];
          if (!this$1.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
            break;
          }
          keep += 2;
          rendered++;
        }
        while (keep < active.length) {
          top2 = active.pop();
          active.pop();
        }
        while (rendered < node5.marks.length) {
          var add3 = node5.marks[rendered++];
          var markDOM = this$1.serializeMark(add3, node5.isInline, options);
          if (markDOM) {
            active.push(add3, top2);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this$1.serializeNodeInner(node5, options));
    });
    return target;
  };
  DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner(node5, options) {
    if (options === void 0)
      options = {};
    var ref = DOMSerializer.renderSpec(doc(options), this.nodes[node5.type.name](node5));
    var dom = ref.dom;
    var contentDOM = ref.contentDOM;
    if (contentDOM) {
      if (node5.isLeaf) {
        throw new RangeError("Content hole not allowed in a leaf node spec");
      }
      if (options.onContent) {
        options.onContent(node5, contentDOM, options);
      } else {
        this.serializeFragment(node5.content, options, contentDOM);
      }
    }
    return dom;
  };
  DOMSerializer.prototype.serializeNode = function serializeNode(node5, options) {
    if (options === void 0)
      options = {};
    var dom = this.serializeNodeInner(node5, options);
    for (var i = node5.marks.length - 1; i >= 0; i--) {
      var wrap = this.serializeMark(node5.marks[i], node5.isInline, options);
      if (wrap) {
        (wrap.contentDOM || wrap.dom).appendChild(dom);
        dom = wrap.dom;
      }
    }
    return dom;
  };
  DOMSerializer.prototype.serializeMark = function serializeMark(mark4, inline2, options) {
    if (options === void 0)
      options = {};
    var toDOM = this.marks[mark4.type.name];
    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark4, inline2));
  };
  DOMSerializer.renderSpec = function renderSpec(doc2, structure, xmlNS) {
    if (xmlNS === void 0)
      xmlNS = null;
    if (typeof structure == "string") {
      return { dom: doc2.createTextNode(structure) };
    }
    if (structure.nodeType != null) {
      return { dom: structure };
    }
    if (structure.dom && structure.dom.nodeType != null) {
      return structure;
    }
    var tagName = structure[0], space = tagName.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName.slice(0, space);
      tagName = tagName.slice(space + 1);
    }
    var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
    var attrs = structure[1], start6 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start6 = 2;
      for (var name in attrs) {
        if (attrs[name] != null) {
          var space$1 = name.indexOf(" ");
          if (space$1 > 0) {
            dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
          } else {
            dom.setAttribute(name, attrs[name]);
          }
        }
      }
    }
    for (var i = start6; i < structure.length; i++) {
      var child5 = structure[i];
      if (child5 === 0) {
        if (i < structure.length - 1 || i > start6) {
          throw new RangeError("Content hole must be the only child of its parent node");
        }
        return { dom, contentDOM: dom };
      } else {
        var ref = DOMSerializer.renderSpec(doc2, child5, xmlNS);
        var inner = ref.dom;
        var innerContent = ref.contentDOM;
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM) {
            throw new RangeError("Multiple content holes");
          }
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  };
  DOMSerializer.fromSchema = function fromSchema2(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  };
  DOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {
    var result2 = gatherToDOM(schema.nodes);
    if (!result2.text) {
      result2.text = function(node5) {
        return node5.text;
      };
    }
    return result2;
  };
  DOMSerializer.marksFromSchema = function marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  };
  function gatherToDOM(obj) {
    var result2 = {};
    for (var name in obj) {
      var toDOM = obj[name].spec.toDOM;
      if (toDOM) {
        result2[name] = toDOM;
      }
    }
    return result2;
  }
  function doc(options) {
    return options.document || window.document;
  }

  // node_modules/prosemirror-transform/dist/index.es.js
  var lower16 = 65535;
  var factor16 = Math.pow(2, 16);
  function makeRecover(index3, offset4) {
    return index3 + offset4 * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  var MapResult = function MapResult2(pos, deleted, recover3) {
    if (deleted === void 0)
      deleted = false;
    if (recover3 === void 0)
      recover3 = null;
    this.pos = pos;
    this.deleted = deleted;
    this.recover = recover3;
  };
  var StepMap = function StepMap2(ranges, inverted) {
    if (inverted === void 0)
      inverted = false;
    if (!ranges.length && StepMap2.empty) {
      return StepMap2.empty;
    }
    this.ranges = ranges;
    this.inverted = inverted;
  };
  StepMap.prototype.recover = function recover(value) {
    var diff = 0, index3 = recoverIndex(value);
    if (!this.inverted) {
      for (var i = 0; i < index3; i++) {
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      }
    }
    return this.ranges[index3 * 3] + diff + recoverOffset(value);
  };
  StepMap.prototype.mapResult = function mapResult(pos, assoc) {
    if (assoc === void 0)
      assoc = 1;
    return this._map(pos, assoc, false);
  };
  StepMap.prototype.map = function map(pos, assoc) {
    if (assoc === void 0)
      assoc = 1;
    return this._map(pos, assoc, true);
  };
  StepMap.prototype._map = function _map(pos, assoc, simple) {
    var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var i = 0; i < this.ranges.length; i += 3) {
      var start6 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start6 > pos) {
        break;
      }
      var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end4 = start6 + oldSize;
      if (pos <= end4) {
        var side = !oldSize ? assoc : pos == start6 ? -1 : pos == end4 ? 1 : assoc;
        var result2 = start6 + diff + (side < 0 ? 0 : newSize);
        if (simple) {
          return result2;
        }
        var recover3 = pos == (assoc < 0 ? start6 : end4) ? null : makeRecover(i / 3, pos - start6);
        return new MapResult(result2, assoc < 0 ? pos != start6 : pos != end4, recover3);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff);
  };
  StepMap.prototype.touches = function touches(pos, recover3) {
    var diff = 0, index3 = recoverIndex(recover3);
    var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var i = 0; i < this.ranges.length; i += 3) {
      var start6 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start6 > pos) {
        break;
      }
      var oldSize = this.ranges[i + oldIndex], end4 = start6 + oldSize;
      if (pos <= end4 && i == index3 * 3) {
        return true;
      }
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  };
  StepMap.prototype.forEach = function forEach3(f) {
    var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
      var start6 = this.ranges[i], oldStart = start6 - (this.inverted ? diff : 0), newStart = start6 + (this.inverted ? 0 : diff);
      var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  };
  StepMap.prototype.invert = function invert() {
    return new StepMap(this.ranges, !this.inverted);
  };
  StepMap.prototype.toString = function toString6() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  };
  StepMap.offset = function offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  };
  StepMap.empty = new StepMap([]);
  var Mapping = function Mapping2(maps, mirror, from5, to) {
    this.maps = maps || [];
    this.from = from5 || 0;
    this.to = to == null ? this.maps.length : to;
    this.mirror = mirror;
  };
  Mapping.prototype.slice = function slice2(from5, to) {
    if (from5 === void 0)
      from5 = 0;
    if (to === void 0)
      to = this.maps.length;
    return new Mapping(this.maps, this.mirror, from5, to);
  };
  Mapping.prototype.copy = function copy3() {
    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  };
  Mapping.prototype.appendMap = function appendMap(map22, mirrors) {
    this.to = this.maps.push(map22);
    if (mirrors != null) {
      this.setMirror(this.maps.length - 1, mirrors);
    }
  };
  Mapping.prototype.appendMapping = function appendMapping(mapping) {
    for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      var mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
    }
  };
  Mapping.prototype.getMirror = function getMirror(n) {
    if (this.mirror) {
      for (var i = 0; i < this.mirror.length; i++) {
        if (this.mirror[i] == n) {
          return this.mirror[i + (i % 2 ? -1 : 1)];
        }
      }
    }
  };
  Mapping.prototype.setMirror = function setMirror(n, m) {
    if (!this.mirror) {
      this.mirror = [];
    }
    this.mirror.push(n, m);
  };
  Mapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
    for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      var mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
    }
  };
  Mapping.prototype.invert = function invert2() {
    var inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  };
  Mapping.prototype.map = function map2(pos, assoc) {
    if (assoc === void 0)
      assoc = 1;
    if (this.mirror) {
      return this._map(pos, assoc, true);
    }
    for (var i = this.from; i < this.to; i++) {
      pos = this.maps[i].map(pos, assoc);
    }
    return pos;
  };
  Mapping.prototype.mapResult = function mapResult2(pos, assoc) {
    if (assoc === void 0)
      assoc = 1;
    return this._map(pos, assoc, false);
  };
  Mapping.prototype._map = function _map2(pos, assoc, simple) {
    var deleted = false;
    for (var i = this.from; i < this.to; i++) {
      var map22 = this.maps[i], result2 = map22.mapResult(pos, assoc);
      if (result2.recover != null) {
        var corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result2.recover);
          continue;
        }
      }
      if (result2.deleted) {
        deleted = true;
      }
      pos = result2.pos;
    }
    return simple ? pos : new MapResult(pos, deleted);
  };
  function TransformError(message) {
    var err3 = Error.call(this, message);
    err3.__proto__ = TransformError.prototype;
    return err3;
  }
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";
  var Transform = function Transform2(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  };
  var prototypeAccessors2 = { before: { configurable: true }, docChanged: { configurable: true } };
  prototypeAccessors2.before.get = function() {
    return this.docs.length ? this.docs[0] : this.doc;
  };
  Transform.prototype.step = function step(object) {
    var result2 = this.maybeStep(object);
    if (result2.failed) {
      throw new TransformError(result2.failed);
    }
    return this;
  };
  Transform.prototype.maybeStep = function maybeStep(step3) {
    var result2 = step3.apply(this.doc);
    if (!result2.failed) {
      this.addStep(step3, result2.doc);
    }
    return result2;
  };
  prototypeAccessors2.docChanged.get = function() {
    return this.steps.length > 0;
  };
  Transform.prototype.addStep = function addStep(step3, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step3);
    this.mapping.appendMap(step3.getMap());
    this.doc = doc2;
  };
  Object.defineProperties(Transform.prototype, prototypeAccessors2);
  function mustOverride() {
    throw new Error("Override me");
  }
  var stepsByID = /* @__PURE__ */ Object.create(null);
  var Step = function Step2() {
  };
  Step.prototype.apply = function apply(_doc) {
    return mustOverride();
  };
  Step.prototype.getMap = function getMap() {
    return StepMap.empty;
  };
  Step.prototype.invert = function invert3(_doc) {
    return mustOverride();
  };
  Step.prototype.map = function map3(_mapping) {
    return mustOverride();
  };
  Step.prototype.merge = function merge(_other) {
    return null;
  };
  Step.prototype.toJSON = function toJSON5() {
    return mustOverride();
  };
  Step.fromJSON = function fromJSON5(schema, json2) {
    if (!json2 || !json2.stepType) {
      throw new RangeError("Invalid input for Step.fromJSON");
    }
    var type = stepsByID[json2.stepType];
    if (!type) {
      throw new RangeError("No step type " + json2.stepType + " defined");
    }
    return type.fromJSON(schema, json2);
  };
  Step.jsonID = function jsonID(id, stepClass) {
    if (id in stepsByID) {
      throw new RangeError("Duplicate use of step JSON ID " + id);
    }
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  };
  var StepResult = function StepResult2(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  };
  StepResult.ok = function ok(doc2) {
    return new StepResult(doc2, null);
  };
  StepResult.fail = function fail(message) {
    return new StepResult(null, message);
  };
  StepResult.fromReplace = function fromReplace(doc2, from5, to, slice6) {
    try {
      return StepResult.ok(doc2.replace(from5, to, slice6));
    } catch (e) {
      if (e instanceof ReplaceError) {
        return StepResult.fail(e.message);
      }
      throw e;
    }
  };
  var ReplaceStep = /* @__PURE__ */ function(Step5) {
    function ReplaceStep3(from5, to, slice6, structure) {
      Step5.call(this);
      this.from = from5;
      this.to = to;
      this.slice = slice6;
      this.structure = !!structure;
    }
    if (Step5)
      ReplaceStep3.__proto__ = Step5;
    ReplaceStep3.prototype = Object.create(Step5 && Step5.prototype);
    ReplaceStep3.prototype.constructor = ReplaceStep3;
    ReplaceStep3.prototype.apply = function apply15(doc2) {
      if (this.structure && contentBetween(doc2, this.from, this.to)) {
        return StepResult.fail("Structure replace would overwrite content");
      }
      return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
    };
    ReplaceStep3.prototype.getMap = function getMap3() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    };
    ReplaceStep3.prototype.invert = function invert7(doc2) {
      return new ReplaceStep3(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
    };
    ReplaceStep3.prototype.map = function map22(mapping) {
      var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from5.deleted && to.deleted) {
        return null;
      }
      return new ReplaceStep3(from5.pos, Math.max(from5.pos, to.pos), this.slice);
    };
    ReplaceStep3.prototype.merge = function merge4(other) {
      if (!(other instanceof ReplaceStep3) || other.structure || this.structure) {
        return null;
      }
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        var slice6 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep3(this.from, this.to + (other.to - other.from), slice6, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new ReplaceStep3(other.from, this.to, slice$1, this.structure);
      } else {
        return null;
      }
    };
    ReplaceStep3.prototype.toJSON = function toJSON13() {
      var json2 = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size) {
        json2.slice = this.slice.toJSON();
      }
      if (this.structure) {
        json2.structure = true;
      }
      return json2;
    };
    ReplaceStep3.fromJSON = function fromJSON15(schema, json2) {
      if (typeof json2.from != "number" || typeof json2.to != "number") {
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      }
      return new ReplaceStep3(json2.from, json2.to, Slice.fromJSON(schema, json2.slice), !!json2.structure);
    };
    return ReplaceStep3;
  }(Step);
  Step.jsonID("replace", ReplaceStep);
  var ReplaceAroundStep = /* @__PURE__ */ function(Step5) {
    function ReplaceAroundStep3(from5, to, gapFrom, gapTo, slice6, insert, structure) {
      Step5.call(this);
      this.from = from5;
      this.to = to;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice6;
      this.insert = insert;
      this.structure = !!structure;
    }
    if (Step5)
      ReplaceAroundStep3.__proto__ = Step5;
    ReplaceAroundStep3.prototype = Object.create(Step5 && Step5.prototype);
    ReplaceAroundStep3.prototype.constructor = ReplaceAroundStep3;
    ReplaceAroundStep3.prototype.apply = function apply15(doc2) {
      if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to))) {
        return StepResult.fail("Structure gap-replace would overwrite content");
      }
      var gap = doc2.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd) {
        return StepResult.fail("Gap is not a flat range");
      }
      var inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted) {
        return StepResult.fail("Content does not fit in gap");
      }
      return StepResult.fromReplace(doc2, this.from, this.to, inserted);
    };
    ReplaceAroundStep3.prototype.getMap = function getMap3() {
      return new StepMap([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    };
    ReplaceAroundStep3.prototype.invert = function invert7(doc2) {
      var gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep3(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    };
    ReplaceAroundStep3.prototype.map = function map22(mapping) {
      var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
      if (from5.deleted && to.deleted || gapFrom < from5.pos || gapTo > to.pos) {
        return null;
      }
      return new ReplaceAroundStep3(from5.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    };
    ReplaceAroundStep3.prototype.toJSON = function toJSON13() {
      var json2 = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size) {
        json2.slice = this.slice.toJSON();
      }
      if (this.structure) {
        json2.structure = true;
      }
      return json2;
    };
    ReplaceAroundStep3.fromJSON = function fromJSON15(schema, json2) {
      if (typeof json2.from != "number" || typeof json2.to != "number" || typeof json2.gapFrom != "number" || typeof json2.gapTo != "number" || typeof json2.insert != "number") {
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      }
      return new ReplaceAroundStep3(json2.from, json2.to, json2.gapFrom, json2.gapTo, Slice.fromJSON(schema, json2.slice), json2.insert, !!json2.structure);
    };
    return ReplaceAroundStep3;
  }(Step);
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc2, from5, to) {
    var $from = doc2.resolve(from5), dist = to - from5, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      var next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf) {
          return true;
        }
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function canCut(node5, start6, end4) {
    return (start6 == 0 || node5.canReplace(start6, node5.childCount)) && (end4 == node5.childCount || node5.canReplace(0, end4));
  }
  function liftTarget(range) {
    var parent = range.parent;
    var content3 = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (var depth = range.depth; ; --depth) {
      var node5 = range.$from.node(depth);
      var index3 = range.$from.index(depth), endIndex2 = range.$to.indexAfter(depth);
      if (depth < range.depth && node5.canReplace(index3, endIndex2, content3)) {
        return depth;
      }
      if (depth == 0 || node5.type.spec.isolating || !canCut(node5, index3, endIndex2)) {
        break;
      }
    }
  }
  Transform.prototype.lift = function(range, target) {
    var $from = range.$from;
    var $to = range.$to;
    var depth = range.depth;
    var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    var start6 = gapStart, end4 = gapEnd;
    var before3 = Fragment.empty, openStart = 0;
    for (var d = depth, splitting = false; d > target; d--) {
      if (splitting || $from.index(d) > 0) {
        splitting = true;
        before3 = Fragment.from($from.node(d).copy(before3));
        openStart++;
      } else {
        start6--;
      }
    }
    var after3 = Fragment.empty, openEnd = 0;
    for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
      if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
        splitting$1 = true;
        after3 = Fragment.from($to.node(d$1).copy(after3));
        openEnd++;
      } else {
        end4++;
      }
    }
    return this.step(new ReplaceAroundStep(start6, end4, gapStart, gapEnd, new Slice(before3.append(after3), openStart, openEnd), before3.size - openStart, true));
  };
  function findWrapping3(range, nodeType2, attrs, innerRange) {
    if (innerRange === void 0)
      innerRange = range;
    var around = findWrappingOutside(range, nodeType2);
    var inner = around && findWrappingInside(innerRange, nodeType2);
    if (!inner) {
      return null;
    }
    return around.map(withAttrs).concat({ type: nodeType2, attrs }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    var parent = range.parent;
    var startIndex2 = range.startIndex;
    var endIndex2 = range.endIndex;
    var around = parent.contentMatchAt(startIndex2).findWrapping(type);
    if (!around) {
      return null;
    }
    var outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex2, endIndex2, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    var parent = range.parent;
    var startIndex2 = range.startIndex;
    var endIndex2 = range.endIndex;
    var inner = parent.child(startIndex2);
    var inside = type.contentMatch.findWrapping(inner.type);
    if (!inside) {
      return null;
    }
    var lastType = inside.length ? inside[inside.length - 1] : type;
    var innerMatch = lastType.contentMatch;
    for (var i = startIndex2; innerMatch && i < endIndex2; i++) {
      innerMatch = innerMatch.matchType(parent.child(i).type);
    }
    if (!innerMatch || !innerMatch.validEnd) {
      return null;
    }
    return inside;
  }
  Transform.prototype.wrap = function(range, wrappers) {
    var content3 = Fragment.empty;
    for (var i = wrappers.length - 1; i >= 0; i--) {
      if (content3.size) {
        var match = wrappers[i].type.contentMatch.matchFragment(content3);
        if (!match || !match.validEnd) {
          throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
      }
      content3 = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content3));
    }
    var start6 = range.start, end4 = range.end;
    return this.step(new ReplaceAroundStep(start6, end4, start6, end4, new Slice(content3, 0, 0), wrappers.length, true));
  };
  Transform.prototype.setBlockType = function(from5, to, type, attrs) {
    var this$1 = this;
    if (to === void 0)
      to = from5;
    if (!type.isTextblock) {
      throw new RangeError("Type given to setBlockType should be a textblock");
    }
    var mapFrom = this.steps.length;
    this.doc.nodesBetween(from5, to, function(node5, pos) {
      if (node5.isTextblock && !node5.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {
        this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);
        var mapping = this$1.mapping.slice(mapFrom);
        var startM = mapping.map(pos, 1), endM = mapping.map(pos + node5.nodeSize, 1);
        this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node5.marks)), 0, 0), 1, true));
        return false;
      }
    });
    return this;
  };
  function canChangeType(doc2, pos, type) {
    var $pos = doc2.resolve(pos), index3 = $pos.index();
    return $pos.parent.canReplaceWith(index3, index3 + 1, type);
  }
  Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks3) {
    var node5 = this.doc.nodeAt(pos);
    if (!node5) {
      throw new RangeError("No node at given position");
    }
    if (!type) {
      type = node5.type;
    }
    var newNode = type.create(attrs, null, marks3 || node5.marks);
    if (node5.isLeaf) {
      return this.replaceWith(pos, pos + node5.nodeSize, newNode);
    }
    if (!type.validContent(node5.content)) {
      throw new RangeError("Invalid content for node type " + type.name);
    }
    return this.step(new ReplaceAroundStep(pos, pos + node5.nodeSize, pos + 1, pos + node5.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
  };
  function canSplit(doc2, pos, depth, typesAfter) {
    if (depth === void 0)
      depth = 1;
    var $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
    var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
      return false;
    }
    for (var d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
      var node5 = $pos.node(d), index$1 = $pos.index(d);
      if (node5.type.spec.isolating) {
        return false;
      }
      var rest = node5.content.cutByIndex(index$1, node5.childCount);
      var after3 = typesAfter && typesAfter[i] || node5;
      if (after3 != node5) {
        rest = rest.replaceChild(0, after3.type.create(after3.attrs));
      }
      if (!node5.canReplace(index$1 + 1, node5.childCount) || !after3.type.validContent(rest)) {
        return false;
      }
    }
    var index3 = $pos.indexAfter(base2);
    var baseType = typesAfter && typesAfter[0];
    return $pos.node(base2).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base2 + 1).type);
  }
  Transform.prototype.split = function(pos, depth, typesAfter) {
    if (depth === void 0)
      depth = 1;
    var $pos = this.doc.resolve(pos), before3 = Fragment.empty, after3 = Fragment.empty;
    for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
      before3 = Fragment.from($pos.node(d).copy(before3));
      var typeAfter = typesAfter && typesAfter[i];
      after3 = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after3) : $pos.node(d).copy(after3));
    }
    return this.step(new ReplaceStep(pos, pos, new Slice(before3.append(after3), depth, depth), true));
  };
  function canJoin(doc2, pos) {
    var $pos = doc2.resolve(pos), index3 = $pos.index();
    return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
  }
  function joinable2(a, b) {
    return a && b && !a.isLeaf && a.canAppend(b);
  }
  Transform.prototype.join = function(pos, depth) {
    if (depth === void 0)
      depth = 1;
    var step3 = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
    return this.step(step3);
  };
  function insertPoint(doc2, pos, nodeType2) {
    var $pos = doc2.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
      return pos;
    }
    if ($pos.parentOffset == 0) {
      for (var d = $pos.depth - 1; d >= 0; d--) {
        var index3 = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index3, index3, nodeType2)) {
          return $pos.before(d + 1);
        }
        if (index3 > 0) {
          return null;
        }
      }
    }
    if ($pos.parentOffset == $pos.parent.content.size) {
      for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
        var index$1 = $pos.indexAfter(d$1);
        if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
          return $pos.after(d$1 + 1);
        }
        if (index$1 < $pos.node(d$1).childCount) {
          return null;
        }
      }
    }
  }
  function dropPoint(doc2, pos, slice6) {
    var $pos = doc2.resolve(pos);
    if (!slice6.content.size) {
      return pos;
    }
    var content3 = slice6.content;
    for (var i = 0; i < slice6.openStart; i++) {
      content3 = content3.firstChild.content;
    }
    for (var pass = 1; pass <= (slice6.openStart == 0 && slice6.size ? 2 : 1); pass++) {
      for (var d = $pos.depth; d >= 0; d--) {
        var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
        var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
        var parent = $pos.node(d), fits = false;
        if (pass == 1) {
          fits = parent.canReplace(insertPos, insertPos, content3);
        } else {
          var wrapping = parent.contentMatchAt(insertPos).findWrapping(content3.firstChild.type);
          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
        }
        if (fits) {
          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
        }
      }
    }
    return null;
  }
  function mapFragment(fragment, f, parent) {
    var mapped = [];
    for (var i = 0; i < fragment.childCount; i++) {
      var child5 = fragment.child(i);
      if (child5.content.size) {
        child5 = child5.copy(mapFragment(child5.content, f, child5));
      }
      if (child5.isInline) {
        child5 = f(child5, parent, i);
      }
      mapped.push(child5);
    }
    return Fragment.fromArray(mapped);
  }
  var AddMarkStep = /* @__PURE__ */ function(Step5) {
    function AddMarkStep3(from5, to, mark4) {
      Step5.call(this);
      this.from = from5;
      this.to = to;
      this.mark = mark4;
    }
    if (Step5)
      AddMarkStep3.__proto__ = Step5;
    AddMarkStep3.prototype = Object.create(Step5 && Step5.prototype);
    AddMarkStep3.prototype.constructor = AddMarkStep3;
    AddMarkStep3.prototype.apply = function apply15(doc2) {
      var this$1 = this;
      var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
      var parent = $from.node($from.sharedDepth(this.to));
      var slice6 = new Slice(mapFragment(oldSlice.content, function(node5, parent2) {
        if (!node5.isAtom || !parent2.type.allowsMarkType(this$1.mark.type)) {
          return node5;
        }
        return node5.mark(this$1.mark.addToSet(node5.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc2, this.from, this.to, slice6);
    };
    AddMarkStep3.prototype.invert = function invert7() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    };
    AddMarkStep3.prototype.map = function map22(mapping) {
      var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from5.deleted && to.deleted || from5.pos >= to.pos) {
        return null;
      }
      return new AddMarkStep3(from5.pos, to.pos, this.mark);
    };
    AddMarkStep3.prototype.merge = function merge4(other) {
      if (other instanceof AddMarkStep3 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
        return new AddMarkStep3(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      }
    };
    AddMarkStep3.prototype.toJSON = function toJSON13() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    };
    AddMarkStep3.fromJSON = function fromJSON15(schema, json2) {
      if (typeof json2.from != "number" || typeof json2.to != "number") {
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      }
      return new AddMarkStep3(json2.from, json2.to, schema.markFromJSON(json2.mark));
    };
    return AddMarkStep3;
  }(Step);
  Step.jsonID("addMark", AddMarkStep);
  var RemoveMarkStep = /* @__PURE__ */ function(Step5) {
    function RemoveMarkStep3(from5, to, mark4) {
      Step5.call(this);
      this.from = from5;
      this.to = to;
      this.mark = mark4;
    }
    if (Step5)
      RemoveMarkStep3.__proto__ = Step5;
    RemoveMarkStep3.prototype = Object.create(Step5 && Step5.prototype);
    RemoveMarkStep3.prototype.constructor = RemoveMarkStep3;
    RemoveMarkStep3.prototype.apply = function apply15(doc2) {
      var this$1 = this;
      var oldSlice = doc2.slice(this.from, this.to);
      var slice6 = new Slice(mapFragment(oldSlice.content, function(node5) {
        return node5.mark(this$1.mark.removeFromSet(node5.marks));
      }), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc2, this.from, this.to, slice6);
    };
    RemoveMarkStep3.prototype.invert = function invert7() {
      return new AddMarkStep(this.from, this.to, this.mark);
    };
    RemoveMarkStep3.prototype.map = function map22(mapping) {
      var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from5.deleted && to.deleted || from5.pos >= to.pos) {
        return null;
      }
      return new RemoveMarkStep3(from5.pos, to.pos, this.mark);
    };
    RemoveMarkStep3.prototype.merge = function merge4(other) {
      if (other instanceof RemoveMarkStep3 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
        return new RemoveMarkStep3(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      }
    };
    RemoveMarkStep3.prototype.toJSON = function toJSON13() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    };
    RemoveMarkStep3.fromJSON = function fromJSON15(schema, json2) {
      if (typeof json2.from != "number" || typeof json2.to != "number") {
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      }
      return new RemoveMarkStep3(json2.from, json2.to, schema.markFromJSON(json2.mark));
    };
    return RemoveMarkStep3;
  }(Step);
  Step.jsonID("removeMark", RemoveMarkStep);
  Transform.prototype.addMark = function(from5, to, mark4) {
    var this$1 = this;
    var removed = [], added = [], removing = null, adding = null;
    this.doc.nodesBetween(from5, to, function(node5, pos, parent) {
      if (!node5.isInline) {
        return;
      }
      var marks3 = node5.marks;
      if (!mark4.isInSet(marks3) && parent.type.allowsMarkType(mark4.type)) {
        var start6 = Math.max(pos, from5), end4 = Math.min(pos + node5.nodeSize, to);
        var newSet = mark4.addToSet(marks3);
        for (var i = 0; i < marks3.length; i++) {
          if (!marks3[i].isInSet(newSet)) {
            if (removing && removing.to == start6 && removing.mark.eq(marks3[i])) {
              removing.to = end4;
            } else {
              removed.push(removing = new RemoveMarkStep(start6, end4, marks3[i]));
            }
          }
        }
        if (adding && adding.to == start6) {
          adding.to = end4;
        } else {
          added.push(adding = new AddMarkStep(start6, end4, mark4));
        }
      }
    });
    removed.forEach(function(s) {
      return this$1.step(s);
    });
    added.forEach(function(s) {
      return this$1.step(s);
    });
    return this;
  };
  Transform.prototype.removeMark = function(from5, to, mark4) {
    var this$1 = this;
    if (mark4 === void 0)
      mark4 = null;
    var matched = [], step3 = 0;
    this.doc.nodesBetween(from5, to, function(node5, pos) {
      if (!node5.isInline) {
        return;
      }
      step3++;
      var toRemove = null;
      if (mark4 instanceof MarkType) {
        var set2 = node5.marks, found3;
        while (found3 = mark4.isInSet(set2)) {
          (toRemove || (toRemove = [])).push(found3);
          set2 = found3.removeFromSet(set2);
        }
      } else if (mark4) {
        if (mark4.isInSet(node5.marks)) {
          toRemove = [mark4];
        }
      } else {
        toRemove = node5.marks;
      }
      if (toRemove && toRemove.length) {
        var end4 = Math.min(pos + node5.nodeSize, to);
        for (var i = 0; i < toRemove.length; i++) {
          var style2 = toRemove[i], found$1 = void 0;
          for (var j = 0; j < matched.length; j++) {
            var m = matched[j];
            if (m.step == step3 - 1 && style2.eq(matched[j].style)) {
              found$1 = m;
            }
          }
          if (found$1) {
            found$1.to = end4;
            found$1.step = step3;
          } else {
            matched.push({ style: style2, from: Math.max(pos, from5), to: end4, step: step3 });
          }
        }
      }
    });
    matched.forEach(function(m) {
      return this$1.step(new RemoveMarkStep(m.from, m.to, m.style));
    });
    return this;
  };
  Transform.prototype.clearIncompatible = function(pos, parentType, match) {
    if (match === void 0)
      match = parentType.contentMatch;
    var node5 = this.doc.nodeAt(pos);
    var delSteps = [], cur = pos + 1;
    for (var i = 0; i < node5.childCount; i++) {
      var child5 = node5.child(i), end4 = cur + child5.nodeSize;
      var allowed = match.matchType(child5.type, child5.attrs);
      if (!allowed) {
        delSteps.push(new ReplaceStep(cur, end4, Slice.empty));
      } else {
        match = allowed;
        for (var j = 0; j < child5.marks.length; j++) {
          if (!parentType.allowsMarkType(child5.marks[j].type)) {
            this.step(new RemoveMarkStep(cur, end4, child5.marks[j]));
          }
        }
      }
      cur = end4;
    }
    if (!match.validEnd) {
      var fill = match.fillBefore(Fragment.empty, true);
      this.replace(cur, cur, new Slice(fill, 0, 0));
    }
    for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
      this.step(delSteps[i$1]);
    }
    return this;
  };
  function replaceStep(doc2, from5, to, slice6) {
    if (to === void 0)
      to = from5;
    if (slice6 === void 0)
      slice6 = Slice.empty;
    if (from5 == to && !slice6.size) {
      return null;
    }
    var $from = doc2.resolve(from5), $to = doc2.resolve(to);
    if (fitsTrivially($from, $to, slice6)) {
      return new ReplaceStep(from5, to, slice6);
    }
    return new Fitter($from, $to, slice6).fit();
  }
  Transform.prototype.replace = function(from5, to, slice6) {
    if (to === void 0)
      to = from5;
    if (slice6 === void 0)
      slice6 = Slice.empty;
    var step3 = replaceStep(this.doc, from5, to, slice6);
    if (step3) {
      this.step(step3);
    }
    return this;
  };
  Transform.prototype.replaceWith = function(from5, to, content3) {
    return this.replace(from5, to, new Slice(Fragment.from(content3), 0, 0));
  };
  Transform.prototype.delete = function(from5, to) {
    return this.replace(from5, to, Slice.empty);
  };
  Transform.prototype.insert = function(pos, content3) {
    return this.replaceWith(pos, pos, content3);
  };
  function fitsTrivially($from, $to, slice6) {
    return !slice6.openStart && !slice6.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice6.content);
  }
  var Fitter = function Fitter2($from, $to, slice6) {
    this.$to = $to;
    this.$from = $from;
    this.unplaced = slice6;
    this.frontier = [];
    for (var i = 0; i <= $from.depth; i++) {
      var node5 = $from.node(i);
      this.frontier.push({
        type: node5.type,
        match: node5.contentMatchAt($from.indexAfter(i))
      });
    }
    this.placed = Fragment.empty;
    for (var i$1 = $from.depth; i$1 > 0; i$1--) {
      this.placed = Fragment.from($from.node(i$1).copy(this.placed));
    }
  };
  var prototypeAccessors$12 = { depth: { configurable: true } };
  prototypeAccessors$12.depth.get = function() {
    return this.frontier.length - 1;
  };
  Fitter.prototype.fit = function fit() {
    while (this.unplaced.size) {
      var fit3 = this.findFittable();
      if (fit3) {
        this.placeNodes(fit3);
      } else {
        this.openMore() || this.dropNode();
      }
    }
    var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to) {
      return null;
    }
    var content3 = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content3.childCount == 1) {
      content3 = content3.firstChild.content;
      openStart--;
      openEnd--;
    }
    var slice6 = new Slice(content3, openStart, openEnd);
    if (moveInline > -1) {
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice6, placedSize);
    }
    if (slice6.size || $from.pos != this.$to.pos) {
      return new ReplaceStep($from.pos, $to.pos, slice6);
    }
  };
  Fitter.prototype.findFittable = function findFittable() {
    for (var pass = 1; pass <= 2; pass++) {
      for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        var fragment = void 0, parent = void 0;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        var first2 = fragment.firstChild;
        for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          var ref = this.frontier[frontierDepth];
          var type = ref.type;
          var match = ref.match;
          var wrap = void 0, inject = void 0;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : type.compatibleContent(parent.type))) {
            return { sliceDepth, frontierDepth, parent, inject };
          } else if (pass == 2 && first2 && (wrap = match.findWrapping(first2.type))) {
            return { sliceDepth, frontierDepth, parent, wrap };
          }
          if (parent && match.matchType(parent.type)) {
            break;
          }
        }
      }
    }
  };
  Fitter.prototype.openMore = function openMore() {
    var ref = this.unplaced;
    var content3 = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
    var inner = contentAt(content3, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf) {
      return false;
    }
    this.unplaced = new Slice(content3, openStart + 1, Math.max(openEnd, inner.size + openStart >= content3.size - openEnd ? openStart + 1 : 0));
    return true;
  };
  Fitter.prototype.dropNode = function dropNode() {
    var ref = this.unplaced;
    var content3 = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
    var inner = contentAt(content3, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      var openAtEnd = content3.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content3, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content3, openStart, 1), openStart, openEnd);
    }
  };
  Fitter.prototype.placeNodes = function placeNodes(ref) {
    var sliceDepth = ref.sliceDepth;
    var frontierDepth = ref.frontierDepth;
    var parent = ref.parent;
    var inject = ref.inject;
    var wrap = ref.wrap;
    while (this.depth > frontierDepth) {
      this.closeFrontierNode();
    }
    if (wrap) {
      for (var i = 0; i < wrap.length; i++) {
        this.openFrontierNode(wrap[i]);
      }
    }
    var slice6 = this.unplaced, fragment = parent ? parent.content : slice6.content;
    var openStart = slice6.openStart - sliceDepth;
    var taken = 0, add3 = [];
    var ref$1 = this.frontier[frontierDepth];
    var match = ref$1.match;
    var type = ref$1.type;
    if (inject) {
      for (var i$1 = 0; i$1 < inject.childCount; i$1++) {
        add3.push(inject.child(i$1));
      }
      match = match.matchFragment(inject);
    }
    var openEndCount = fragment.size + sliceDepth - (slice6.content.size - slice6.openEnd);
    while (taken < fragment.childCount) {
      var next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2) {
        break;
      }
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add3.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    var toEnd = taken == fragment.childCount;
    if (!toEnd) {
      openEndCount = -1;
    }
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add3));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
      this.closeFrontierNode();
    }
    for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
      var node5 = cur.lastChild;
      this.frontier.push({ type: node5.type, match: node5.contentMatchAt(node5.childCount) });
      cur = node5.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice6.content, sliceDepth, taken), slice6.openStart, slice6.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice6.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice6.openEnd : sliceDepth - 1);
  };
  Fitter.prototype.mustMoveInline = function mustMoveInline() {
    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
      return -1;
    }
    var top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
      return -1;
    }
    var ref = this.$to;
    var depth = ref.depth;
    var after3 = this.$to.after(depth);
    while (depth > 1 && after3 == this.$to.end(--depth)) {
      ++after3;
    }
    return after3;
  };
  Fitter.prototype.findCloseLevel = function findCloseLevel($to) {
    scan:
      for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        var ref = this.frontier[i];
        var match = ref.match;
        var type = ref.type;
        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        var fit3 = contentAfterFits($to, i, type, match, dropInner);
        if (!fit3) {
          continue;
        }
        for (var d = i - 1; d >= 0; d--) {
          var ref$1 = this.frontier[d];
          var match$1 = ref$1.match;
          var type$1 = ref$1.type;
          var matches2 = contentAfterFits($to, d, type$1, match$1, true);
          if (!matches2 || matches2.childCount) {
            continue scan;
          }
        }
        return { depth: i, fit: fit3, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  };
  Fitter.prototype.close = function close2($to) {
    var close6 = this.findCloseLevel($to);
    if (!close6) {
      return null;
    }
    while (this.depth > close6.depth) {
      this.closeFrontierNode();
    }
    if (close6.fit.childCount) {
      this.placed = addToFragment(this.placed, close6.depth, close6.fit);
    }
    $to = close6.move;
    for (var d = close6.depth + 1; d <= $to.depth; d++) {
      var node5 = $to.node(d), add3 = node5.type.contentMatch.fillBefore(node5.content, true, $to.index(d));
      this.openFrontierNode(node5.type, node5.attrs, add3);
    }
    return $to;
  };
  Fitter.prototype.openFrontierNode = function openFrontierNode(type, attrs, content3) {
    var top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content3)));
    this.frontier.push({ type, match: type.contentMatch });
  };
  Fitter.prototype.closeFrontierNode = function closeFrontierNode() {
    var open2 = this.frontier.pop();
    var add3 = open2.match.fillBefore(Fragment.empty, true);
    if (add3.childCount) {
      this.placed = addToFragment(this.placed, this.frontier.length, add3);
    }
  };
  Object.defineProperties(Fitter.prototype, prototypeAccessors$12);
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0) {
      return fragment.cutByIndex(count);
    }
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment, depth, content3) {
    if (depth == 0) {
      return fragment.append(content3);
    }
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content3)));
  }
  function contentAt(fragment, depth) {
    for (var i = 0; i < depth; i++) {
      fragment = fragment.firstChild.content;
    }
    return fragment;
  }
  function closeNodeStart(node5, openStart, openEnd) {
    if (openStart <= 0) {
      return node5;
    }
    var frag = node5.content;
    if (openStart > 1) {
      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    }
    if (openStart > 0) {
      frag = node5.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0) {
        frag = frag.append(node5.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
      }
    }
    return node5.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open2) {
    var node5 = $to.node(depth), index3 = open2 ? $to.indexAfter(depth) : $to.index(depth);
    if (index3 == node5.childCount && !type.compatibleContent(node5.type)) {
      return null;
    }
    var fit3 = match.fillBefore(node5.content, true, index3);
    return fit3 && !invalidMarks(type, node5.content, index3) ? fit3 : null;
  }
  function invalidMarks(type, fragment, start6) {
    for (var i = start6; i < fragment.childCount; i++) {
      if (!type.allowsMarks(fragment.child(i).marks)) {
        return true;
      }
    }
    return false;
  }
  function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
  }
  Transform.prototype.replaceRange = function(from5, to, slice6) {
    if (!slice6.size) {
      return this.deleteRange(from5, to);
    }
    var $from = this.doc.resolve(from5), $to = this.doc.resolve(to);
    if (fitsTrivially($from, $to, slice6)) {
      return this.step(new ReplaceStep(from5, to, slice6));
    }
    var targetDepths = coveredDepths($from, this.doc.resolve(to));
    if (targetDepths[targetDepths.length - 1] == 0) {
      targetDepths.pop();
    }
    var preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      var spec = $from.node(d).type.spec;
      if (spec.defining || spec.definingAsContext || spec.isolating) {
        break;
      }
      if (targetDepths.indexOf(d) > -1) {
        preferredTarget = d;
      } else if ($from.before(d) == pos) {
        targetDepths.splice(1, 0, -d);
      }
    }
    var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    var leftNodes = [], preferredDepth = slice6.openStart;
    for (var content3 = slice6.content, i = 0; ; i++) {
      var node5 = content3.firstChild;
      leftNodes.push(node5);
      if (i == slice6.openStart) {
        break;
      }
      content3 = node5.content;
    }
    if (preferredDepth > 0 && definesContent(leftNodes[preferredDepth - 1].type) && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
      preferredDepth -= 1;
    } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && definesContent(leftNodes[preferredDepth - 2].type) && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
      preferredDepth -= 2;
    }
    for (var j = slice6.openStart; j >= 0; j--) {
      var openDepth = (j + preferredDepth + 1) % (slice6.openStart + 1);
      var insert = leftNodes[openDepth];
      if (!insert) {
        continue;
      }
      for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
        var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        var parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index3, index3, insert.type, insert.marks)) {
          return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice6.content, 0, slice6.openStart, openDepth), openDepth, slice6.openEnd));
        }
      }
    }
    var startSteps = this.steps.length;
    for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
      this.replace(from5, to, slice6);
      if (this.steps.length > startSteps) {
        break;
      }
      var depth = targetDepths[i$2];
      if (depth < 0) {
        continue;
      }
      from5 = $from.before(depth);
      to = $to.after(depth);
    }
    return this;
  };
  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      var first2 = fragment.firstChild;
      fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
    }
    if (depth > newOpen) {
      var match = parent.contentMatchAt(0);
      var start6 = match.fillBefore(fragment).append(fragment);
      fragment = start6.append(match.matchFragment(start6).fillBefore(Fragment.empty, true));
    }
    return fragment;
  }
  Transform.prototype.replaceRangeWith = function(from5, to, node5) {
    if (!node5.isInline && from5 == to && this.doc.resolve(from5).parent.content.size) {
      var point = insertPoint(this.doc, from5, node5.type);
      if (point != null) {
        from5 = to = point;
      }
    }
    return this.replaceRange(from5, to, new Slice(Fragment.from(node5), 0, 0));
  };
  Transform.prototype.deleteRange = function(from5, to) {
    var $from = this.doc.resolve(from5), $to = this.doc.resolve(to);
    var covered = coveredDepths($from, $to);
    for (var i = 0; i < covered.length; i++) {
      var depth = covered[i], last = i == covered.length - 1;
      if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
        return this.delete($from.start(depth), $to.end(depth));
      }
      if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
        return this.delete($from.before(depth), $to.after(depth));
      }
    }
    for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from5 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {
        return this.delete($from.before(d), to);
      }
    }
    return this.delete(from5, to);
  };
  function coveredDepths($from, $to) {
    var result2 = [], minDepth = Math.min($from.depth, $to.depth);
    for (var d = minDepth; d >= 0; d--) {
      var start6 = $from.start(d);
      if (start6 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
        break;
      }
      if (start6 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start6 - 1) {
        result2.push(d);
      }
    }
    return result2;
  }

  // node_modules/prosemirror-state/dist/index.es.js
  var classesById = /* @__PURE__ */ Object.create(null);
  var Selection = function Selection2($anchor, $head, ranges) {
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    this.$anchor = $anchor;
    this.$head = $head;
  };
  var prototypeAccessors3 = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
  prototypeAccessors3.anchor.get = function() {
    return this.$anchor.pos;
  };
  prototypeAccessors3.head.get = function() {
    return this.$head.pos;
  };
  prototypeAccessors3.from.get = function() {
    return this.$from.pos;
  };
  prototypeAccessors3.to.get = function() {
    return this.$to.pos;
  };
  prototypeAccessors3.$from.get = function() {
    return this.ranges[0].$from;
  };
  prototypeAccessors3.$to.get = function() {
    return this.ranges[0].$to;
  };
  prototypeAccessors3.empty.get = function() {
    var ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      if (ranges[i].$from.pos != ranges[i].$to.pos) {
        return false;
      }
    }
    return true;
  };
  Selection.prototype.content = function content() {
    return this.$from.node(0).slice(this.from, this.to, true);
  };
  Selection.prototype.replace = function replace2(tr, content3) {
    if (content3 === void 0)
      content3 = Slice.empty;
    var lastNode = content3.content.lastChild, lastParent = null;
    for (var i = 0; i < content3.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    var mapFrom = tr.steps.length, ranges = this.ranges;
    for (var i$1 = 0; i$1 < ranges.length; i$1++) {
      var ref = ranges[i$1];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content3);
      if (i$1 == 0) {
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
  };
  Selection.prototype.replaceWith = function replaceWith(tr, node5) {
    var mapFrom = tr.steps.length, ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      var ref = ranges[i];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
      var from5 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from5, to);
      } else {
        tr.replaceRangeWith(from5, to, node5);
        selectionToInsertionEnd(tr, mapFrom, node5.isInline ? -1 : 1);
      }
    }
  };
  Selection.findFrom = function findFrom($pos, dir, textOnly) {
    var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner) {
      return inner;
    }
    for (var depth = $pos.depth - 1; depth >= 0; depth--) {
      var found3 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found3) {
        return found3;
      }
    }
  };
  Selection.near = function near($pos, bias) {
    if (bias === void 0)
      bias = 1;
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  };
  Selection.atStart = function atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  };
  Selection.atEnd = function atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  };
  Selection.fromJSON = function fromJSON6(doc2, json2) {
    if (!json2 || !json2.type) {
      throw new RangeError("Invalid input for Selection.fromJSON");
    }
    var cls = classesById[json2.type];
    if (!cls) {
      throw new RangeError("No selection type " + json2.type + " defined");
    }
    return cls.fromJSON(doc2, json2);
  };
  Selection.jsonID = function jsonID2(id, selectionClass) {
    if (id in classesById) {
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    }
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  };
  Selection.prototype.getBookmark = function getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  };
  Object.defineProperties(Selection.prototype, prototypeAccessors3);
  Selection.prototype.visible = true;
  var SelectionRange = function SelectionRange2($from, $to) {
    this.$from = $from;
    this.$to = $to;
  };
  var TextSelection = /* @__PURE__ */ function(Selection5) {
    function TextSelection3($anchor, $head) {
      if ($head === void 0)
        $head = $anchor;
      Selection5.call(this, $anchor, $head);
    }
    if (Selection5)
      TextSelection3.__proto__ = Selection5;
    TextSelection3.prototype = Object.create(Selection5 && Selection5.prototype);
    TextSelection3.prototype.constructor = TextSelection3;
    var prototypeAccessors$16 = { $cursor: { configurable: true } };
    prototypeAccessors$16.$cursor.get = function() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    };
    TextSelection3.prototype.map = function map22(doc2, mapping) {
      var $head = doc2.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent) {
        return Selection5.near($head);
      }
      var $anchor = doc2.resolve(mapping.map(this.anchor));
      return new TextSelection3($anchor.parent.inlineContent ? $anchor : $head, $head);
    };
    TextSelection3.prototype.replace = function replace5(tr, content3) {
      if (content3 === void 0)
        content3 = Slice.empty;
      Selection5.prototype.replace.call(this, tr, content3);
      if (content3 == Slice.empty) {
        var marks3 = this.$from.marksAcross(this.$to);
        if (marks3) {
          tr.ensureMarks(marks3);
        }
      }
    };
    TextSelection3.prototype.eq = function eq16(other) {
      return other instanceof TextSelection3 && other.anchor == this.anchor && other.head == this.head;
    };
    TextSelection3.prototype.getBookmark = function getBookmark3() {
      return new TextBookmark(this.anchor, this.head);
    };
    TextSelection3.prototype.toJSON = function toJSON13() {
      return { type: "text", anchor: this.anchor, head: this.head };
    };
    TextSelection3.fromJSON = function fromJSON15(doc2, json2) {
      if (typeof json2.anchor != "number" || typeof json2.head != "number") {
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      }
      return new TextSelection3(doc2.resolve(json2.anchor), doc2.resolve(json2.head));
    };
    TextSelection3.create = function create9(doc2, anchor, head) {
      if (head === void 0)
        head = anchor;
      var $anchor = doc2.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
    };
    TextSelection3.between = function between($anchor, $head, bias) {
      var dPos = $anchor.pos - $head.pos;
      if (!bias || dPos) {
        bias = dPos >= 0 ? 1 : -1;
      }
      if (!$head.parent.inlineContent) {
        var found3 = Selection5.findFrom($head, bias, true) || Selection5.findFrom($head, -bias, true);
        if (found3) {
          $head = found3.$head;
        } else {
          return Selection5.near($head, bias);
        }
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection5.findFrom($anchor, -bias, true) || Selection5.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0) {
            $anchor = $head;
          }
        }
      }
      return new TextSelection3($anchor, $head);
    };
    Object.defineProperties(TextSelection3.prototype, prototypeAccessors$16);
    return TextSelection3;
  }(Selection);
  Selection.jsonID("text", TextSelection);
  var TextBookmark = function TextBookmark2(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };
  TextBookmark.prototype.map = function map4(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  };
  TextBookmark.prototype.resolve = function resolve3(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  };
  var NodeSelection = /* @__PURE__ */ function(Selection5) {
    function NodeSelection3($pos) {
      var node5 = $pos.nodeAfter;
      var $end = $pos.node(0).resolve($pos.pos + node5.nodeSize);
      Selection5.call(this, $pos, $end);
      this.node = node5;
    }
    if (Selection5)
      NodeSelection3.__proto__ = Selection5;
    NodeSelection3.prototype = Object.create(Selection5 && Selection5.prototype);
    NodeSelection3.prototype.constructor = NodeSelection3;
    NodeSelection3.prototype.map = function map22(doc2, mapping) {
      var ref = mapping.mapResult(this.anchor);
      var deleted = ref.deleted;
      var pos = ref.pos;
      var $pos = doc2.resolve(pos);
      if (deleted) {
        return Selection5.near($pos);
      }
      return new NodeSelection3($pos);
    };
    NodeSelection3.prototype.content = function content3() {
      return new Slice(Fragment.from(this.node), 0, 0);
    };
    NodeSelection3.prototype.eq = function eq16(other) {
      return other instanceof NodeSelection3 && other.anchor == this.anchor;
    };
    NodeSelection3.prototype.toJSON = function toJSON13() {
      return { type: "node", anchor: this.anchor };
    };
    NodeSelection3.prototype.getBookmark = function getBookmark3() {
      return new NodeBookmark(this.anchor);
    };
    NodeSelection3.fromJSON = function fromJSON15(doc2, json2) {
      if (typeof json2.anchor != "number") {
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      }
      return new NodeSelection3(doc2.resolve(json2.anchor));
    };
    NodeSelection3.create = function create9(doc2, from5) {
      return new this(doc2.resolve(from5));
    };
    NodeSelection3.isSelectable = function isSelectable(node5) {
      return !node5.isText && node5.type.spec.selectable !== false;
    };
    return NodeSelection3;
  }(Selection);
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  var NodeBookmark = function NodeBookmark2(anchor) {
    this.anchor = anchor;
  };
  NodeBookmark.prototype.map = function map5(mapping) {
    var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  };
  NodeBookmark.prototype.resolve = function resolve4(doc2) {
    var $pos = doc2.resolve(this.anchor), node5 = $pos.nodeAfter;
    if (node5 && NodeSelection.isSelectable(node5)) {
      return new NodeSelection($pos);
    }
    return Selection.near($pos);
  };
  var AllSelection = /* @__PURE__ */ function(Selection5) {
    function AllSelection3(doc2) {
      Selection5.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
    }
    if (Selection5)
      AllSelection3.__proto__ = Selection5;
    AllSelection3.prototype = Object.create(Selection5 && Selection5.prototype);
    AllSelection3.prototype.constructor = AllSelection3;
    AllSelection3.prototype.replace = function replace5(tr, content3) {
      if (content3 === void 0)
        content3 = Slice.empty;
      if (content3 == Slice.empty) {
        tr.delete(0, tr.doc.content.size);
        var sel = Selection5.atStart(tr.doc);
        if (!sel.eq(tr.selection)) {
          tr.setSelection(sel);
        }
      } else {
        Selection5.prototype.replace.call(this, tr, content3);
      }
    };
    AllSelection3.prototype.toJSON = function toJSON13() {
      return { type: "all" };
    };
    AllSelection3.fromJSON = function fromJSON15(doc2) {
      return new AllSelection3(doc2);
    };
    AllSelection3.prototype.map = function map22(doc2) {
      return new AllSelection3(doc2);
    };
    AllSelection3.prototype.eq = function eq16(other) {
      return other instanceof AllSelection3;
    };
    AllSelection3.prototype.getBookmark = function getBookmark3() {
      return AllBookmark;
    };
    return AllSelection3;
  }(Selection);
  Selection.jsonID("all", AllSelection);
  var AllBookmark = {
    map: function map6() {
      return this;
    },
    resolve: function resolve5(doc2) {
      return new AllSelection(doc2);
    }
  };
  function findSelectionIn(doc2, node5, pos, index3, dir, text4) {
    if (node5.inlineContent) {
      return TextSelection.create(doc2, pos);
    }
    for (var i = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i < node5.childCount : i >= 0; i += dir) {
      var child5 = node5.child(i);
      if (!child5.isAtom) {
        var inner = findSelectionIn(doc2, child5, pos + dir, dir < 0 ? child5.childCount : 0, dir, text4);
        if (inner) {
          return inner;
        }
      } else if (!text4 && NodeSelection.isSelectable(child5)) {
        return NodeSelection.create(doc2, pos - (dir < 0 ? child5.nodeSize : 0));
      }
      pos += child5.nodeSize * dir;
    }
  }
  function selectionToInsertionEnd(tr, startLen, bias) {
    var last = tr.steps.length - 1;
    if (last < startLen) {
      return;
    }
    var step3 = tr.steps[last];
    if (!(step3 instanceof ReplaceStep || step3 instanceof ReplaceAroundStep)) {
      return;
    }
    var map22 = tr.mapping.maps[last], end4;
    map22.forEach(function(_from, _to, _newFrom, newTo) {
      if (end4 == null) {
        end4 = newTo;
      }
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end4), bias));
  }
  var UPDATED_SEL = 1;
  var UPDATED_MARKS = 2;
  var UPDATED_SCROLL = 4;
  var Transaction = /* @__PURE__ */ function(Transform5) {
    function Transaction3(state) {
      Transform5.call(this, state.doc);
      this.time = Date.now();
      this.curSelection = state.selection;
      this.curSelectionFor = 0;
      this.storedMarks = state.storedMarks;
      this.updated = 0;
      this.meta = /* @__PURE__ */ Object.create(null);
    }
    if (Transform5)
      Transaction3.__proto__ = Transform5;
    Transaction3.prototype = Object.create(Transform5 && Transform5.prototype);
    Transaction3.prototype.constructor = Transaction3;
    var prototypeAccessors6 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
    prototypeAccessors6.selection.get = function() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }
      return this.curSelection;
    };
    Transaction3.prototype.setSelection = function setSelection2(selection) {
      if (selection.$from.doc != this.doc) {
        throw new RangeError("Selection passed to setSelection must point at the current document");
      }
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    };
    prototypeAccessors6.selectionSet.get = function() {
      return (this.updated & UPDATED_SEL) > 0;
    };
    Transaction3.prototype.setStoredMarks = function setStoredMarks(marks3) {
      this.storedMarks = marks3;
      this.updated |= UPDATED_MARKS;
      return this;
    };
    Transaction3.prototype.ensureMarks = function ensureMarks2(marks3) {
      if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks3)) {
        this.setStoredMarks(marks3);
      }
      return this;
    };
    Transaction3.prototype.addStoredMark = function addStoredMark(mark4) {
      return this.ensureMarks(mark4.addToSet(this.storedMarks || this.selection.$head.marks()));
    };
    Transaction3.prototype.removeStoredMark = function removeStoredMark(mark4) {
      return this.ensureMarks(mark4.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    };
    prototypeAccessors6.storedMarksSet.get = function() {
      return (this.updated & UPDATED_MARKS) > 0;
    };
    Transaction3.prototype.addStep = function addStep3(step3, doc2) {
      Transform5.prototype.addStep.call(this, step3, doc2);
      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    };
    Transaction3.prototype.setTime = function setTime(time) {
      this.time = time;
      return this;
    };
    Transaction3.prototype.replaceSelection = function replaceSelection(slice6) {
      this.selection.replace(this, slice6);
      return this;
    };
    Transaction3.prototype.replaceSelectionWith = function replaceSelectionWith(node5, inheritMarks) {
      var selection = this.selection;
      if (inheritMarks !== false) {
        node5 = node5.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
      }
      selection.replaceWith(this, node5);
      return this;
    };
    Transaction3.prototype.deleteSelection = function deleteSelection3() {
      this.selection.replace(this);
      return this;
    };
    Transaction3.prototype.insertText = function insertText(text4, from5, to) {
      if (to === void 0)
        to = from5;
      var schema = this.doc.type.schema;
      if (from5 == null) {
        if (!text4) {
          return this.deleteSelection();
        }
        return this.replaceSelectionWith(schema.text(text4), true);
      } else {
        if (!text4) {
          return this.deleteRange(from5, to);
        }
        var marks3 = this.storedMarks;
        if (!marks3) {
          var $from = this.doc.resolve(from5);
          marks3 = to == from5 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }
        this.replaceRangeWith(from5, to, schema.text(text4, marks3));
        if (!this.selection.empty) {
          this.setSelection(Selection.near(this.selection.$to));
        }
        return this;
      }
    };
    Transaction3.prototype.setMeta = function setMeta2(key2, value) {
      this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
      return this;
    };
    Transaction3.prototype.getMeta = function getMeta(key2) {
      return this.meta[typeof key2 == "string" ? key2 : key2.key];
    };
    prototypeAccessors6.isGeneric.get = function() {
      for (var _ in this.meta) {
        return false;
      }
      return true;
    };
    Transaction3.prototype.scrollIntoView = function scrollIntoView2() {
      this.updated |= UPDATED_SCROLL;
      return this;
    };
    prototypeAccessors6.scrolledIntoView.get = function() {
      return (this.updated & UPDATED_SCROLL) > 0;
    };
    Object.defineProperties(Transaction3.prototype, prototypeAccessors6);
    return Transaction3;
  }(Transform);
  function bind(f, self2) {
    return !self2 || !f ? f : f.bind(self2);
  }
  var FieldDesc = function FieldDesc2(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  };
  var baseFields = [
    new FieldDesc("doc", {
      init: function init(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply: function apply2(tr) {
        return tr.doc;
      }
    }),
    new FieldDesc("selection", {
      init: function init2(config, instance) {
        return config.selection || Selection.atStart(instance.doc);
      },
      apply: function apply3(tr) {
        return tr.selection;
      }
    }),
    new FieldDesc("storedMarks", {
      init: function init3(config) {
        return config.storedMarks || null;
      },
      apply: function apply4(tr, _marks, _old, state) {
        return state.selection.$cursor ? tr.storedMarks : null;
      }
    }),
    new FieldDesc("scrollToSelection", {
      init: function init4() {
        return 0;
      },
      apply: function apply5(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      }
    })
  ];
  var Configuration = function Configuration2(schema, plugins) {
    var this$1 = this;
    this.schema = schema;
    this.fields = baseFields.concat();
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    if (plugins) {
      plugins.forEach(function(plugin) {
        if (this$1.pluginsByKey[plugin.key]) {
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        }
        this$1.plugins.push(plugin);
        this$1.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state) {
          this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
        }
      });
    }
  };
  var EditorState = function EditorState2(config) {
    this.config = config;
  };
  var prototypeAccessors$13 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
  prototypeAccessors$13.schema.get = function() {
    return this.config.schema;
  };
  prototypeAccessors$13.plugins.get = function() {
    return this.config.plugins;
  };
  EditorState.prototype.apply = function apply6(tr) {
    return this.applyTransaction(tr).state;
  };
  EditorState.prototype.filterTransaction = function filterTransaction(tr, ignore) {
    if (ignore === void 0)
      ignore = -1;
    for (var i = 0; i < this.config.plugins.length; i++) {
      if (i != ignore) {
        var plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
          return false;
        }
      }
    }
    return true;
  };
  EditorState.prototype.applyTransaction = function applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr)) {
      return { state: this, transactions: [] };
    }
    var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      var haveNew = false;
      for (var i = 0; i < this.config.plugins.length; i++) {
        var plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (var j = 0; j < this.config.plugins.length; j++) {
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
              }
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen) {
            seen[i] = { state: newState, n: trs.length };
          }
        }
      }
      if (!haveNew) {
        return { state: newState, transactions: trs };
      }
    }
  };
  EditorState.prototype.applyInner = function applyInner(tr) {
    if (!tr.before.eq(this.doc)) {
      throw new RangeError("Applying a mismatched transaction");
    }
    var newInstance = new EditorState(this.config), fields = this.config.fields;
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    for (var i$1 = 0; i$1 < applyListeners.length; i$1++) {
      applyListeners[i$1](this, tr, newInstance);
    }
    return newInstance;
  };
  prototypeAccessors$13.tr.get = function() {
    return new Transaction(this);
  };
  EditorState.create = function create3(config) {
    var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    var instance = new EditorState($config);
    for (var i = 0; i < $config.fields.length; i++) {
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    }
    return instance;
  };
  EditorState.prototype.reconfigure = function reconfigure(config) {
    var $config = new Configuration(this.schema, config.plugins);
    var fields = $config.fields, instance = new EditorState($config);
    for (var i = 0; i < fields.length; i++) {
      var name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  };
  EditorState.prototype.toJSON = function toJSON6(pluginFields) {
    var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks) {
      result2.storedMarks = this.storedMarks.map(function(m) {
        return m.toJSON();
      });
    }
    if (pluginFields && typeof pluginFields == "object") {
      for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection") {
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        }
        var plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON) {
          result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
        }
      }
    }
    return result2;
  };
  EditorState.fromJSON = function fromJSON7(config, json2, pluginFields) {
    if (!json2) {
      throw new RangeError("Invalid input for EditorState.fromJSON");
    }
    if (!config.schema) {
      throw new RangeError("Required config field 'schema' missing");
    }
    var $config = new Configuration(config.schema, config.plugins);
    var instance = new EditorState($config);
    $config.fields.forEach(function(field) {
      if (field.name == "doc") {
        instance.doc = Node2.fromJSON(config.schema, json2.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json2.selection);
      } else if (field.name == "storedMarks") {
        if (json2.storedMarks) {
          instance.storedMarks = json2.storedMarks.map(config.schema.markFromJSON);
        }
      } else {
        if (pluginFields) {
          for (var prop in pluginFields) {
            var plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json2, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json2[prop], instance);
              return;
            }
          }
        }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  };
  EditorState.addApplyListener = function addApplyListener(f) {
    applyListeners.push(f);
  };
  EditorState.removeApplyListener = function removeApplyListener(f) {
    var found3 = applyListeners.indexOf(f);
    if (found3 > -1) {
      applyListeners.splice(found3, 1);
    }
  };
  Object.defineProperties(EditorState.prototype, prototypeAccessors$13);
  var applyListeners = [];
  function bindProps(obj, self2, target) {
    for (var prop in obj) {
      var val = obj[prop];
      if (val instanceof Function) {
        val = val.bind(self2);
      } else if (prop == "handleDOMEvents") {
        val = bindProps(val, self2, {});
      }
      target[prop] = val;
    }
    return target;
  }
  var Plugin = function Plugin2(spec) {
    this.props = {};
    if (spec.props) {
      bindProps(spec.props, this, this.props);
    }
    this.spec = spec;
    this.key = spec.key ? spec.key.key : createKey("plugin");
  };
  Plugin.prototype.getState = function getState(state) {
    return state[this.key];
  };
  var keys = /* @__PURE__ */ Object.create(null);
  function createKey(name) {
    if (name in keys) {
      return name + "$" + ++keys[name];
    }
    keys[name] = 0;
    return name + "$";
  }
  var PluginKey = function PluginKey2(name) {
    if (name === void 0)
      name = "key";
    this.key = createKey(name);
  };
  PluginKey.prototype.get = function get2(state) {
    return state.config.pluginsByKey[this.key];
  };
  PluginKey.prototype.getState = function getState2(state) {
    return state[this.key];
  };

  // node_modules/prosemirror-commands/dist/index.es.js
  function deleteSelection(state, dispatch3) {
    if (state.selection.empty) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.deleteSelection().scrollIntoView());
    }
    return true;
  }
  function joinBackward(state, dispatch3, view) {
    var ref = state.selection;
    var $cursor = ref.$cursor;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
      return false;
    }
    var $cut = findCutBefore($cursor);
    if (!$cut) {
      var range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null) {
        return false;
      }
      if (dispatch3) {
        dispatch3(state.tr.lift(range, target).scrollIntoView());
      }
      return true;
    }
    var before3 = $cut.nodeBefore;
    if (!before3.type.spec.isolating && deleteBarrier(state, $cut, dispatch3)) {
      return true;
    }
    if ($cursor.parent.content.size == 0 && (textblockAt(before3, "end") || NodeSelection.isSelectable(before3))) {
      var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch3) {
          var tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(before3, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before3.nodeSize));
          dispatch3(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (before3.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch3) {
        dispatch3(state.tr.delete($cut.pos - before3.nodeSize, $cut.pos).scrollIntoView());
      }
      return true;
    }
    return false;
  }
  function textblockAt(node5, side, only) {
    for (; node5; node5 = side == "start" ? node5.firstChild : node5.lastChild) {
      if (node5.isTextblock) {
        return true;
      }
      if (only && node5.childCount != 1) {
        return false;
      }
    }
    return false;
  }
  function selectNodeBackward(state, dispatch3, view) {
    var ref = state.selection;
    var $head = ref.$head;
    var empty2 = ref.empty;
    var $cut = $head;
    if (!empty2) {
      return false;
    }
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) {
        return false;
      }
      $cut = findCutBefore($head);
    }
    var node5 = $cut && $cut.nodeBefore;
    if (!node5 || !NodeSelection.isSelectable(node5)) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node5.nodeSize)).scrollIntoView());
    }
    return true;
  }
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating) {
      for (var i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0) {
          return $pos.doc.resolve($pos.before(i + 1));
        }
        if ($pos.node(i).type.spec.isolating) {
          break;
        }
      }
    }
    return null;
  }
  function joinForward(state, dispatch3, view) {
    var ref = state.selection;
    var $cursor = ref.$cursor;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
      return false;
    }
    var $cut = findCutAfter($cursor);
    if (!$cut) {
      return false;
    }
    var after3 = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch3)) {
      return true;
    }
    if ($cursor.parent.content.size == 0 && (textblockAt(after3, "start") || NodeSelection.isSelectable(after3))) {
      var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch3) {
          var tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(after3, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
          dispatch3(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (after3.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch3) {
        dispatch3(state.tr.delete($cut.pos, $cut.pos + after3.nodeSize).scrollIntoView());
      }
      return true;
    }
    return false;
  }
  function selectNodeForward(state, dispatch3, view) {
    var ref = state.selection;
    var $head = ref.$head;
    var empty2 = ref.empty;
    var $cut = $head;
    if (!empty2) {
      return false;
    }
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) {
        return false;
      }
      $cut = findCutAfter($head);
    }
    var node5 = $cut && $cut.nodeAfter;
    if (!node5 || !NodeSelection.isSelectable(node5)) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    }
    return true;
  }
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating) {
      for (var i = $pos.depth - 1; i >= 0; i--) {
        var parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount) {
          return $pos.doc.resolve($pos.after(i + 1));
        }
        if (parent.type.spec.isolating) {
          break;
        }
      }
    }
    return null;
  }
  function lift(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), target = range && liftTarget(range);
    if (target == null) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.lift(range, target).scrollIntoView());
    }
    return true;
  }
  function newlineInCode(state, dispatch3) {
    var ref = state.selection;
    var $head = ref.$head;
    var $anchor = ref.$anchor;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.insertText("\n").scrollIntoView());
    }
    return true;
  }
  function defaultBlockAt(match) {
    for (var i = 0; i < match.edgeCount; i++) {
      var ref = match.edge(i);
      var type = ref.type;
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function exitCode(state, dispatch3) {
    var ref = state.selection;
    var $head = ref.$head;
    var $anchor = ref.$anchor;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
      return false;
    }
    var above = $head.node(-1), after3 = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after3));
    if (!above.canReplaceWith(after3, after3, type)) {
      return false;
    }
    if (dispatch3) {
      var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  function createParagraphNear(state, dispatch3) {
    var sel = state.selection;
    var $from = sel.$from;
    var $to = sel.$to;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) {
      return false;
    }
    var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock) {
      return false;
    }
    if (dispatch3) {
      var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
      var tr = state.tr.insert(side, type.createAndFill());
      tr.setSelection(TextSelection.create(tr.doc, side + 1));
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  function liftEmptyBlock(state, dispatch3) {
    var ref = state.selection;
    var $cursor = ref.$cursor;
    if (!$cursor || $cursor.parent.content.size) {
      return false;
    }
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      var before3 = $cursor.before();
      if (canSplit(state.doc, before3)) {
        if (dispatch3) {
          dispatch3(state.tr.split(before3).scrollIntoView());
        }
        return true;
      }
    }
    var range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.lift(range, target).scrollIntoView());
    }
    return true;
  }
  function splitBlock(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {
        return false;
      }
      if (dispatch3) {
        dispatch3(state.tr.split($from.pos).scrollIntoView());
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    if (dispatch3) {
      var atEnd3 = $to.parentOffset == $to.parent.content.size;
      var tr = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) {
        tr.deleteSelection();
      }
      var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      var types = atEnd3 && deflt ? [{ type: deflt }] : null;
      var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
        types = [{ type: deflt }];
        can = true;
      }
      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (!atEnd3 && !$from.parentOffset && $from.parent.type != deflt) {
          var first2 = tr.mapping.map($from.before()), $first = tr.doc.resolve(first2);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
      }
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  function selectParentNode(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var to = ref.to;
    var pos;
    var same = $from.sharedDepth(to);
    if (same == 0) {
      return false;
    }
    pos = $from.before(same);
    if (dispatch3) {
      dispatch3(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    }
    return true;
  }
  function selectAll(state, dispatch3) {
    if (dispatch3) {
      dispatch3(state.tr.setSelection(new AllSelection(state.doc)));
    }
    return true;
  }
  function joinMaybeClear(state, $pos, dispatch3) {
    var before3 = $pos.nodeBefore, after3 = $pos.nodeAfter, index3 = $pos.index();
    if (!before3 || !after3 || !before3.type.compatibleContent(after3.type)) {
      return false;
    }
    if (!before3.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
      if (dispatch3) {
        dispatch3(state.tr.delete($pos.pos - before3.nodeSize, $pos.pos).scrollIntoView());
      }
      return true;
    }
    if (!$pos.parent.canReplace(index3, index3 + 1) || !(after3.isTextblock || canJoin(state.doc, $pos.pos))) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.clearIncompatible($pos.pos, before3.type, before3.contentMatchAt(before3.childCount)).join($pos.pos).scrollIntoView());
    }
    return true;
  }
  function deleteBarrier(state, $cut, dispatch3) {
    var before3 = $cut.nodeBefore, after3 = $cut.nodeAfter, conn, match;
    if (before3.type.spec.isolating || after3.type.spec.isolating) {
      return false;
    }
    if (joinMaybeClear(state, $cut, dispatch3)) {
      return true;
    }
    var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before3.contentMatchAt(before3.childCount)).findWrapping(after3.type)) && match.matchType(conn[0] || after3.type).validEnd) {
      if (dispatch3) {
        var end4 = $cut.pos + after3.nodeSize, wrap = Fragment.empty;
        for (var i = conn.length - 1; i >= 0; i--) {
          wrap = Fragment.from(conn[i].create(null, wrap));
        }
        wrap = Fragment.from(before3.copy(wrap));
        var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end4, $cut.pos, end4, new Slice(wrap, 1, 0), conn.length, true));
        var joinAt = end4 + 2 * conn.length;
        if (canJoin(tr.doc, joinAt)) {
          tr.join(joinAt);
        }
        dispatch3(tr.scrollIntoView());
      }
      return true;
    }
    var selAfter = Selection.findFrom($cut, 1);
    var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch3) {
        dispatch3(state.tr.lift(range, target).scrollIntoView());
      }
      return true;
    }
    if (canDelAfter && textblockAt(after3, "start", true) && textblockAt(before3, "end")) {
      var at = before3, wrap$1 = [];
      for (; ; ) {
        wrap$1.push(at);
        if (at.isTextblock) {
          break;
        }
        at = at.lastChild;
      }
      var afterText = after3, afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild) {
        afterDepth++;
      }
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch3) {
          var end$1 = Fragment.empty;
          for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) {
            end$1 = Fragment.from(wrap$1[i$1].copy(end$1));
          }
          var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after3.nodeSize, $cut.pos + afterDepth, $cut.pos + after3.nodeSize - afterDepth, new Slice(end$1, wrap$1.length, 0), 0, true));
          dispatch3(tr$1.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function(state, dispatch3) {
      var sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
      var depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth) {
          return false;
        }
        depth--;
      }
      if (!$pos.node(depth).isTextblock) {
        return false;
      }
      if (dispatch3) {
        dispatch3(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      }
      return true;
    };
  }
  var selectTextblockStart = selectTextblockSide(-1);
  var selectTextblockEnd = selectTextblockSide(1);
  function wrapIn(nodeType2, attrs) {
    return function(state, dispatch3) {
      var ref = state.selection;
      var $from = ref.$from;
      var $to = ref.$to;
      var range = $from.blockRange($to), wrapping = range && findWrapping3(range, nodeType2, attrs);
      if (!wrapping) {
        return false;
      }
      if (dispatch3) {
        dispatch3(state.tr.wrap(range, wrapping).scrollIntoView());
      }
      return true;
    };
  }
  function setBlockType(nodeType2, attrs) {
    return function(state, dispatch3) {
      var ref = state.selection;
      var from5 = ref.from;
      var to = ref.to;
      var applicable = false;
      state.doc.nodesBetween(from5, to, function(node5, pos) {
        if (applicable) {
          return false;
        }
        if (!node5.isTextblock || node5.hasMarkup(nodeType2, attrs)) {
          return;
        }
        if (node5.type == nodeType2) {
          applicable = true;
        } else {
          var $pos = state.doc.resolve(pos), index3 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index3, index3 + 1, nodeType2);
        }
      });
      if (!applicable) {
        return false;
      }
      if (dispatch3) {
        dispatch3(state.tr.setBlockType(from5, to, nodeType2, attrs).scrollIntoView());
      }
      return true;
    };
  }
  function chainCommands() {
    var commands = [], len = arguments.length;
    while (len--)
      commands[len] = arguments[len];
    return function(state, dispatch3, view) {
      for (var i = 0; i < commands.length; i++) {
        if (commands[i](state, dispatch3, view)) {
          return true;
        }
      }
      return false;
    };
  }
  var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
  var del2 = chainCommands(deleteSelection, joinForward, selectNodeForward);
  var pcBaseKeymap = {
    "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
    "Mod-Enter": exitCode,
    "Backspace": backspace,
    "Mod-Backspace": backspace,
    "Shift-Backspace": backspace,
    "Delete": del2,
    "Mod-Delete": del2,
    "Mod-a": selectAll
  };
  var macBaseKeymap = {
    "Ctrl-h": pcBaseKeymap["Backspace"],
    "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
    "Ctrl-d": pcBaseKeymap["Delete"],
    "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
    "Alt-Delete": pcBaseKeymap["Mod-Delete"],
    "Alt-d": pcBaseKeymap["Mod-Delete"],
    "Ctrl-a": selectTextblockStart,
    "Ctrl-e": selectTextblockEnd
  };
  for (key2 in pcBaseKeymap) {
    macBaseKeymap[key2] = pcBaseKeymap[key2];
  }
  var key2;
  var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;

  // node_modules/prosemirror-schema-list/dist/index.es.js
  function wrapInList(listType, attrs) {
    return function(state, dispatch3) {
      var ref = state.selection;
      var $from = ref.$from;
      var $to = ref.$to;
      var range = $from.blockRange($to), doJoin = false, outerRange = range;
      if (!range) {
        return false;
      }
      if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
        if ($from.index(range.depth - 1) == 0) {
          return false;
        }
        var $insert = state.doc.resolve(range.start - 2);
        outerRange = new NodeRange($insert, $insert, range.depth);
        if (range.endIndex < range.parent.childCount) {
          range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
        }
        doJoin = true;
      }
      var wrap = findWrapping3(outerRange, listType, attrs, range);
      if (!wrap) {
        return false;
      }
      if (dispatch3) {
        dispatch3(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
      }
      return true;
    };
  }
  function doWrapInList(tr, range, wrappers, joinBefore, listType) {
    var content3 = Fragment.empty;
    for (var i = wrappers.length - 1; i >= 0; i--) {
      content3 = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content3));
    }
    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content3, 0, 0), wrappers.length, true));
    var found3 = 0;
    for (var i$1 = 0; i$1 < wrappers.length; i$1++) {
      if (wrappers[i$1].type == listType) {
        found3 = i$1 + 1;
      }
    }
    var splitDepth = wrappers.length - found3;
    var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (var i$2 = range.startIndex, e = range.endIndex, first2 = true; i$2 < e; i$2++, first2 = false) {
      if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
        tr.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i$2).nodeSize;
    }
    return tr;
  }
  function liftListItem(itemType) {
    return function(state, dispatch3) {
      var ref = state.selection;
      var $from = ref.$from;
      var $to = ref.$to;
      var range = $from.blockRange($to, function(node5) {
        return node5.childCount && node5.firstChild.type == itemType;
      });
      if (!range) {
        return false;
      }
      if (!dispatch3) {
        return true;
      }
      if ($from.node(range.depth - 1).type == itemType) {
        return liftToOuterList(state, dispatch3, itemType, range);
      } else {
        return liftOutOfList(state, dispatch3, range);
      }
    };
  }
  function liftToOuterList(state, dispatch3, itemType, range) {
    var tr = state.tr, end4 = range.end, endOfList = range.$to.end(range.depth);
    if (end4 < endOfList) {
      tr.step(new ReplaceAroundStep(end4 - 1, endOfList, end4, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    dispatch3(tr.lift(range, liftTarget(range)).scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch3, range) {
    var tr = state.tr, list = range.parent;
    for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
      pos -= list.child(i).nodeSize;
      tr.delete(pos - 1, pos + 1);
    }
    var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) {
      return false;
    }
    var atStart3 = range.startIndex == 0, atEnd3 = range.endIndex == list.childCount;
    var parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart3 ? 0 : 1), indexBefore + 1, item.content.append(atEnd3 ? Fragment.empty : Fragment.from(list)))) {
      return false;
    }
    var start6 = $start.pos, end4 = start6 + item.nodeSize;
    tr.step(new ReplaceAroundStep(start6 - (atStart3 ? 1 : 0), end4 + (atEnd3 ? 1 : 0), start6 + 1, end4 - 1, new Slice((atStart3 ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd3 ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart3 ? 0 : 1, atEnd3 ? 0 : 1), atStart3 ? 0 : 1));
    dispatch3(tr.scrollIntoView());
    return true;
  }
  function sinkListItem(itemType) {
    return function(state, dispatch3) {
      var ref = state.selection;
      var $from = ref.$from;
      var $to = ref.$to;
      var range = $from.blockRange($to, function(node5) {
        return node5.childCount && node5.firstChild.type == itemType;
      });
      if (!range) {
        return false;
      }
      var startIndex2 = range.startIndex;
      if (startIndex2 == 0) {
        return false;
      }
      var parent = range.parent, nodeBefore = parent.child(startIndex2 - 1);
      if (nodeBefore.type != itemType) {
        return false;
      }
      if (dispatch3) {
        var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        var inner = Fragment.from(nestedBefore ? itemType.create() : null);
        var slice6 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        var before3 = range.start, after3 = range.end;
        dispatch3(state.tr.step(new ReplaceAroundStep(before3 - (nestedBefore ? 3 : 1), after3, before3, after3, slice6, 1, true)).scrollIntoView());
      }
      return true;
    };
  }

  // node_modules/prosemirror-view/dist/index.es.js
  var result = {};
  if (typeof navigator != "undefined" && typeof document != "undefined") {
    ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
    ie_upto10 = /MSIE \d/.test(navigator.userAgent);
    ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    ie2 = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
    result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
    result.gecko = !ie2 && /gecko\/(\d+)/i.test(navigator.userAgent);
    result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
    chrome2 = !ie2 && /Chrome\/(\d+)/.exec(navigator.userAgent);
    result.chrome = !!chrome2;
    result.chrome_version = chrome2 && +chrome2[1];
    result.safari = !ie2 && /Apple Computer/.test(navigator.vendor);
    result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
    result.mac = result.ios || /Mac/.test(navigator.platform);
    result.android = /Android \d/.test(navigator.userAgent);
    result.webkit = "webkitFontSmoothing" in document.documentElement.style;
    result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  }
  var ie_edge;
  var ie_upto10;
  var ie_11up;
  var ie2;
  var chrome2;
  var domIndex = function(node5) {
    for (var index3 = 0; ; index3++) {
      node5 = node5.previousSibling;
      if (!node5) {
        return index3;
      }
    }
  };
  var parentNode = function(node5) {
    var parent = node5.assignedSlot || node5.parentNode;
    return parent && parent.nodeType == 11 ? parent.host : parent;
  };
  var reusedRange = null;
  var textRange = function(node5, from5, to) {
    var range = reusedRange || (reusedRange = document.createRange());
    range.setEnd(node5, to == null ? node5.nodeValue.length : to);
    range.setStart(node5, from5 || 0);
    return range;
  };
  var isEquivalentPosition = function(node5, off, targetNode, targetOff) {
    return targetNode && (scanFor(node5, off, targetNode, targetOff, -1) || scanFor(node5, off, targetNode, targetOff, 1));
  };
  var atomElements = /^(img|br|input|textarea|hr)$/i;
  function scanFor(node5, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node5 == targetNode && off == targetOff) {
        return true;
      }
      if (off == (dir < 0 ? 0 : nodeSize(node5))) {
        var parent = node5.parentNode;
        if (!parent || parent.nodeType != 1 || hasBlockDesc(node5) || atomElements.test(node5.nodeName) || node5.contentEditable == "false") {
          return false;
        }
        off = domIndex(node5) + (dir < 0 ? 0 : 1);
        node5 = parent;
      } else if (node5.nodeType == 1) {
        node5 = node5.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node5.contentEditable == "false") {
          return false;
        }
        off = dir < 0 ? nodeSize(node5) : 0;
      } else {
        return false;
      }
    }
  }
  function nodeSize(node5) {
    return node5.nodeType == 3 ? node5.nodeValue.length : node5.childNodes.length;
  }
  function isOnEdge(node5, offset4, parent) {
    for (var atStart3 = offset4 == 0, atEnd3 = offset4 == nodeSize(node5); atStart3 || atEnd3; ) {
      if (node5 == parent) {
        return true;
      }
      var index3 = domIndex(node5);
      node5 = node5.parentNode;
      if (!node5) {
        return false;
      }
      atStart3 = atStart3 && index3 == 0;
      atEnd3 = atEnd3 && index3 == nodeSize(node5);
    }
  }
  function hasBlockDesc(dom) {
    var desc;
    for (var cur = dom; cur; cur = cur.parentNode) {
      if (desc = cur.pmViewDesc) {
        break;
      }
    }
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
  }
  var selectionCollapsed = function(domSel) {
    var collapsed = domSel.isCollapsed;
    if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
      collapsed = false;
    }
    return collapsed;
  };
  function keyEvent(keyCode, key2) {
    var event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key2;
    return event;
  }
  function windowRect(doc2) {
    return {
      left: 0,
      right: doc2.documentElement.clientWidth,
      top: 0,
      bottom: doc2.documentElement.clientHeight
    };
  }
  function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
  }
  function clientRect(node5) {
    var rect = node5.getBoundingClientRect();
    var scaleX = rect.width / node5.offsetWidth || 1;
    var scaleY = rect.height / node5.offsetHeight || 1;
    return {
      left: rect.left,
      right: rect.left + node5.clientWidth * scaleX,
      top: rect.top,
      bottom: rect.top + node5.clientHeight * scaleY
    };
  }
  function scrollRectIntoView(view, rect, startDOM) {
    var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
    var doc2 = view.dom.ownerDocument;
    for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
      if (!parent) {
        break;
      }
      if (parent.nodeType != 1) {
        continue;
      }
      var atTop = parent == doc2.body || parent.nodeType != 1;
      var bounding = atTop ? windowRect(doc2) : clientRect(parent);
      var moveX = 0, moveY = 0;
      if (rect.top < bounding.top + getSide(scrollThreshold, "top")) {
        moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
      } else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
        moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
      }
      if (rect.left < bounding.left + getSide(scrollThreshold, "left")) {
        moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
      } else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) {
        moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
      }
      if (moveX || moveY) {
        if (atTop) {
          doc2.defaultView.scrollBy(moveX, moveY);
        } else {
          var startX = parent.scrollLeft, startY = parent.scrollTop;
          if (moveY) {
            parent.scrollTop += moveY;
          }
          if (moveX) {
            parent.scrollLeft += moveX;
          }
          var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
        }
      }
      if (atTop) {
        break;
      }
    }
  }
  function storeScrollPos(view) {
    var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
    var refDOM, refTop;
    for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
      var dom = view.root.elementFromPoint(x, y);
      if (dom == view.dom || !view.dom.contains(dom)) {
        continue;
      }
      var localRect = dom.getBoundingClientRect();
      if (localRect.top >= startY - 20) {
        refDOM = dom;
        refTop = localRect.top;
        break;
      }
    }
    return { refDOM, refTop, stack: scrollStack(view.dom) };
  }
  function scrollStack(dom) {
    var stack = [], doc2 = dom.ownerDocument;
    for (; dom; dom = parentNode(dom)) {
      stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
      if (dom == doc2) {
        break;
      }
    }
    return stack;
  }
  function resetScrollPos(ref) {
    var refDOM = ref.refDOM;
    var refTop = ref.refTop;
    var stack = ref.stack;
    var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
  }
  function restoreScrollStack(stack, dTop) {
    for (var i = 0; i < stack.length; i++) {
      var ref = stack[i];
      var dom = ref.dom;
      var top2 = ref.top;
      var left2 = ref.left;
      if (dom.scrollTop != top2 + dTop) {
        dom.scrollTop = top2 + dTop;
      }
      if (dom.scrollLeft != left2) {
        dom.scrollLeft = left2;
      }
    }
  }
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive) {
      return dom.setActive();
    }
    if (preventScrollSupported) {
      return dom.focus(preventScrollSupported);
    }
    var stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      restoreScrollStack(stored, 0);
    }
  }
  function findOffsetInNode(node5, coords) {
    var closest, dxClosest = 2e8, coordsClosest, offset4 = 0;
    var rowBot = coords.top, rowTop = coords.top;
    for (var child5 = node5.firstChild, childIndex = 0; child5; child5 = child5.nextSibling, childIndex++) {
      var rects = void 0;
      if (child5.nodeType == 1) {
        rects = child5.getClientRects();
      } else if (child5.nodeType == 3) {
        rects = textRange(child5).getClientRects();
      } else {
        continue;
      }
      for (var i = 0; i < rects.length; i++) {
        var rect = rects[i];
        if (rect.top <= rowBot && rect.bottom >= rowTop) {
          rowBot = Math.max(rect.bottom, rowBot);
          rowTop = Math.min(rect.top, rowTop);
          var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
          if (dx < dxClosest) {
            closest = child5;
            dxClosest = dx;
            coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
            if (child5.nodeType == 1 && dx) {
              offset4 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
            }
            continue;
          }
        }
        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
          offset4 = childIndex + 1;
        }
      }
    }
    if (closest && closest.nodeType == 3) {
      return findOffsetInText(closest, coordsClosest);
    }
    if (!closest || dxClosest && closest.nodeType == 1) {
      return { node: node5, offset: offset4 };
    }
    return findOffsetInNode(closest, coordsClosest);
  }
  function findOffsetInText(node5, coords) {
    var len = node5.nodeValue.length;
    var range = document.createRange();
    for (var i = 0; i < len; i++) {
      range.setEnd(node5, i + 1);
      range.setStart(node5, i);
      var rect = singleRect(range, 1);
      if (rect.top == rect.bottom) {
        continue;
      }
      if (inRect(coords, rect)) {
        return { node: node5, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
      }
    }
    return { node: node5, offset: 0 };
  }
  function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
  }
  function targetKludge(dom, coords) {
    var parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
      return parent;
    }
    return dom;
  }
  function posFromElement(view, elt, coords) {
    var ref = findOffsetInNode(elt, coords);
    var node5 = ref.node;
    var offset4 = ref.offset;
    var bias = -1;
    if (node5.nodeType == 1 && !node5.firstChild) {
      var rect = node5.getBoundingClientRect();
      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node5, offset4, bias);
  }
  function posFromCaret(view, node5, offset4, coords) {
    var outside = -1;
    for (var cur = node5; ; ) {
      if (cur == view.dom) {
        break;
      }
      var desc = view.docView.nearestDesc(cur, true);
      if (!desc) {
        return null;
      }
      if (desc.node.isBlock && desc.parent) {
        var rect = desc.dom.getBoundingClientRect();
        if (rect.left > coords.left || rect.top > coords.top) {
          outside = desc.posBefore;
        } else if (rect.right < coords.left || rect.bottom < coords.top) {
          outside = desc.posAfter;
        } else {
          break;
        }
      }
      cur = desc.dom.parentNode;
    }
    return outside > -1 ? outside : view.docView.posFromDOM(node5, offset4);
  }
  function elementFromPoint(element, coords, box) {
    var len = element.childNodes.length;
    if (len && box.top < box.bottom) {
      for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
        var child5 = element.childNodes[i];
        if (child5.nodeType == 1) {
          var rects = child5.getClientRects();
          for (var j = 0; j < rects.length; j++) {
            var rect = rects[j];
            if (inRect(coords, rect)) {
              return elementFromPoint(child5, coords, rect);
            }
          }
        }
        if ((i = (i + 1) % len) == startI) {
          break;
        }
      }
    }
    return element;
  }
  function posAtCoords(view, coords) {
    var assign, assign$1;
    var doc2 = view.dom.ownerDocument, node5, offset4;
    if (doc2.caretPositionFromPoint) {
      try {
        var pos$1 = doc2.caretPositionFromPoint(coords.left, coords.top);
        if (pos$1) {
          assign = pos$1, node5 = assign.offsetNode, offset4 = assign.offset;
        }
      } catch (_) {
      }
    }
    if (!node5 && doc2.caretRangeFromPoint) {
      var range = doc2.caretRangeFromPoint(coords.left, coords.top);
      if (range) {
        assign$1 = range, node5 = assign$1.startContainer, offset4 = assign$1.startOffset;
      }
    }
    var elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top + 1), pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
      var box = view.dom.getBoundingClientRect();
      if (!inRect(coords, box)) {
        return null;
      }
      elt = elementFromPoint(view.dom, coords, box);
      if (!elt) {
        return null;
      }
    }
    if (result.safari) {
      for (var p = elt; node5 && p; p = parentNode(p)) {
        if (p.draggable) {
          node5 = offset4 = null;
        }
      }
    }
    elt = targetKludge(elt, coords);
    if (node5) {
      if (result.gecko && node5.nodeType == 1) {
        offset4 = Math.min(offset4, node5.childNodes.length);
        if (offset4 < node5.childNodes.length) {
          var next = node5.childNodes[offset4], box$1;
          if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
            offset4++;
          }
        }
      }
      if (node5 == view.dom && offset4 == node5.childNodes.length - 1 && node5.lastChild.nodeType == 1 && coords.top > node5.lastChild.getBoundingClientRect().bottom) {
        pos = view.state.doc.content.size;
      } else if (offset4 == 0 || node5.nodeType != 1 || node5.childNodes[offset4 - 1].nodeName != "BR") {
        pos = posFromCaret(view, node5, offset4, coords);
      }
    }
    if (pos == null) {
      pos = posFromElement(view, elt, coords);
    }
    var desc = view.docView.nearestDesc(elt, true);
    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
  }
  function singleRect(object, bias) {
    var rects = object.getClientRects();
    return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
  }
  var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function coordsAtPos(view, pos, side) {
    var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
    var node5 = ref.node;
    var offset4 = ref.offset;
    var supportEmptyRange = result.webkit || result.gecko;
    if (node5.nodeType == 3) {
      if (supportEmptyRange && (BIDI.test(node5.nodeValue) || (side < 0 ? !offset4 : offset4 == node5.nodeValue.length))) {
        var rect = singleRect(textRange(node5, offset4, offset4), side);
        if (result.gecko && offset4 && /\s/.test(node5.nodeValue[offset4 - 1]) && offset4 < node5.nodeValue.length) {
          var rectBefore = singleRect(textRange(node5, offset4 - 1, offset4 - 1), -1);
          if (rectBefore.top == rect.top) {
            var rectAfter = singleRect(textRange(node5, offset4, offset4 + 1), -1);
            if (rectAfter.top != rect.top) {
              return flattenV(rectAfter, rectAfter.left < rectBefore.left);
            }
          }
        }
        return rect;
      } else {
        var from5 = offset4, to = offset4, takeSide = side < 0 ? 1 : -1;
        if (side < 0 && !offset4) {
          to++;
          takeSide = -1;
        } else if (side >= 0 && offset4 == node5.nodeValue.length) {
          from5--;
          takeSide = 1;
        } else if (side < 0) {
          from5--;
        } else {
          to++;
        }
        return flattenV(singleRect(textRange(node5, from5, to), takeSide), takeSide < 0);
      }
    }
    if (!view.state.doc.resolve(pos).parent.inlineContent) {
      if (offset4 && (side < 0 || offset4 == nodeSize(node5))) {
        var before3 = node5.childNodes[offset4 - 1];
        if (before3.nodeType == 1) {
          return flattenH(before3.getBoundingClientRect(), false);
        }
      }
      if (offset4 < nodeSize(node5)) {
        var after3 = node5.childNodes[offset4];
        if (after3.nodeType == 1) {
          return flattenH(after3.getBoundingClientRect(), true);
        }
      }
      return flattenH(node5.getBoundingClientRect(), side >= 0);
    }
    if (offset4 && (side < 0 || offset4 == nodeSize(node5))) {
      var before$1 = node5.childNodes[offset4 - 1];
      var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
      if (target) {
        return flattenV(singleRect(target, 1), false);
      }
    }
    if (offset4 < nodeSize(node5)) {
      var after$1 = node5.childNodes[offset4];
      while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) {
        after$1 = after$1.nextSibling;
      }
      var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
      if (target$1) {
        return flattenV(singleRect(target$1, -1), true);
      }
    }
    return flattenV(singleRect(node5.nodeType == 3 ? textRange(node5) : node5, -side), side >= 0);
  }
  function flattenV(rect, left2) {
    if (rect.width == 0) {
      return rect;
    }
    var x = left2 ? rect.left : rect.right;
    return { top: rect.top, bottom: rect.bottom, left: x, right: x };
  }
  function flattenH(rect, top2) {
    if (rect.height == 0) {
      return rect;
    }
    var y = top2 ? rect.top : rect.bottom;
    return { top: y, bottom: y, left: rect.left, right: rect.right };
  }
  function withFlushedState(view, state, f) {
    var viewState = view.state, active = view.root.activeElement;
    if (viewState != state) {
      view.updateState(state);
    }
    if (active != view.dom) {
      view.focus();
    }
    try {
      return f();
    } finally {
      if (viewState != state) {
        view.updateState(viewState);
      }
      if (active != view.dom && active) {
        active.focus();
      }
    }
  }
  function endOfTextblockVertical(view, state, dir) {
    var sel = state.selection;
    var $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, function() {
      var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
      var dom = ref.node;
      for (; ; ) {
        var nearest = view.docView.nearestDesc(dom, true);
        if (!nearest) {
          break;
        }
        if (nearest.node.isBlock) {
          dom = nearest.dom;
          break;
        }
        dom = nearest.dom.parentNode;
      }
      var coords = coordsAtPos(view, $pos.pos, 1);
      for (var child5 = dom.firstChild; child5; child5 = child5.nextSibling) {
        var boxes = void 0;
        if (child5.nodeType == 1) {
          boxes = child5.getClientRects();
        } else if (child5.nodeType == 3) {
          boxes = textRange(child5, 0, child5.nodeValue.length).getClientRects();
        } else {
          continue;
        }
        for (var i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) {
            return false;
          }
        }
      }
      return true;
    });
  }
  var maybeRTL = /[\u0590-\u08ac]/;
  function endOfTextblockHorizontal(view, state, dir) {
    var ref = state.selection;
    var $head = ref.$head;
    if (!$head.parent.isTextblock) {
      return false;
    }
    var offset4 = $head.parentOffset, atStart3 = !offset4, atEnd3 = offset4 == $head.parent.content.size;
    var sel = view.root.getSelection();
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
      return dir == "left" || dir == "backward" ? atStart3 : atEnd3;
    }
    return withFlushedState(view, state, function() {
      var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
      var oldBidiLevel = sel.caretBidiLevel;
      sel.modify("move", dir, "character");
      var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
      var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
      sel.removeAllRanges();
      sel.addRange(oldRange);
      if (oldBidiLevel != null) {
        sel.caretBidiLevel = oldBidiLevel;
      }
      return result2;
    });
  }
  var cachedState = null;
  var cachedDir = null;
  var cachedResult = false;
  function endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir) {
      return cachedResult;
    }
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
  }
  var NOT_DIRTY = 0;
  var CHILD_DIRTY = 1;
  var CONTENT_DIRTY = 2;
  var NODE_DIRTY = 3;
  var ViewDesc = function ViewDesc2(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    dom.pmViewDesc = this;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
  };
  var prototypeAccessors4 = { size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
  ViewDesc.prototype.matchesWidget = function matchesWidget() {
    return false;
  };
  ViewDesc.prototype.matchesMark = function matchesMark() {
    return false;
  };
  ViewDesc.prototype.matchesNode = function matchesNode() {
    return false;
  };
  ViewDesc.prototype.matchesHack = function matchesHack(_nodeName) {
    return false;
  };
  ViewDesc.prototype.parseRule = function parseRule() {
    return null;
  };
  ViewDesc.prototype.stopEvent = function stopEvent() {
    return false;
  };
  prototypeAccessors4.size.get = function() {
    var size = 0;
    for (var i = 0; i < this.children.length; i++) {
      size += this.children[i].size;
    }
    return size;
  };
  prototypeAccessors4.border.get = function() {
    return 0;
  };
  ViewDesc.prototype.destroy = function destroy2() {
    this.parent = null;
    if (this.dom.pmViewDesc == this) {
      this.dom.pmViewDesc = null;
    }
    for (var i = 0; i < this.children.length; i++) {
      this.children[i].destroy();
    }
  };
  ViewDesc.prototype.posBeforeChild = function posBeforeChild(child5) {
    for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
      var cur = this.children[i];
      if (cur == child5) {
        return pos;
      }
      pos += cur.size;
    }
  };
  prototypeAccessors4.posBefore.get = function() {
    return this.parent.posBeforeChild(this);
  };
  prototypeAccessors4.posAtStart.get = function() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  };
  prototypeAccessors4.posAfter.get = function() {
    return this.posBefore + this.size;
  };
  prototypeAccessors4.posAtEnd.get = function() {
    return this.posAtStart + this.size - 2 * this.border;
  };
  ViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset4, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        var domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset4 - 1];
        } else {
          while (dom.parentNode != this.contentDOM) {
            dom = dom.parentNode;
          }
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
          domBefore = domBefore.previousSibling;
        }
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        var domAfter, desc$1;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset4];
        } else {
          while (dom.parentNode != this.contentDOM) {
            dom = dom.parentNode;
          }
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
          domAfter = domAfter.nextSibling;
        }
        return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
      }
    }
    var atEnd3;
    if (dom == this.dom && this.contentDOM) {
      atEnd3 = offset4 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd3 = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset4 == 0) {
        for (var search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd3 = false;
            break;
          }
          if (search.parentNode.firstChild != search) {
            break;
          }
        }
      }
      if (atEnd3 == null && offset4 == dom.childNodes.length) {
        for (var search$1 = dom; ; search$1 = search$1.parentNode) {
          if (search$1 == this.dom) {
            atEnd3 = true;
            break;
          }
          if (search$1.parentNode.lastChild != search$1) {
            break;
          }
        }
      }
    }
    return (atEnd3 == null ? bias > 0 : atEnd3) ? this.posAtEnd : this.posAtStart;
  };
  ViewDesc.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
    for (var first2 = true, cur = dom; cur; cur = cur.parentNode) {
      var desc = this.getDesc(cur);
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
          first2 = false;
        } else {
          return desc;
        }
      }
    }
  };
  ViewDesc.prototype.getDesc = function getDesc(dom) {
    var desc = dom.pmViewDesc;
    for (var cur = desc; cur; cur = cur.parent) {
      if (cur == this) {
        return desc;
      }
    }
  };
  ViewDesc.prototype.posFromDOM = function posFromDOM(dom, offset4, bias) {
    for (var scan = dom; scan; scan = scan.parentNode) {
      var desc = this.getDesc(scan);
      if (desc) {
        return desc.localPosFromDOM(dom, offset4, bias);
      }
    }
    return -1;
  };
  ViewDesc.prototype.descAt = function descAt(pos) {
    for (var i = 0, offset4 = 0; i < this.children.length; i++) {
      var child5 = this.children[i], end4 = offset4 + child5.size;
      if (offset4 == pos && end4 != offset4) {
        while (!child5.border && child5.children.length) {
          child5 = child5.children[0];
        }
        return child5;
      }
      if (pos < end4) {
        return child5.descAt(pos - offset4 - child5.border);
      }
      offset4 = end4;
    }
  };
  ViewDesc.prototype.domFromPos = function domFromPos(pos, side) {
    if (!this.contentDOM) {
      return { node: this.dom, offset: 0 };
    }
    var i = 0, offset4 = 0;
    for (var curPos = 0; i < this.children.length; i++) {
      var child5 = this.children[i], end4 = curPos + child5.size;
      if (end4 > pos || child5 instanceof TrailingHackViewDesc) {
        offset4 = pos - curPos;
        break;
      }
      curPos = end4;
    }
    if (offset4) {
      return this.children[i].domFromPos(offset4 - this.children[i].border, side);
    }
    for (var prev = void 0; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i--) {
    }
    if (side <= 0) {
      var prev$1, enter4 = true;
      for (; ; i--, enter4 = false) {
        prev$1 = i ? this.children[i - 1] : null;
        if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) {
          break;
        }
      }
      if (prev$1 && side && enter4 && !prev$1.border && !prev$1.domAtom) {
        return prev$1.domFromPos(prev$1.size, side);
      }
      return { node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0 };
    } else {
      var next, enter$12 = true;
      for (; ; i++, enter$12 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM) {
          break;
        }
      }
      if (next && enter$12 && !next.border && !next.domAtom) {
        return next.domFromPos(0, side);
      }
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  };
  ViewDesc.prototype.parseRange = function parseRange(from5, to, base2) {
    if (base2 === void 0)
      base2 = 0;
    if (this.children.length == 0) {
      return { node: this.contentDOM, from: from5, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    }
    var fromOffset = -1, toOffset = -1;
    for (var offset4 = base2, i = 0; ; i++) {
      var child5 = this.children[i], end4 = offset4 + child5.size;
      if (fromOffset == -1 && from5 <= end4) {
        var childBase = offset4 + child5.border;
        if (from5 >= childBase && to <= end4 - child5.border && child5.node && child5.contentDOM && this.contentDOM.contains(child5.contentDOM)) {
          return child5.parseRange(from5, to, childBase);
        }
        from5 = offset4;
        for (var j = i; j > 0; j--) {
          var prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from5 -= prev.size;
        }
        if (fromOffset == -1) {
          fromOffset = 0;
        }
      }
      if (fromOffset > -1 && (end4 > to || i == this.children.length - 1)) {
        to = end4;
        for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
          var next = this.children[j$1];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1) {
          toOffset = this.contentDOM.childNodes.length;
        }
        break;
      }
      offset4 = end4;
    }
    return { node: this.contentDOM, from: from5, to, fromOffset, toOffset };
  };
  ViewDesc.prototype.emptyChildAt = function emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length) {
      return false;
    }
    var child5 = this.children[side < 0 ? 0 : this.children.length - 1];
    return child5.size == 0 || child5.emptyChildAt(side);
  };
  ViewDesc.prototype.domAfterPos = function domAfterPos(pos) {
    var ref = this.domFromPos(pos, 0);
    var node5 = ref.node;
    var offset4 = ref.offset;
    if (node5.nodeType != 1 || offset4 == node5.childNodes.length) {
      throw new RangeError("No node after pos " + pos);
    }
    return node5.childNodes[offset4];
  };
  ViewDesc.prototype.setSelection = function setSelection(anchor, head, root, force) {
    var from5 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (var i = 0, offset4 = 0; i < this.children.length; i++) {
      var child5 = this.children[i], end4 = offset4 + child5.size;
      if (from5 > offset4 && to < end4) {
        return child5.setSelection(anchor - offset4 - child5.border, head - offset4 - child5.border, root, force);
      }
      offset4 = end4;
    }
    var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    var domSel = root.getSelection();
    var brKludge = false;
    if ((result.gecko || result.safari) && anchor == head) {
      var node5 = anchorDOM.node;
      var offset$1 = anchorDOM.offset;
      if (node5.nodeType == 3) {
        brKludge = offset$1 && node5.nodeValue[offset$1 - 1] == "\n";
        if (brKludge && offset$1 == node5.nodeValue.length) {
          for (var scan = node5, after3 = void 0; scan; scan = scan.parentNode) {
            if (after3 = scan.nextSibling) {
              if (after3.nodeName == "BR") {
                anchorDOM = headDOM = { node: after3.parentNode, offset: domIndex(after3) + 1 };
              }
              break;
            }
            var desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock) {
              break;
            }
          }
        }
      } else {
        var prev = node5.childNodes[offset$1 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after$1 && after$1.contentEditable == "false") {
        force = true;
      }
    }
    if (!(force || brKludge && result.safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
      return;
    }
    var domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head) {
          domSel.extend(headDOM.node, headDOM.offset);
        }
        domSelExtended = true;
      } catch (err3) {
        if (!(err3 instanceof DOMException)) {
          throw err3;
        }
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        var tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      var range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  };
  ViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  };
  prototypeAccessors4.contentLost.get = function() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  };
  ViewDesc.prototype.markDirty = function markDirty(from5, to) {
    for (var offset4 = 0, i = 0; i < this.children.length; i++) {
      var child5 = this.children[i], end4 = offset4 + child5.size;
      if (offset4 == end4 ? from5 <= end4 && to >= offset4 : from5 < end4 && to > offset4) {
        var startInside = offset4 + child5.border, endInside = end4 - child5.border;
        if (from5 >= startInside && to <= endInside) {
          this.dirty = from5 == offset4 || to == end4 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from5 == startInside && to == endInside && (child5.contentLost || child5.dom.parentNode != this.contentDOM)) {
            child5.dirty = NODE_DIRTY;
          } else {
            child5.markDirty(from5 - startInside, to - startInside);
          }
          return;
        } else {
          child5.dirty = child5.dom == child5.contentDOM && child5.dom.parentNode == this.contentDOM && !child5.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset4 = end4;
    }
    this.dirty = CONTENT_DIRTY;
  };
  ViewDesc.prototype.markParentsDirty = function markParentsDirty() {
    var level = 1;
    for (var node5 = this.parent; node5; node5 = node5.parent, level++) {
      var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node5.dirty < dirty) {
        node5.dirty = dirty;
      }
    }
  };
  prototypeAccessors4.domAtom.get = function() {
    return false;
  };
  prototypeAccessors4.ignoreForCoords.get = function() {
    return false;
  };
  Object.defineProperties(ViewDesc.prototype, prototypeAccessors4);
  var nothing = [];
  var WidgetViewDesc = /* @__PURE__ */ function(ViewDesc3) {
    function WidgetViewDesc2(parent, widget2, view, pos) {
      var self2, dom = widget2.type.toDOM;
      if (typeof dom == "function") {
        dom = dom(view, function() {
          if (!self2) {
            return pos;
          }
          if (self2.parent) {
            return self2.parent.posBeforeChild(self2);
          }
        });
      }
      if (!widget2.type.spec.raw) {
        if (dom.nodeType != 1) {
          var wrap = document.createElement("span");
          wrap.appendChild(dom);
          dom = wrap;
        }
        dom.contentEditable = false;
        dom.classList.add("ProseMirror-widget");
      }
      ViewDesc3.call(this, parent, nothing, dom, null);
      this.widget = widget2;
      self2 = this;
    }
    if (ViewDesc3)
      WidgetViewDesc2.__proto__ = ViewDesc3;
    WidgetViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
    WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
    var prototypeAccessors$16 = { domAtom: { configurable: true } };
    WidgetViewDesc2.prototype.matchesWidget = function matchesWidget2(widget2) {
      return this.dirty == NOT_DIRTY && widget2.type.eq(this.widget.type);
    };
    WidgetViewDesc2.prototype.parseRule = function parseRule2() {
      return { ignore: true };
    };
    WidgetViewDesc2.prototype.stopEvent = function stopEvent2(event) {
      var stop2 = this.widget.spec.stopEvent;
      return stop2 ? stop2(event) : false;
    };
    WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    };
    WidgetViewDesc2.prototype.destroy = function destroy6() {
      this.widget.type.destroy(this.dom);
      ViewDesc3.prototype.destroy.call(this);
    };
    prototypeAccessors$16.domAtom.get = function() {
      return true;
    };
    Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$16);
    return WidgetViewDesc2;
  }(ViewDesc);
  var CompositionViewDesc = /* @__PURE__ */ function(ViewDesc3) {
    function CompositionViewDesc2(parent, dom, textDOM, text4) {
      ViewDesc3.call(this, parent, nothing, dom, null);
      this.textDOM = textDOM;
      this.text = text4;
    }
    if (ViewDesc3)
      CompositionViewDesc2.__proto__ = ViewDesc3;
    CompositionViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
    CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
    var prototypeAccessors$24 = { size: { configurable: true } };
    prototypeAccessors$24.size.get = function() {
      return this.text.length;
    };
    CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset4) {
      if (dom != this.textDOM) {
        return this.posAtStart + (offset4 ? this.size : 0);
      }
      return this.posAtStart + offset4;
    };
    CompositionViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
      return { node: this.textDOM, offset: pos };
    };
    CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mut) {
      return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
    };
    Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$24);
    return CompositionViewDesc2;
  }(ViewDesc);
  var MarkViewDesc = /* @__PURE__ */ function(ViewDesc3) {
    function MarkViewDesc2(parent, mark4, dom, contentDOM) {
      ViewDesc3.call(this, parent, [], dom, contentDOM);
      this.mark = mark4;
    }
    if (ViewDesc3)
      MarkViewDesc2.__proto__ = ViewDesc3;
    MarkViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
    MarkViewDesc2.prototype.constructor = MarkViewDesc2;
    MarkViewDesc2.create = function create9(parent, mark4, inline2, view) {
      var custom = view.nodeViews[mark4.type.name];
      var spec = custom && custom(mark4, view, inline2);
      if (!spec || !spec.dom) {
        spec = DOMSerializer.renderSpec(document, mark4.type.spec.toDOM(mark4, inline2));
      }
      return new MarkViewDesc2(parent, mark4, spec.dom, spec.contentDOM || spec.dom);
    };
    MarkViewDesc2.prototype.parseRule = function parseRule2() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) {
        return null;
      }
      return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
    };
    MarkViewDesc2.prototype.matchesMark = function matchesMark2(mark4) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark4);
    };
    MarkViewDesc2.prototype.markDirty = function markDirty2(from5, to) {
      ViewDesc3.prototype.markDirty.call(this, from5, to);
      if (this.dirty != NOT_DIRTY) {
        var parent = this.parent;
        while (!parent.node) {
          parent = parent.parent;
        }
        if (parent.dirty < this.dirty) {
          parent.dirty = this.dirty;
        }
        this.dirty = NOT_DIRTY;
      }
    };
    MarkViewDesc2.prototype.slice = function slice6(from5, to, view) {
      var copy7 = MarkViewDesc2.create(this.parent, this.mark, true, view);
      var nodes = this.children, size = this.size;
      if (to < size) {
        nodes = replaceNodes(nodes, to, size, view);
      }
      if (from5 > 0) {
        nodes = replaceNodes(nodes, 0, from5, view);
      }
      for (var i = 0; i < nodes.length; i++) {
        nodes[i].parent = copy7;
      }
      copy7.children = nodes;
      return copy7;
    };
    return MarkViewDesc2;
  }(ViewDesc);
  var NodeViewDesc = /* @__PURE__ */ function(ViewDesc3) {
    function NodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos) {
      ViewDesc3.call(this, parent, node5.isLeaf ? nothing : [], dom, contentDOM);
      this.nodeDOM = nodeDOM2;
      this.node = node5;
      this.outerDeco = outerDeco;
      this.innerDeco = innerDeco;
      if (contentDOM) {
        this.updateChildren(view, pos);
      }
    }
    if (ViewDesc3)
      NodeViewDesc2.__proto__ = ViewDesc3;
    NodeViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
    NodeViewDesc2.prototype.constructor = NodeViewDesc2;
    var prototypeAccessors$33 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
    NodeViewDesc2.create = function create9(parent, node5, outerDeco, innerDeco, view, pos) {
      var assign;
      var custom = view.nodeViews[node5.type.name], descObj;
      var spec = custom && custom(node5, view, function() {
        if (!descObj) {
          return pos;
        }
        if (descObj.parent) {
          return descObj.parent.posBeforeChild(descObj);
        }
      }, outerDeco, innerDeco);
      var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
      if (node5.isText) {
        if (!dom) {
          dom = document.createTextNode(node5.text);
        } else if (dom.nodeType != 3) {
          throw new RangeError("Text must be rendered as a DOM text node");
        }
      } else if (!dom) {
        assign = DOMSerializer.renderSpec(document, node5.type.spec.toDOM(node5)), dom = assign.dom, contentDOM = assign.contentDOM;
      }
      if (!contentDOM && !node5.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable")) {
          dom.contentEditable = false;
        }
        if (node5.type.spec.draggable) {
          dom.draggable = true;
        }
      }
      var nodeDOM2 = dom;
      dom = applyOuterDeco(dom, outerDeco, node5);
      if (spec) {
        return descObj = new CustomNodeViewDesc(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos + 1);
      } else if (node5.isText) {
        return new TextViewDesc(parent, node5, outerDeco, innerDeco, dom, nodeDOM2, view);
      } else {
        return new NodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos + 1);
      }
    };
    NodeViewDesc2.prototype.parseRule = function parseRule2() {
      var this$1 = this;
      if (this.node.type.spec.reparseInView) {
        return null;
      }
      var rule = { node: this.node.type.name, attrs: this.node.attrs };
      if (this.node.type.whitespace == "pre") {
        rule.preserveWhitespace = "full";
      }
      if (this.contentDOM && !this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        rule.getContent = function() {
          return this$1.contentDOM ? Fragment.empty : this$1.node.content;
        };
      }
      return rule;
    };
    NodeViewDesc2.prototype.matchesNode = function matchesNode2(node5, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node5.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    };
    prototypeAccessors$33.size.get = function() {
      return this.node.nodeSize;
    };
    prototypeAccessors$33.border.get = function() {
      return this.node.isLeaf ? 0 : 1;
    };
    NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
      var this$1 = this;
      var inline2 = this.node.inlineContent, off = pos;
      var composition = view.composing && this.localCompositionInfo(view, pos);
      var localComposition = composition && composition.pos > -1 ? composition : null;
      var compositionInChild = composition && composition.pos < 0;
      var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
      iterDeco(this.node, this.innerDeco, function(widget2, i, insideNode) {
        if (widget2.spec.marks) {
          updater.syncToMarks(widget2.spec.marks, inline2, view);
        } else if (widget2.type.side >= 0 && !insideNode) {
          updater.syncToMarks(i == this$1.node.childCount ? Mark.none : this$1.node.child(i).marks, inline2, view);
        }
        updater.placeWidget(widget2, view, off);
      }, function(child5, outerDeco, innerDeco, i) {
        updater.syncToMarks(child5.marks, inline2, view);
        var compIndex;
        if (updater.findNodeMatch(child5, outerDeco, innerDeco, i))
          ;
        else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child5.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child5, outerDeco, innerDeco, compIndex, view))
          ;
        else if (updater.updateNextNode(child5, outerDeco, innerDeco, view, i))
          ;
        else {
          updater.addNode(child5, outerDeco, innerDeco, view, off);
        }
        off += child5.nodeSize;
      });
      updater.syncToMarks(nothing, inline2, view);
      if (this.node.isTextblock) {
        updater.addTextblockHacks();
      }
      updater.destroyRest();
      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition) {
          this.protectLocalComposition(view, localComposition);
        }
        renderDescs(this.contentDOM, this.children, view);
        if (result.ios) {
          iosHacks(this.dom);
        }
      }
    };
    NodeViewDesc2.prototype.localCompositionInfo = function localCompositionInfo(view, pos) {
      var ref = view.state.selection;
      var from5 = ref.from;
      var to = ref.to;
      if (!(view.state.selection instanceof TextSelection) || from5 < pos || to > pos + this.node.content.size) {
        return;
      }
      var sel = view.root.getSelection();
      var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
      if (!textNode || !this.dom.contains(textNode.parentNode)) {
        return;
      }
      if (this.node.inlineContent) {
        var text4 = textNode.nodeValue;
        var textPos = findTextInFragment(this.node.content, text4, from5 - pos, to - pos);
        return textPos < 0 ? null : { node: textNode, pos: textPos, text: text4 };
      } else {
        return { node: textNode, pos: -1 };
      }
    };
    NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref) {
      var node5 = ref.node;
      var pos = ref.pos;
      var text4 = ref.text;
      if (this.getDesc(node5)) {
        return;
      }
      var topNode = node5;
      for (; ; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM) {
          break;
        }
        while (topNode.previousSibling) {
          topNode.parentNode.removeChild(topNode.previousSibling);
        }
        while (topNode.nextSibling) {
          topNode.parentNode.removeChild(topNode.nextSibling);
        }
        if (topNode.pmViewDesc) {
          topNode.pmViewDesc = null;
        }
      }
      var desc = new CompositionViewDesc(this, topNode, node5, text4);
      view.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text4.length, view, desc);
    };
    NodeViewDesc2.prototype.update = function update4(node5, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node5.sameMarkup(this.node)) {
        return false;
      }
      this.updateInner(node5, outerDeco, innerDeco, view);
      return true;
    };
    NodeViewDesc2.prototype.updateInner = function updateInner(node5, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node5;
      this.innerDeco = innerDeco;
      if (this.contentDOM) {
        this.updateChildren(view, this.posAtStart);
      }
      this.dirty = NOT_DIRTY;
    };
    NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco)) {
        return;
      }
      var needsWrap = this.nodeDOM.nodeType != 1;
      var oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = null;
        this.dom.pmViewDesc = this;
      }
      this.outerDeco = outerDeco;
    };
    NodeViewDesc2.prototype.selectNode = function selectNode() {
      this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) {
        this.dom.draggable = true;
      }
    };
    NodeViewDesc2.prototype.deselectNode = function deselectNode() {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) {
        this.dom.removeAttribute("draggable");
      }
    };
    prototypeAccessors$33.domAtom.get = function() {
      return this.node.isAtom;
    };
    Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$33);
    return NodeViewDesc2;
  }(ViewDesc);
  function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc2);
    return new NodeViewDesc(null, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
  }
  var TextViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
    function TextViewDesc2(parent, node5, outerDeco, innerDeco, dom, nodeDOM2, view) {
      NodeViewDesc2.call(this, parent, node5, outerDeco, innerDeco, dom, null, nodeDOM2, view);
    }
    if (NodeViewDesc2)
      TextViewDesc2.__proto__ = NodeViewDesc2;
    TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
    TextViewDesc2.prototype.constructor = TextViewDesc2;
    var prototypeAccessors$43 = { domAtom: { configurable: true } };
    TextViewDesc2.prototype.parseRule = function parseRule2() {
      var skip = this.nodeDOM.parentNode;
      while (skip && skip != this.dom && !skip.pmIsDeco) {
        skip = skip.parentNode;
      }
      return { skip: skip || true };
    };
    TextViewDesc2.prototype.update = function update4(node5, outerDeco, _, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node5.sameMarkup(this.node)) {
        return false;
      }
      this.updateOuterDeco(outerDeco);
      if ((this.dirty != NOT_DIRTY || node5.text != this.node.text) && node5.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node5.text;
        if (view.trackWrites == this.nodeDOM) {
          view.trackWrites = null;
        }
      }
      this.node = node5;
      this.dirty = NOT_DIRTY;
      return true;
    };
    TextViewDesc2.prototype.inParent = function inParent() {
      var parentDOM = this.parent.contentDOM;
      for (var n = this.nodeDOM; n; n = n.parentNode) {
        if (n == parentDOM) {
          return true;
        }
      }
      return false;
    };
    TextViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
      return { node: this.nodeDOM, offset: pos };
    };
    TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset4, bias) {
      if (dom == this.nodeDOM) {
        return this.posAtStart + Math.min(offset4, this.node.text.length);
      }
      return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset4, bias);
    };
    TextViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    };
    TextViewDesc2.prototype.slice = function slice6(from5, to, view) {
      var node5 = this.node.cut(from5, to), dom = document.createTextNode(node5.text);
      return new TextViewDesc2(this.parent, node5, this.outerDeco, this.innerDeco, dom, dom, view);
    };
    TextViewDesc2.prototype.markDirty = function markDirty2(from5, to) {
      NodeViewDesc2.prototype.markDirty.call(this, from5, to);
      if (this.dom != this.nodeDOM && (from5 == 0 || to == this.nodeDOM.nodeValue.length)) {
        this.dirty = NODE_DIRTY;
      }
    };
    prototypeAccessors$43.domAtom.get = function() {
      return false;
    };
    Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$43);
    return TextViewDesc2;
  }(NodeViewDesc);
  var TrailingHackViewDesc = /* @__PURE__ */ function(ViewDesc3) {
    function TrailingHackViewDesc2() {
      ViewDesc3.apply(this, arguments);
    }
    if (ViewDesc3)
      TrailingHackViewDesc2.__proto__ = ViewDesc3;
    TrailingHackViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
    TrailingHackViewDesc2.prototype.constructor = TrailingHackViewDesc2;
    var prototypeAccessors$53 = { domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
    TrailingHackViewDesc2.prototype.parseRule = function parseRule2() {
      return { ignore: true };
    };
    TrailingHackViewDesc2.prototype.matchesHack = function matchesHack2(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    };
    prototypeAccessors$53.domAtom.get = function() {
      return true;
    };
    prototypeAccessors$53.ignoreForCoords.get = function() {
      return this.dom.nodeName == "IMG";
    };
    Object.defineProperties(TrailingHackViewDesc2.prototype, prototypeAccessors$53);
    return TrailingHackViewDesc2;
  }(ViewDesc);
  var CustomNodeViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
    function CustomNodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos) {
      NodeViewDesc2.call(this, parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos);
      this.spec = spec;
    }
    if (NodeViewDesc2)
      CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
    CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
    CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
    CustomNodeViewDesc2.prototype.update = function update4(node5, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY) {
        return false;
      }
      if (this.spec.update) {
        var result2 = this.spec.update(node5, outerDeco, innerDeco);
        if (result2) {
          this.updateInner(node5, outerDeco, innerDeco, view);
        }
        return result2;
      } else if (!this.contentDOM && !node5.isLeaf) {
        return false;
      } else {
        return NodeViewDesc2.prototype.update.call(this, node5, outerDeco, innerDeco, view);
      }
    };
    CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
    };
    CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
    };
    CustomNodeViewDesc2.prototype.setSelection = function setSelection2(anchor, head, root, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root, force);
    };
    CustomNodeViewDesc2.prototype.destroy = function destroy6() {
      if (this.spec.destroy) {
        this.spec.destroy();
      }
      NodeViewDesc2.prototype.destroy.call(this);
    };
    CustomNodeViewDesc2.prototype.stopEvent = function stopEvent2(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    };
    CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
    };
    return CustomNodeViewDesc2;
  }(NodeViewDesc);
  function renderDescs(parentDOM, descs, view) {
    var dom = parentDOM.firstChild, written = false;
    for (var i = 0; i < descs.length; i++) {
      var desc = descs[i], childDOM = desc.dom;
      if (childDOM.parentNode == parentDOM) {
        while (childDOM != dom) {
          dom = rm(dom);
          written = true;
        }
        dom = dom.nextSibling;
      } else {
        written = true;
        parentDOM.insertBefore(childDOM, dom);
      }
      if (desc instanceof MarkViewDesc) {
        var pos = dom ? dom.previousSibling : parentDOM.lastChild;
        renderDescs(desc.contentDOM, desc.children, view);
        dom = pos ? pos.nextSibling : parentDOM.firstChild;
      }
    }
    while (dom) {
      dom = rm(dom);
      written = true;
    }
    if (written && view.trackWrites == parentDOM) {
      view.trackWrites = null;
    }
  }
  function OuterDecoLevel(nodeName) {
    if (nodeName) {
      this.nodeName = nodeName;
    }
  }
  OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
  var noDeco = [new OuterDecoLevel()];
  function computeOuterDeco(outerDeco, node5, needsWrap) {
    if (outerDeco.length == 0) {
      return noDeco;
    }
    var top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top2];
    for (var i = 0; i < outerDeco.length; i++) {
      var attrs = outerDeco[i].type.attrs;
      if (!attrs) {
        continue;
      }
      if (attrs.nodeName) {
        result2.push(top2 = new OuterDecoLevel(attrs.nodeName));
      }
      for (var name in attrs) {
        var val = attrs[name];
        if (val == null) {
          continue;
        }
        if (needsWrap && result2.length == 1) {
          result2.push(top2 = new OuterDecoLevel(node5.isInline ? "span" : "div"));
        }
        if (name == "class") {
          top2.class = (top2.class ? top2.class + " " : "") + val;
        } else if (name == "style") {
          top2.style = (top2.style ? top2.style + ";" : "") + val;
        } else if (name != "nodeName") {
          top2[name] = val;
        }
      }
    }
    return result2;
  }
  function patchOuterDeco(outerDOM, nodeDOM2, prevComputed, curComputed) {
    if (prevComputed == noDeco && curComputed == noDeco) {
      return nodeDOM2;
    }
    var curDOM = nodeDOM2;
    for (var i = 0; i < curComputed.length; i++) {
      var deco = curComputed[i], prev = prevComputed[i];
      if (i) {
        var parent = void 0;
        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
          curDOM = parent;
        } else {
          parent = document.createElement(deco.nodeName);
          parent.pmIsDeco = true;
          parent.appendChild(curDOM);
          prev = noDeco[0];
          curDOM = parent;
        }
      }
      patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
  }
  function patchAttributes(dom, prev, cur) {
    for (var name in prev) {
      if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
        dom.removeAttribute(name);
      }
    }
    for (var name$1 in cur) {
      if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
        dom.setAttribute(name$1, cur[name$1]);
      }
    }
    if (prev.class != cur.class) {
      var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
      var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
      for (var i = 0; i < prevList.length; i++) {
        if (curList.indexOf(prevList[i]) == -1) {
          dom.classList.remove(prevList[i]);
        }
      }
      for (var i$1 = 0; i$1 < curList.length; i$1++) {
        if (prevList.indexOf(curList[i$1]) == -1) {
          dom.classList.add(curList[i$1]);
        }
      }
      if (dom.classList.length == 0) {
        dom.removeAttribute("class");
      }
    }
    if (prev.style != cur.style) {
      if (prev.style) {
        var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
        while (m = prop.exec(prev.style)) {
          dom.style.removeProperty(m[1]);
        }
      }
      if (cur.style) {
        dom.style.cssText += cur.style;
      }
    }
  }
  function applyOuterDeco(dom, deco, node5) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node5, dom.nodeType != 1));
  }
  function sameOuterDeco(a, b) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!a[i].type.eq(b[i].type)) {
        return false;
      }
    }
    return true;
  }
  function rm(dom) {
    var next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ViewTreeUpdater = function ViewTreeUpdater2(top2, lockedNode) {
    this.top = top2;
    this.lock = lockedNode;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.preMatch = preMatch(top2.node.content, top2);
  };
  ViewTreeUpdater.prototype.destroyBetween = function destroyBetween(start6, end4) {
    if (start6 == end4) {
      return;
    }
    for (var i = start6; i < end4; i++) {
      this.top.children[i].destroy();
    }
    this.top.children.splice(start6, end4 - start6);
    this.changed = true;
  };
  ViewTreeUpdater.prototype.destroyRest = function destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  };
  ViewTreeUpdater.prototype.syncToMarks = function syncToMarks(marks3, inline2, view) {
    var keep = 0, depth = this.stack.length >> 1;
    var maxKeep = Math.min(depth, marks3.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks3[keep]) && marks3[keep].type.spec.spanning !== false) {
      keep++;
    }
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks3.length) {
      this.stack.push(this.top, this.index + 1);
      var found3 = -1;
      for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        if (this.top.children[i].matchesMark(marks3[depth])) {
          found3 = i;
          break;
        }
      }
      if (found3 > -1) {
        if (found3 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found3);
        }
        this.top = this.top.children[this.index];
      } else {
        var markDesc = MarkViewDesc.create(this.top, marks3[depth], inline2, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  };
  ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch(node5, outerDeco, innerDeco, index3) {
    var found3 = -1, targetDesc;
    if (index3 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index3 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node5, outerDeco, innerDeco)) {
      found3 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        var child5 = this.top.children[i];
        if (child5.matchesNode(node5, outerDeco, innerDeco) && !this.preMatch.matched.has(child5)) {
          found3 = i;
          break;
        }
      }
    }
    if (found3 < 0) {
      return false;
    }
    this.destroyBetween(this.index, found3);
    this.index++;
    return true;
  };
  ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt(node5, outerDeco, innerDeco, index3, view) {
    var child5 = this.top.children[index3];
    if (!child5.update(node5, outerDeco, innerDeco, view)) {
      return false;
    }
    this.destroyBetween(this.index, index3);
    this.index = index3 + 1;
    return true;
  };
  ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild(domNode) {
    for (; ; ) {
      var parent = domNode.parentNode;
      if (!parent) {
        return -1;
      }
      if (parent == this.top.contentDOM) {
        var desc = domNode.pmViewDesc;
        if (desc) {
          for (var i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc) {
              return i;
            }
          }
        }
        return -1;
      }
      domNode = parent;
    }
  };
  ViewTreeUpdater.prototype.updateNextNode = function updateNextNode(node5, outerDeco, innerDeco, view, index3) {
    for (var i = this.index; i < this.top.children.length; i++) {
      var next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        var preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index3) {
          return false;
        }
        var nextDOM = next.dom;
        var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node5.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node5.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node5, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM) {
            this.changed = true;
          }
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  };
  ViewTreeUpdater.prototype.addNode = function addNode2(node5, outerDeco, innerDeco, view, pos) {
    this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node5, outerDeco, innerDeco, view, pos));
    this.changed = true;
  };
  ViewTreeUpdater.prototype.placeWidget = function placeWidget(widget2, view, pos) {
    var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget2) && (widget2 == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      var desc = new WidgetViewDesc(this.top, widget2, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  };
  ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks() {
    var lastChild = this.top.children[this.index - 1];
    while (lastChild instanceof MarkViewDesc) {
      lastChild = lastChild.children[lastChild.children.length - 1];
    }
    if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
      if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == "false") {
        this.addHackNode("IMG");
      }
      this.addHackNode("BR");
    }
  };
  ViewTreeUpdater.prototype.addHackNode = function addHackNode(nodeName) {
    if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      var dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR") {
        dom.className = "ProseMirror-trailingBreak";
      }
      this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
      this.changed = true;
    }
  };
  function preMatch(frag, parentDesc) {
    var curDesc = parentDesc, descI = curDesc.children.length;
    var fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
    outer:
      while (fI > 0) {
        var desc = void 0;
        for (; ; ) {
          if (descI) {
            var next = curDesc.children[descI - 1];
            if (next instanceof MarkViewDesc) {
              curDesc = next;
              descI = next.children.length;
            } else {
              desc = next;
              descI--;
              break;
            }
          } else if (curDesc == parentDesc) {
            break outer;
          } else {
            descI = curDesc.parent.children.indexOf(curDesc);
            curDesc = curDesc.parent;
          }
        }
        var node5 = desc.node;
        if (!node5) {
          continue;
        }
        if (node5 != frag.child(fI - 1)) {
          break;
        }
        --fI;
        matched.set(desc, fI);
        matches2.push(desc);
      }
    return { index: fI, matched, matches: matches2.reverse() };
  }
  function compareSide(a, b) {
    return a.type.side - b.type.side;
  }
  function iterDeco(parent, deco, onWidget, onNode) {
    var locals3 = deco.locals(parent), offset4 = 0;
    if (locals3.length == 0) {
      for (var i = 0; i < parent.childCount; i++) {
        var child5 = parent.child(i);
        onNode(child5, locals3, deco.forChild(offset4, child5), i);
        offset4 += child5.nodeSize;
      }
      return;
    }
    var decoIndex = 0, active = [], restNode = null;
    for (var parentIndex = 0; ; ) {
      if (decoIndex < locals3.length && locals3[decoIndex].to == offset4) {
        var widget2 = locals3[decoIndex++], widgets = void 0;
        while (decoIndex < locals3.length && locals3[decoIndex].to == offset4) {
          (widgets || (widgets = [widget2])).push(locals3[decoIndex++]);
        }
        if (widgets) {
          widgets.sort(compareSide);
          for (var i$1 = 0; i$1 < widgets.length; i$1++) {
            onWidget(widgets[i$1], parentIndex, !!restNode);
          }
        } else {
          onWidget(widget2, parentIndex, !!restNode);
        }
      }
      var child$1 = void 0, index3 = void 0;
      if (restNode) {
        index3 = -1;
        child$1 = restNode;
        restNode = null;
      } else if (parentIndex < parent.childCount) {
        index3 = parentIndex;
        child$1 = parent.child(parentIndex++);
      } else {
        break;
      }
      for (var i$2 = 0; i$2 < active.length; i$2++) {
        if (active[i$2].to <= offset4) {
          active.splice(i$2--, 1);
        }
      }
      while (decoIndex < locals3.length && locals3[decoIndex].from <= offset4 && locals3[decoIndex].to > offset4) {
        active.push(locals3[decoIndex++]);
      }
      var end4 = offset4 + child$1.nodeSize;
      if (child$1.isText) {
        var cutAt = end4;
        if (decoIndex < locals3.length && locals3[decoIndex].from < cutAt) {
          cutAt = locals3[decoIndex].from;
        }
        for (var i$3 = 0; i$3 < active.length; i$3++) {
          if (active[i$3].to < cutAt) {
            cutAt = active[i$3].to;
          }
        }
        if (cutAt < end4) {
          restNode = child$1.cut(cutAt - offset4);
          child$1 = child$1.cut(0, cutAt - offset4);
          end4 = cutAt;
          index3 = -1;
        }
      }
      var outerDeco = !active.length ? nothing : child$1.isInline && !child$1.isLeaf ? active.filter(function(d) {
        return !d.inline;
      }) : active.slice();
      onNode(child$1, outerDeco, deco.forChild(offset4, child$1), index3);
      offset4 = end4;
    }
  }
  function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
      var oldCSS = dom.style.cssText;
      dom.style.cssText = oldCSS + "; list-style: square !important";
      window.getComputedStyle(dom).listStyle;
      dom.style.cssText = oldCSS;
    }
  }
  function nearbyTextNode(node5, offset4) {
    for (; ; ) {
      if (node5.nodeType == 3) {
        return node5;
      }
      if (node5.nodeType == 1 && offset4 > 0) {
        if (node5.childNodes.length > offset4 && node5.childNodes[offset4].nodeType == 3) {
          return node5.childNodes[offset4];
        }
        node5 = node5.childNodes[offset4 - 1];
        offset4 = nodeSize(node5);
      } else if (node5.nodeType == 1 && offset4 < node5.childNodes.length) {
        node5 = node5.childNodes[offset4];
        offset4 = 0;
      } else {
        return null;
      }
    }
  }
  function findTextInFragment(frag, text4, from5, to) {
    for (var i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
      var child5 = frag.child(i++), childStart = pos;
      pos += child5.nodeSize;
      if (!child5.isText) {
        continue;
      }
      var str = child5.text;
      while (i < frag.childCount) {
        var next = frag.child(i++);
        pos += next.nodeSize;
        if (!next.isText) {
          break;
        }
        str += next.text;
      }
      if (pos >= from5) {
        var found3 = childStart < to ? str.lastIndexOf(text4, to - childStart - 1) : -1;
        if (found3 >= 0 && found3 + text4.length + childStart >= from5) {
          return childStart + found3;
        }
        if (from5 == to && str.length >= to + text4.length - childStart && str.slice(to - childStart, to - childStart + text4.length) == text4) {
          return to;
        }
      }
    }
    return -1;
  }
  function replaceNodes(nodes, from5, to, view, replacement) {
    var result2 = [];
    for (var i = 0, off = 0; i < nodes.length; i++) {
      var child5 = nodes[i], start6 = off, end4 = off += child5.size;
      if (start6 >= to || end4 <= from5) {
        result2.push(child5);
      } else {
        if (start6 < from5) {
          result2.push(child5.slice(0, from5 - start6, view));
        }
        if (replacement) {
          result2.push(replacement);
          replacement = null;
        }
        if (end4 > to) {
          result2.push(child5.slice(to - start6, child5.size, view));
        }
      }
    }
    return result2;
  }
  function selectionFromDOM(view, origin) {
    var domSel = view.root.getSelection(), doc2 = view.state.doc;
    if (!domSel.focusNode) {
      return null;
    }
    var nearestDesc2 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc2 && nearestDesc2.size == 0;
    var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
    if (head < 0) {
      return null;
    }
    var $head = doc2.resolve(head), $anchor, selection;
    if (selectionCollapsed(domSel)) {
      $anchor = $head;
      while (nearestDesc2 && !nearestDesc2.node) {
        nearestDesc2 = nearestDesc2.parent;
      }
      if (nearestDesc2 && nearestDesc2.node.isAtom && NodeSelection.isSelectable(nearestDesc2.node) && nearestDesc2.parent && !(nearestDesc2.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc2.dom))) {
        var pos = nearestDesc2.posBefore;
        selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
      }
    } else {
      var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      if (anchor < 0) {
        return null;
      }
      $anchor = doc2.resolve(anchor);
    }
    if (!selection) {
      var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
      selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
  }
  function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
  }
  function selectionToDOM(view, force) {
    var sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view)) {
      return;
    }
    if (!force && view.mouseDown && view.mouseDown.allowDefault && result.chrome) {
      var domSel = view.root.getSelection(), curSel = view.domObserver.currentSelection;
      if (domSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
        view.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
      selectCursorWrapper(view);
    } else {
      var anchor = sel.anchor;
      var head = sel.head;
      var resetEditableFrom, resetEditableTo;
      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
        if (!sel.$from.parent.inlineContent) {
          resetEditableFrom = temporarilyEditableNear(view, sel.from);
        }
        if (!sel.empty && !sel.$from.parent.inlineContent) {
          resetEditableTo = temporarilyEditableNear(view, sel.to);
        }
      }
      view.docView.setSelection(anchor, head, view.root, force);
      if (brokenSelectBetweenUneditable) {
        if (resetEditableFrom) {
          resetEditable(resetEditableFrom);
        }
        if (resetEditableTo) {
          resetEditable(resetEditableTo);
        }
      }
      if (sel.visible) {
        view.dom.classList.remove("ProseMirror-hideselection");
      } else {
        view.dom.classList.add("ProseMirror-hideselection");
        if ("onselectionchange" in document) {
          removeClassOnSelectionChange(view);
        }
      }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
  }
  var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;
  function temporarilyEditableNear(view, pos) {
    var ref = view.docView.domFromPos(pos, 0);
    var node5 = ref.node;
    var offset4 = ref.offset;
    var after3 = offset4 < node5.childNodes.length ? node5.childNodes[offset4] : null;
    var before3 = offset4 ? node5.childNodes[offset4 - 1] : null;
    if (result.safari && after3 && after3.contentEditable == "false") {
      return setEditable(after3);
    }
    if ((!after3 || after3.contentEditable == "false") && (!before3 || before3.contentEditable == "false")) {
      if (after3) {
        return setEditable(after3);
      } else if (before3) {
        return setEditable(before3);
      }
    }
  }
  function setEditable(element) {
    element.contentEditable = "true";
    if (result.safari && element.draggable) {
      element.draggable = false;
      element.wasDraggable = true;
    }
    return element;
  }
  function resetEditable(element) {
    element.contentEditable = "false";
    if (element.wasDraggable) {
      element.draggable = true;
      element.wasDraggable = null;
    }
  }
  function removeClassOnSelectionChange(view) {
    var doc2 = view.dom.ownerDocument;
    doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
    var domSel = view.root.getSelection();
    var node5 = domSel.anchorNode, offset4 = domSel.anchorOffset;
    doc2.addEventListener("selectionchange", view.hideSelectionGuard = function() {
      if (domSel.anchorNode != node5 || domSel.anchorOffset != offset4) {
        doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
        setTimeout(function() {
          if (!editorOwnsSelection(view) || view.state.selection.visible) {
            view.dom.classList.remove("ProseMirror-hideselection");
          }
        }, 20);
      }
    });
  }
  function selectCursorWrapper(view) {
    var domSel = view.root.getSelection(), range = document.createRange();
    var node5 = view.cursorWrapper.dom, img = node5.nodeName == "IMG";
    if (img) {
      range.setEnd(node5.parentNode, domIndex(node5) + 1);
    } else {
      range.setEnd(node5, 0);
    }
    range.collapse(false);
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
      node5.disabled = true;
      node5.disabled = false;
    }
  }
  function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
      var desc = view.docView.descAt(sel.from);
      if (desc != view.lastSelectedViewDesc) {
        clearNodeSelection(view);
        if (desc) {
          desc.selectNode();
        }
        view.lastSelectedViewDesc = desc;
      }
    } else {
      clearNodeSelection(view);
    }
  }
  function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
      if (view.lastSelectedViewDesc.parent) {
        view.lastSelectedViewDesc.deselectNode();
      }
      view.lastSelectedViewDesc = null;
    }
  }
  function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", function(f) {
      return f(view, $anchor, $head);
    }) || TextSelection.between($anchor, $head, bias);
  }
  function hasFocusAndSelection(view) {
    if (view.editable && view.root.activeElement != view.dom) {
      return false;
    }
    return hasSelection(view);
  }
  function hasSelection(view) {
    var sel = view.root.getSelection();
    if (!sel.anchorNode) {
      return false;
    }
    try {
      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    } catch (_) {
      return false;
    }
  }
  function anchorInRightPlace(view) {
    var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    var domSel = view.root.getSelection();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
  }
  function moveSelectionBlock(state, dir) {
    var ref = state.selection;
    var $anchor = ref.$anchor;
    var $head = ref.$head;
    var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
  }
  function apply7(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
  }
  function selectHorizontally(view, dir, mods) {
    var sel = view.state.selection;
    if (sel instanceof TextSelection) {
      if (!sel.empty || mods.indexOf("s") > -1) {
        return false;
      } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
        var next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection) {
          return apply7(view, next);
        }
        return false;
      } else if (!(result.mac && mods.indexOf("m") > -1)) {
        var $head = sel.$head, node5 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
        if (!node5 || node5.isText) {
          return false;
        }
        var nodePos = dir < 0 ? $head.pos - node5.nodeSize : $head.pos;
        if (!(node5.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
          return false;
        }
        if (NodeSelection.isSelectable(node5)) {
          return apply7(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node5.nodeSize) : $head));
        } else if (result.webkit) {
          return apply7(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node5.nodeSize)));
        } else {
          return false;
        }
      }
    } else if (sel instanceof NodeSelection && sel.node.isInline) {
      return apply7(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    } else {
      var next$1 = moveSelectionBlock(view.state, dir);
      if (next$1) {
        return apply7(view, next$1);
      }
      return false;
    }
  }
  function nodeLen(node5) {
    return node5.nodeType == 3 ? node5.nodeValue.length : node5.childNodes.length;
  }
  function isIgnorable(dom) {
    var desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
  }
  function skipIgnoredNodesLeft(view) {
    var sel = view.root.getSelection();
    var node5 = sel.focusNode, offset4 = sel.focusOffset;
    if (!node5) {
      return;
    }
    var moveNode, moveOffset, force = false;
    if (result.gecko && node5.nodeType == 1 && offset4 < nodeLen(node5) && isIgnorable(node5.childNodes[offset4])) {
      force = true;
    }
    for (; ; ) {
      if (offset4 > 0) {
        if (node5.nodeType != 1) {
          break;
        } else {
          var before3 = node5.childNodes[offset4 - 1];
          if (isIgnorable(before3)) {
            moveNode = node5;
            moveOffset = --offset4;
          } else if (before3.nodeType == 3) {
            node5 = before3;
            offset4 = node5.nodeValue.length;
          } else {
            break;
          }
        }
      } else if (isBlockNode(node5)) {
        break;
      } else {
        var prev = node5.previousSibling;
        while (prev && isIgnorable(prev)) {
          moveNode = node5.parentNode;
          moveOffset = domIndex(prev);
          prev = prev.previousSibling;
        }
        if (!prev) {
          node5 = node5.parentNode;
          if (node5 == view.dom) {
            break;
          }
          offset4 = 0;
        } else {
          node5 = prev;
          offset4 = nodeLen(node5);
        }
      }
    }
    if (force) {
      setSelFocus(view, sel, node5, offset4);
    } else if (moveNode) {
      setSelFocus(view, sel, moveNode, moveOffset);
    }
  }
  function skipIgnoredNodesRight(view) {
    var sel = view.root.getSelection();
    var node5 = sel.focusNode, offset4 = sel.focusOffset;
    if (!node5) {
      return;
    }
    var len = nodeLen(node5);
    var moveNode, moveOffset;
    for (; ; ) {
      if (offset4 < len) {
        if (node5.nodeType != 1) {
          break;
        }
        var after3 = node5.childNodes[offset4];
        if (isIgnorable(after3)) {
          moveNode = node5;
          moveOffset = ++offset4;
        } else {
          break;
        }
      } else if (isBlockNode(node5)) {
        break;
      } else {
        var next = node5.nextSibling;
        while (next && isIgnorable(next)) {
          moveNode = next.parentNode;
          moveOffset = domIndex(next) + 1;
          next = next.nextSibling;
        }
        if (!next) {
          node5 = node5.parentNode;
          if (node5 == view.dom) {
            break;
          }
          offset4 = len = 0;
        } else {
          node5 = next;
          offset4 = 0;
          len = nodeLen(node5);
        }
      }
    }
    if (moveNode) {
      setSelFocus(view, sel, moveNode, moveOffset);
    }
  }
  function isBlockNode(dom) {
    var desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
  }
  function setSelFocus(view, sel, node5, offset4) {
    if (selectionCollapsed(sel)) {
      var range = document.createRange();
      range.setEnd(node5, offset4);
      range.setStart(node5, offset4);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (sel.extend) {
      sel.extend(node5, offset4);
    }
    view.domObserver.setCurSelection();
    var state = view.state;
    setTimeout(function() {
      if (view.state == state) {
        selectionToDOM(view);
      }
    }, 50);
  }
  function selectVertically(view, dir, mods) {
    var sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) {
      return false;
    }
    if (result.mac && mods.indexOf("m") > -1) {
      return false;
    }
    var $from = sel.$from;
    var $to = sel.$to;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection) {
        return apply7(view, next);
      }
    }
    if (!$from.parent.inlineContent) {
      var side = dir < 0 ? $from : $to;
      var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
      return beyond ? apply7(view, beyond) : false;
    }
    return false;
  }
  function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection)) {
      return true;
    }
    var ref = view.state.selection;
    var $head = ref.$head;
    var $anchor = ref.$anchor;
    var empty2 = ref.empty;
    if (!$head.sameParent($anchor)) {
      return true;
    }
    if (!empty2) {
      return false;
    }
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      return true;
    }
    var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
      var tr = view.state.tr;
      if (dir < 0) {
        tr.delete($head.pos - nextNode.nodeSize, $head.pos);
      } else {
        tr.delete($head.pos, $head.pos + nextNode.nodeSize);
      }
      view.dispatch(tr);
      return true;
    }
    return false;
  }
  function switchEditable(view, node5, state) {
    view.domObserver.stop();
    node5.contentEditable = state;
    view.domObserver.start();
  }
  function safariDownArrowBug(view) {
    if (!result.safari || view.state.selection.$head.parentOffset > 0) {
      return;
    }
    var ref = view.root.getSelection();
    var focusNode = ref.focusNode;
    var focusOffset = ref.focusOffset;
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
      var child5 = focusNode.firstChild;
      switchEditable(view, child5, true);
      setTimeout(function() {
        return switchEditable(view, child5, false);
      }, 20);
    }
  }
  function getMods(event) {
    var result2 = "";
    if (event.ctrlKey) {
      result2 += "c";
    }
    if (event.metaKey) {
      result2 += "m";
    }
    if (event.altKey) {
      result2 += "a";
    }
    if (event.shiftKey) {
      result2 += "s";
    }
    return result2;
  }
  function captureKeyDown(view, event) {
    var code = event.keyCode, mods = getMods(event);
    if (code == 8 || result.mac && code == 72 && mods == "c") {
      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
    } else if (code == 46 || result.mac && code == 68 && mods == "c") {
      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
    } else if (code == 13 || code == 27) {
      return true;
    } else if (code == 37) {
      return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
    } else if (code == 39) {
      return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
    } else if (code == 38) {
      return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
    } else if (code == 40) {
      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
    } else if (mods == (result.mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
      return true;
    }
    return false;
  }
  function parseBetween(view, from_, to_) {
    var ref = view.docView.parseRange(from_, to_);
    var parent = ref.node;
    var fromOffset = ref.fromOffset;
    var toOffset = ref.toOffset;
    var from5 = ref.from;
    var to = ref.to;
    var domSel = view.root.getSelection(), find3 = null, anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
      find3 = [{ node: anchor, offset: domSel.anchorOffset }];
      if (!selectionCollapsed(domSel)) {
        find3.push({ node: domSel.focusNode, offset: domSel.focusOffset });
      }
    }
    if (result.chrome && view.lastKeyCode === 8) {
      for (var off = toOffset; off > fromOffset; off--) {
        var node5 = parent.childNodes[off - 1], desc = node5.pmViewDesc;
        if (node5.nodeName == "BR" && !desc) {
          toOffset = off;
          break;
        }
        if (!desc || desc.size) {
          break;
        }
      }
    }
    var startDoc = view.state.doc;
    var parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    var $from = startDoc.resolve(from5);
    var sel = null, doc2 = parser.parse(parent, {
      topNode: $from.parent,
      topMatch: $from.parent.contentMatchAt($from.index()),
      topOpen: true,
      from: fromOffset,
      to: toOffset,
      preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
      editableContent: true,
      findPositions: find3,
      ruleFromNode,
      context: $from
    });
    if (find3 && find3[0].pos != null) {
      var anchor$1 = find3[0].pos, head = find3[1] && find3[1].pos;
      if (head == null) {
        head = anchor$1;
      }
      sel = { anchor: anchor$1 + from5, head: head + from5 };
    }
    return { doc: doc2, sel, from: from5, to };
  }
  function ruleFromNode(dom) {
    var desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        var skip = document.createElement("div");
        skip.appendChild(document.createElement("li"));
        return { skip };
      } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
        return { ignore: true };
      }
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return { ignore: true };
    }
  }
  function readDOMChange(view, from5, to, typeOver, addedNodes) {
    if (from5 < 0) {
      var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
      var newSel = selectionFromDOM(view, origin);
      if (newSel && !view.state.selection.eq(newSel)) {
        var tr$1 = view.state.tr.setSelection(newSel);
        if (origin == "pointer") {
          tr$1.setMeta("pointer", true);
        } else if (origin == "key") {
          tr$1.scrollIntoView();
        }
        view.dispatch(tr$1);
      }
      return;
    }
    var $before = view.state.doc.resolve(from5);
    var shared = $before.sharedDepth(to);
    from5 = $before.before(shared + 1);
    to = view.state.doc.resolve(to).after(shared + 1);
    var sel = view.state.selection;
    var parse4 = parseBetween(view, from5, to);
    if (result.chrome && view.cursorWrapper && parse4.sel && parse4.sel.anchor == view.cursorWrapper.deco.from) {
      var text4 = view.cursorWrapper.deco.type.toDOM.nextSibling;
      var size = text4 && text4.nodeValue ? text4.nodeValue.length : 1;
      parse4.sel = { anchor: parse4.sel.anchor + size, head: parse4.sel.anchor + size };
    }
    var doc2 = view.state.doc, compare = doc2.slice(parse4.from, parse4.to);
    var preferredPos, preferredSide;
    if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
      preferredPos = view.state.selection.to;
      preferredSide = "end";
    } else {
      preferredPos = view.state.selection.from;
      preferredSide = "start";
    }
    view.lastKeyCode = null;
    var change = findDiff(compare.content, parse4.doc.content, parse4.from, preferredPos, preferredSide);
    if (!change) {
      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse4.sel && parse4.sel.anchor != parse4.sel.head)) {
        change = { start: sel.from, endA: sel.to, endB: sel.to };
      } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) && addedNodes.some(function(n) {
        return n.nodeName == "DIV" || n.nodeName == "P";
      }) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      })) {
        view.lastIOSEnter = 0;
        return;
      } else {
        if (parse4.sel) {
          var sel$1 = resolveSelection(view, view.state.doc, parse4.sel);
          if (sel$1 && !sel$1.eq(view.state.selection)) {
            view.dispatch(view.state.tr.setSelection(sel$1));
          }
        }
        return;
      }
    }
    view.domChangeCount++;
    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse4.from) {
        change.start = view.state.selection.from;
      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse4.to) {
        change.endB += view.state.selection.to - change.endA;
        change.endA = view.state.selection.to;
      }
    }
    if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse4.from && parse4.doc.textBetween(change.start - parse4.from - 1, change.start - parse4.from + 1) == " \xA0") {
      change.start--;
      change.endA--;
      change.endB--;
    }
    var $from = parse4.doc.resolveNoCache(change.start - parse4.from);
    var $to = parse4.doc.resolveNoCache(change.endB - parse4.from);
    var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
    var nextSel;
    if ((result.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n) {
      return n.nodeName == "DIV" || n.nodeName == "P";
    })) || !inlineChange && $from.pos < parse4.doc.content.size && (nextSel = Selection.findFrom(parse4.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f) {
      return f(view, keyEvent(13, "Enter"));
    })) {
      view.lastIOSEnter = 0;
      return;
    }
    if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f) {
      return f(view, keyEvent(8, "Backspace"));
    })) {
      if (result.android && result.chrome) {
        view.domObserver.suppressSelectionUpdates();
      }
      return;
    }
    if (result.chrome && result.android && change.toB == change.from) {
      view.lastAndroidDelete = Date.now();
    }
    if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse4.sel && parse4.sel.anchor == parse4.sel.head && parse4.sel.head == change.endA) {
      change.endB -= 2;
      $to = parse4.doc.resolveNoCache(change.endB - parse4.from);
      setTimeout(function() {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        });
      }, 20);
    }
    var chFrom = change.start, chTo = change.endA;
    var tr, storedMarks, markChange, $from1;
    if (inlineChange) {
      if ($from.pos == $to.pos) {
        if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
          view.domObserver.suppressSelectionUpdates();
          setTimeout(function() {
            return selectionToDOM(view);
          }, 20);
        }
        tr = view.state.tr.delete(chFrom, chTo);
        storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      } else if (change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
        tr = view.state.tr;
        if (markChange.type == "add") {
          tr.addMark(chFrom, chTo, markChange.mark);
        } else {
          tr.removeMark(chFrom, chTo, markChange.mark);
        }
      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
        var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
        if (view.someProp("handleTextInput", function(f) {
          return f(view, chFrom, chTo, text$1);
        })) {
          return;
        }
        tr = view.state.tr.insertText(text$1, chFrom, chTo);
      }
    }
    if (!tr) {
      tr = view.state.tr.replace(chFrom, chTo, parse4.doc.slice(change.start - parse4.from, change.endB - parse4.from));
    }
    if (parse4.sel) {
      var sel$2 = resolveSelection(view, tr.doc, parse4.sel);
      if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty && (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result.ie && sel$2.empty && sel$2.head == chFrom)) {
        tr.setSelection(sel$2);
      }
    }
    if (storedMarks) {
      tr.ensureMarks(storedMarks);
    }
    view.dispatch(tr.scrollIntoView());
  }
  function resolveSelection(view, doc2, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
      return null;
    }
    return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
  }
  function isMarkChange(cur, prev) {
    var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
    var added = curMarks, removed = prevMarks, type, mark4, update4;
    for (var i = 0; i < prevMarks.length; i++) {
      added = prevMarks[i].removeFromSet(added);
    }
    for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
      removed = curMarks[i$1].removeFromSet(removed);
    }
    if (added.length == 1 && removed.length == 0) {
      mark4 = added[0];
      type = "add";
      update4 = function(node5) {
        return node5.mark(mark4.addToSet(node5.marks));
      };
    } else if (added.length == 0 && removed.length == 1) {
      mark4 = removed[0];
      type = "remove";
      update4 = function(node5) {
        return node5.mark(mark4.removeFromSet(node5.marks));
      };
    } else {
      return null;
    }
    var updated = [];
    for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
      updated.push(update4(prev.child(i$2)));
    }
    if (Fragment.from(updated).eq(cur)) {
      return { mark: mark4, type };
    }
  }
  function looksLikeJoin(old, start6, end4, $newStart, $newEnd) {
    if (!$newStart.parent.isTextblock || end4 - start6 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
      return false;
    }
    var $start = old.resolve(start6);
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
      return false;
    }
    var $next = old.resolve(skipClosingAndOpening($start, true, true));
    if (!$next.parent.isTextblock || $next.pos > end4 || skipClosingAndOpening($next, true, false) < end4) {
      return false;
    }
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
  }
  function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    var depth = $pos.depth, end4 = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
      depth--;
      end4++;
      fromEnd = false;
    }
    if (mayOpen) {
      var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
      while (next && !next.isLeaf) {
        next = next.firstChild;
        end4++;
      }
    }
    return end4;
  }
  function findDiff(a, b, pos, preferredPos, preferredSide) {
    var start6 = a.findDiffStart(b, pos);
    if (start6 == null) {
      return null;
    }
    var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
    var endA = ref.a;
    var endB = ref.b;
    if (preferredSide == "end") {
      var adjust = Math.max(0, start6 - Math.min(endA, endB));
      preferredPos -= endA + adjust - start6;
    }
    if (endA < start6 && a.size < b.size) {
      var move2 = preferredPos <= start6 && preferredPos >= endA ? start6 - preferredPos : 0;
      start6 -= move2;
      endB = start6 + (endB - endA);
      endA = start6;
    } else if (endB < start6) {
      var move$1 = preferredPos <= start6 && preferredPos >= endB ? start6 - preferredPos : 0;
      start6 -= move$1;
      endA = start6 + (endA - endB);
      endB = start6;
    }
    return { start: start6, endA, endB };
  }
  function serializeForClipboard(view, slice6) {
    var context = [];
    var content3 = slice6.content;
    var openStart = slice6.openStart;
    var openEnd = slice6.openEnd;
    while (openStart > 1 && openEnd > 1 && content3.childCount == 1 && content3.firstChild.childCount == 1) {
      openStart--;
      openEnd--;
      var node5 = content3.firstChild;
      context.push(node5.type.name, node5.attrs != node5.type.defaultAttrs ? node5.attrs : null);
      content3 = node5.content;
    }
    var serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    var doc2 = detachedDoc(), wrap = doc2.createElement("div");
    wrap.appendChild(serializer.serializeFragment(content3, { document: doc2 }));
    var firstChild = wrap.firstChild, needsWrap;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
      for (var i = needsWrap.length - 1; i >= 0; i--) {
        var wrapper = doc2.createElement(needsWrap[i]);
        while (wrap.firstChild) {
          wrapper.appendChild(wrap.firstChild);
        }
        wrap.appendChild(wrapper);
        if (needsWrap[i] != "tbody") {
          openStart++;
          openEnd++;
        }
      }
      firstChild = wrap.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1) {
      firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
    }
    var text4 = view.someProp("clipboardTextSerializer", function(f) {
      return f(slice6);
    }) || slice6.content.textBetween(0, slice6.content.size, "\n\n");
    return { dom: wrap, text: text4 };
  }
  function parseFromClipboard(view, text4, html, plainText, $context) {
    var dom, inCode = $context.parent.type.spec.code, slice6;
    if (!html && !text4) {
      return null;
    }
    var asText = text4 && (plainText || inCode || !html);
    if (asText) {
      view.someProp("transformPastedText", function(f) {
        text4 = f(text4, inCode || plainText);
      });
      if (inCode) {
        return text4 ? new Slice(Fragment.from(view.state.schema.text(text4.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
      }
      var parsed = view.someProp("clipboardTextParser", function(f) {
        return f(text4, $context, plainText);
      });
      if (parsed) {
        slice6 = parsed;
      } else {
        var marks3 = $context.marks();
        var ref = view.state;
        var schema = ref.schema;
        var serializer = DOMSerializer.fromSchema(schema);
        dom = document.createElement("div");
        text4.split(/(?:\r\n?|\n)+/).forEach(function(block) {
          var p = dom.appendChild(document.createElement("p"));
          if (block) {
            p.appendChild(serializer.serializeNode(schema.text(block, marks3)));
          }
        });
      }
    } else {
      view.someProp("transformPastedHTML", function(f) {
        html = f(html);
      });
      dom = readHTML(html);
      if (result.webkit) {
        restoreReplacedSpaces(dom);
      }
    }
    var contextNode = dom && dom.querySelector("[data-pm-slice]");
    var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
    if (!slice6) {
      var parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
      slice6 = parser.parseSlice(dom, {
        preserveWhitespace: !!(asText || sliceData),
        context: $context,
        ruleFromNode: function ruleFromNode2(dom2) {
          if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName)) {
            return { ignore: true };
          }
        }
      });
    }
    if (sliceData) {
      slice6 = addContext(closeSlice(slice6, +sliceData[1], +sliceData[2]), sliceData[3]);
    } else {
      slice6 = Slice.maxOpen(normalizeSiblings(slice6.content, $context), true);
      if (slice6.openStart || slice6.openEnd) {
        var openStart = 0, openEnd = 0;
        for (var node5 = slice6.content.firstChild; openStart < slice6.openStart && !node5.type.spec.isolating; openStart++, node5 = node5.firstChild) {
        }
        for (var node$1 = slice6.content.lastChild; openEnd < slice6.openEnd && !node$1.type.spec.isolating; openEnd++, node$1 = node$1.lastChild) {
        }
        slice6 = closeSlice(slice6, openStart, openEnd);
      }
    }
    view.someProp("transformPasted", function(f) {
      slice6 = f(slice6);
    });
    return slice6;
  }
  var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function normalizeSiblings(fragment, $context) {
    if (fragment.childCount < 2) {
      return fragment;
    }
    var loop = function(d2) {
      var parent = $context.node(d2);
      var match = parent.contentMatchAt($context.index(d2));
      var lastWrap = void 0, result2 = [];
      fragment.forEach(function(node5) {
        if (!result2) {
          return;
        }
        var wrap = match.findWrapping(node5.type), inLast;
        if (!wrap) {
          return result2 = null;
        }
        if (inLast = result2.length && lastWrap.length && addToSibling(wrap, lastWrap, node5, result2[result2.length - 1], 0)) {
          result2[result2.length - 1] = inLast;
        } else {
          if (result2.length) {
            result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
          }
          var wrapped = withWrappers(node5, wrap);
          result2.push(wrapped);
          match = match.matchType(wrapped.type, wrapped.attrs);
          lastWrap = wrap;
        }
      });
      if (result2) {
        return { v: Fragment.from(result2) };
      }
    };
    for (var d = $context.depth; d >= 0; d--) {
      var returned = loop(d);
      if (returned)
        return returned.v;
    }
    return fragment;
  }
  function withWrappers(node5, wrap, from5) {
    if (from5 === void 0)
      from5 = 0;
    for (var i = wrap.length - 1; i >= from5; i--) {
      node5 = wrap[i].create(null, Fragment.from(node5));
    }
    return node5;
  }
  function addToSibling(wrap, lastWrap, node5, sibling, depth) {
    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
      var inner = addToSibling(wrap, lastWrap, node5, sibling.lastChild, depth + 1);
      if (inner) {
        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
      }
      var match = sibling.contentMatchAt(sibling.childCount);
      if (match.matchType(depth == wrap.length - 1 ? node5.type : wrap[depth + 1])) {
        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node5, wrap, depth + 1))));
      }
    }
  }
  function closeRight(node5, depth) {
    if (depth == 0) {
      return node5;
    }
    var fragment = node5.content.replaceChild(node5.childCount - 1, closeRight(node5.lastChild, depth - 1));
    var fill = node5.contentMatchAt(node5.childCount).fillBefore(Fragment.empty, true);
    return node5.copy(fragment.append(fill));
  }
  function closeRange(fragment, side, from5, to, depth, openEnd) {
    var node5 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node5.content;
    if (depth < to - 1) {
      inner = closeRange(inner, side, from5, to, depth + 1, openEnd);
    }
    if (depth >= from5) {
      inner = side < 0 ? node5.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node5.contentMatchAt(node5.childCount).fillBefore(Fragment.empty, true));
    }
    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node5.copy(inner));
  }
  function closeSlice(slice6, openStart, openEnd) {
    if (openStart < slice6.openStart) {
      slice6 = new Slice(closeRange(slice6.content, -1, openStart, slice6.openStart, 0, slice6.openEnd), openStart, slice6.openEnd);
    }
    if (openEnd < slice6.openEnd) {
      slice6 = new Slice(closeRange(slice6.content, 1, openEnd, slice6.openEnd, 0, 0), slice6.openStart, openEnd);
    }
    return slice6;
  }
  var wrapMap = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  };
  var _detachedDoc = null;
  function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
  }
  function readHTML(html) {
    var metas = /^(\s*<meta [^>]*>)*/.exec(html);
    if (metas) {
      html = html.slice(metas[0].length);
    }
    var elt = detachedDoc().createElement("div");
    var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
      html = wrap.map(function(n) {
        return "<" + n + ">";
      }).join("") + html + wrap.map(function(n) {
        return "</" + n + ">";
      }).reverse().join("");
    }
    elt.innerHTML = html;
    if (wrap) {
      for (var i = 0; i < wrap.length; i++) {
        elt = elt.querySelector(wrap[i]) || elt;
      }
    }
    return elt;
  }
  function restoreReplacedSpaces(dom) {
    var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (var i = 0; i < nodes.length; i++) {
      var node5 = nodes[i];
      if (node5.childNodes.length == 1 && node5.textContent == "\xA0" && node5.parentNode) {
        node5.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node5);
      }
    }
  }
  function addContext(slice6, context) {
    if (!slice6.size) {
      return slice6;
    }
    var schema = slice6.content.firstChild.type.schema, array;
    try {
      array = JSON.parse(context);
    } catch (e) {
      return slice6;
    }
    var content3 = slice6.content;
    var openStart = slice6.openStart;
    var openEnd = slice6.openEnd;
    for (var i = array.length - 2; i >= 0; i -= 2) {
      var type = schema.nodes[array[i]];
      if (!type || type.hasRequiredAttrs()) {
        break;
      }
      content3 = Fragment.from(type.create(array[i + 1], content3));
      openStart++;
      openEnd++;
    }
    return new Slice(content3, openStart, openEnd);
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  };
  var useCharData = result.ie && result.ie_version <= 11;
  var SelectionState = function SelectionState2() {
    this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
  };
  SelectionState.prototype.set = function set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  };
  SelectionState.prototype.eq = function eq5(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  };
  var DOMObserver = function DOMObserver2(view, handleDOMChange) {
    var this$1 = this;
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
      for (var i = 0; i < mutations.length; i++) {
        this$1.queue.push(mutations[i]);
      }
      if (result.ie && result.ie_version <= 11 && mutations.some(function(m) {
        return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
      })) {
        this$1.flushSoon();
      } else {
        this$1.flush();
      }
    });
    this.currentSelection = new SelectionState();
    if (useCharData) {
      this.onCharData = function(e) {
        this$1.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this$1.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.suppressingSelectionUpdates = false;
  };
  DOMObserver.prototype.flushSoon = function flushSoon() {
    var this$1 = this;
    if (this.flushingSoon < 0) {
      this.flushingSoon = window.setTimeout(function() {
        this$1.flushingSoon = -1;
        this$1.flush();
      }, 20);
    }
  };
  DOMObserver.prototype.forceFlush = function forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  };
  DOMObserver.prototype.start = function start3() {
    if (this.observer) {
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (useCharData) {
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    }
    this.connectSelection();
  };
  DOMObserver.prototype.stop = function stop() {
    var this$1 = this;
    if (this.observer) {
      var take = this.observer.takeRecords();
      if (take.length) {
        for (var i = 0; i < take.length; i++) {
          this.queue.push(take[i]);
        }
        window.setTimeout(function() {
          return this$1.flush();
        }, 20);
      }
      this.observer.disconnect();
    }
    if (useCharData) {
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    this.disconnectSelection();
  };
  DOMObserver.prototype.connectSelection = function connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  };
  DOMObserver.prototype.disconnectSelection = function disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  };
  DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates() {
    var this$1 = this;
    this.suppressingSelectionUpdates = true;
    setTimeout(function() {
      return this$1.suppressingSelectionUpdates = false;
    }, 50);
  };
  DOMObserver.prototype.onSelectionChange = function onSelectionChange() {
    if (!hasFocusAndSelection(this.view)) {
      return;
    }
    if (this.suppressingSelectionUpdates) {
      return selectionToDOM(this.view);
    }
    if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
      var sel = this.view.root.getSelection();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
        return this.flushSoon();
      }
    }
    this.flush();
  };
  DOMObserver.prototype.setCurSelection = function setCurSelection() {
    this.currentSelection.set(this.view.root.getSelection());
  };
  DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange(sel) {
    if (sel.rangeCount == 0) {
      return true;
    }
    var container = sel.getRangeAt(0).commonAncestorContainer;
    var desc = this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
      this.setCurSelection();
      return true;
    }
  };
  DOMObserver.prototype.flush = function flush() {
    if (!this.view.docView || this.flushingSoon > -1) {
      return;
    }
    var mutations = this.observer ? this.observer.takeRecords() : [];
    if (this.queue.length) {
      mutations = this.queue.concat(mutations);
      this.queue.length = 0;
    }
    var sel = this.view.root.getSelection();
    var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);
    var from5 = -1, to = -1, typeOver = false, added = [];
    if (this.view.editable) {
      for (var i = 0; i < mutations.length; i++) {
        var result$1 = this.registerMutation(mutations[i], added);
        if (result$1) {
          from5 = from5 < 0 ? result$1.from : Math.min(result$1.from, from5);
          to = to < 0 ? result$1.to : Math.max(result$1.to, to);
          if (result$1.typeOver) {
            typeOver = true;
          }
        }
      }
    }
    if (result.gecko && added.length > 1) {
      var brs = added.filter(function(n) {
        return n.nodeName == "BR";
      });
      if (brs.length == 2) {
        var a = brs[0];
        var b = brs[1];
        if (a.parentNode && a.parentNode.parentNode == b.parentNode) {
          b.remove();
        } else {
          a.remove();
        }
      }
    }
    if (from5 > -1 || newSel) {
      if (from5 > -1) {
        this.view.docView.markDirty(from5, to);
        checkCSS(this.view);
      }
      this.handleDOMChange(from5, to, typeOver, added);
      if (this.view.docView && this.view.docView.dirty) {
        this.view.updateState(this.view.state);
      } else if (!this.currentSelection.eq(sel)) {
        selectionToDOM(this.view);
      }
      this.currentSelection.set(sel);
    }
  };
  DOMObserver.prototype.registerMutation = function registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1) {
      return null;
    }
    var desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
      return null;
    }
    if (!desc || desc.ignoreMutation(mut)) {
      return null;
    }
    if (mut.type == "childList") {
      for (var i = 0; i < mut.addedNodes.length; i++) {
        added.push(mut.addedNodes[i]);
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
        return { from: desc.posBefore, to: desc.posAfter };
      }
      var prev = mut.previousSibling, next = mut.nextSibling;
      if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
        for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
          var ref = mut.addedNodes[i$1];
          var previousSibling = ref.previousSibling;
          var nextSibling = ref.nextSibling;
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
            prev = previousSibling;
          }
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
            next = nextSibling;
          }
        }
      }
      var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      var from5 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      var to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from5, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  };
  var cssChecked = false;
  function checkCSS(view) {
    if (cssChecked) {
      return;
    }
    cssChecked = true;
    if (getComputedStyle(view.dom).whiteSpace == "normal") {
      console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    }
  }
  var handlers = {};
  var editHandlers = {};
  function initInput(view) {
    view.shiftKey = false;
    view.mouseDown = null;
    view.lastKeyCode = null;
    view.lastKeyCodeTime = 0;
    view.lastClick = { time: 0, x: 0, y: 0, type: "" };
    view.lastSelectionOrigin = null;
    view.lastSelectionTime = 0;
    view.lastIOSEnter = 0;
    view.lastIOSEnterFallbackTimeout = null;
    view.lastAndroidDelete = 0;
    view.composing = false;
    view.composingTimeout = null;
    view.compositionNodes = [];
    view.compositionEndedAt = -2e8;
    view.domObserver = new DOMObserver(view, function(from5, to, typeOver, added) {
      return readDOMChange(view, from5, to, typeOver, added);
    });
    view.domObserver.start();
    view.domChangeCount = 0;
    view.eventHandlers = /* @__PURE__ */ Object.create(null);
    var loop = function(event2) {
      var handler = handlers[event2];
      view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
        if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers))) {
          handler(view, event3);
        }
      });
    };
    for (var event in handlers)
      loop(event);
    if (result.safari) {
      view.dom.addEventListener("input", function() {
        return null;
      });
    }
    ensureListeners(view);
  }
  function setSelectionOrigin(view, origin) {
    view.lastSelectionOrigin = origin;
    view.lastSelectionTime = Date.now();
  }
  function destroyInput(view) {
    view.domObserver.stop();
    for (var type in view.eventHandlers) {
      view.dom.removeEventListener(type, view.eventHandlers[type]);
    }
    clearTimeout(view.composingTimeout);
    clearTimeout(view.lastIOSEnterFallbackTimeout);
  }
  function ensureListeners(view) {
    view.someProp("handleDOMEvents", function(currentHandlers) {
      for (var type in currentHandlers) {
        if (!view.eventHandlers[type]) {
          view.dom.addEventListener(type, view.eventHandlers[type] = function(event) {
            return runCustomHandler(view, event);
          });
        }
      }
    });
  }
  function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", function(handlers2) {
      var handler = handlers2[event.type];
      return handler ? handler(view, event) || event.defaultPrevented : false;
    });
  }
  function eventBelongsToView(view, event) {
    if (!event.bubbles) {
      return true;
    }
    if (event.defaultPrevented) {
      return false;
    }
    for (var node5 = event.target; node5 != view.dom; node5 = node5.parentNode) {
      if (!node5 || node5.nodeType == 11 || node5.pmViewDesc && node5.pmViewDesc.stopEvent(event)) {
        return false;
      }
    }
    return true;
  }
  function dispatchEvent2(view, event) {
    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) {
      handlers[event.type](view, event);
    }
  }
  editHandlers.keydown = function(view, event) {
    view.shiftKey = event.keyCode == 16 || event.shiftKey;
    if (inOrNearComposition(view, event)) {
      return;
    }
    view.lastKeyCode = event.keyCode;
    view.lastKeyCodeTime = Date.now();
    if (result.android && result.chrome && event.keyCode == 13) {
      return;
    }
    if (event.keyCode != 229) {
      view.domObserver.forceFlush();
    }
    if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
      var now2 = Date.now();
      view.lastIOSEnter = now2;
      view.lastIOSEnterFallbackTimeout = setTimeout(function() {
        if (view.lastIOSEnter == now2) {
          view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(13, "Enter"));
          });
          view.lastIOSEnter = 0;
        }
      }, 200);
    } else if (view.someProp("handleKeyDown", function(f) {
      return f(view, event);
    }) || captureKeyDown(view, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "key");
    }
  };
  editHandlers.keyup = function(view, e) {
    if (e.keyCode == 16) {
      view.shiftKey = false;
    }
  };
  editHandlers.keypress = function(view, event) {
    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
      return;
    }
    if (view.someProp("handleKeyPress", function(f) {
      return f(view, event);
    })) {
      event.preventDefault();
      return;
    }
    var sel = view.state.selection;
    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
      var text4 = String.fromCharCode(event.charCode);
      if (!view.someProp("handleTextInput", function(f) {
        return f(view, sel.$from.pos, sel.$to.pos, text4);
      })) {
        view.dispatch(view.state.tr.insertText(text4).scrollIntoView());
      }
      event.preventDefault();
    }
  };
  function eventCoords(event) {
    return { left: event.clientX, top: event.clientY };
  }
  function isNear(event, click) {
    var dx = click.x - event.clientX, dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
  }
  function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1) {
      return false;
    }
    var $pos = view.state.doc.resolve(inside);
    var loop = function(i2) {
      if (view.someProp(propName, function(f) {
        return i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false);
      })) {
        return { v: true };
      }
    };
    for (var i = $pos.depth + 1; i > 0; i--) {
      var returned = loop(i);
      if (returned)
        return returned.v;
    }
    return false;
  }
  function updateSelection(view, selection, origin) {
    if (!view.focused) {
      view.focus();
    }
    var tr = view.state.tr.setSelection(selection);
    if (origin == "pointer") {
      tr.setMeta("pointer", true);
    }
    view.dispatch(tr);
  }
  function selectClickedLeaf(view, inside) {
    if (inside == -1) {
      return false;
    }
    var $pos = view.state.doc.resolve(inside), node5 = $pos.nodeAfter;
    if (node5 && node5.isAtom && NodeSelection.isSelectable(node5)) {
      updateSelection(view, new NodeSelection($pos), "pointer");
      return true;
    }
    return false;
  }
  function selectClickedNode(view, inside) {
    if (inside == -1) {
      return false;
    }
    var sel = view.state.selection, selectedNode, selectAt;
    if (sel instanceof NodeSelection) {
      selectedNode = sel.node;
    }
    var $pos = view.state.doc.resolve(inside);
    for (var i = $pos.depth + 1; i > 0; i--) {
      var node5 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      if (NodeSelection.isSelectable(node5)) {
        if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
          selectAt = $pos.before(sel.$from.depth);
        } else {
          selectAt = $pos.before(i);
        }
        break;
      }
    }
    if (selectAt != null) {
      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
      return true;
    } else {
      return false;
    }
  }
  function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f) {
      return f(view, pos, event);
    }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
  }
  function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f) {
      return f(view, pos, event);
    });
  }
  function handleTripleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f) {
      return f(view, pos, event);
    }) || defaultTripleClick(view, inside, event);
  }
  function defaultTripleClick(view, inside, event) {
    if (event.button != 0) {
      return false;
    }
    var doc2 = view.state.doc;
    if (inside == -1) {
      if (doc2.inlineContent) {
        updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
        return true;
      }
      return false;
    }
    var $pos = doc2.resolve(inside);
    for (var i = $pos.depth + 1; i > 0; i--) {
      var node5 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      var nodePos = $pos.before(i);
      if (node5.inlineContent) {
        updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node5.content.size), "pointer");
      } else if (NodeSelection.isSelectable(node5)) {
        updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
      } else {
        continue;
      }
      return true;
    }
  }
  function forceDOMFlush(view) {
    return endComposition(view);
  }
  var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";
  handlers.mousedown = function(view, event) {
    view.shiftKey = event.shiftKey;
    var flushed = forceDOMFlush(view);
    var now2 = Date.now(), type = "singleClick";
    if (now2 - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
      if (view.lastClick.type == "singleClick") {
        type = "doubleClick";
      } else if (view.lastClick.type == "doubleClick") {
        type = "tripleClick";
      }
    }
    view.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
    var pos = view.posAtCoords(eventCoords(event));
    if (!pos) {
      return;
    }
    if (type == "singleClick") {
      if (view.mouseDown) {
        view.mouseDown.done();
      }
      view.mouseDown = new MouseDown(view, pos, event, flushed);
    } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "pointer");
    }
  };
  var MouseDown = function MouseDown2(view, pos, event, flushed) {
    var this$1 = this;
    this.view = view;
    this.startDoc = view.state.doc;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.selectNode = event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    this.delayedSelectionSync = false;
    var targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      var $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    this.mightDrag = null;
    var target = flushed ? null : event.target;
    var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    var ref = view.state;
    var selection = ref.selection;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos) {
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: this.target && !this.target.draggable,
        setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
      };
    }
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr) {
        this.target.draggable = true;
      }
      if (this.mightDrag.setUneditable) {
        setTimeout(function() {
          if (this$1.view.mouseDown == this$1) {
            this$1.target.setAttribute("contentEditable", "false");
          }
        }, 20);
      }
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  };
  MouseDown.prototype.done = function done() {
    var this$1 = this;
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr) {
        this.target.removeAttribute("draggable");
      }
      if (this.mightDrag.setUneditable) {
        this.target.removeAttribute("contentEditable");
      }
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync) {
      setTimeout(function() {
        return selectionToDOM(this$1.view);
      });
    }
    this.view.mouseDown = null;
  };
  MouseDown.prototype.up = function up(event) {
    this.done();
    if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
      return;
    }
    var pos = this.pos;
    if (this.view.state.doc != this.startDoc) {
      pos = this.view.posAtCoords(eventCoords(event));
    }
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || result.safari && this.mightDrag && !this.mightDrag.node.isAtom || result.chrome && !(this.view.state.selection instanceof TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  };
  MouseDown.prototype.move = function move(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
      this.allowDefault = true;
    }
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0) {
      this.done();
    }
  };
  handlers.touchdown = function(view) {
    forceDOMFlush(view);
    setSelectionOrigin(view, "pointer");
  };
  handlers.contextmenu = function(view) {
    return forceDOMFlush(view);
  };
  function inOrNearComposition(view, event) {
    if (view.composing) {
      return true;
    }
    if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
      view.compositionEndedAt = -2e8;
      return true;
    }
    return false;
  }
  var timeoutComposition = result.android ? 5e3 : -1;
  editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
    if (!view.composing) {
      view.domObserver.flush();
      var state = view.state;
      var $pos = state.selection.$from;
      if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m) {
        return m.type.spec.inclusive === false;
      }))) {
        view.markCursor = view.state.storedMarks || $pos.marks();
        endComposition(view, true);
        view.markCursor = null;
      } else {
        endComposition(view);
        if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
          var sel = view.root.getSelection();
          for (var node5 = sel.focusNode, offset4 = sel.focusOffset; node5 && node5.nodeType == 1 && offset4 != 0; ) {
            var before3 = offset4 < 0 ? node5.lastChild : node5.childNodes[offset4 - 1];
            if (!before3) {
              break;
            }
            if (before3.nodeType == 3) {
              sel.collapse(before3, before3.nodeValue.length);
              break;
            } else {
              node5 = before3;
              offset4 = -1;
            }
          }
        }
      }
      view.composing = true;
    }
    scheduleComposeEnd(view, timeoutComposition);
  };
  editHandlers.compositionend = function(view, event) {
    if (view.composing) {
      view.composing = false;
      view.compositionEndedAt = event.timeStamp;
      scheduleComposeEnd(view, 20);
    }
  };
  function scheduleComposeEnd(view, delay) {
    clearTimeout(view.composingTimeout);
    if (delay > -1) {
      view.composingTimeout = setTimeout(function() {
        return endComposition(view);
      }, delay);
    }
  }
  function clearComposition(view) {
    if (view.composing) {
      view.composing = false;
      view.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.compositionNodes.length > 0) {
      view.compositionNodes.pop().markParentsDirty();
    }
  }
  function timestampFromCustomEvent() {
    var event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
  }
  function endComposition(view, forceUpdate) {
    if (result.android && view.domObserver.flushingSoon >= 0) {
      return;
    }
    view.domObserver.forceFlush();
    clearComposition(view);
    if (forceUpdate || view.docView && view.docView.dirty) {
      var sel = selectionFromDOM(view);
      if (sel && !sel.eq(view.state.selection)) {
        view.dispatch(view.state.tr.setSelection(sel));
      } else {
        view.updateState(view.state);
      }
      return true;
    }
    return false;
  }
  function captureCopy(view, dom) {
    if (!view.dom.parentNode) {
      return;
    }
    var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap.appendChild(dom);
    wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
    var sel = getSelection(), range = document.createRange();
    range.selectNodeContents(dom);
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(function() {
      if (wrap.parentNode) {
        wrap.parentNode.removeChild(wrap);
      }
      view.focus();
    }, 50);
  }
  var brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;
  handlers.copy = editHandlers.cut = function(view, e) {
    var sel = view.state.selection, cut5 = e.type == "cut";
    if (sel.empty) {
      return;
    }
    var data = brokenClipboardAPI ? null : e.clipboardData;
    var slice6 = sel.content();
    var ref = serializeForClipboard(view, slice6);
    var dom = ref.dom;
    var text4 = ref.text;
    if (data) {
      e.preventDefault();
      data.clearData();
      data.setData("text/html", dom.innerHTML);
      data.setData("text/plain", text4);
    } else {
      captureCopy(view, dom);
    }
    if (cut5) {
      view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    }
  };
  function sliceSingleNode(slice6) {
    return slice6.openStart == 0 && slice6.openEnd == 0 && slice6.content.childCount == 1 ? slice6.content.firstChild : null;
  }
  function capturePaste(view, e) {
    if (!view.dom.parentNode) {
      return;
    }
    var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
    var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText) {
      target.contentEditable = "true";
    }
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(function() {
      view.focus();
      if (target.parentNode) {
        target.parentNode.removeChild(target);
      }
      if (plainText) {
        doPaste(view, target.value, null, e);
      } else {
        doPaste(view, target.textContent, target.innerHTML, e);
      }
    }, 50);
  }
  function doPaste(view, text4, html, e) {
    var slice6 = parseFromClipboard(view, text4, html, view.shiftKey, view.state.selection.$from);
    if (view.someProp("handlePaste", function(f) {
      return f(view, e, slice6 || Slice.empty);
    })) {
      return true;
    }
    if (!slice6) {
      return false;
    }
    var singleNode = sliceSingleNode(slice6);
    var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice6);
    view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
  }
  editHandlers.paste = function(view, e) {
    if (view.composing && !result.android) {
      return;
    }
    var data = brokenClipboardAPI ? null : e.clipboardData;
    if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e)) {
      e.preventDefault();
    } else {
      capturePaste(view, e);
    }
  };
  var Dragging = function Dragging2(slice6, move2) {
    this.slice = slice6;
    this.move = move2;
  };
  var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";
  handlers.dragstart = function(view, e) {
    var mouseDown = view.mouseDown;
    if (mouseDown) {
      mouseDown.done();
    }
    if (!e.dataTransfer) {
      return;
    }
    var sel = view.state.selection;
    var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
      ;
    else if (mouseDown && mouseDown.mightDrag) {
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
    } else if (e.target && e.target.nodeType == 1) {
      var desc = view.docView.nearestDesc(e.target, true);
      if (desc && desc.node.type.spec.draggable && desc != view.docView) {
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
      }
    }
    var slice6 = view.state.selection.content();
    var ref = serializeForClipboard(view, slice6);
    var dom = ref.dom;
    var text4 = ref.text;
    e.dataTransfer.clearData();
    e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
    e.dataTransfer.effectAllowed = "copyMove";
    if (!brokenClipboardAPI) {
      e.dataTransfer.setData("text/plain", text4);
    }
    view.dragging = new Dragging(slice6, !e[dragCopyModifier]);
  };
  handlers.dragend = function(view) {
    var dragging = view.dragging;
    window.setTimeout(function() {
      if (view.dragging == dragging) {
        view.dragging = null;
      }
    }, 50);
  };
  editHandlers.dragover = editHandlers.dragenter = function(_, e) {
    return e.preventDefault();
  };
  editHandlers.drop = function(view, e) {
    var dragging = view.dragging;
    view.dragging = null;
    if (!e.dataTransfer) {
      return;
    }
    var eventPos = view.posAtCoords(eventCoords(e));
    if (!eventPos) {
      return;
    }
    var $mouse = view.state.doc.resolve(eventPos.pos);
    if (!$mouse) {
      return;
    }
    var slice6 = dragging && dragging.slice;
    if (slice6) {
      view.someProp("transformPasted", function(f) {
        slice6 = f(slice6);
      });
    } else {
      slice6 = parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
    }
    var move2 = dragging && !e[dragCopyModifier];
    if (view.someProp("handleDrop", function(f) {
      return f(view, e, slice6 || Slice.empty, move2);
    })) {
      e.preventDefault();
      return;
    }
    if (!slice6) {
      return;
    }
    e.preventDefault();
    var insertPos = slice6 ? dropPoint(view.state.doc, $mouse.pos, slice6) : $mouse.pos;
    if (insertPos == null) {
      insertPos = $mouse.pos;
    }
    var tr = view.state.tr;
    if (move2) {
      tr.deleteSelection();
    }
    var pos = tr.mapping.map(insertPos);
    var isNode = slice6.openStart == 0 && slice6.openEnd == 0 && slice6.content.childCount == 1;
    var beforeInsert = tr.doc;
    if (isNode) {
      tr.replaceRangeWith(pos, pos, slice6.content.firstChild);
    } else {
      tr.replaceRange(pos, pos, slice6);
    }
    if (tr.doc.eq(beforeInsert)) {
      return;
    }
    var $pos = tr.doc.resolve(pos);
    if (isNode && NodeSelection.isSelectable(slice6.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice6.content.firstChild)) {
      tr.setSelection(new NodeSelection($pos));
    } else {
      var end4 = tr.mapping.map(insertPos);
      tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
        return end4 = newTo;
      });
      tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end4)));
    }
    view.focus();
    view.dispatch(tr.setMeta("uiEvent", "drop"));
  };
  handlers.focus = function(view) {
    if (!view.focused) {
      view.domObserver.stop();
      view.dom.classList.add("ProseMirror-focused");
      view.domObserver.start();
      view.focused = true;
      setTimeout(function() {
        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
          selectionToDOM(view);
        }
      }, 20);
    }
  };
  handlers.blur = function(view, e) {
    if (view.focused) {
      view.domObserver.stop();
      view.dom.classList.remove("ProseMirror-focused");
      view.domObserver.start();
      if (e.relatedTarget && view.dom.contains(e.relatedTarget)) {
        view.domObserver.currentSelection.set({});
      }
      view.focused = false;
    }
  };
  handlers.beforeinput = function(view, event) {
    if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
      view.domObserver.flushSoon();
      var domChangeCount = view.domChangeCount;
      setTimeout(function() {
        if (view.domChangeCount != domChangeCount) {
          return;
        }
        view.dom.blur();
        view.focus();
        if (view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(8, "Backspace"));
        })) {
          return;
        }
        var ref = view.state.selection;
        var $cursor = ref.$cursor;
        if ($cursor && $cursor.pos > 0) {
          view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
        }
      }, 50);
    }
  };
  for (prop in editHandlers) {
    handlers[prop] = editHandlers[prop];
  }
  var prop;
  function compareObjs(a, b) {
    if (a == b) {
      return true;
    }
    for (var p in a) {
      if (a[p] !== b[p]) {
        return false;
      }
    }
    for (var p$1 in b) {
      if (!(p$1 in a)) {
        return false;
      }
    }
    return true;
  }
  var WidgetType = function WidgetType2(toDOM, spec) {
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
    this.toDOM = toDOM;
  };
  WidgetType.prototype.map = function map7(mapping, span, offset4, oldOffset) {
    var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    var pos = ref.pos;
    var deleted = ref.deleted;
    return deleted ? null : new Decoration(pos - offset4, pos - offset4, this);
  };
  WidgetType.prototype.valid = function valid() {
    return true;
  };
  WidgetType.prototype.eq = function eq6(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  };
  WidgetType.prototype.destroy = function destroy3(node5) {
    if (this.spec.destroy) {
      this.spec.destroy(node5);
    }
  };
  var InlineType = function InlineType2(attrs, spec) {
    this.spec = spec || noSpec;
    this.attrs = attrs;
  };
  InlineType.prototype.map = function map8(mapping, span, offset4, oldOffset) {
    var from5 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset4;
    var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset4;
    return from5 >= to ? null : new Decoration(from5, to, this);
  };
  InlineType.prototype.valid = function valid2(_, span) {
    return span.from < span.to;
  };
  InlineType.prototype.eq = function eq7(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  };
  InlineType.is = function is(span) {
    return span.type instanceof InlineType;
  };
  var NodeType3 = function NodeType4(attrs, spec) {
    this.spec = spec || noSpec;
    this.attrs = attrs;
  };
  NodeType3.prototype.map = function map9(mapping, span, offset4, oldOffset) {
    var from5 = mapping.mapResult(span.from + oldOffset, 1);
    if (from5.deleted) {
      return null;
    }
    var to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from5.pos) {
      return null;
    }
    return new Decoration(from5.pos - offset4, to.pos - offset4, this);
  };
  NodeType3.prototype.valid = function valid3(node5, span) {
    var ref = node5.content.findIndex(span.from);
    var index3 = ref.index;
    var offset4 = ref.offset;
    var child5;
    return offset4 == span.from && !(child5 = node5.child(index3)).isText && offset4 + child5.nodeSize == span.to;
  };
  NodeType3.prototype.eq = function eq8(other) {
    return this == other || other instanceof NodeType3 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  };
  var Decoration = function Decoration2(from5, to, type) {
    this.from = from5;
    this.to = to;
    this.type = type;
  };
  var prototypeAccessors$14 = { spec: { configurable: true }, inline: { configurable: true } };
  Decoration.prototype.copy = function copy4(from5, to) {
    return new Decoration(from5, to, this.type);
  };
  Decoration.prototype.eq = function eq9(other, offset4) {
    if (offset4 === void 0)
      offset4 = 0;
    return this.type.eq(other.type) && this.from + offset4 == other.from && this.to + offset4 == other.to;
  };
  Decoration.prototype.map = function map10(mapping, offset4, oldOffset) {
    return this.type.map(mapping, this, offset4, oldOffset);
  };
  Decoration.widget = function widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  };
  Decoration.inline = function inline(from5, to, attrs, spec) {
    return new Decoration(from5, to, new InlineType(attrs, spec));
  };
  Decoration.node = function node3(from5, to, attrs, spec) {
    return new Decoration(from5, to, new NodeType3(attrs, spec));
  };
  prototypeAccessors$14.spec.get = function() {
    return this.type.spec;
  };
  prototypeAccessors$14.inline.get = function() {
    return this.type instanceof InlineType;
  };
  Object.defineProperties(Decoration.prototype, prototypeAccessors$14);
  var none = [];
  var noSpec = {};
  var DecorationSet = function DecorationSet2(local, children) {
    this.local = local && local.length ? local : none;
    this.children = children && children.length ? children : none;
  };
  DecorationSet.create = function create4(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  };
  DecorationSet.prototype.find = function find(start6, end4, predicate) {
    var result2 = [];
    this.findInner(start6 == null ? 0 : start6, end4 == null ? 1e9 : end4, result2, 0, predicate);
    return result2;
  };
  DecorationSet.prototype.findInner = function findInner(start6, end4, result2, offset4, predicate) {
    for (var i = 0; i < this.local.length; i++) {
      var span = this.local[i];
      if (span.from <= end4 && span.to >= start6 && (!predicate || predicate(span.spec))) {
        result2.push(span.copy(span.from + offset4, span.to + offset4));
      }
    }
    for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
      if (this.children[i$1] < end4 && this.children[i$1 + 1] > start6) {
        var childOff = this.children[i$1] + 1;
        this.children[i$1 + 2].findInner(start6 - childOff, end4 - childOff, result2, offset4 + childOff, predicate);
      }
    }
  };
  DecorationSet.prototype.map = function map11(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0) {
      return this;
    }
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  };
  DecorationSet.prototype.mapInner = function mapInner(mapping, node5, offset4, oldOffset, options) {
    var newLocal;
    for (var i = 0; i < this.local.length; i++) {
      var mapped = this.local[i].map(mapping, offset4, oldOffset);
      if (mapped && mapped.type.valid(node5, mapped)) {
        (newLocal || (newLocal = [])).push(mapped);
      } else if (options.onRemove) {
        options.onRemove(this.local[i].spec);
      }
    }
    if (this.children.length) {
      return mapChildren(this.children, newLocal, mapping, node5, offset4, oldOffset, options);
    } else {
      return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty;
    }
  };
  DecorationSet.prototype.add = function add2(doc2, decorations) {
    if (!decorations.length) {
      return this;
    }
    if (this == empty) {
      return DecorationSet.create(doc2, decorations);
    }
    return this.addInner(doc2, decorations, 0);
  };
  DecorationSet.prototype.addInner = function addInner(doc2, decorations, offset4) {
    var this$1 = this;
    var children, childIndex = 0;
    doc2.forEach(function(childNode, childOffset) {
      var baseOffset = childOffset + offset4, found3;
      if (!(found3 = takeSpansForNode(decorations, childNode, baseOffset))) {
        return;
      }
      if (!children) {
        children = this$1.children.slice();
      }
      while (childIndex < children.length && children[childIndex] < childOffset) {
        childIndex += 3;
      }
      if (children[childIndex] == childOffset) {
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found3, baseOffset + 1);
      } else {
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found3, childNode, baseOffset + 1, noSpec));
      }
      childIndex += 3;
    });
    var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset4);
    for (var i = 0; i < local.length; i++) {
      if (!local[i].type.valid(doc2, local[i])) {
        local.splice(i--, 1);
      }
    }
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  };
  DecorationSet.prototype.remove = function remove(decorations) {
    if (decorations.length == 0 || this == empty) {
      return this;
    }
    return this.removeInner(decorations, 0);
  };
  DecorationSet.prototype.removeInner = function removeInner(decorations, offset4) {
    var children = this.children, local = this.local;
    for (var i = 0; i < children.length; i += 3) {
      var found3 = void 0, from5 = children[i] + offset4, to = children[i + 1] + offset4;
      for (var j = 0, span = void 0; j < decorations.length; j++) {
        if (span = decorations[j]) {
          if (span.from > from5 && span.to < to) {
            decorations[j] = null;
            (found3 || (found3 = [])).push(span);
          }
        }
      }
      if (!found3) {
        continue;
      }
      if (children == this.children) {
        children = this.children.slice();
      }
      var removed = children[i + 2].removeInner(found3, from5 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
        if (span$1 = decorations[i$1]) {
          for (var j$1 = 0; j$1 < local.length; j$1++) {
            if (local[j$1].eq(span$1, offset4)) {
              if (local == this.local) {
                local = this.local.slice();
              }
              local.splice(j$1--, 1);
            }
          }
        }
      }
    }
    if (children == this.children && local == this.local) {
      return this;
    }
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  };
  DecorationSet.prototype.forChild = function forChild(offset4, node5) {
    if (this == empty) {
      return this;
    }
    if (node5.isLeaf) {
      return DecorationSet.empty;
    }
    var child5, local;
    for (var i = 0; i < this.children.length; i += 3) {
      if (this.children[i] >= offset4) {
        if (this.children[i] == offset4) {
          child5 = this.children[i + 2];
        }
        break;
      }
    }
    var start6 = offset4 + 1, end4 = start6 + node5.content.size;
    for (var i$1 = 0; i$1 < this.local.length; i$1++) {
      var dec = this.local[i$1];
      if (dec.from < end4 && dec.to > start6 && dec.type instanceof InlineType) {
        var from5 = Math.max(start6, dec.from) - start6, to = Math.min(end4, dec.to) - start6;
        if (from5 < to) {
          (local || (local = [])).push(dec.copy(from5, to));
        }
      }
    }
    if (local) {
      var localSet = new DecorationSet(local.sort(byPos));
      return child5 ? new DecorationGroup([localSet, child5]) : localSet;
    }
    return child5 || empty;
  };
  DecorationSet.prototype.eq = function eq10(other) {
    if (this == other) {
      return true;
    }
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) {
      return false;
    }
    for (var i = 0; i < this.local.length; i++) {
      if (!this.local[i].eq(other.local[i])) {
        return false;
      }
    }
    for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
      if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
        return false;
      }
    }
    return true;
  };
  DecorationSet.prototype.locals = function locals(node5) {
    return removeOverlap(this.localsInner(node5));
  };
  DecorationSet.prototype.localsInner = function localsInner(node5) {
    if (this == empty) {
      return none;
    }
    if (node5.inlineContent || !this.local.some(InlineType.is)) {
      return this.local;
    }
    var result2 = [];
    for (var i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType)) {
        result2.push(this.local[i]);
      }
    }
    return result2;
  };
  var empty = new DecorationSet();
  DecorationSet.empty = empty;
  DecorationSet.removeOverlap = removeOverlap;
  var DecorationGroup = function DecorationGroup2(members) {
    this.members = members;
  };
  DecorationGroup.prototype.map = function map12(mapping, doc2) {
    var mappedDecos = this.members.map(function(member) {
      return member.map(mapping, doc2, noSpec);
    });
    return DecorationGroup.from(mappedDecos);
  };
  DecorationGroup.prototype.forChild = function forChild2(offset4, child5) {
    if (child5.isLeaf) {
      return DecorationSet.empty;
    }
    var found3 = [];
    for (var i = 0; i < this.members.length; i++) {
      var result2 = this.members[i].forChild(offset4, child5);
      if (result2 == empty) {
        continue;
      }
      if (result2 instanceof DecorationGroup) {
        found3 = found3.concat(result2.members);
      } else {
        found3.push(result2);
      }
    }
    return DecorationGroup.from(found3);
  };
  DecorationGroup.prototype.eq = function eq11(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) {
      return false;
    }
    for (var i = 0; i < this.members.length; i++) {
      if (!this.members[i].eq(other.members[i])) {
        return false;
      }
    }
    return true;
  };
  DecorationGroup.prototype.locals = function locals2(node5) {
    var result2, sorted = true;
    for (var i = 0; i < this.members.length; i++) {
      var locals3 = this.members[i].localsInner(node5);
      if (!locals3.length) {
        continue;
      }
      if (!result2) {
        result2 = locals3;
      } else {
        if (sorted) {
          result2 = result2.slice();
          sorted = false;
        }
        for (var j = 0; j < locals3.length; j++) {
          result2.push(locals3[j]);
        }
      }
    }
    return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
  };
  DecorationGroup.from = function from2(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members);
    }
  };
  function mapChildren(oldChildren, newLocal, mapping, node5, offset4, oldOffset, options) {
    var children = oldChildren.slice();
    var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
      for (var i2 = 0; i2 < children.length; i2 += 3) {
        var end4 = children[i2 + 1], dSize = void 0;
        if (end4 < 0 || oldStart > end4 + oldOffset) {
          continue;
        }
        var start6 = children[i2] + oldOffset;
        if (oldEnd >= start6) {
          children[i2 + 1] = oldStart <= start6 ? -2 : -1;
        } else if (newStart >= offset4 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
    };
    for (var i = 0; i < mapping.maps.length; i++) {
      mapping.maps[i].forEach(shift2);
    }
    var mustRebuild = false;
    for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
      if (children[i$1 + 1] < 0) {
        if (children[i$1 + 1] == -2) {
          mustRebuild = true;
          children[i$1 + 1] = -1;
          continue;
        }
        var from5 = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from5 - offset4;
        if (fromLocal < 0 || fromLocal >= node5.content.size) {
          mustRebuild = true;
          continue;
        }
        var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset4;
        var ref = node5.content.findIndex(fromLocal);
        var index3 = ref.index;
        var childOffset = ref.offset;
        var childNode = node5.maybeChild(index3);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          var mapped = children[i$1 + 2].mapInner(mapping, childNode, from5 + 1, oldChildren[i$1] + oldOffset + 1, options);
          if (mapped != empty) {
            children[i$1] = fromLocal;
            children[i$1 + 1] = toLocal;
            children[i$1 + 2] = mapped;
          } else {
            children[i$1 + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      }
    }
    if (mustRebuild) {
      var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping, offset4, oldOffset, options);
      var built = buildTree(decorations, node5, 0, options);
      newLocal = built.local;
      for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
        if (children[i$2 + 1] < 0) {
          children.splice(i$2, 3);
          i$2 -= 3;
        }
      }
      for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
        var from$1 = built.children[i$3];
        while (j < children.length && children[j] < from$1) {
          j += 3;
        }
        children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
      }
    }
    return new DecorationSet(newLocal && newLocal.sort(byPos), children);
  }
  function moveSpans(spans, offset4) {
    if (!offset4 || !spans.length) {
      return spans;
    }
    var result2 = [];
    for (var i = 0; i < spans.length; i++) {
      var span = spans[i];
      result2.push(new Decoration(span.from + offset4, span.to + offset4, span.type));
    }
    return result2;
  }
  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset4, oldOffset, options) {
    function gather(set2, oldOffset2) {
      for (var i2 = 0; i2 < set2.local.length; i2++) {
        var mapped = set2.local[i2].map(mapping, offset4, oldOffset2);
        if (mapped) {
          decorations.push(mapped);
        } else if (options.onRemove) {
          options.onRemove(set2.local[i2].spec);
        }
      }
      for (var i$1 = 0; i$1 < set2.children.length; i$1 += 3) {
        gather(set2.children[i$1 + 2], set2.children[i$1] + oldOffset2 + 1);
      }
    }
    for (var i = 0; i < children.length; i += 3) {
      if (children[i + 1] == -1) {
        gather(children[i + 2], oldChildren[i] + oldOffset + 1);
      }
    }
    return decorations;
  }
  function takeSpansForNode(spans, node5, offset4) {
    if (node5.isLeaf) {
      return null;
    }
    var end4 = offset4 + node5.nodeSize, found3 = null;
    for (var i = 0, span = void 0; i < spans.length; i++) {
      if ((span = spans[i]) && span.from > offset4 && span.to < end4) {
        (found3 || (found3 = [])).push(span);
        spans[i] = null;
      }
    }
    return found3;
  }
  function withoutNulls(array) {
    var result2 = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i] != null) {
        result2.push(array[i]);
      }
    }
    return result2;
  }
  function buildTree(spans, node5, offset4, options) {
    var children = [], hasNulls = false;
    node5.forEach(function(childNode, localStart) {
      var found3 = takeSpansForNode(spans, childNode, localStart + offset4);
      if (found3) {
        hasNulls = true;
        var subtree = buildTree(found3, childNode, offset4 + localStart + 1, options);
        if (subtree != empty) {
          children.push(localStart, localStart + childNode.nodeSize, subtree);
        }
      }
    });
    var locals3 = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset4).sort(byPos);
    for (var i = 0; i < locals3.length; i++) {
      if (!locals3[i].type.valid(node5, locals3[i])) {
        if (options.onRemove) {
          options.onRemove(locals3[i].spec);
        }
        locals3.splice(i--, 1);
      }
    }
    return locals3.length || children.length ? new DecorationSet(locals3, children) : empty;
  }
  function byPos(a, b) {
    return a.from - b.from || a.to - b.to;
  }
  function removeOverlap(spans) {
    var working = spans;
    for (var i = 0; i < working.length - 1; i++) {
      var span = working[i];
      if (span.from != span.to) {
        for (var j = i + 1; j < working.length; j++) {
          var next = working[j];
          if (next.from == span.from) {
            if (next.to != span.to) {
              if (working == spans) {
                working = spans.slice();
              }
              working[j] = next.copy(next.from, span.to);
              insertAhead(working, j + 1, next.copy(span.to, next.to));
            }
            continue;
          } else {
            if (next.from < span.to) {
              if (working == spans) {
                working = spans.slice();
              }
              working[i] = span.copy(span.from, next.from);
              insertAhead(working, j, span.copy(next.from, span.to));
            }
            break;
          }
        }
      }
    }
    return working;
  }
  function insertAhead(array, i, deco) {
    while (i < array.length && byPos(deco, array[i]) > 0) {
      i++;
    }
    array.splice(i, 0, deco);
  }
  function viewDecorations(view) {
    var found3 = [];
    view.someProp("decorations", function(f) {
      var result2 = f(view.state);
      if (result2 && result2 != empty) {
        found3.push(result2);
      }
    });
    if (view.cursorWrapper) {
      found3.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    }
    return DecorationGroup.from(found3);
  }
  var EditorView = function EditorView2(place, props) {
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild) {
        place.appendChild(this.dom);
      } else if (place.apply) {
        place(this.dom);
      } else if (place.mount) {
        this.mounted = true;
      }
    }
    this.editable = getEditable(this);
    this.markCursor = null;
    this.cursorWrapper = null;
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.lastSelectedViewDesc = null;
    this.dragging = null;
    initInput(this);
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.updatePluginViews();
  };
  var prototypeAccessors$22 = { props: { configurable: true }, root: { configurable: true }, isDestroyed: { configurable: true } };
  prototypeAccessors$22.props.get = function() {
    if (this._props.state != this.state) {
      var prev = this._props;
      this._props = {};
      for (var name in prev) {
        this._props[name] = prev[name];
      }
      this._props.state = this.state;
    }
    return this._props;
  };
  EditorView.prototype.update = function update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, true);
  };
  EditorView.prototype.setProps = function setProps(props) {
    var updated = {};
    for (var name in this._props) {
      updated[name] = this._props[name];
    }
    updated.state = this.state;
    for (var name$1 in props) {
      updated[name$1] = props[name$1];
    }
    this.update(updated);
  };
  EditorView.prototype.updateState = function updateState(state) {
    this.updateStateInner(state, this.state.plugins != state.plugins);
  };
  EditorView.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
    var this$1 = this;
    var prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    if (reconfigured) {
      var nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection)) {
      updateSel = true;
    }
    var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        var chromeKludge = result.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco([]);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites) {
          forceSelUpdate = true;
        }
      }
      if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      var startDOM = this.root.getSelection().focusNode;
      if (this.someProp("handleScrollToSelection", function(f) {
        return f(this$1);
      }))
        ;
      else if (state.selection instanceof NodeSelection) {
        scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
      }
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  };
  EditorView.prototype.destroyPluginViews = function destroyPluginViews() {
    var view;
    while (view = this.pluginViews.pop()) {
      if (view.destroy) {
        view.destroy();
      }
    }
  };
  EditorView.prototype.updatePluginViews = function updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (var i = 0; i < this.directPlugins.length; i++) {
        var plugin = this.directPlugins[i];
        if (plugin.spec.view) {
          this.pluginViews.push(plugin.spec.view(this));
        }
      }
      for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {
        var plugin$1 = this.state.plugins[i$1];
        if (plugin$1.spec.view) {
          this.pluginViews.push(plugin$1.spec.view(this));
        }
      }
    } else {
      for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {
        var pluginView = this.pluginViews[i$2];
        if (pluginView.update) {
          pluginView.update(this, prevState);
        }
      }
    }
  };
  EditorView.prototype.someProp = function someProp(propName, f) {
    var prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop)) {
      return value;
    }
    for (var i = 0; i < this.directPlugins.length; i++) {
      var prop$1 = this.directPlugins[i].props[propName];
      if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) {
        return value;
      }
    }
    var plugins = this.state.plugins;
    if (plugins) {
      for (var i$1 = 0; i$1 < plugins.length; i$1++) {
        var prop$2 = plugins[i$1].props[propName];
        if (prop$2 != null && (value = f ? f(prop$2) : prop$2)) {
          return value;
        }
      }
    }
  };
  EditorView.prototype.hasFocus = function hasFocus() {
    return this.root.activeElement == this.dom;
  };
  EditorView.prototype.focus = function focus() {
    this.domObserver.stop();
    if (this.editable) {
      focusPreventScroll(this.dom);
    }
    selectionToDOM(this);
    this.domObserver.start();
  };
  prototypeAccessors$22.root.get = function() {
    var cached = this._root;
    if (cached == null) {
      for (var search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection) {
            Object.getPrototypeOf(search).getSelection = function() {
              return document.getSelection();
            };
          }
          return this._root = search;
        }
      }
    }
    return cached || document;
  };
  EditorView.prototype.posAtCoords = function posAtCoords$1(coords) {
    return posAtCoords(this, coords);
  };
  EditorView.prototype.coordsAtPos = function coordsAtPos$1(pos, side) {
    if (side === void 0)
      side = 1;
    return coordsAtPos(this, pos, side);
  };
  EditorView.prototype.domAtPos = function domAtPos(pos, side) {
    if (side === void 0)
      side = 0;
    return this.docView.domFromPos(pos, side);
  };
  EditorView.prototype.nodeDOM = function nodeDOM(pos) {
    var desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  };
  EditorView.prototype.posAtDOM = function posAtDOM(node5, offset4, bias) {
    if (bias === void 0)
      bias = -1;
    var pos = this.docView.posFromDOM(node5, offset4, bias);
    if (pos == null) {
      throw new RangeError("DOM position not inside the editor");
    }
    return pos;
  };
  EditorView.prototype.endOfTextblock = function endOfTextblock$1(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  };
  EditorView.prototype.destroy = function destroy4() {
    if (!this.docView) {
      return;
    }
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  };
  prototypeAccessors$22.isDestroyed.get = function() {
    return this.docView == null;
  };
  EditorView.prototype.dispatchEvent = function dispatchEvent$1(event) {
    return dispatchEvent2(this, event);
  };
  EditorView.prototype.dispatch = function dispatch2(tr) {
    var dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction) {
      dispatchTransaction.call(this, tr);
    } else {
      this.updateState(this.state.apply(tr));
    }
  };
  Object.defineProperties(EditorView.prototype, prototypeAccessors$22);
  function computeDocDeco(view) {
    var attrs = /* @__PURE__ */ Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    attrs.translate = "no";
    view.someProp("attributes", function(value) {
      if (typeof value == "function") {
        value = value(view.state);
      }
      if (value) {
        for (var attr in value) {
          if (attr == "class") {
            attrs.class += " " + value[attr];
          }
          if (attr == "style") {
            attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
          } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
            attrs[attr] = String(value[attr]);
          }
        }
      }
    });
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
  }
  function updateCursorWrapper(view) {
    if (view.markCursor) {
      var dom = document.createElement("img");
      dom.className = "ProseMirror-separator";
      dom.setAttribute("mark-placeholder", "true");
      dom.setAttribute("alt", "");
      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
    } else {
      view.cursorWrapper = null;
    }
  }
  function getEditable(view) {
    return !view.someProp("editable", function(value) {
      return value(view.state) === false;
    });
  }
  function selectionContextChanged(sel1, sel2) {
    var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
  }
  function buildNodeViews(view) {
    var result2 = {};
    view.someProp("nodeViews", function(obj) {
      for (var prop in obj) {
        if (!Object.prototype.hasOwnProperty.call(result2, prop)) {
          result2[prop] = obj[prop];
        }
      }
    });
    return result2;
  }
  function changedNodeViews(a, b) {
    var nA = 0, nB = 0;
    for (var prop in a) {
      if (a[prop] != b[prop]) {
        return true;
      }
      nA++;
    }
    for (var _ in b) {
      nB++;
    }
    return nA != nB;
  }
  function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) {
      throw new RangeError("Plugins passed directly to the view must not have a state component");
    }
  }

  // node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    229: "q"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
    229: "Q"
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = chrome && (mac2 || +chrome[1] < 57) || gecko && mac2;
  for (i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  var i;
  for (i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  var i;
  for (i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  var i;
  for (code in base)
    if (!shift.hasOwnProperty(code))
      shift[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name == "Esc")
      name = "Escape";
    if (name == "Del")
      name = "Delete";
    if (name == "Left")
      name = "ArrowLeft";
    if (name == "Up")
      name = "ArrowUp";
    if (name == "Right")
      name = "ArrowRight";
    if (name == "Down")
      name = "ArrowDown";
    return name;
  }

  // node_modules/prosemirror-keymap/dist/index.es.js
  var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
    if (result2 == "Space") {
      result2 = " ";
    }
    var alt, ctrl, shift2, meta;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift2 = true;
      } else if (/^mod$/i.test(mod)) {
        if (mac3) {
          meta = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }
    if (alt) {
      result2 = "Alt-" + result2;
    }
    if (ctrl) {
      result2 = "Ctrl-" + result2;
    }
    if (meta) {
      result2 = "Meta-" + result2;
    }
    if (shift2) {
      result2 = "Shift-" + result2;
    }
    return result2;
  }
  function normalize(map22) {
    var copy7 = /* @__PURE__ */ Object.create(null);
    for (var prop in map22) {
      copy7[normalizeKeyName(prop)] = map22[prop];
    }
    return copy7;
  }
  function modifiers(name, event, shift2) {
    if (event.altKey) {
      name = "Alt-" + name;
    }
    if (event.ctrlKey) {
      name = "Ctrl-" + name;
    }
    if (event.metaKey) {
      name = "Meta-" + name;
    }
    if (shift2 !== false && event.shiftKey) {
      name = "Shift-" + name;
    }
    return name;
  }
  function keymap(bindings) {
    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
  }
  function keydownHandler(bindings) {
    var map22 = normalize(bindings);
    return function(view, event) {
      var name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
      var direct = map22[modifiers(name, event, !isChar)];
      if (direct && direct(view.state, view.dispatch, view)) {
        return true;
      }
      if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        var fromCode = map22[modifiers(baseName, event, true)];
        if (fromCode && fromCode(view.state, view.dispatch, view)) {
          return true;
        }
      } else if (isChar && event.shiftKey) {
        var withShift = map22[modifiers(name, event, true)];
        if (withShift && withShift(view.state, view.dispatch, view)) {
          return true;
        }
      }
      return false;
    };
  }

  // node_modules/@tiptap/core/dist/tiptap-core.esm.js
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
  }
  function mergeDeep(target, source2) {
    const output = { ...target };
    if (isPlainObject(target) && isPlainObject(source2)) {
      Object.keys(source2).forEach((key2) => {
        if (isPlainObject(source2[key2])) {
          if (!(key2 in target)) {
            Object.assign(output, { [key2]: source2[key2] });
          } else {
            output[key2] = mergeDeep(target[key2], source2[key2]);
          }
        } else {
          Object.assign(output, { [key2]: source2[key2] });
        }
      });
    }
    return output;
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function callOrReturn(value, context = void 0, ...props) {
    if (isFunction(value)) {
      if (context) {
        return value.bind(context)(...props);
      }
      return value(...props);
    }
    return value;
  }
  function getExtensionField(extension, field, context) {
    if (extension.config[field] === void 0 && extension.parent) {
      return getExtensionField(extension.parent, field, context);
    }
    if (typeof extension.config[field] === "function") {
      const value = extension.config[field].bind({
        ...context,
        parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
      });
      return value;
    }
    return extension.config[field];
  }
  var Extension = class {
    constructor(config = {}) {
      this.type = "extension";
      this.name = "extension";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new Extension(config);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new Extension(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  };
  function getTextBetween(startNode, range, options) {
    const { from: from5, to } = range;
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    let text4 = "";
    let separated = true;
    startNode.nodesBetween(from5, to, (node5, pos, parent, index3) => {
      var _a;
      const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node5.type.name];
      if (textSerializer) {
        if (node5.isBlock && !separated) {
          text4 += blockSeparator;
          separated = true;
        }
        text4 += textSerializer({
          node: node5,
          pos,
          parent,
          index: index3
        });
      } else if (node5.isText) {
        text4 += (_a = node5 === null || node5 === void 0 ? void 0 : node5.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from5, pos) - pos, to - pos);
        separated = false;
      } else if (node5.isBlock && !separated) {
        text4 += blockSeparator;
        separated = true;
      }
    });
    return text4;
  }
  function getTextSeralizersFromSchema(schema) {
    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node5]) => node5.spec.toText).map(([name, node5]) => [name, node5.spec.toText]));
  }
  var ClipboardTextSerializer = Extension.create({
    name: "clipboardTextSerializer",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor } = this;
              const { state, schema } = editor;
              const { doc: doc2, selection } = state;
              const { ranges } = selection;
              const from5 = Math.min(...ranges.map((range2) => range2.$from.pos));
              const to = Math.max(...ranges.map((range2) => range2.$to.pos));
              const textSerializers = getTextSeralizersFromSchema(schema);
              const range = { from: from5, to };
              return getTextBetween(doc2, range, {
                textSerializers
              });
            }
          }
        })
      ];
    }
  });
  var blur = () => ({ editor, view }) => {
    requestAnimationFrame(() => {
      var _a;
      if (!editor.isDestroyed) {
        view.dom.blur();
        (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
      }
    });
    return true;
  };
  var blur$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    blur
  });
  var clearContent = (emitUpdate = false) => ({ commands }) => {
    return commands.setContent("", emitUpdate);
  };
  var clearContent$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    clearContent
  });
  var clearNodes = () => ({ state, tr, dispatch: dispatch3 }) => {
    const { selection } = tr;
    const { ranges } = selection;
    if (!dispatch3) {
      return true;
    }
    ranges.forEach(({ $from, $to }) => {
      state.doc.nodesBetween($from.pos, $to.pos, (node5, pos) => {
        if (node5.type.isText) {
          return;
        }
        const { doc: doc2, mapping } = tr;
        const $mappedFrom = doc2.resolve(mapping.map(pos));
        const $mappedTo = doc2.resolve(mapping.map(pos + node5.nodeSize));
        const nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) {
          return;
        }
        const targetLiftDepth = liftTarget(nodeRange);
        if (node5.type.isTextblock) {
          const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
          tr.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
  var clearNodes$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    clearNodes
  });
  var command = (fn2) => (props) => {
    return fn2(props);
  };
  var command$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    command
  });
  var createParagraphNear2 = () => ({ state, dispatch: dispatch3 }) => {
    return createParagraphNear(state, dispatch3);
  };
  var createParagraphNear$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    createParagraphNear: createParagraphNear2
  });
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  var deleteNode = (typeOrName) => ({ tr, state, dispatch: dispatch3 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const $pos = tr.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node5 = $pos.node(depth);
      if (node5.type === type) {
        if (dispatch3) {
          const from5 = $pos.before(depth);
          const to = $pos.after(depth);
          tr.delete(from5, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteNode$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    deleteNode
  });
  var deleteRange = (range) => ({ tr, dispatch: dispatch3 }) => {
    const { from: from5, to } = range;
    if (dispatch3) {
      tr.delete(from5, to);
    }
    return true;
  };
  var deleteRange$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    deleteRange
  });
  var deleteSelection2 = () => ({ state, dispatch: dispatch3 }) => {
    return deleteSelection(state, dispatch3);
  };
  var deleteSelection$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    deleteSelection: deleteSelection2
  });
  var enter2 = () => ({ commands }) => {
    return commands.keyboardShortcut("Enter");
  };
  var enter$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    enter: enter2
  });
  var exitCode2 = () => ({ state, dispatch: dispatch3 }) => {
    return exitCode(state, dispatch3);
  };
  var exitCode$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exitCode: exitCode2
  });
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  function objectIncludes(object1, object2, options = { strict: true }) {
    const keys2 = Object.keys(object2);
    if (!keys2.length) {
      return true;
    }
    return keys2.every((key2) => {
      if (options.strict) {
        return object2[key2] === object1[key2];
      }
      if (isRegExp(object2[key2])) {
        return object2[key2].test(object1[key2]);
      }
      return object2[key2] === object1[key2];
    });
  }
  function findMarkInSet(marks3, type, attributes = {}) {
    return marks3.find((item) => {
      return item.type === type && objectIncludes(item.attrs, attributes);
    });
  }
  function isMarkInSet(marks3, type, attributes = {}) {
    return !!findMarkInSet(marks3, type, attributes);
  }
  function getMarkRange($pos, type, attributes = {}) {
    if (!$pos || !type) {
      return;
    }
    const start6 = $pos.parent.childAfter($pos.parentOffset);
    if (!start6.node) {
      return;
    }
    const mark4 = findMarkInSet(start6.node.marks, type, attributes);
    if (!mark4) {
      return;
    }
    let startIndex2 = $pos.index();
    let startPos = $pos.start() + start6.offset;
    let endIndex2 = startIndex2 + 1;
    let endPos = startPos + start6.node.nodeSize;
    findMarkInSet(start6.node.marks, type, attributes);
    while (startIndex2 > 0 && mark4.isInSet($pos.parent.child(startIndex2 - 1).marks)) {
      startIndex2 -= 1;
      startPos -= $pos.parent.child(startIndex2).nodeSize;
    }
    while (endIndex2 < $pos.parent.childCount && isMarkInSet($pos.parent.child(endIndex2).marks, type, attributes)) {
      endPos += $pos.parent.child(endIndex2).nodeSize;
      endIndex2 += 1;
    }
    return {
      from: startPos,
      to: endPos
    };
  }
  var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch3 }) => {
    const type = getMarkType(typeOrName, state.schema);
    const { doc: doc2, selection } = tr;
    const { $from, from: from5, to } = selection;
    if (dispatch3) {
      const range = getMarkRange($from, type, attributes);
      if (range && range.from <= from5 && range.to >= to) {
        const newSelection = TextSelection.create(doc2, range.from, range.to);
        tr.setSelection(newSelection);
      }
    }
    return true;
  };
  var extendMarkRange$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    extendMarkRange
  });
  var first = (commands) => (props) => {
    const items = typeof commands === "function" ? commands(props) : commands;
    for (let i = 0; i < items.length; i += 1) {
      if (items[i](props)) {
        return true;
      }
    }
    return false;
  };
  var first$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    first
  });
  function isClass(value) {
    var _a;
    if (((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== "class") {
      return false;
    }
    return true;
  }
  function isObject(value) {
    return value && typeof value === "object" && !Array.isArray(value) && !isClass(value);
  }
  function isTextSelection(value) {
    return isObject(value) && value instanceof TextSelection;
  }
  function isiOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  function minMax(value = 0, min4 = 0, max4 = 0) {
    return Math.min(Math.max(value, min4), max4);
  }
  function resolveFocusPosition(doc2, position = null) {
    if (!position) {
      return null;
    }
    const selectionAtStart = Selection.atStart(doc2);
    const selectionAtEnd = Selection.atEnd(doc2);
    if (position === "start" || position === true) {
      return selectionAtStart;
    }
    if (position === "end") {
      return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position === "all") {
      return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc2, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
  }
  var focus2 = (position = null, options) => ({ editor, view, tr, dispatch: dispatch3 }) => {
    options = {
      scrollIntoView: true,
      ...options
    };
    const delayedFocus = () => {
      if (isiOS()) {
        view.dom.focus();
      }
      requestAnimationFrame(() => {
        if (!editor.isDestroyed) {
          view.focus();
          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
            editor.commands.scrollIntoView();
          }
        }
      });
    };
    if (view.hasFocus() && position === null || position === false) {
      return true;
    }
    if (dispatch3 && position === null && !isTextSelection(editor.state.selection)) {
      delayedFocus();
      return true;
    }
    const selection = resolveFocusPosition(editor.state.doc, position) || editor.state.selection;
    const isSameSelection = editor.state.selection.eq(selection);
    if (dispatch3) {
      if (!isSameSelection) {
        tr.setSelection(selection);
      }
      if (isSameSelection && tr.storedMarks) {
        tr.setStoredMarks(tr.storedMarks);
      }
      delayedFocus();
    }
    return true;
  };
  var focus$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    focus: focus2
  });
  var forEach4 = (items, fn2) => (props) => {
    return items.every((item, index3) => fn2(item, { ...props, index: index3 }));
  };
  var forEach$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    forEach: forEach4
  });
  var insertContent = (value, options) => ({ tr, commands }) => {
    return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
  };
  var insertContent$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    insertContent
  });
  function elementFromString(value) {
    const wrappedValue = `<body>${value}</body>`;
    return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  }
  function createNodeFromContent(content3, schema, options) {
    options = {
      slice: true,
      parseOptions: {},
      ...options
    };
    if (typeof content3 === "object" && content3 !== null) {
      try {
        if (Array.isArray(content3)) {
          return Fragment.fromArray(content3.map((item) => schema.nodeFromJSON(item)));
        }
        return schema.nodeFromJSON(content3);
      } catch (error3) {
        console.warn("[tiptap warn]: Invalid content.", "Passed value:", content3, "Error:", error3);
        return createNodeFromContent("", schema, options);
      }
    }
    if (typeof content3 === "string") {
      const parser = DOMParser2.fromSchema(schema);
      return options.slice ? parser.parseSlice(elementFromString(content3), options.parseOptions).content : parser.parse(elementFromString(content3), options.parseOptions);
    }
    return createNodeFromContent("", schema, options);
  }
  function selectionToInsertionEnd2(tr, startLen, bias) {
    const last = tr.steps.length - 1;
    if (last < startLen) {
      return;
    }
    const step3 = tr.steps[last];
    if (!(step3 instanceof ReplaceStep || step3 instanceof ReplaceAroundStep)) {
      return;
    }
    const map22 = tr.mapping.maps[last];
    let end4 = 0;
    map22.forEach((_from, _to, _newFrom, newTo) => {
      if (end4 === 0) {
        end4 = newTo;
      }
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end4), bias));
  }
  var isFragment = (nodeOrFragment) => {
    return nodeOrFragment.toString().startsWith("<");
  };
  var insertContentAt = (position, value, options) => ({ tr, dispatch: dispatch3, editor }) => {
    if (dispatch3) {
      options = {
        parseOptions: {},
        updateSelection: true,
        ...options
      };
      const content3 = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        }
      });
      if (content3.toString() === "<>") {
        return true;
      }
      let { from: from5, to } = typeof position === "number" ? { from: position, to: position } : position;
      let isOnlyTextContent = true;
      let isOnlyBlockContent = true;
      const nodes = isFragment(content3) ? content3 : [content3];
      nodes.forEach((node5) => {
        node5.check();
        isOnlyTextContent = isOnlyTextContent ? node5.isText && node5.marks.length === 0 : false;
        isOnlyBlockContent = isOnlyBlockContent ? node5.isBlock : false;
      });
      if (from5 === to && isOnlyBlockContent) {
        const { parent } = tr.doc.resolve(from5);
        const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
        if (isEmptyTextBlock) {
          from5 -= 1;
          to += 1;
        }
      }
      if (isOnlyTextContent) {
        tr.insertText(value, from5, to);
      } else {
        tr.replaceWith(from5, to, content3);
      }
      if (options.updateSelection) {
        selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
      }
    }
    return true;
  };
  var insertContentAt$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    insertContentAt
  });
  var joinBackward2 = () => ({ state, dispatch: dispatch3 }) => {
    return joinBackward(state, dispatch3);
  };
  var joinBackward$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    joinBackward: joinBackward2
  });
  var joinForward2 = () => ({ state, dispatch: dispatch3 }) => {
    return joinForward(state, dispatch3);
  };
  var joinForward$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    joinForward: joinForward2
  });
  function isMacOS() {
    return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  }
  function normalizeKeyName2(name) {
    const parts = name.split(/-(?!$)/);
    let result2 = parts[parts.length - 1];
    if (result2 === "Space") {
      result2 = " ";
    }
    let alt;
    let ctrl;
    let shift2;
    let meta;
    for (let i = 0; i < parts.length - 1; i += 1) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift2 = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error(`Unrecognized modifier name: ${mod}`);
      }
    }
    if (alt) {
      result2 = `Alt-${result2}`;
    }
    if (ctrl) {
      result2 = `Ctrl-${result2}`;
    }
    if (meta) {
      result2 = `Meta-${result2}`;
    }
    if (shift2) {
      result2 = `Shift-${result2}`;
    }
    return result2;
  }
  var keyboardShortcut = (name) => ({ editor, view, tr, dispatch: dispatch3 }) => {
    const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
    const key2 = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
    const event = new KeyboardEvent("keydown", {
      key: key2 === "Space" ? " " : key2,
      altKey: keys2.includes("Alt"),
      ctrlKey: keys2.includes("Ctrl"),
      metaKey: keys2.includes("Meta"),
      shiftKey: keys2.includes("Shift"),
      bubbles: true,
      cancelable: true
    });
    const capturedTransaction = editor.captureTransaction(() => {
      view.someProp("handleKeyDown", (f) => f(view, event));
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step3) => {
      const newStep = step3.map(tr.mapping);
      if (newStep && dispatch3) {
        tr.maybeStep(newStep);
      }
    });
    return true;
  };
  var keyboardShortcut$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    keyboardShortcut
  });
  function isNodeActive(state, typeOrName, attributes = {}) {
    const { from: from5, to, empty: empty2 } = state.selection;
    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from5, to, (node5, pos) => {
      if (node5.isText) {
        return;
      }
      const relativeFrom = Math.max(from5, pos);
      const relativeTo = Math.min(to, pos + node5.nodeSize);
      nodeRanges.push({
        node: node5,
        from: relativeFrom,
        to: relativeTo
      });
    });
    const selectionRange = to - from5;
    const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
      if (!type) {
        return true;
      }
      return type.name === nodeRange.node.type.name;
    }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
    if (empty2) {
      return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
    return range >= selectionRange;
  }
  var lift2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch3 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (!isActive2) {
      return false;
    }
    return lift(state, dispatch3);
  };
  var lift$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    lift: lift2
  });
  var liftEmptyBlock2 = () => ({ state, dispatch: dispatch3 }) => {
    return liftEmptyBlock(state, dispatch3);
  };
  var liftEmptyBlock$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    liftEmptyBlock: liftEmptyBlock2
  });
  var liftListItem2 = (typeOrName) => ({ state, dispatch: dispatch3 }) => {
    const type = getNodeType(typeOrName, state.schema);
    return liftListItem(type)(state, dispatch3);
  };
  var liftListItem$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    liftListItem: liftListItem2
  });
  var newlineInCode2 = () => ({ state, dispatch: dispatch3 }) => {
    return newlineInCode(state, dispatch3);
  };
  var newlineInCode$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    newlineInCode: newlineInCode2
  });
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce((newObj, prop) => {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch: dispatch3 }) => {
    let nodeType2 = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType2 = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch3) {
      tr.selection.ranges.forEach((range) => {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node5, pos) => {
          if (nodeType2 && nodeType2 === node5.type) {
            tr.setNodeMarkup(pos, void 0, deleteProps(node5.attrs, attributes));
          }
          if (markType && node5.marks.length) {
            node5.marks.forEach((mark4) => {
              if (markType === mark4.type) {
                tr.addMark(pos, pos + node5.nodeSize, markType.create(deleteProps(mark4.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
  var resetAttributes$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    resetAttributes
  });
  var scrollIntoView = () => ({ tr, dispatch: dispatch3 }) => {
    if (dispatch3) {
      tr.scrollIntoView();
    }
    return true;
  };
  var scrollIntoView$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    scrollIntoView
  });
  var selectAll2 = () => ({ tr, commands }) => {
    return commands.setTextSelection({
      from: 0,
      to: tr.doc.content.size
    });
  };
  var selectAll$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    selectAll: selectAll2
  });
  var selectNodeBackward2 = () => ({ state, dispatch: dispatch3 }) => {
    return selectNodeBackward(state, dispatch3);
  };
  var selectNodeBackward$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    selectNodeBackward: selectNodeBackward2
  });
  var selectNodeForward2 = () => ({ state, dispatch: dispatch3 }) => {
    return selectNodeForward(state, dispatch3);
  };
  var selectNodeForward$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    selectNodeForward: selectNodeForward2
  });
  var selectParentNode2 = () => ({ state, dispatch: dispatch3 }) => {
    return selectParentNode(state, dispatch3);
  };
  var selectParentNode$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    selectParentNode: selectParentNode2
  });
  var selectTextblockEnd2 = () => ({ state, dispatch: dispatch3 }) => {
    return selectTextblockEnd(state, dispatch3);
  };
  var selectTextblockEnd$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    selectTextblockEnd: selectTextblockEnd2
  });
  var selectTextblockStart2 = () => ({ state, dispatch: dispatch3 }) => {
    return selectTextblockStart(state, dispatch3);
  };
  var selectTextblockStart$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    selectTextblockStart: selectTextblockStart2
  });
  function createDocument(content3, schema, parseOptions = {}) {
    return createNodeFromContent(content3, schema, { slice: false, parseOptions });
  }
  var setContent = (content3, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch: dispatch3 }) => {
    const { doc: doc2 } = tr;
    const document2 = createDocument(content3, editor.schema, parseOptions);
    const selection = TextSelection.create(doc2, 0, doc2.content.size);
    if (dispatch3) {
      tr.setSelection(selection).replaceSelectionWith(document2, false).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  };
  var setContent$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setContent
  });
  function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from: from5, to, empty: empty2 } = state.selection;
    const marks3 = [];
    if (empty2) {
      if (state.storedMarks) {
        marks3.push(...state.storedMarks);
      }
      marks3.push(...state.selection.$head.marks());
    } else {
      state.doc.nodesBetween(from5, to, (node5) => {
        marks3.push(...node5.marks);
      });
    }
    const mark4 = marks3.find((markItem) => markItem.type.name === type.name);
    if (!mark4) {
      return {};
    }
    return { ...mark4.attrs };
  }
  var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch3 }) => {
    const { selection } = tr;
    const { empty: empty2, ranges } = selection;
    const type = getMarkType(typeOrName, state.schema);
    if (dispatch3) {
      if (empty2) {
        const oldAttributes = getMarkAttributes(state, type);
        tr.addStoredMark(type.create({
          ...oldAttributes,
          ...attributes
        }));
      } else {
        ranges.forEach((range) => {
          const from5 = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from5, to, (node5, pos) => {
            const trimmedFrom = Math.max(pos, from5);
            const trimmedTo = Math.min(pos + node5.nodeSize, to);
            const someHasMark = node5.marks.find((mark4) => mark4.type === type);
            if (someHasMark) {
              node5.marks.forEach((mark4) => {
                if (type === mark4.type) {
                  tr.addMark(trimmedFrom, trimmedTo, type.create({
                    ...mark4.attrs,
                    ...attributes
                  }));
                }
              });
            } else {
              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return true;
  };
  var setMark$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setMark
  });
  var setMeta = (key2, value) => ({ tr }) => {
    tr.setMeta(key2, value);
    return true;
  };
  var setMeta$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setMeta
  });
  var setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch3, chain }) => {
    const type = getNodeType(typeOrName, state.schema);
    if (!type.isTextblock) {
      console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
      return false;
    }
    return chain().command(({ commands }) => {
      const canSetBlock = setBlockType(type, attributes)(state);
      if (canSetBlock) {
        return true;
      }
      return commands.clearNodes();
    }).command(({ state: updatedState }) => {
      return setBlockType(type, attributes)(updatedState, dispatch3);
    }).run();
  };
  var setNode$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setNode
  });
  var setNodeSelection = (position) => ({ tr, dispatch: dispatch3 }) => {
    if (dispatch3) {
      const { doc: doc2 } = tr;
      const minPos = Selection.atStart(doc2).from;
      const maxPos = Selection.atEnd(doc2).to;
      const resolvedPos = minMax(position, minPos, maxPos);
      const selection = NodeSelection.create(doc2, resolvedPos);
      tr.setSelection(selection);
    }
    return true;
  };
  var setNodeSelection$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setNodeSelection
  });
  var setTextSelection = (position) => ({ tr, dispatch: dispatch3 }) => {
    if (dispatch3) {
      const { doc: doc2 } = tr;
      const { from: from5, to } = typeof position === "number" ? { from: position, to: position } : position;
      const minPos = TextSelection.atStart(doc2).from;
      const maxPos = TextSelection.atEnd(doc2).to;
      const resolvedFrom = minMax(from5, minPos, maxPos);
      const resolvedEnd = minMax(to, minPos, maxPos);
      const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
      tr.setSelection(selection);
    }
    return true;
  };
  var setTextSelection$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setTextSelection
  });
  var sinkListItem2 = (typeOrName) => ({ state, dispatch: dispatch3 }) => {
    const type = getNodeType(typeOrName, state.schema);
    return sinkListItem(type)(state, dispatch3);
  };
  var sinkListItem$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    sinkListItem: sinkListItem2
  });
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    }));
  }
  function defaultBlockAt$1(match) {
    for (let i = 0; i < match.edgeCount; i += 1) {
      const { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function ensureMarks(state, splittableMarks) {
    const marks3 = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks3) {
      const filteredMarks = marks3.filter((mark4) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark4.type.name));
      state.tr.ensureMarks(filteredMarks);
    }
  }
  var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr, state, dispatch: dispatch3, editor }) => {
    const { selection, doc: doc2 } = tr;
    const { $from, $to } = selection;
    const extensionAttributes = editor.extensionManager.attributes;
    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
        return false;
      }
      if (dispatch3) {
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    if (dispatch3) {
      const atEnd3 = $to.parentOffset === $to.parent.content.size;
      if (selection instanceof TextSelection) {
        tr.deleteSelection();
      }
      const deflt = $from.depth === 0 ? void 0 : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let types = atEnd3 && deflt ? [{
        type: deflt,
        attrs: newAttributes
      }] : void 0;
      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types = deflt ? [{
          type: deflt,
          attrs: newAttributes
        }] : void 0;
      }
      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (deflt && !atEnd3 && !$from.parentOffset && $from.parent.type !== deflt) {
          const first2 = tr.mapping.map($from.before());
          const $first = tr.doc.resolve(first2);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.scrollIntoView();
    }
    return true;
  };
  var splitBlock$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    splitBlock: splitBlock2
  });
  var splitListItem = (typeOrName) => ({ tr, state, dispatch: dispatch3, editor }) => {
    var _a;
    const type = getNodeType(typeOrName, state.schema);
    const { $from, $to } = state.selection;
    const node5 = state.selection.node;
    if (node5 && node5.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    const grandParent = $from.node(-1);
    if (grandParent.type !== type) {
      return false;
    }
    const extensionAttributes = editor.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch3) {
        let wrap = Fragment.empty;
        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
          wrap = Fragment.from($from.node(d).copy(wrap));
        }
        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
        const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
        wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
        const start6 = $from.before($from.depth - (depthBefore - 1));
        tr.replace(start6, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));
        let sel = -1;
        tr.doc.nodesBetween(start6, tr.doc.content.size, (n, pos) => {
          if (sel > -1) {
            return false;
          }
          if (n.isTextblock && n.content.size === 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
        }
        tr.scrollIntoView();
      }
      return true;
    }
    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
    const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    tr.delete($from.pos, $to.pos);
    const types = nextType ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }] : [{ type, attrs: newTypeAttributes }];
    if (!canSplit(tr.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch3) {
      tr.split($from.pos, 2, types).scrollIntoView();
    }
    return true;
  };
  var splitListItem$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    splitListItem
  });
  function findParentNodeClosestToPos($pos, predicate) {
    for (let i = $pos.depth; i > 0; i -= 1) {
      const node5 = $pos.node(i);
      if (predicate(node5)) {
        return {
          pos: i > 0 ? $pos.before(i) : 0,
          start: $pos.start(i),
          depth: i,
          node: node5
        };
      }
    }
  }
  function findParentNode(predicate) {
    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
  }
  function splitExtensions(extensions2) {
    const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
    const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
    const markExtensions = extensions2.filter((extension) => extension.type === "mark");
    return {
      baseExtensions,
      nodeExtensions,
      markExtensions
    };
  }
  function isList(name, extensions2) {
    const { nodeExtensions } = splitExtensions(extensions2);
    const extension = nodeExtensions.find((item) => item.name === name);
    if (!extension) {
      return false;
    }
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const group = callOrReturn(getExtensionField(extension, "group", context));
    if (typeof group !== "string") {
      return false;
    }
    return group.split(" ").includes("list");
  }
  var joinListBackwards = (tr, listType) => {
    const list = findParentNode((node5) => node5.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const before3 = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
    if (before3 === void 0) {
      return true;
    }
    const nodeBefore = tr.doc.nodeAt(before3);
    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
    if (!canJoinBackwards) {
      return true;
    }
    tr.join(list.pos);
    return true;
  };
  var joinListForwards = (tr, listType) => {
    const list = findParentNode((node5) => node5.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const after3 = tr.doc.resolve(list.start).after(list.depth);
    if (after3 === void 0) {
      return true;
    }
    const nodeAfter = tr.doc.nodeAt(after3);
    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after3);
    if (!canJoinForwards) {
      return true;
    }
    tr.join(after3);
    return true;
  };
  var toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch: dispatch3, chain, commands, can }) => {
    const { extensions: extensions2 } = editor.extensionManager;
    const listType = getNodeType(listTypeOrName, state.schema);
    const itemType = getNodeType(itemTypeOrName, state.schema);
    const { selection } = state;
    const { $from, $to } = selection;
    const range = $from.blockRange($to);
    if (!range) {
      return false;
    }
    const parentList = findParentNode((node5) => isList(node5.type.name, extensions2))(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
      if (parentList.node.type === listType) {
        return commands.liftListItem(itemType);
      }
      if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch3) {
        return chain().command(() => {
          tr.setNodeMarkup(parentList.pos, listType);
          return true;
        }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
      }
    }
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
  };
  var toggleList$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    toggleList
  });
  function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty: empty2, ranges } = state.selection;
    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty2) {
      return !!(state.storedMarks || state.selection.$from.marks()).filter((mark4) => {
        if (!type) {
          return true;
        }
        return type.name === mark4.type.name;
      }).find((mark4) => objectIncludes(mark4.attrs, attributes, { strict: false }));
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
      const from5 = $from.pos;
      const to = $to.pos;
      state.doc.nodesBetween(from5, to, (node5, pos) => {
        if (!node5.isText && !node5.marks.length) {
          return;
        }
        const relativeFrom = Math.max(from5, pos);
        const relativeTo = Math.min(to, pos + node5.nodeSize);
        const range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push(...node5.marks.map((mark4) => ({
          mark: mark4,
          from: relativeFrom,
          to: relativeTo
        })));
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    const matchedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return type.name === markRange.mark.type.name;
    }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const excludedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
    const { extendEmptyMarkRange = false } = options;
    const type = getMarkType(typeOrName, state.schema);
    const isActive2 = isMarkActive(state, type, attributes);
    if (isActive2) {
      return commands.unsetMark(type, { extendEmptyMarkRange });
    }
    return commands.setMark(type, attributes);
  };
  var toggleMark$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    toggleMark
  });
  var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
    const type = getNodeType(typeOrName, state.schema);
    const toggleType = getNodeType(toggleTypeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (isActive2) {
      return commands.setNode(toggleType);
    }
    return commands.setNode(type, attributes);
  };
  var toggleNode$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    toggleNode
  });
  var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (isActive2) {
      return commands.lift(type);
    }
    return commands.wrapIn(type, attributes);
  };
  var toggleWrap$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    toggleWrap
  });
  var undoInputRule = () => ({ state, dispatch: dispatch3 }) => {
    const plugins = state.plugins;
    for (let i = 0; i < plugins.length; i += 1) {
      const plugin = plugins[i];
      let undoable;
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch3) {
          const tr = state.tr;
          const toUndo = undoable.transform;
          for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
            tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
          }
          if (undoable.text) {
            const marks3 = tr.doc.resolve(undoable.from).marks();
            tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks3));
          } else {
            tr.delete(undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
  var undoInputRule$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    undoInputRule
  });
  var unsetAllMarks = () => ({ tr, dispatch: dispatch3 }) => {
    const { selection } = tr;
    const { empty: empty2, ranges } = selection;
    if (empty2) {
      return true;
    }
    if (dispatch3) {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
  var unsetAllMarks$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    unsetAllMarks
  });
  var unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch: dispatch3 }) => {
    var _a;
    const { extendEmptyMarkRange = false } = options;
    const { selection } = tr;
    const type = getMarkType(typeOrName, state.schema);
    const { $from, empty: empty2, ranges } = selection;
    if (!dispatch3) {
      return true;
    }
    if (empty2 && extendEmptyMarkRange) {
      let { from: from5, to } = selection;
      const attrs = (_a = $from.marks().find((mark4) => mark4.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
      const range = getMarkRange($from, type, attrs);
      if (range) {
        from5 = range.from;
        to = range.to;
      }
      tr.removeMark(from5, to, type);
    } else {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos, type);
      });
    }
    tr.removeStoredMark(type);
    return true;
  };
  var unsetMark$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    unsetMark
  });
  var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch3 }) => {
    let nodeType2 = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType2 = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch3) {
      tr.selection.ranges.forEach((range) => {
        const from5 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from5, to, (node5, pos) => {
          if (nodeType2 && nodeType2 === node5.type) {
            tr.setNodeMarkup(pos, void 0, {
              ...node5.attrs,
              ...attributes
            });
          }
          if (markType && node5.marks.length) {
            node5.marks.forEach((mark4) => {
              if (markType === mark4.type) {
                const trimmedFrom = Math.max(pos, from5);
                const trimmedTo = Math.min(pos + node5.nodeSize, to);
                tr.addMark(trimmedFrom, trimmedTo, markType.create({
                  ...mark4.attrs,
                  ...attributes
                }));
              }
            });
          }
        });
      });
    }
    return true;
  };
  var updateAttributes$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    updateAttributes
  });
  var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch3 }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapIn(type, attributes)(state, dispatch3);
  };
  var wrapIn$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    wrapIn: wrapIn2
  });
  var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch3 }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapInList(type, attributes)(state, dispatch3);
  };
  var wrapInList$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    wrapInList: wrapInList2
  });
  var Commands = Extension.create({
    name: "commands",
    addCommands() {
      return {
        ...blur$1,
        ...clearContent$1,
        ...clearNodes$1,
        ...command$1,
        ...createParagraphNear$1,
        ...deleteNode$1,
        ...deleteRange$1,
        ...deleteSelection$1,
        ...enter$1,
        ...exitCode$1,
        ...extendMarkRange$1,
        ...first$1,
        ...focus$1,
        ...forEach$1,
        ...insertContent$1,
        ...insertContentAt$1,
        ...joinBackward$1,
        ...joinForward$1,
        ...keyboardShortcut$1,
        ...lift$1,
        ...liftEmptyBlock$1,
        ...liftListItem$1,
        ...newlineInCode$1,
        ...resetAttributes$1,
        ...scrollIntoView$1,
        ...selectAll$1,
        ...selectNodeBackward$1,
        ...selectNodeForward$1,
        ...selectParentNode$1,
        ...selectTextblockEnd$1,
        ...selectTextblockStart$1,
        ...setContent$1,
        ...setMark$1,
        ...setMeta$1,
        ...setNode$1,
        ...setNodeSelection$1,
        ...setTextSelection$1,
        ...sinkListItem$1,
        ...splitBlock$1,
        ...splitListItem$1,
        ...toggleList$1,
        ...toggleMark$1,
        ...toggleNode$1,
        ...toggleWrap$1,
        ...undoInputRule$1,
        ...unsetAllMarks$1,
        ...unsetMark$1,
        ...updateAttributes$1,
        ...wrapIn$1,
        ...wrapInList$1
      };
    }
  });
  var Editable = Extension.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("editable"),
          props: {
            editable: () => this.editor.options.editable
          }
        })
      ];
    }
  });
  var FocusEvents = Extension.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor } = this;
      return [
        new Plugin({
          key: new PluginKey("focusEvents"),
          props: {
            handleDOMEvents: {
              focus: (view, event) => {
                editor.isFocused = true;
                const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              },
              blur: (view, event) => {
                editor.isFocused = false;
                const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              }
            }
          }
        })
      ];
    }
  });
  function createChainableState(config) {
    const { state, transaction } = config;
    let { selection } = transaction;
    let { doc: doc2 } = transaction;
    let { storedMarks } = transaction;
    return {
      ...state,
      schema: state.schema,
      plugins: state.plugins,
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc2;
      },
      get tr() {
        selection = transaction.selection;
        doc2 = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      }
    };
  }
  var CommandManager = class {
    constructor(props) {
      this.editor = props.editor;
      this.rawCommands = this.editor.extensionManager.commands;
      this.customState = props.state;
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const { tr } = state;
      const props = this.buildProps(tr);
      return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr);
          }
          return callback;
        };
        return [name, method];
      }));
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(startTr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const callbacks = [];
      const hasStartTransaction = !!startTr;
      const tr = startTr || state.tr;
      const run3 = () => {
        if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callbacks.every((callback) => callback === true);
      };
      const chain = {
        ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain;
          };
          return [name, chainedCommand];
        })),
        run: run3
      };
      return chain;
    }
    createCan(startTr) {
      const { rawCommands, state } = this;
      const dispatch3 = void 0;
      const tr = startTr || state.tr;
      const props = this.buildProps(tr, dispatch3);
      const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: dispatch3 })];
      }));
      return {
        ...formattedCommands,
        chain: () => this.createChain(tr, dispatch3)
      };
    }
    buildProps(tr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      if (state.storedMarks) {
        tr.setStoredMarks(state.storedMarks);
      }
      const props = {
        tr,
        editor,
        view,
        state: createChainableState({
          state,
          transaction: tr
        }),
        dispatch: shouldDispatch ? () => void 0 : void 0,
        chain: () => this.createChain(tr),
        can: () => this.createCan(tr),
        get commands() {
          return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          }));
        }
      };
      return props;
    }
  };
  var Keymap = Extension.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const handleBackspace = () => this.editor.commands.first(({ commands }) => [
        () => commands.undoInputRule(),
        () => commands.command(({ tr }) => {
          const { selection, doc: doc2 } = tr;
          const { empty: empty2, $anchor } = selection;
          const { pos, parent } = $anchor;
          const isAtStart = Selection.atStart(doc2).from === pos;
          if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
            return false;
          }
          return commands.clearNodes();
        }),
        () => commands.deleteSelection(),
        () => commands.joinBackward(),
        () => commands.selectNodeBackward()
      ]);
      const handleDelete = () => this.editor.commands.first(({ commands }) => [
        () => commands.deleteSelection(),
        () => commands.joinForward(),
        () => commands.selectNodeForward()
      ]);
      const handleEnter = () => this.editor.commands.first(({ commands }) => [
        () => commands.newlineInCode(),
        () => commands.createParagraphNear(),
        () => commands.liftEmptyBlock(),
        () => commands.splitBlock()
      ]);
      const baseKeymap = {
        Enter: handleEnter,
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: handleBackspace,
        "Mod-Backspace": handleBackspace,
        "Shift-Backspace": handleBackspace,
        Delete: handleDelete,
        "Mod-Delete": handleDelete,
        "Mod-a": () => this.editor.commands.selectAll()
      };
      const pcKeymap = {
        ...baseKeymap,
        Home: () => this.editor.commands.selectTextblockStart(),
        End: () => this.editor.commands.selectTextblockEnd()
      };
      const macKeymap = {
        ...baseKeymap,
        "Ctrl-h": handleBackspace,
        "Alt-Backspace": handleBackspace,
        "Ctrl-d": handleDelete,
        "Ctrl-Alt-Backspace": handleDelete,
        "Alt-Delete": handleDelete,
        "Alt-d": handleDelete,
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
      };
      if (isiOS() || isMacOS()) {
        return macKeymap;
      }
      return pcKeymap;
    },
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("clearDocument"),
          appendTransaction: (transactions, oldState, newState) => {
            const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
            if (!docChanges) {
              return;
            }
            const { empty: empty2, from: from5, to } = oldState.selection;
            const allFrom = Selection.atStart(oldState.doc).from;
            const allEnd = Selection.atEnd(oldState.doc).to;
            const allWasSelected = from5 === allFrom && to === allEnd;
            const isEmpty2 = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
            if (empty2 || !allWasSelected || !isEmpty2) {
              return;
            }
            const tr = newState.tr;
            const state = createChainableState({
              state: newState,
              transaction: tr
            });
            const { commands } = new CommandManager({
              editor: this.editor,
              state
            });
            commands.clearNodes();
            if (!tr.steps.length) {
              return;
            }
            return tr;
          }
        })
      ];
    }
  });
  var Tabindex = Extension.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tabindex"),
          props: {
            attributes: () => {
              if (this.editor.isEditable) {
                return {
                  tabindex: "0"
                };
              }
            }
          }
        })
      ];
    }
  });
  var extensions = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ClipboardTextSerializer,
    Commands,
    Editable,
    FocusEvents,
    Keymap,
    Tabindex
  });
  function getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from: from5, to } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from5, to, (node6) => {
      nodes.push(node6);
    });
    const node5 = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node5) {
      return {};
    }
    return { ...node5.attrs };
  }
  function getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (schemaType === "node") {
      return getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return getMarkAttributes(state, typeOrName);
    }
    return {};
  }
  function isActive(state, name, attributes = {}) {
    if (!name) {
      return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
    }
    const schemaType = getSchemaTypeNameByName(name, state.schema);
    if (schemaType === "node") {
      return isNodeActive(state, name, attributes);
    }
    if (schemaType === "mark") {
      return isMarkActive(state, name, attributes);
    }
    return false;
  }
  function getHTMLFromFragment(fragment, schema) {
    const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
    const temporaryDocument = document.implementation.createHTMLDocument();
    const container = temporaryDocument.createElement("div");
    container.appendChild(documentFragment);
    return container.innerHTML;
  }
  function getText(node5, options) {
    const range = {
      from: 0,
      to: node5.content.size
    };
    return getTextBetween(node5, range, options);
  }
  function isNodeEmpty(node5) {
    var _a;
    const defaultContent = (_a = node5.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
    const content3 = node5.toJSON();
    return JSON.stringify(defaultContent) === JSON.stringify(content3);
  }
  function createStyleTag(style2) {
    const tipTapStyleTag = document.querySelector("style[data-tiptap-style]");
    if (tipTapStyleTag !== null) {
      return tipTapStyleTag;
    }
    const styleNode = document.createElement("style");
    styleNode.setAttribute("data-tiptap-style", "");
    styleNode.innerHTML = style2;
    document.getElementsByTagName("head")[0].appendChild(styleNode);
    return styleNode;
  }
  var InputRule = class {
    constructor(config) {
      this.find = config.find;
      this.handler = config.handler;
    }
  };
  var inputRuleMatcherHandler = (text4, find3) => {
    if (isRegExp(find3)) {
      return find3.exec(text4);
    }
    const inputRuleMatch = find3(text4);
    if (!inputRuleMatch) {
      return null;
    }
    const result2 = [];
    result2.push(inputRuleMatch.text);
    result2.index = inputRuleMatch.index;
    result2.input = text4;
    result2.data = inputRuleMatch.data;
    if (inputRuleMatch.replaceWith) {
      if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
      }
      result2.push(inputRuleMatch.replaceWith);
    }
    return result2;
  };
  function run$1(config) {
    var _a;
    const { editor, from: from5, to, text: text4, rules, plugin } = config;
    const { view } = editor;
    if (view.composing) {
      return false;
    }
    const $from = view.state.doc.resolve(from5);
    if ($from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark4) => mark4.type.spec.code))) {
      return false;
    }
    let matched = false;
    const maxMatch = 500;
    const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, void 0, " ") + text4;
    rules.forEach((rule) => {
      if (matched) {
        return;
      }
      const match = inputRuleMatcherHandler(textBefore, rule.find);
      if (!match) {
        return;
      }
      const tr = view.state.tr;
      const state = createChainableState({
        state: view.state,
        transaction: tr
      });
      const range = {
        from: from5 - (match[0].length - text4.length),
        to
      };
      const { commands, chain, can } = new CommandManager({
        editor,
        state
      });
      const handler = rule.handler({
        state,
        range,
        match,
        commands,
        chain,
        can
      });
      if (handler === null || !tr.steps.length) {
        return;
      }
      tr.setMeta(plugin, {
        transform: tr,
        from: from5,
        to,
        text: text4
      });
      view.dispatch(tr);
      matched = true;
    });
    return matched;
  }
  function inputRulesPlugin(props) {
    const { editor, rules } = props;
    const plugin = new Plugin({
      state: {
        init() {
          return null;
        },
        apply(tr, prev) {
          const stored = tr.getMeta(this);
          if (stored) {
            return stored;
          }
          return tr.selectionSet || tr.docChanged ? null : prev;
        }
      },
      props: {
        handleTextInput(view, from5, to, text4) {
          return run$1({
            editor,
            from: from5,
            to,
            text: text4,
            rules,
            plugin
          });
        },
        handleDOMEvents: {
          compositionend: (view) => {
            setTimeout(() => {
              const { $cursor } = view.state.selection;
              if ($cursor) {
                run$1({
                  editor,
                  from: $cursor.pos,
                  to: $cursor.pos,
                  text: "",
                  rules,
                  plugin
                });
              }
            });
            return false;
          }
        },
        handleKeyDown(view, event) {
          if (event.key !== "Enter") {
            return false;
          }
          const { $cursor } = view.state.selection;
          if ($cursor) {
            return run$1({
              editor,
              from: $cursor.pos,
              to: $cursor.pos,
              text: "\n",
              rules,
              plugin
            });
          }
          return false;
        }
      },
      isInputRules: true
    });
    return plugin;
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  var PasteRule = class {
    constructor(config) {
      this.find = config.find;
      this.handler = config.handler;
    }
  };
  var pasteRuleMatcherHandler = (text4, find3) => {
    if (isRegExp(find3)) {
      return [...text4.matchAll(find3)];
    }
    const matches2 = find3(text4);
    if (!matches2) {
      return [];
    }
    return matches2.map((pasteRuleMatch) => {
      const result2 = [];
      result2.push(pasteRuleMatch.text);
      result2.index = pasteRuleMatch.index;
      result2.input = text4;
      result2.data = pasteRuleMatch.data;
      if (pasteRuleMatch.replaceWith) {
        if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
        }
        result2.push(pasteRuleMatch.replaceWith);
      }
      return result2;
    });
  };
  function run(config) {
    const { editor, state, from: from5, to, rule } = config;
    const { commands, chain, can } = new CommandManager({
      editor,
      state
    });
    const handlers2 = [];
    state.doc.nodesBetween(from5, to, (node5, pos) => {
      if (!node5.isTextblock || node5.type.spec.code) {
        return;
      }
      const resolvedFrom = Math.max(from5, pos);
      const resolvedTo = Math.min(to, pos + node5.content.size);
      const textToMatch = node5.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
      const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find);
      matches2.forEach((match) => {
        if (match.index === void 0) {
          return;
        }
        const start6 = resolvedFrom + match.index + 1;
        const end4 = start6 + match[0].length;
        const range = {
          from: state.tr.mapping.map(start6),
          to: state.tr.mapping.map(end4)
        };
        const handler = rule.handler({
          state,
          range,
          match,
          commands,
          chain,
          can
        });
        handlers2.push(handler);
      });
    });
    const success = handlers2.every((handler) => handler !== null);
    return success;
  }
  function pasteRulesPlugin(props) {
    const { editor, rules } = props;
    let dragSourceElement = null;
    let isPastedFromProseMirror = false;
    let isDroppedFromProseMirror = false;
    const plugins = rules.map((rule) => {
      return new Plugin({
        view(view) {
          const handleDragstart = (event) => {
            var _a;
            dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
          };
          window.addEventListener("dragstart", handleDragstart);
          return {
            destroy() {
              window.removeEventListener("dragstart", handleDragstart);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (view) => {
              isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
              return false;
            },
            paste: (view, event) => {
              var _a;
              const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
              isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
              return false;
            }
          }
        },
        appendTransaction: (transactions, oldState, state) => {
          const transaction = transactions[0];
          const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
          const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
          if (!isPaste && !isDrop) {
            return;
          }
          const from5 = oldState.doc.content.findDiffStart(state.doc.content);
          const to = oldState.doc.content.findDiffEnd(state.doc.content);
          if (!isNumber(from5) || !to || from5 === to.b) {
            return;
          }
          const tr = state.tr;
          const chainableState = createChainableState({
            state,
            transaction: tr
          });
          const handler = run({
            editor,
            state: chainableState,
            from: Math.max(from5 - 1, 0),
            to: to.b,
            rule
          });
          if (!handler || !tr.steps.length) {
            return;
          }
          return tr;
        }
      });
    });
    return plugins;
  }
  function getAttributesFromExtensions(extensions2) {
    const extensionAttributes = [];
    const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: true
    };
    extensions2.forEach((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
      if (!addGlobalAttributes) {
        return;
      }
      const globalAttributes = addGlobalAttributes();
      globalAttributes.forEach((globalAttribute) => {
        globalAttribute.types.forEach((type) => {
          Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
            extensionAttributes.push({
              type,
              name,
              attribute: {
                ...defaultAttribute,
                ...attribute
              }
            });
          });
        });
      });
    });
    nodeAndMarkExtensions.forEach((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addAttributes = getExtensionField(extension, "addAttributes", context);
      if (!addAttributes) {
        return;
      }
      const attributes = addAttributes();
      Object.entries(attributes).forEach(([name, attribute]) => {
        extensionAttributes.push({
          type: extension.name,
          name,
          attribute: {
            ...defaultAttribute,
            ...attribute
          }
        });
      });
    });
    return extensionAttributes;
  }
  function mergeAttributes(...objects) {
    return objects.filter((item) => !!item).reduce((items, item) => {
      const mergedAttributes = { ...items };
      Object.entries(item).forEach(([key2, value]) => {
        const exists = mergedAttributes[key2];
        if (!exists) {
          mergedAttributes[key2] = value;
          return;
        }
        if (key2 === "class") {
          mergedAttributes[key2] = [mergedAttributes[key2], value].join(" ");
        } else if (key2 === "style") {
          mergedAttributes[key2] = [mergedAttributes[key2], value].join("; ");
        } else {
          mergedAttributes[key2] = value;
        }
      });
      return mergedAttributes;
    }, {});
  }
  function getRenderedAttributes(nodeOrMark, extensionAttributes) {
    return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderHTML) {
        return {
          [item.name]: nodeOrMark.attrs[item.name]
        };
      }
      return item.attribute.renderHTML(nodeOrMark.attrs) || {};
    }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
  }
  function isEmptyObject(value = {}) {
    return Object.keys(value).length === 0 && value.constructor === Object;
  }
  function fromString(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
      return Number(value);
    }
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  function injectExtensionAttributesToParseRule(parseRule2, extensionAttributes) {
    if (parseRule2.style) {
      return parseRule2;
    }
    return {
      ...parseRule2,
      getAttrs: (node5) => {
        const oldAttributes = parseRule2.getAttrs ? parseRule2.getAttrs(node5) : parseRule2.attrs;
        if (oldAttributes === false) {
          return false;
        }
        const newAttributes = extensionAttributes.reduce((items, item) => {
          const value = item.attribute.parseHTML ? item.attribute.parseHTML(node5) : fromString(node5.getAttribute(item.name));
          if (value === null || value === void 0) {
            return items;
          }
          return {
            ...items,
            [item.name]: value
          };
        }, {});
        return { ...oldAttributes, ...newAttributes };
      }
    };
  }
  function cleanUpSchemaItem(data) {
    return Object.fromEntries(Object.entries(data).filter(([key2, value]) => {
      if (key2 === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    }));
  }
  function getSchemaByResolvedExtensions(extensions2) {
    var _a;
    const allAttributes = getAttributesFromExtensions(extensions2);
    const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
    const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
    const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const extraNodeFields = extensions2.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension, "content", context)),
        marks: callOrReturn(getExtensionField(extension, "marks", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        inline: callOrReturn(getExtensionField(extension, "inline", context)),
        atom: callOrReturn(getExtensionField(extension, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        defining: callOrReturn(getExtensionField(extension, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a2;
          return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule2) => injectExtensionAttributesToParseRule(parseRule2, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node5) => renderHTML({
          node: node5,
          HTMLAttributes: getRenderedAttributes(node5, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    }));
    const marks3 = Object.fromEntries(markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const extraMarkFields = extensions2.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a2;
          return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule2) => injectExtensionAttributesToParseRule(parseRule2, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark4) => renderHTML({
          mark: mark4,
          HTMLAttributes: getRenderedAttributes(mark4, extensionAttributes)
        });
      }
      return [extension.name, schema];
    }));
    return new Schema({
      topNode,
      nodes,
      marks: marks3
    });
  }
  function getSchemaTypeByName(name, schema) {
    return schema.nodes[name] || schema.marks[name] || null;
  }
  function isExtensionRulesEnabled(extension, enabled) {
    if (Array.isArray(enabled)) {
      return enabled.some((enabledExtension) => {
        const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
        return name === extension.name;
      });
    }
    return enabled;
  }
  function findDuplicates(items) {
    const filtered = items.filter((el, index3) => items.indexOf(el) !== index3);
    return [...new Set(filtered)];
  }
  var ExtensionManager = class {
    constructor(extensions2, editor) {
      this.splittableMarks = [];
      this.editor = editor;
      this.extensions = ExtensionManager.resolve(extensions2);
      this.schema = getSchemaByResolvedExtensions(this.extensions);
      this.extensions.forEach((extension) => {
        var _a;
        this.editor.extensionStorage[extension.name] = extension.storage;
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        if (extension.type === "mark") {
          const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
          if (keepOnSplit) {
            this.splittableMarks.push(extension.name);
          }
        }
        const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
        if (onBeforeCreate) {
          this.editor.on("beforeCreate", onBeforeCreate);
        }
        const onCreate2 = getExtensionField(extension, "onCreate", context);
        if (onCreate2) {
          this.editor.on("create", onCreate2);
        }
        const onUpdate = getExtensionField(extension, "onUpdate", context);
        if (onUpdate) {
          this.editor.on("update", onUpdate);
        }
        const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
        if (onSelectionUpdate) {
          this.editor.on("selectionUpdate", onSelectionUpdate);
        }
        const onTransaction = getExtensionField(extension, "onTransaction", context);
        if (onTransaction) {
          this.editor.on("transaction", onTransaction);
        }
        const onFocus = getExtensionField(extension, "onFocus", context);
        if (onFocus) {
          this.editor.on("focus", onFocus);
        }
        const onBlur = getExtensionField(extension, "onBlur", context);
        if (onBlur) {
          this.editor.on("blur", onBlur);
        }
        const onDestroy2 = getExtensionField(extension, "onDestroy", context);
        if (onDestroy2) {
          this.editor.on("destroy", onDestroy2);
        }
      });
    }
    static resolve(extensions2) {
      const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions2));
      const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
      if (duplicatedNames.length) {
        console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
      }
      return resolvedExtensions;
    }
    static flatten(extensions2) {
      return extensions2.map((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        const addExtensions = getExtensionField(extension, "addExtensions", context);
        if (addExtensions) {
          return [
            extension,
            ...this.flatten(addExtensions())
          ];
        }
        return extension;
      }).flat(10);
    }
    static sort(extensions2) {
      const defaultPriority = 100;
      return extensions2.sort((a, b) => {
        const priorityA = getExtensionField(a, "priority") || defaultPriority;
        const priorityB = getExtensionField(b, "priority") || defaultPriority;
        if (priorityA > priorityB) {
          return -1;
        }
        if (priorityA < priorityB) {
          return 1;
        }
        return 0;
      });
    }
    get commands() {
      return this.extensions.reduce((commands, extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        const addCommands = getExtensionField(extension, "addCommands", context);
        if (!addCommands) {
          return commands;
        }
        return {
          ...commands,
          ...addCommands()
        };
      }, {});
    }
    get plugins() {
      const { editor } = this;
      const extensions2 = ExtensionManager.sort([...this.extensions].reverse());
      const inputRules = [];
      const pasteRules = [];
      const allPlugins = extensions2.map((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        const plugins = [];
        const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
        if (addKeyboardShortcuts) {
          const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor })];
          }));
          const keyMapPlugin = keymap(bindings);
          plugins.push(keyMapPlugin);
        }
        const addInputRules = getExtensionField(extension, "addInputRules", context);
        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
          inputRules.push(...addInputRules());
        }
        const addPasteRules = getExtensionField(extension, "addPasteRules", context);
        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
          pasteRules.push(...addPasteRules());
        }
        const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
        if (addProseMirrorPlugins) {
          const proseMirrorPlugins = addProseMirrorPlugins();
          plugins.push(...proseMirrorPlugins);
        }
        return plugins;
      }).flat();
      return [
        inputRulesPlugin({
          editor,
          rules: inputRules
        }),
        ...pasteRulesPlugin({
          editor,
          rules: pasteRules
        }),
        ...allPlugins
      ];
    }
    get attributes() {
      return getAttributesFromExtensions(this.extensions);
    }
    get nodeViews() {
      const { editor } = this;
      const { nodeExtensions } = splitExtensions(this.extensions);
      return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor,
          type: getNodeType(extension.name, this.schema)
        };
        const addNodeView = getExtensionField(extension, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeview = (node5, view, getPos, decorations) => {
          const HTMLAttributes = getRenderedAttributes(node5, extensionAttributes);
          return addNodeView()({
            editor,
            node: node5,
            getPos,
            decorations,
            HTMLAttributes,
            extension
          });
        };
        return [extension.name, nodeview];
      }));
    }
  };
  var EventEmitter = class {
    constructor() {
      this.callbacks = {};
    }
    on(event, fn2) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [];
      }
      this.callbacks[event].push(fn2);
      return this;
    }
    emit(event, ...args) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        callbacks.forEach((callback) => callback.apply(this, args));
      }
      return this;
    }
    off(event, fn2) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        if (fn2) {
          this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
        } else {
          delete this.callbacks[event];
        }
      }
      return this;
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  };
  var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
  var Editor = class extends EventEmitter {
    constructor(options = {}) {
      super();
      this.isFocused = false;
      this.extensionStorage = {};
      this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: true,
        extensions: [],
        autofocus: false,
        editable: true,
        editorProps: {},
        parseOptions: {},
        enableInputRules: true,
        enablePasteRules: true,
        enableCoreExtensions: true,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null
      };
      this.isCapturingTransaction = false;
      this.capturedTransaction = null;
      this.setOptions(options);
      this.createExtensionManager();
      this.createCommandManager();
      this.createSchema();
      this.on("beforeCreate", this.options.onBeforeCreate);
      this.emit("beforeCreate", { editor: this });
      this.createView();
      this.injectCSS();
      this.on("create", this.options.onCreate);
      this.on("update", this.options.onUpdate);
      this.on("selectionUpdate", this.options.onSelectionUpdate);
      this.on("transaction", this.options.onTransaction);
      this.on("focus", this.options.onFocus);
      this.on("blur", this.options.onBlur);
      this.on("destroy", this.options.onDestroy);
      window.setTimeout(() => {
        if (this.isDestroyed) {
          return;
        }
        this.commands.focus(this.options.autofocus);
        this.emit("create", { editor: this });
      }, 0);
    }
    get storage() {
      return this.extensionStorage;
    }
    get commands() {
      return this.commandManager.commands;
    }
    chain() {
      return this.commandManager.chain();
    }
    can() {
      return this.commandManager.can();
    }
    injectCSS() {
      if (this.options.injectCSS && document) {
        this.css = createStyleTag(style);
      }
    }
    setOptions(options = {}) {
      this.options = {
        ...this.options,
        ...options
      };
      if (!this.view || !this.state || this.isDestroyed) {
        return;
      }
      if (this.options.editorProps) {
        this.view.setProps(this.options.editorProps);
      }
      this.view.updateState(this.state);
    }
    setEditable(editable) {
      this.setOptions({ editable });
    }
    get isEditable() {
      return this.options.editable && this.view && this.view.editable;
    }
    get state() {
      return this.view.state;
    }
    registerPlugin(plugin, handlePlugins) {
      const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, this.state.plugins) : [...this.state.plugins, plugin];
      const state = this.state.reconfigure({ plugins });
      this.view.updateState(state);
    }
    unregisterPlugin(nameOrPluginKey) {
      if (this.isDestroyed) {
        return;
      }
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      const state = this.state.reconfigure({
        plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
      });
      this.view.updateState(state);
    }
    createExtensionManager() {
      const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
      const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
        return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
      });
      this.extensionManager = new ExtensionManager(allExtensions, this);
    }
    createCommandManager() {
      this.commandManager = new CommandManager({
        editor: this
      });
    }
    createSchema() {
      this.schema = this.extensionManager.schema;
    }
    createView() {
      const doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions);
      const selection = resolveFocusPosition(doc2, this.options.autofocus);
      this.view = new EditorView(this.options.element, {
        ...this.options.editorProps,
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: EditorState.create({
          doc: doc2,
          selection
        })
      });
      const newState = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(newState);
      this.createNodeViews();
      const dom = this.view.dom;
      dom.editor = this;
    }
    createNodeViews() {
      this.view.setProps({
        nodeViews: this.extensionManager.nodeViews
      });
    }
    captureTransaction(fn2) {
      this.isCapturingTransaction = true;
      fn2();
      this.isCapturingTransaction = false;
      const tr = this.capturedTransaction;
      this.capturedTransaction = null;
      return tr;
    }
    dispatchTransaction(transaction) {
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = transaction;
          return;
        }
        transaction.steps.forEach((step3) => {
          var _a;
          return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step3);
        });
        return;
      }
      const state = this.state.apply(transaction);
      const selectionHasChanged = !this.state.selection.eq(state.selection);
      this.view.updateState(state);
      this.emit("transaction", {
        editor: this,
        transaction
      });
      if (selectionHasChanged) {
        this.emit("selectionUpdate", {
          editor: this,
          transaction
        });
      }
      const focus3 = transaction.getMeta("focus");
      const blur2 = transaction.getMeta("blur");
      if (focus3) {
        this.emit("focus", {
          editor: this,
          event: focus3.event,
          transaction
        });
      }
      if (blur2) {
        this.emit("blur", {
          editor: this,
          event: blur2.event,
          transaction
        });
      }
      if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
        return;
      }
      this.emit("update", {
        editor: this,
        transaction
      });
    }
    getAttributes(nameOrType) {
      return getAttributes(this.state, nameOrType);
    }
    isActive(nameOrAttributes, attributesOrUndefined) {
      const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
      const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
      return isActive(this.state, name, attributes);
    }
    getJSON() {
      return this.state.doc.toJSON();
    }
    getHTML() {
      return getHTMLFromFragment(this.state.doc.content, this.schema);
    }
    getText(options) {
      const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
      return getText(this.state.doc, {
        blockSeparator,
        textSerializers: {
          ...textSerializers,
          ...getTextSeralizersFromSchema(this.schema)
        }
      });
    }
    get isEmpty() {
      return isNodeEmpty(this.state.doc);
    }
    getCharacterCount() {
      console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
      return this.state.doc.content.size - 2;
    }
    destroy() {
      this.emit("destroy");
      if (this.view) {
        this.view.destroy();
      }
      this.removeAllListeners();
    }
    get isDestroyed() {
      var _a;
      return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
    }
  };
  var Node4 = class {
    constructor(config = {}) {
      this.type = "node";
      this.name = "node";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new Node4(config);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new Node4(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  };
  var Mark3 = class {
    constructor(config = {}) {
      this.type = "mark";
      this.name = "mark";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new Mark3(config);
    }
    configure(options = {}) {
      const extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new Mark3(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  };
  function nodeInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        const { tr } = state;
        const start6 = range.from;
        let end4 = range.to;
        if (match[1]) {
          const offset4 = match[0].lastIndexOf(match[1]);
          let matchStart = start6 + offset4;
          if (matchStart > end4) {
            matchStart = end4;
          } else {
            end4 = matchStart + match[1].length;
          }
          const lastChar = match[0][match[0].length - 1];
          tr.insertText(lastChar, start6 + match[0].length - 1);
          tr.replaceWith(matchStart, end4, config.type.create(attributes));
        } else if (match[0]) {
          tr.replaceWith(start6, end4, config.type.create(attributes));
        }
      }
    });
  }
  function getMarksBetween(from5, to, doc2) {
    const marks3 = [];
    if (from5 === to) {
      doc2.resolve(from5).marks().forEach((mark4) => {
        const $pos = doc2.resolve(from5 - 1);
        const range = getMarkRange($pos, mark4.type);
        if (!range) {
          return;
        }
        marks3.push({
          mark: mark4,
          ...range
        });
      });
    } else {
      doc2.nodesBetween(from5, to, (node5, pos) => {
        marks3.push(...node5.marks.map((mark4) => ({
          from: pos,
          to: pos + node5.nodeSize,
          mark: mark4
        })));
      });
    }
    return marks3;
  }
  function markInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        let markEnd = range.to;
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr.delete(range.from + startSpaces, textStart);
          }
          markEnd = range.from + startSpaces + captureGroup.length;
          tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
          tr.removeStoredMark(config.type);
        }
      }
    });
  }
  function textblockTypeInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const $start = state.doc.resolve(range.from);
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
          return null;
        }
        state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
      }
    });
  }
  function wrappingInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        const tr = state.tr.delete(range.from, range.to);
        const $start = tr.doc.resolve(range.from);
        const blockRange3 = $start.blockRange();
        const wrapping = blockRange3 && findWrapping3(blockRange3, config.type, attributes);
        if (!wrapping) {
          return null;
        }
        tr.wrap(blockRange3, wrapping);
        const before3 = tr.doc.resolve(range.from - 1).nodeBefore;
        if (before3 && before3.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before3))) {
          tr.join(range.from - 1);
        }
      }
    });
  }
  function markPasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        let markEnd = range.to;
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr.delete(range.from + startSpaces, textStart);
          }
          markEnd = range.from + startSpaces + captureGroup.length;
          tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
          tr.removeStoredMark(config.type);
        }
      }
    });
  }
  function escapeForRegEx(string) {
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function combineTransactionSteps(oldDoc, transactions) {
    const transform = new Transform(oldDoc);
    transactions.forEach((transaction) => {
      transaction.steps.forEach((step3) => {
        transform.step(step3);
      });
    });
    return transform;
  }
  function findChildren(node5, predicate) {
    const nodesWithPos = [];
    node5.descendants((child5, pos) => {
      if (predicate(child5)) {
        nodesWithPos.push({
          node: child5,
          pos
        });
      }
    });
    return nodesWithPos;
  }
  function findChildrenInRange(node5, range, predicate) {
    const nodesWithPos = [];
    node5.nodesBetween(range.from, range.to, (child5, pos) => {
      if (predicate(child5)) {
        nodesWithPos.push({
          node: child5,
          pos
        });
      }
    });
    return nodesWithPos;
  }
  function removeDuplicates(array, by = JSON.stringify) {
    const seen = {};
    return array.filter((item) => {
      const key2 = by(item);
      return Object.prototype.hasOwnProperty.call(seen, key2) ? false : seen[key2] = true;
    });
  }
  function simplifyChangedRanges(changes) {
    const uniqueChanges = removeDuplicates(changes);
    return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index3) => {
      const rest = uniqueChanges.filter((_, i) => i !== index3);
      return !rest.some((otherChange) => {
        return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
      });
    });
  }
  function getChangedRanges(transform) {
    const { mapping, steps } = transform;
    const changes = [];
    mapping.maps.forEach((stepMap, index3) => {
      const ranges = [];
      if (!stepMap.ranges.length) {
        const { from: from5, to } = steps[index3];
        if (from5 === void 0 || to === void 0) {
          return;
        }
        ranges.push({ from: from5, to });
      } else {
        stepMap.forEach((from5, to) => {
          ranges.push({ from: from5, to });
        });
      }
      ranges.forEach(({ from: from5, to }) => {
        const newStart = mapping.slice(index3).map(from5, -1);
        const newEnd = mapping.slice(index3).map(to);
        const oldStart = mapping.invert().map(newStart, -1);
        const oldEnd = mapping.invert().map(newEnd);
        changes.push({
          oldRange: {
            from: oldStart,
            to: oldEnd
          },
          newRange: {
            from: newStart,
            to: newEnd
          }
        });
      });
    });
    return simplifyChangedRanges(changes);
  }
  function isNodeSelection(value) {
    return isObject(value) && value instanceof NodeSelection;
  }
  function posToDOMRect(view, from5, to) {
    const minPos = 0;
    const maxPos = view.state.doc.content.size;
    const resolvedFrom = minMax(from5, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const start6 = view.coordsAtPos(resolvedFrom);
    const end4 = view.coordsAtPos(resolvedEnd, -1);
    const top2 = Math.min(start6.top, end4.top);
    const bottom2 = Math.max(start6.bottom, end4.bottom);
    const left2 = Math.min(start6.left, end4.left);
    const right2 = Math.max(start6.right, end4.right);
    const width = right2 - left2;
    const height = bottom2 - top2;
    const x = left2;
    const y = top2;
    const data = {
      top: top2,
      bottom: bottom2,
      left: left2,
      right: right2,
      width,
      height,
      x,
      y
    };
    return {
      ...data,
      toJSON: () => data
    };
  }

  // node_modules/@tiptap/extension-blockquote/dist/tiptap-extension-blockquote.esm.js
  var inputRegex = /^\s*>\s$/;
  var Blockquote = Node4.create({
    name: "blockquote",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    group: "block",
    defining: true,
    parseHTML() {
      return [
        { tag: "blockquote" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setBlockquote: () => ({ commands }) => {
          return commands.wrapIn(this.name);
        },
        toggleBlockquote: () => ({ commands }) => {
          return commands.toggleWrap(this.name);
        },
        unsetBlockquote: () => ({ commands }) => {
          return commands.lift(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
      };
    },
    addInputRules() {
      return [
        wrappingInputRule({
          find: inputRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-bold/dist/tiptap-extension-bold.esm.js
  var starInputRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
  var starPasteRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
  var underscoreInputRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
  var underscorePasteRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
  var Bold = Mark3.create({
    name: "bold",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "strong"
        },
        {
          tag: "b",
          getAttrs: (node5) => node5.style.fontWeight !== "normal" && null
        },
        {
          style: "font-weight",
          getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setBold: () => ({ commands }) => {
          return commands.setMark(this.name);
        },
        toggleBold: () => ({ commands }) => {
          return commands.toggleMark(this.name);
        },
        unsetBold: () => ({ commands }) => {
          return commands.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-bullet-list/dist/tiptap-extension-bullet-list.esm.js
  var inputRegex2 = /^\s*([-+*])\s$/;
  var BulletList = Node4.create({
    name: "bulletList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {}
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
      return [
        { tag: "ul" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        toggleBulletList: () => ({ commands }) => {
          return commands.toggleList(this.name, this.options.itemTypeName);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
      };
    },
    addInputRules() {
      return [
        wrappingInputRule({
          find: inputRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-code/dist/tiptap-extension-code.esm.js
  var inputRegex3 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
  var pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
  var Code = Mark3.create({
    name: "code",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    excludes: "_",
    code: true,
    parseHTML() {
      return [
        { tag: "code" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setCode: () => ({ commands }) => {
          return commands.setMark(this.name);
        },
        toggleCode: () => ({ commands }) => {
          return commands.toggleMark(this.name);
        },
        unsetCode: () => ({ commands }) => {
          return commands.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-e": () => this.editor.commands.toggleCode()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex3,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-code-block/dist/tiptap-extension-code-block.esm.js
  var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
  var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
  var CodeBlock = Node4.create({
    name: "codeBlock",
    addOptions() {
      return {
        languageClassPrefix: "language-",
        exitOnTripleEnter: true,
        exitOnArrowDown: true,
        HTMLAttributes: {}
      };
    },
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    addAttributes() {
      return {
        language: {
          default: null,
          parseHTML: (element) => {
            var _a;
            const { languageClassPrefix } = this.options;
            const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
            const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
            const language = languages[0];
            if (!language) {
              return null;
            }
            return language;
          },
          rendered: false
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "pre",
          preserveWhitespace: "full"
        }
      ];
    },
    renderHTML({ node: node5, HTMLAttributes }) {
      return [
        "pre",
        mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
        [
          "code",
          {
            class: node5.attrs.language ? this.options.languageClassPrefix + node5.attrs.language : null
          },
          0
        ]
      ];
    },
    addCommands() {
      return {
        setCodeBlock: (attributes) => ({ commands }) => {
          return commands.setNode(this.name, attributes);
        },
        toggleCodeBlock: (attributes) => ({ commands }) => {
          return commands.toggleNode(this.name, "paragraph", attributes);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
        Backspace: () => {
          const { empty: empty2, $anchor } = this.editor.state.selection;
          const isAtStart = $anchor.pos === 1;
          if (!empty2 || $anchor.parent.type.name !== this.name) {
            return false;
          }
          if (isAtStart || !$anchor.parent.textContent.length) {
            return this.editor.commands.clearNodes();
          }
          return false;
        },
        Enter: ({ editor }) => {
          if (!this.options.exitOnTripleEnter) {
            return false;
          }
          const { state } = editor;
          const { selection } = state;
          const { $from, empty: empty2 } = selection;
          if (!empty2 || $from.parent.type !== this.type) {
            return false;
          }
          const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
          const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
          if (!isAtEnd || !endsWithDoubleNewline) {
            return false;
          }
          return editor.chain().command(({ tr }) => {
            tr.delete($from.pos - 2, $from.pos);
            return true;
          }).exitCode().run();
        },
        ArrowDown: ({ editor }) => {
          if (!this.options.exitOnArrowDown) {
            return false;
          }
          const { state } = editor;
          const { selection, doc: doc2 } = state;
          const { $from, empty: empty2 } = selection;
          if (!empty2 || $from.parent.type !== this.type) {
            return false;
          }
          const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
          if (!isAtEnd) {
            return false;
          }
          const after3 = $from.after();
          if (after3 === void 0) {
            return false;
          }
          const nodeAfter = doc2.nodeAt(after3);
          if (nodeAfter) {
            return false;
          }
          return editor.commands.exitCode();
        }
      };
    },
    addInputRules() {
      return [
        textblockTypeInputRule({
          find: backtickInputRegex,
          type: this.type,
          getAttributes: (match) => ({
            language: match[1]
          })
        }),
        textblockTypeInputRule({
          find: tildeInputRegex,
          type: this.type,
          getAttributes: (match) => ({
            language: match[1]
          })
        })
      ];
    },
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("codeBlockVSCodeHandler"),
          props: {
            handlePaste: (view, event) => {
              if (!event.clipboardData) {
                return false;
              }
              if (this.editor.isActive(this.type.name)) {
                return false;
              }
              const text4 = event.clipboardData.getData("text/plain");
              const vscode = event.clipboardData.getData("vscode-editor-data");
              const vscodeData = vscode ? JSON.parse(vscode) : void 0;
              const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
              if (!text4 || !language) {
                return false;
              }
              const { tr } = view.state;
              tr.replaceSelectionWith(this.type.create({ language }));
              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
              tr.insertText(text4.replace(/\r\n?/g, "\n"));
              tr.setMeta("paste", true);
              view.dispatch(tr);
              return true;
            }
          }
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-document/dist/tiptap-extension-document.esm.js
  var Document = Node4.create({
    name: "doc",
    topNode: true,
    content: "block+"
  });

  // node_modules/prosemirror-dropcursor/dist/index.es.js
  function dropCursor(options) {
    if (options === void 0)
      options = {};
    return new Plugin({
      view: function view(editorView) {
        return new DropCursorView(editorView, options);
      }
    });
  }
  var DropCursorView = function DropCursorView2(editorView, options) {
    var this$1 = this;
    this.editorView = editorView;
    this.width = options.width || 1;
    this.color = options.color || "black";
    this.class = options.class;
    this.cursorPos = null;
    this.element = null;
    this.timeout = null;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function(name) {
      var handler = function(e) {
        return this$1[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  };
  DropCursorView.prototype.destroy = function destroy5() {
    var this$1 = this;
    this.handlers.forEach(function(ref) {
      var name = ref.name;
      var handler = ref.handler;
      return this$1.editorView.dom.removeEventListener(name, handler);
    });
  };
  DropCursorView.prototype.update = function update2(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size) {
        this.setCursor(null);
      } else {
        this.updateOverlay();
      }
    }
  };
  DropCursorView.prototype.setCursor = function setCursor(pos) {
    if (pos == this.cursorPos) {
      return;
    }
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  };
  DropCursorView.prototype.updateOverlay = function updateOverlay() {
    var $pos = this.editorView.state.doc.resolve(this.cursorPos), rect;
    if (!$pos.parent.inlineContent) {
      var before3 = $pos.nodeBefore, after3 = $pos.nodeAfter;
      if (before3 || after3) {
        var nodeRect = this.editorView.nodeDOM(this.cursorPos - (before3 ? before3.nodeSize : 0)).getBoundingClientRect();
        var top2 = before3 ? nodeRect.bottom : nodeRect.top;
        if (before3 && after3) {
          top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
        }
        rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
      }
    }
    if (!rect) {
      var coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    var parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class) {
        this.element.className = this.class;
      }
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
    }
    var parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      var rect$1 = parent.getBoundingClientRect();
      parentLeft = rect$1.left - parent.scrollLeft;
      parentTop = rect$1.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  };
  DropCursorView.prototype.scheduleRemoval = function scheduleRemoval(timeout) {
    var this$1 = this;
    clearTimeout(this.timeout);
    this.timeout = setTimeout(function() {
      return this$1.setCursor(null);
    }, timeout);
  };
  DropCursorView.prototype.dragover = function dragover(event) {
    if (!this.editorView.editable) {
      return;
    }
    var pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    var node5 = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    var disableDropCursor = node5 && node5.type.spec.disableDropCursor;
    var disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos) : disableDropCursor;
    if (pos && !disabled) {
      var target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        target = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (target == null) {
          return this.setCursor(null);
        }
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  };
  DropCursorView.prototype.dragend = function dragend() {
    this.scheduleRemoval(20);
  };
  DropCursorView.prototype.drop = function drop() {
    this.scheduleRemoval(20);
  };
  DropCursorView.prototype.dragleave = function dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget)) {
      this.setCursor(null);
    }
  };

  // node_modules/@tiptap/extension-dropcursor/dist/tiptap-extension-dropcursor.esm.js
  var Dropcursor = Extension.create({
    name: "dropCursor",
    addOptions() {
      return {
        color: "currentColor",
        width: 1,
        class: null
      };
    },
    addProseMirrorPlugins() {
      return [
        dropCursor(this.options)
      ];
    }
  });

  // node_modules/prosemirror-gapcursor/dist/index.es.js
  var GapCursor = /* @__PURE__ */ function(Selection5) {
    function GapCursor2($pos) {
      Selection5.call(this, $pos, $pos);
    }
    if (Selection5)
      GapCursor2.__proto__ = Selection5;
    GapCursor2.prototype = Object.create(Selection5 && Selection5.prototype);
    GapCursor2.prototype.constructor = GapCursor2;
    GapCursor2.prototype.map = function map22(doc2, mapping) {
      var $pos = doc2.resolve(mapping.map(this.head));
      return GapCursor2.valid($pos) ? new GapCursor2($pos) : Selection5.near($pos);
    };
    GapCursor2.prototype.content = function content3() {
      return Slice.empty;
    };
    GapCursor2.prototype.eq = function eq16(other) {
      return other instanceof GapCursor2 && other.head == this.head;
    };
    GapCursor2.prototype.toJSON = function toJSON13() {
      return { type: "gapcursor", pos: this.head };
    };
    GapCursor2.fromJSON = function fromJSON15(doc2, json2) {
      if (typeof json2.pos != "number") {
        throw new RangeError("Invalid input for GapCursor.fromJSON");
      }
      return new GapCursor2(doc2.resolve(json2.pos));
    };
    GapCursor2.prototype.getBookmark = function getBookmark3() {
      return new GapBookmark(this.anchor);
    };
    GapCursor2.valid = function valid4($pos) {
      var parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) {
        return false;
      }
      var override = parent.type.spec.allowGapCursor;
      if (override != null) {
        return override;
      }
      var deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    };
    GapCursor2.findFrom = function findFrom3($pos, dir, mustMove) {
      search:
        for (; ; ) {
          if (!mustMove && GapCursor2.valid($pos)) {
            return $pos;
          }
          var pos = $pos.pos, next = null;
          for (var d = $pos.depth; ; d--) {
            var parent = $pos.node(d);
            if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
              next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
              break;
            } else if (d == 0) {
              return null;
            }
            pos += dir;
            var $cur = $pos.doc.resolve(pos);
            if (GapCursor2.valid($cur)) {
              return $cur;
            }
          }
          for (; ; ) {
            var inside = dir > 0 ? next.firstChild : next.lastChild;
            if (!inside) {
              if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                mustMove = false;
                continue search;
              }
              break;
            }
            next = inside;
            pos += dir;
            var $cur$1 = $pos.doc.resolve(pos);
            if (GapCursor2.valid($cur$1)) {
              return $cur$1;
            }
          }
          return null;
        }
    };
    return GapCursor2;
  }(Selection);
  GapCursor.prototype.visible = false;
  Selection.jsonID("gapcursor", GapCursor);
  var GapBookmark = function GapBookmark2(pos) {
    this.pos = pos;
  };
  GapBookmark.prototype.map = function map13(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  };
  GapBookmark.prototype.resolve = function resolve6(doc2) {
    var $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  };
  function closedBefore($pos) {
    for (var d = $pos.depth; d >= 0; d--) {
      var index3 = $pos.index(d), parent = $pos.node(d);
      if (index3 == 0) {
        if (parent.type.spec.isolating) {
          return true;
        }
        continue;
      }
      for (var before3 = parent.child(index3 - 1); ; before3 = before3.lastChild) {
        if (before3.childCount == 0 && !before3.inlineContent || before3.isAtom || before3.type.spec.isolating) {
          return true;
        }
        if (before3.inlineContent) {
          return false;
        }
      }
    }
    return true;
  }
  function closedAfter($pos) {
    for (var d = $pos.depth; d >= 0; d--) {
      var index3 = $pos.indexAfter(d), parent = $pos.node(d);
      if (index3 == parent.childCount) {
        if (parent.type.spec.isolating) {
          return true;
        }
        continue;
      }
      for (var after3 = parent.child(index3); ; after3 = after3.firstChild) {
        if (after3.childCount == 0 && !after3.inlineContent || after3.isAtom || after3.type.spec.isolating) {
          return true;
        }
        if (after3.inlineContent) {
          return false;
        }
      }
    }
    return true;
  }
  var gapCursor = function() {
    return new Plugin({
      props: {
        decorations: drawGapCursor,
        createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
          if ($anchor.pos == $head.pos && GapCursor.valid($head)) {
            return new GapCursor($head);
          }
        },
        handleClick,
        handleKeyDown,
        handleDOMEvents: { beforeinput }
      }
    });
  };
  var handleKeyDown = keydownHandler({
    "ArrowLeft": arrow("horiz", -1),
    "ArrowRight": arrow("horiz", 1),
    "ArrowUp": arrow("vert", -1),
    "ArrowDown": arrow("vert", 1)
  });
  function arrow(axis, dir) {
    var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
    return function(state, dispatch3, view) {
      var sel = state.selection;
      var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
      if (sel instanceof TextSelection) {
        if (!view.endOfTextblock(dirStr) || $start.depth == 0) {
          return false;
        }
        mustMove = false;
        $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
      }
      var $found = GapCursor.findFrom($start, dir, mustMove);
      if (!$found) {
        return false;
      }
      if (dispatch3) {
        dispatch3(state.tr.setSelection(new GapCursor($found)));
      }
      return true;
    };
  }
  function handleClick(view, pos, event) {
    if (!view.editable) {
      return false;
    }
    var $pos = view.state.doc.resolve(pos);
    if (!GapCursor.valid($pos)) {
      return false;
    }
    var ref = view.posAtCoords({ left: event.clientX, top: event.clientY });
    var inside = ref.inside;
    if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) {
      return false;
    }
    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
    return true;
  }
  function beforeinput(view, event) {
    if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor)) {
      return false;
    }
    var ref = view.state.selection;
    var $from = ref.$from;
    var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
    if (!insert) {
      return false;
    }
    var frag = Fragment.empty;
    for (var i = insert.length - 1; i >= 0; i--) {
      frag = Fragment.from(insert[i].createAndFill(null, frag));
    }
    var tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
    view.dispatch(tr);
    return false;
  }
  function drawGapCursor(state) {
    if (!(state.selection instanceof GapCursor)) {
      return null;
    }
    var node5 = document.createElement("div");
    node5.className = "ProseMirror-gapcursor";
    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node5, { key: "gapcursor" })]);
  }

  // node_modules/@tiptap/extension-gapcursor/dist/tiptap-extension-gapcursor.esm.js
  var Gapcursor = Extension.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [
        gapCursor()
      ];
    },
    extendNodeSchema(extension) {
      var _a;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      return {
        allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
      };
    }
  });

  // node_modules/@tiptap/extension-hard-break/dist/tiptap-extension-hard-break.esm.js
  var HardBreak = Node4.create({
    name: "hardBreak",
    addOptions() {
      return {
        keepMarks: true,
        HTMLAttributes: {}
      };
    },
    inline: true,
    group: "inline",
    selectable: false,
    parseHTML() {
      return [
        { tag: "br" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    renderText() {
      return "\n";
    },
    addCommands() {
      return {
        setHardBreak: () => ({ commands, chain, state, editor }) => {
          return commands.first([
            () => commands.exitCode(),
            () => commands.command(() => {
              const { selection, storedMarks } = state;
              if (selection.$from.parent.type.spec.isolating) {
                return false;
              }
              const { keepMarks } = this.options;
              const { splittableMarks } = editor.extensionManager;
              const marks3 = storedMarks || selection.$to.parentOffset && selection.$from.marks();
              return chain().insertContent({ type: this.name }).command(({ tr, dispatch: dispatch3 }) => {
                if (dispatch3 && marks3 && keepMarks) {
                  const filteredMarks = marks3.filter((mark4) => splittableMarks.includes(mark4.type.name));
                  tr.ensureMarks(filteredMarks);
                }
                return true;
              }).run();
            })
          ]);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.setHardBreak(),
        "Shift-Enter": () => this.editor.commands.setHardBreak()
      };
    }
  });

  // node_modules/@tiptap/extension-heading/dist/tiptap-extension-heading.esm.js
  var Heading = Node4.create({
    name: "heading",
    addOptions() {
      return {
        levels: [1, 2, 3, 4, 5, 6],
        HTMLAttributes: {}
      };
    },
    content: "inline*",
    group: "block",
    defining: true,
    addAttributes() {
      return {
        level: {
          default: 1,
          rendered: false
        }
      };
    },
    parseHTML() {
      return this.options.levels.map((level) => ({
        tag: `h${level}`,
        attrs: { level }
      }));
    },
    renderHTML({ node: node5, HTMLAttributes }) {
      const hasLevel = this.options.levels.includes(node5.attrs.level);
      const level = hasLevel ? node5.attrs.level : this.options.levels[0];
      return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setHeading: (attributes) => ({ commands }) => {
          if (!this.options.levels.includes(attributes.level)) {
            return false;
          }
          return commands.setNode(this.name, attributes);
        },
        toggleHeading: (attributes) => ({ commands }) => {
          if (!this.options.levels.includes(attributes.level)) {
            return false;
          }
          return commands.toggleNode(this.name, "paragraph", attributes);
        }
      };
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce((items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }), {});
    },
    addInputRules() {
      return this.options.levels.map((level) => {
        return textblockTypeInputRule({
          find: new RegExp(`^(#{1,${level}})\\s$`),
          type: this.type,
          getAttributes: {
            level
          }
        });
      });
    }
  });

  // node_modules/rope-sequence/dist/index.es.js
  var GOOD_LEAF_SIZE = 200;
  var RopeSequence = function RopeSequence2() {
  };
  RopeSequence.prototype.append = function append2(other) {
    if (!other.length) {
      return this;
    }
    other = RopeSequence.from(other);
    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
  };
  RopeSequence.prototype.prepend = function prepend(other) {
    if (!other.length) {
      return this;
    }
    return RopeSequence.from(other).append(this);
  };
  RopeSequence.prototype.appendInner = function appendInner(other) {
    return new Append(this, other);
  };
  RopeSequence.prototype.slice = function slice3(from5, to) {
    if (from5 === void 0)
      from5 = 0;
    if (to === void 0)
      to = this.length;
    if (from5 >= to) {
      return RopeSequence.empty;
    }
    return this.sliceInner(Math.max(0, from5), Math.min(this.length, to));
  };
  RopeSequence.prototype.get = function get3(i) {
    if (i < 0 || i >= this.length) {
      return void 0;
    }
    return this.getInner(i);
  };
  RopeSequence.prototype.forEach = function forEach5(f, from5, to) {
    if (from5 === void 0)
      from5 = 0;
    if (to === void 0)
      to = this.length;
    if (from5 <= to) {
      this.forEachInner(f, from5, to, 0);
    } else {
      this.forEachInvertedInner(f, from5, to, 0);
    }
  };
  RopeSequence.prototype.map = function map14(f, from5, to) {
    if (from5 === void 0)
      from5 = 0;
    if (to === void 0)
      to = this.length;
    var result2 = [];
    this.forEach(function(elt, i) {
      return result2.push(f(elt, i));
    }, from5, to);
    return result2;
  };
  RopeSequence.from = function from3(values) {
    if (values instanceof RopeSequence) {
      return values;
    }
    return values && values.length ? new Leaf(values) : RopeSequence.empty;
  };
  var Leaf = /* @__PURE__ */ function(RopeSequence3) {
    function Leaf2(values) {
      RopeSequence3.call(this);
      this.values = values;
    }
    if (RopeSequence3)
      Leaf2.__proto__ = RopeSequence3;
    Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Leaf2.prototype.constructor = Leaf2;
    var prototypeAccessors6 = { length: { configurable: true }, depth: { configurable: true } };
    Leaf2.prototype.flatten = function flatten() {
      return this.values;
    };
    Leaf2.prototype.sliceInner = function sliceInner(from5, to) {
      if (from5 == 0 && to == this.length) {
        return this;
      }
      return new Leaf2(this.values.slice(from5, to));
    };
    Leaf2.prototype.getInner = function getInner(i) {
      return this.values[i];
    };
    Leaf2.prototype.forEachInner = function forEachInner(f, from5, to, start6) {
      for (var i = from5; i < to; i++) {
        if (f(this.values[i], start6 + i) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from5, to, start6) {
      for (var i = from5 - 1; i >= to; i--) {
        if (f(this.values[i], start6 + i) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.leafAppend = function leafAppend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(this.values.concat(other.flatten()));
      }
    };
    Leaf2.prototype.leafPrepend = function leafPrepend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(other.flatten().concat(this.values));
      }
    };
    prototypeAccessors6.length.get = function() {
      return this.values.length;
    };
    prototypeAccessors6.depth.get = function() {
      return 0;
    };
    Object.defineProperties(Leaf2.prototype, prototypeAccessors6);
    return Leaf2;
  }(RopeSequence);
  RopeSequence.empty = new Leaf([]);
  var Append = /* @__PURE__ */ function(RopeSequence3) {
    function Append2(left2, right2) {
      RopeSequence3.call(this);
      this.left = left2;
      this.right = right2;
      this.length = left2.length + right2.length;
      this.depth = Math.max(left2.depth, right2.depth) + 1;
    }
    if (RopeSequence3)
      Append2.__proto__ = RopeSequence3;
    Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Append2.prototype.constructor = Append2;
    Append2.prototype.flatten = function flatten() {
      return this.left.flatten().concat(this.right.flatten());
    };
    Append2.prototype.getInner = function getInner(i) {
      return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
    };
    Append2.prototype.forEachInner = function forEachInner(f, from5, to, start6) {
      var leftLen = this.left.length;
      if (from5 < leftLen && this.left.forEachInner(f, from5, Math.min(to, leftLen), start6) === false) {
        return false;
      }
      if (to > leftLen && this.right.forEachInner(f, Math.max(from5 - leftLen, 0), Math.min(this.length, to) - leftLen, start6 + leftLen) === false) {
        return false;
      }
    };
    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from5, to, start6) {
      var leftLen = this.left.length;
      if (from5 > leftLen && this.right.forEachInvertedInner(f, from5 - leftLen, Math.max(to, leftLen) - leftLen, start6 + leftLen) === false) {
        return false;
      }
      if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from5, leftLen), to, start6) === false) {
        return false;
      }
    };
    Append2.prototype.sliceInner = function sliceInner(from5, to) {
      if (from5 == 0 && to == this.length) {
        return this;
      }
      var leftLen = this.left.length;
      if (to <= leftLen) {
        return this.left.slice(from5, to);
      }
      if (from5 >= leftLen) {
        return this.right.slice(from5 - leftLen, to - leftLen);
      }
      return this.left.slice(from5, leftLen).append(this.right.slice(0, to - leftLen));
    };
    Append2.prototype.leafAppend = function leafAppend(other) {
      var inner = this.right.leafAppend(other);
      if (inner) {
        return new Append2(this.left, inner);
      }
    };
    Append2.prototype.leafPrepend = function leafPrepend(other) {
      var inner = this.left.leafPrepend(other);
      if (inner) {
        return new Append2(inner, this.right);
      }
    };
    Append2.prototype.appendInner = function appendInner2(other) {
      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
        return new Append2(this.left, new Append2(this.right, other));
      }
      return new Append2(this, other);
    };
    return Append2;
  }(RopeSequence);
  var ropeSequence = RopeSequence;
  var index_es_default2 = ropeSequence;

  // node_modules/prosemirror-history/dist/index.es.js
  var max_empty_items = 500;
  var Branch = function Branch2(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  };
  Branch.prototype.popEvent = function popEvent(state, preserveItems) {
    var this$1 = this;
    if (this.eventCount == 0) {
      return null;
    }
    var end4 = this.items.length;
    for (; ; end4--) {
      var next = this.items.get(end4 - 1);
      if (next.selection) {
        --end4;
        break;
      }
    }
    var remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end4, this.items.length);
      mapFrom = remap.maps.length;
    }
    var transform = state.tr;
    var selection, remaining;
    var addAfter = [], addBefore = [];
    this.items.forEach(function(item, i) {
      if (!item.step) {
        if (!remap) {
          remap = this$1.remapping(end4, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        var step3 = item.step.map(remap.slice(mapFrom)), map22;
        if (step3 && transform.maybeStep(step3).doc) {
          map22 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map22, null, null, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map22) {
          remap.appendMap(map22, mapFrom);
        }
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this$1.items.slice(0, end4).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  };
  Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
    var newItems = [], eventCount = this.eventCount;
    var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (var i = 0; i < transform.steps.length; i++) {
      var step3 = transform.steps[i].invert(transform.docs[i]);
      var item = new Item(transform.mapping.maps[i], step3, selection), merged = void 0;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i) {
          newItems.pop();
        } else {
          oldItems = oldItems.slice(0, oldItems.length - 1);
        }
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = null;
      }
      if (!preserveItems) {
        lastItem = item;
      }
    }
    var overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  };
  Branch.prototype.remapping = function remapping(from5, to) {
    var maps = new Mapping();
    this.items.forEach(function(item, i) {
      var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from5 ? maps.maps.length - item.mirrorOffset : null;
      maps.appendMap(item.map, mirrorPos);
    }, from5, to);
    return maps;
  };
  Branch.prototype.addMaps = function addMaps(array) {
    if (this.eventCount == 0) {
      return this;
    }
    return new Branch(this.items.append(array.map(function(map22) {
      return new Item(map22);
    })), this.eventCount);
  };
  Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount) {
      return this;
    }
    var rebasedItems = [], start6 = Math.max(0, this.items.length - rebasedCount);
    var mapping = rebasedTransform.mapping;
    var newUntil = rebasedTransform.steps.length;
    var eventCount = this.eventCount;
    this.items.forEach(function(item) {
      if (item.selection) {
        eventCount--;
      }
    }, start6);
    var iRebased = rebasedCount;
    this.items.forEach(function(item) {
      var pos = mapping.getMirror(--iRebased);
      if (pos == null) {
        return;
      }
      newUntil = Math.min(newUntil, pos);
      var map22 = mapping.maps[pos];
      if (item.step) {
        var step3 = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection) {
          eventCount++;
        }
        rebasedItems.push(new Item(map22, step3, selection));
      } else {
        rebasedItems.push(new Item(map22));
      }
    }, start6);
    var newMaps = [];
    for (var i = rebasedCount; i < newUntil; i++) {
      newMaps.push(new Item(mapping.maps[i]));
    }
    var items = this.items.slice(0, start6).append(newMaps).append(rebasedItems);
    var branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items) {
      branch = branch.compress(this.items.length - rebasedItems.length);
    }
    return branch;
  };
  Branch.prototype.emptyItemCount = function emptyItemCount() {
    var count = 0;
    this.items.forEach(function(item) {
      if (!item.step) {
        count++;
      }
    });
    return count;
  };
  Branch.prototype.compress = function compress(upto) {
    if (upto === void 0)
      upto = this.items.length;
    var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    var items = [], events = 0;
    this.items.forEach(function(item, i) {
      if (i >= upto) {
        items.push(item);
        if (item.selection) {
          events++;
        }
      } else if (item.step) {
        var step3 = item.step.map(remap.slice(mapFrom)), map22 = step3 && step3.getMap();
        mapFrom--;
        if (map22) {
          remap.appendMap(map22, mapFrom);
        }
        if (step3) {
          var selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection) {
            events++;
          }
          var newItem = new Item(map22.invert(), step3, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem)) {
            items[last] = merged;
          } else {
            items.push(newItem);
          }
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(index_es_default2.from(items.reverse()), events);
  };
  Branch.empty = new Branch(index_es_default2.empty, 0);
  function cutOffEvents(items, n) {
    var cutPoint;
    items.forEach(function(item, i) {
      if (item.selection && n-- == 0) {
        cutPoint = i;
        return false;
      }
    });
    return items.slice(cutPoint);
  }
  var Item = function Item2(map22, step3, selection, mirrorOffset) {
    this.map = map22;
    this.step = step3;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  };
  Item.prototype.merge = function merge2(other) {
    if (this.step && other.step && !other.selection) {
      var step3 = other.step.merge(this.step);
      if (step3) {
        return new Item(step3.getMap().invert(), step3, this.selection);
      }
    }
  };
  var HistoryState = function HistoryState2(done2, undone, prevRanges, prevTime) {
    this.done = done2;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
  };
  var DEPTH_OVERFLOW = 20;
  function applyTransaction2(history3, state, tr, options) {
    var historyTr = tr.getMeta(historyKey), rebased2;
    if (historyTr) {
      return historyTr.historyState;
    }
    if (tr.getMeta(closeHistoryKey)) {
      history3 = new HistoryState(history3.done, history3.undone, null, 0);
    }
    var appended = tr.getMeta("appendedTransaction");
    if (tr.steps.length == 0) {
      return history3;
    } else if (appended && appended.getMeta(historyKey)) {
      if (appended.getMeta(historyKey).redo) {
        return new HistoryState(history3.done.addTransform(tr, null, options, mustPreserveItems(state)), history3.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history3.prevTime);
      } else {
        return new HistoryState(history3.done, history3.undone.addTransform(tr, null, options, mustPreserveItems(state)), null, history3.prevTime);
      }
    } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
      var newGroup = history3.prevTime == 0 || !appended && (history3.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history3.prevRanges));
      var prevRanges = appended ? mapRanges(history3.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
      return new HistoryState(history3.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
    } else if (rebased2 = tr.getMeta("rebased")) {
      return new HistoryState(history3.done.rebased(tr, rebased2), history3.undone.rebased(tr, rebased2), mapRanges(history3.prevRanges, tr.mapping), history3.prevTime);
    } else {
      return new HistoryState(history3.done.addMaps(tr.mapping.maps), history3.undone.addMaps(tr.mapping.maps), mapRanges(history3.prevRanges, tr.mapping), history3.prevTime);
    }
  }
  function isAdjacentTo(transform, prevRanges) {
    if (!prevRanges) {
      return false;
    }
    if (!transform.docChanged) {
      return true;
    }
    var adjacent = false;
    transform.mapping.maps[0].forEach(function(start6, end4) {
      for (var i = 0; i < prevRanges.length; i += 2) {
        if (start6 <= prevRanges[i + 1] && end4 >= prevRanges[i]) {
          adjacent = true;
        }
      }
    });
    return adjacent;
  }
  function rangesFor(map22) {
    var result2 = [];
    map22.forEach(function(_from, _to, from5, to) {
      return result2.push(from5, to);
    });
    return result2;
  }
  function mapRanges(ranges, mapping) {
    if (!ranges) {
      return null;
    }
    var result2 = [];
    for (var i = 0; i < ranges.length; i += 2) {
      var from5 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
      if (from5 <= to) {
        result2.push(from5, to);
      }
    }
    return result2;
  }
  function histTransaction(history3, state, dispatch3, redo2) {
    var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
    var pop = (redo2 ? history3.undone : history3.done).popEvent(state, preserveItems);
    if (!pop) {
      return;
    }
    var selection = pop.selection.resolve(pop.transform.doc);
    var added = (redo2 ? history3.done : history3.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
    dispatch3(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
  }
  var cachedPreserveItems = false;
  var cachedPreserveItemsPlugins = null;
  function mustPreserveItems(state) {
    var plugins = state.plugins;
    if (cachedPreserveItemsPlugins != plugins) {
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = plugins;
      for (var i = 0; i < plugins.length; i++) {
        if (plugins[i].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break;
        }
      }
    }
    return cachedPreserveItems;
  }
  var historyKey = new PluginKey("history");
  var closeHistoryKey = new PluginKey("closeHistory");
  function history2(config) {
    config = {
      depth: config && config.depth || 100,
      newGroupDelay: config && config.newGroupDelay || 500
    };
    return new Plugin({
      key: historyKey,
      state: {
        init: function init10() {
          return new HistoryState(Branch.empty, Branch.empty, null, 0);
        },
        apply: function apply15(tr, hist, state) {
          return applyTransaction2(hist, state, tr, config);
        }
      },
      config,
      props: {
        handleDOMEvents: {
          beforeinput: function beforeinput2(view, e) {
            var handled = e.inputType == "historyUndo" ? undo(view.state, view.dispatch) : e.inputType == "historyRedo" ? redo(view.state, view.dispatch) : false;
            if (handled) {
              e.preventDefault();
            }
            return handled;
          }
        }
      }
    });
  }
  function undo(state, dispatch3) {
    var hist = historyKey.getState(state);
    if (!hist || hist.done.eventCount == 0) {
      return false;
    }
    if (dispatch3) {
      histTransaction(hist, state, dispatch3, false);
    }
    return true;
  }
  function redo(state, dispatch3) {
    var hist = historyKey.getState(state);
    if (!hist || hist.undone.eventCount == 0) {
      return false;
    }
    if (dispatch3) {
      histTransaction(hist, state, dispatch3, true);
    }
    return true;
  }

  // node_modules/@tiptap/extension-history/dist/tiptap-extension-history.esm.js
  var History2 = Extension.create({
    name: "history",
    addOptions() {
      return {
        depth: 100,
        newGroupDelay: 500
      };
    },
    addCommands() {
      return {
        undo: () => ({ state, dispatch: dispatch3 }) => {
          return undo(state, dispatch3);
        },
        redo: () => ({ state, dispatch: dispatch3 }) => {
          return redo(state, dispatch3);
        }
      };
    },
    addProseMirrorPlugins() {
      return [
        history2(this.options)
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Mod-y": () => this.editor.commands.redo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Mod-\u044F": () => this.editor.commands.undo(),
        "Shift-Mod-\u044F": () => this.editor.commands.redo()
      };
    }
  });

  // node_modules/@tiptap/extension-horizontal-rule/dist/tiptap-extension-horizontal-rule.esm.js
  var HorizontalRule = Node4.create({
    name: "horizontalRule",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    parseHTML() {
      return [
        { tag: "hr" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    addCommands() {
      return {
        setHorizontalRule: () => ({ chain }) => {
          return chain().insertContent({ type: this.name }).command(({ tr, dispatch: dispatch3 }) => {
            var _a;
            if (dispatch3) {
              const { $to } = tr.selection;
              const posAfter = $to.end();
              if ($to.nodeAfter) {
                tr.setSelection(TextSelection.create(tr.doc, $to.pos));
              } else {
                const node5 = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                if (node5) {
                  tr.insert(posAfter, node5);
                  tr.setSelection(TextSelection.create(tr.doc, posAfter));
                }
              }
              tr.scrollIntoView();
            }
            return true;
          }).run();
        }
      };
    },
    addInputRules() {
      return [
        nodeInputRule({
          find: /^(?:---|—-|___\s|\*\*\*\s)$/,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-italic/dist/tiptap-extension-italic.esm.js
  var starInputRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
  var starPasteRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
  var underscoreInputRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
  var underscorePasteRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
  var Italic = Mark3.create({
    name: "italic",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "em"
        },
        {
          tag: "i",
          getAttrs: (node5) => node5.style.fontStyle !== "normal" && null
        },
        {
          style: "font-style=italic"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setItalic: () => ({ commands }) => {
          return commands.setMark(this.name);
        },
        toggleItalic: () => ({ commands }) => {
          return commands.toggleMark(this.name);
        },
        unsetItalic: () => ({ commands }) => {
          return commands.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex2,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex2,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex2,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-list-item/dist/tiptap-extension-list-item.esm.js
  var ListItem = Node4.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "paragraph block*",
    defining: true,
    parseHTML() {
      return [
        {
          tag: "li"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
      };
    }
  });

  // node_modules/@tiptap/extension-ordered-list/dist/tiptap-extension-ordered-list.esm.js
  var inputRegex4 = /^(\d+)\.\s$/;
  var OrderedList = Node4.create({
    name: "orderedList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {}
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (element) => {
            return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
          }
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "ol"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      const { start: start6, ...attributesWithoutStart } = HTMLAttributes;
      return start6 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        toggleOrderedList: () => ({ commands }) => {
          return commands.toggleList(this.name, this.options.itemTypeName);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
      };
    },
    addInputRules() {
      return [
        wrappingInputRule({
          find: inputRegex4,
          type: this.type,
          getAttributes: (match) => ({ start: +match[1] }),
          joinPredicate: (match, node5) => node5.childCount + node5.attrs.start === +match[1]
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-paragraph/dist/tiptap-extension-paragraph.esm.js
  var Paragraph = Node4.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    content: "inline*",
    parseHTML() {
      return [
        { tag: "p" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setParagraph: () => ({ commands }) => {
          return commands.setNode(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-0": () => this.editor.commands.setParagraph()
      };
    }
  });

  // node_modules/@tiptap/extension-strike/dist/tiptap-extension-strike.esm.js
  var inputRegex5 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
  var pasteRegex2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
  var Strike = Mark3.create({
    name: "strike",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "s"
        },
        {
          tag: "del"
        },
        {
          tag: "strike"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style2) => style2.includes("line-through") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setStrike: () => ({ commands }) => {
          return commands.setMark(this.name);
        },
        toggleStrike: () => ({ commands }) => {
          return commands.toggleMark(this.name);
        },
        unsetStrike: () => ({ commands }) => {
          return commands.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-x": () => this.editor.commands.toggleStrike()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex5,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-text/dist/tiptap-extension-text.esm.js
  var Text = Node4.create({
    name: "text",
    group: "inline"
  });

  // node_modules/@tiptap/starter-kit/dist/tiptap-starter-kit.esm.js
  var StarterKit = Extension.create({
    name: "starterKit",
    addExtensions() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
      const extensions2 = [];
      if (this.options.blockquote !== false) {
        extensions2.push(Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
      }
      if (this.options.bold !== false) {
        extensions2.push(Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
      }
      if (this.options.bulletList !== false) {
        extensions2.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
      }
      if (this.options.code !== false) {
        extensions2.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
      }
      if (this.options.codeBlock !== false) {
        extensions2.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
      }
      if (this.options.document !== false) {
        extensions2.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
      }
      if (this.options.dropcursor !== false) {
        extensions2.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
      }
      if (this.options.gapcursor !== false) {
        extensions2.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
      }
      if (this.options.hardBreak !== false) {
        extensions2.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
      }
      if (this.options.heading !== false) {
        extensions2.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
      }
      if (this.options.history !== false) {
        extensions2.push(History2.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
      }
      if (this.options.horizontalRule !== false) {
        extensions2.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
      }
      if (this.options.italic !== false) {
        extensions2.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
      }
      if (this.options.listItem !== false) {
        extensions2.push(ListItem.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
      }
      if (this.options.orderedList !== false) {
        extensions2.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
      }
      if (this.options.paragraph !== false) {
        extensions2.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
      }
      if (this.options.strike !== false) {
        extensions2.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
      }
      if (this.options.text !== false) {
        extensions2.push(Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
      }
      return extensions2;
    }
  });

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start4 = "start";
  var end2 = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start4, placement + "-" + end2]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start4, placement + "-" + end2]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node5) {
    if (node5 == null) {
      return window;
    }
    if (node5.toString() !== "[object Window]") {
      var ownerDocument = node5.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node5;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node5) {
    var OwnElement = getWindow(node5).Element;
    return node5 instanceof OwnElement || node5 instanceof Element;
  }
  function isHTMLElement(node5) {
    var OwnElement = getWindow(node5).HTMLElement;
    return node5 instanceof OwnElement || node5 instanceof HTMLElement;
  }
  function isShadowRoot(node5) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node5).ShadowRoot;
    return node5 instanceof OwnElement || node5 instanceof ShadowRoot;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style2 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style2 = styleProperties.reduce(function(style3, property) {
          style3[property] = "";
          return style3;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/math.js
  var max2 = Math.max;
  var min2 = Math.min;
  var round = Math.round;

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (isHTMLElement(element) && includeScale) {
      var offsetHeight = element.offsetHeight;
      var offsetWidth = element.offsetWidth;
      if (offsetWidth > 0) {
        scaleX = round(rect.width) / offsetWidth || 1;
      }
      if (offsetHeight > 0) {
        scaleY = round(rect.height) / offsetHeight || 1;
      }
    }
    return {
      width: rect.width / scaleX,
      height: rect.height / scaleY,
      top: rect.top / scaleY,
      right: rect.right / scaleX,
      bottom: rect.bottom / scaleY,
      left: rect.left / scaleX,
      x: rect.left / scaleX,
      y: rect.top / scaleY
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect2 = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect2.width - width) <= 1) {
      width = clientRect2.width;
    }
    if (Math.abs(clientRect2.height - height) <= 1) {
      height = clientRect2.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child5) {
    var rootNode = child5.getRootNode && child5.getRootNode();
    if (parent.contains(child5)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child5;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css2 = getComputedStyle2(currentNode);
      if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/within.js
  function within(min4, value, max4) {
    return max2(min4, min2(value, max4));
  }
  function withinMaxClamp(min4, value, max4) {
    var v = within(min4, value, max4);
    return v > max4 ? max4 : v;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys2) {
    return keys2.reduce(function(hashMap, key2) {
      hashMap[key2] = value;
      return hashMap;
    }, {});
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow2(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min4 = paddingObject[minProp];
    var max4 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset4 = within(min4, center, max4);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset4, _state$modifiersData$.centerOffset = offset4 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow2,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end2) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end2) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node5) {
    var win = getWindow(node5);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node5) {
    if (["html", "body", "#document"].indexOf(getNodeName(node5)) >= 0) {
      return node5.ownerDocument.body;
    }
    if (isHTMLElement(node5) && isScrollParent(node5)) {
      return node5;
    }
    return getScrollParent(getParentNode(node5));
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = max2(rect.top, accRect.top);
      accRect.right = min2(rect.right, accRect.right);
      accRect.bottom = min2(rect.bottom, accRect.bottom);
      accRect.left = max2(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start4:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end2:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset4 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key2) {
        var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
        overflowOffsets[key2] += offset4[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start4;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check4) {
        return check4;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check4) {
              return check4;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset4) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset4 === "function" ? offset4(Object.assign({}, rects, {
      placement
    })) : offset4, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset2(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset4 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset4);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset2
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset4 = popperOffsets2[mainAxis];
      var min4 = offset4 + overflow[mainSide];
      var max4 = offset4 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start4 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start4 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset4 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset4 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min2(min4, tetherMin) : min4, offset4, tether ? max2(max4, tetherMax) : max4);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset4;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node5) {
    if (node5 === getWindow(node5) || !isHTMLElement(node5)) {
      return getWindowScroll(node5);
    } else {
      return getHTMLElementScroll(node5);
    }
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers2) {
    var map22 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result2 = [];
    modifiers2.forEach(function(modifier) {
      map22.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map22.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result2.push(modifier);
    }
    modifiers2.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result2;
  }
  function orderModifiers(modifiers2) {
    var orderedModifiers = order(modifiers2);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve14) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve14(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/format.js
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p, c) {
      return p.replace(/%s/, c);
    }, str);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers2) {
    modifiers2.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index3, self2) {
        return self2.indexOf(value) === index3;
      }).forEach(function(key2) {
        switch (key2) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
              return '"' + s + '"';
            }).join(", ") + '; but "' + key2 + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers2.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/uniqueBy.js
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers2) {
    var merged = modifiers2.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key2) {
      return merged[key2];
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions4 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions4;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions4),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions4, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          if (true) {
            var modifiers2 = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers2);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index3 = 0; index3 < state.orderedModifiers.length; index3++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index3 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index3], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        update: debounce(function() {
          return new Promise(function(resolve14) {
            instance.forceUpdate();
            resolve14(state);
          });
        }),
        destroy: function destroy6() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect5 = _ref3.effect;
          if (typeof effect5 === "function") {
            var cleanupFn = effect5({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/tippy.js/dist/tippy.esm.js
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
    return document.body;
  };
  function hasOwnProperty(obj, key2) {
    return {}.hasOwnProperty.call(obj, key2);
  }
  function getValueAtIndexOrReturn(value, index3, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index3];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index3] : defaultValue : v;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce2(fn2, ms) {
    if (ms === 0) {
      return fn2;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn2(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys2) {
    var clone = Object.assign({}, obj);
    keys2.forEach(function(key2) {
      delete clone[key2];
    });
    return clone;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index3) {
      return arr.indexOf(item) === index3;
    });
  }
  function getBasePlacement2(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key2) {
      if (obj[key2] !== void 0) {
        acc[key2] = obj[key2];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement2(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement2(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement2(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
      box[method](event, listener);
    });
  }
  function actualContains(parent, child5) {
    var target = child5;
    while (target) {
      var _target$getRootNode;
      if (parent.contains(target)) {
        return true;
      }
      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now2 = performance.now();
    if (now2 - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now2;
  }
  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var isIE11 = isBrowser ? !!window.msCrypto : false;
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      "line-height: 1.5",
      "color: #a6a095;"
    ];
  }
  var visitedMessages;
  if (true) {
    resetVisitedMessages();
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {
    },
    onBeforeUpdate: function onBeforeUpdate() {
    },
    onCreate: function onCreate() {
    },
    onDestroy: function onDestroy() {
    },
    onHidden: function onHidden() {
    },
    onHide: function onHide() {
    },
    onMount: function onMount() {
    },
    onShow: function onShow() {
    },
    onShown: function onShown() {
    },
    onTrigger: function onTrigger() {
    },
    onUntrigger: function onUntrigger() {
    },
    onClickOutside: function onClickOutside() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, pluginProps, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps2(partialProps) {
    if (true) {
      validateProps(partialProps, []);
    }
    var keys2 = Object.keys(partialProps);
    keys2.forEach(function(key2) {
      defaultProps[key2] = partialProps[key2];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps2 = plugins.reduce(function(acc, plugin) {
      var name = plugin.name, defaultValue = plugin.defaultValue;
      if (name) {
        var _name;
        acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps2);
  }
  function getDataAttributeProps(reference2, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key2) {
      var valueAsString = (reference2.getAttribute("data-tippy-" + key2) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key2 === "content") {
        acc[key2] = valueAsString;
      } else {
        try {
          acc[key2] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key2] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference2, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference2])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var keys2 = Object.keys(partialProps);
    keys2.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins.filter(function(plugin) {
          return plugin.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var innerHTML = function innerHTML2() {
    return "innerHTML";
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow4 = div();
    if (value === true) {
      arrow4.className = ARROW_CLASS;
    } else {
      arrow4.className = SVG_ARROW_CLASS;
      if (isElement2(value)) {
        arrow4.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow4, value);
      }
    }
    return arrow4;
  }
  function setContent2(content3, props) {
    if (isElement2(props.content)) {
      dangerouslySetInnerHTML(content3, "");
      content3.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content3, props.content);
      } else {
        content3.textContent = props.content;
      }
    }
  }
  function getChildren(popper2) {
    var box = popper2.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node5) {
        return node5.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node5) {
        return node5.classList.contains(ARROW_CLASS) || node5.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node5) {
        return node5.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper2 = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content3 = div();
    content3.className = CONTENT_CLASS;
    content3.setAttribute("data-state", "hidden");
    setContent2(content3, instance.props);
    popper2.appendChild(box);
    box.appendChild(content3);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper2), box2 = _getChildren.box, content4 = _getChildren.content, arrow4 = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent2(content4, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow4) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow4);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow4) {
        box2.removeChild(arrow4);
      }
    }
    return {
      popper: popper2,
      onUpdate
    };
  }
  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = [];
  var mountedInstances = [];
  function createTippy(reference2, passedProps) {
    var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      isEnabled: true,
      isVisible: false,
      isDestroyed: false,
      isMounted: false,
      isShown: false
    };
    var instance = {
      id,
      reference: reference2,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins,
      clearDelayTimeouts,
      setProps: setProps2,
      setContent: setContent3,
      show,
      hide: hide2,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy: destroy6
    };
    if (!props.render) {
      if (true) {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper2.setAttribute("data-tippy-root", "");
    popper2.id = "tippy-" + instance.id;
    instance.popper = popper2;
    reference2._tippy = instance;
    popper2._tippy = instance;
    var pluginsHooks = plugins.map(function(plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper2.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper2.addEventListener("mouseleave", function() {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference2;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper2);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }
      popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
      popper2.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id2 = popper2.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node5) {
        var currentValue = node5.getAttribute(attr);
        if (instance.state.isVisible) {
          node5.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
        } else {
          var nextValue = currentValue && currentValue.replace(id2, "").trim();
          if (nextValue) {
            node5.setAttribute(attr, nextValue);
          } else {
            node5.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node5) {
        if (instance.props.interactive) {
          node5.setAttribute("aria-expanded", instance.state.isVisible && node5 === getCurrentTarget() ? "true" : "false");
        } else {
          node5.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === "mousedown") {
          return;
        }
      }
      var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
      if (instance.props.interactive && actualContains(popper2, actualTarget)) {
        return;
      }
      if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc2 = getDocument();
      doc2.addEventListener("mousedown", onDocumentPress, true);
      doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc2 = getDocument();
      doc2.removeEventListener("mousedown", onDocumentPress, true);
      doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function() {
        if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback();
        }
      }
      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node5) {
        node5.addEventListener(eventType, handler, options);
        listeners.push({
          node: node5,
          eventType,
          handler,
          options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on("touchstart", onTrigger2, {
          passive: true
        });
        on("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on("mouseleave", onMouseLeave);
            break;
          case "focus":
            on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node5 = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
        node5.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger2(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
      if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
      if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
        var _instance$popperInsta;
        var instance2 = popper3._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper3.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset4 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow4 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference2;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn2(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers2 = [{
        name: "offset",
        options: {
          offset: offset4
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow4) {
        modifiers2.push({
          name: "arrow",
          options: {
            element: arrow4,
            padding: 3
          }
        });
      }
      modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers: modifiers2
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode2;
      var node5 = getCurrentTarget();
      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
        parentNode2 = node5.parentNode;
      } else {
        parentNode2 = invokeWithArgsOrReturn(appendTo, [node5]);
      }
      if (!parentNode2.contains(popper2)) {
        parentNode2.appendChild(popper2);
      }
      instance.state.isMounted = true;
      createPopperInstance();
      if (true) {
        warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node5.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook("onTrigger", [instance, event]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps2(partialProps) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node5) {
          node5.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference2.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent3(content3) {
      instance.setProps({
        content: content3
      });
    }
    function show() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper2.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content3 = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content3], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper2.offsetHeight;
        popper2.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount();
    }
    function hide2() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content3 = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content3], duration);
          setVisibilityState([box, content3], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper2.parentNode) {
        popper2.parentNode.removeChild(popper2);
      }
      mountedInstances = mountedInstances.filter(function(i) {
        return i !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy6() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference2._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (true) {
      validateTargets(targets);
      validateProps(optionalProps, plugins);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins
    });
    var elements = getArrayOfElements(targets);
    if (true) {
      var isSingleContentElement = isElement2(passedProps.content);
      var isMoreThanOneReferenceElement = elements.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances = elements.reduce(function(acc, reference2) {
      var instance = reference2 && createTippy(reference2, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement2(targets) ? instances[0] : instances;
  }
  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;
  var applyStylesModifier = Object.assign({}, applyStyles_default, {
    effect: function effect4(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
    }
  });
  tippy.setDefaultProps({
    render
  });
  var tippy_esm_default = tippy;

  // node_modules/@tiptap/extension-bubble-menu/dist/tiptap-extension-bubble-menu.esm.js
  var BubbleMenuView = class {
    constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
      this.preventHide = false;
      this.shouldShow = ({ view: view2, state, from: from5, to }) => {
        const { doc: doc2, selection } = state;
        const { empty: empty2 } = selection;
        const isEmptyTextBlock = !doc2.textBetween(from5, to).length && isTextSelection(state.selection);
        if (!view2.hasFocus() || empty2 || isEmptyTextBlock) {
          return false;
        }
        return true;
      };
      this.mousedownHandler = () => {
        this.preventHide = true;
      };
      this.dragstartHandler = () => {
        this.hide();
      };
      this.focusHandler = () => {
        setTimeout(() => this.update(this.editor.view));
      };
      this.blurHandler = ({ event }) => {
        var _a;
        if (this.preventHide) {
          this.preventHide = false;
          return;
        }
        if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
          return;
        }
        this.hide();
      };
      this.editor = editor;
      this.element = element;
      this.view = view;
      if (shouldShow) {
        this.shouldShow = shouldShow;
      }
      this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
      this.view.dom.addEventListener("dragstart", this.dragstartHandler);
      this.editor.on("focus", this.focusHandler);
      this.editor.on("blur", this.blurHandler);
      this.tippyOptions = tippyOptions;
      this.element.remove();
      this.element.style.visibility = "visible";
    }
    createTooltip() {
      const { element: editorElement } = this.editor.options;
      const editorIsAttached = !!editorElement.parentElement;
      if (this.tippy || !editorIsAttached) {
        return;
      }
      this.tippy = tippy_esm_default(editorElement, {
        duration: 0,
        getReferenceClientRect: null,
        content: this.element,
        interactive: true,
        trigger: "manual",
        placement: "top",
        hideOnClick: "toggle",
        ...this.tippyOptions
      });
      if (this.tippy.popper.firstChild) {
        this.tippy.popper.firstChild.addEventListener("blur", (event) => {
          this.blurHandler({ event });
        });
      }
    }
    update(view, oldState) {
      var _a, _b;
      const { state, composing } = view;
      const { doc: doc2, selection } = state;
      const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from5 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
        editor: this.editor,
        view,
        state,
        oldState,
        from: from5,
        to
      });
      if (!shouldShow) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: () => {
          if (isNodeSelection(state.selection)) {
            const node5 = view.nodeDOM(from5);
            if (node5) {
              return node5.getBoundingClientRect();
            }
          }
          return posToDOMRect(view, from5, to);
        }
      });
      this.show();
    }
    show() {
      var _a;
      (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
    }
    hide() {
      var _a;
      (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
    }
    destroy() {
      var _a;
      (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();
      this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
      this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
      this.editor.off("focus", this.focusHandler);
      this.editor.off("blur", this.blurHandler);
    }
  };
  var BubbleMenuPlugin = (options) => {
    return new Plugin({
      key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
      view: (view) => new BubbleMenuView({ view, ...options })
    });
  };
  var BubbleMenu = Extension.create({
    name: "bubbleMenu",
    addOptions() {
      return {
        element: null,
        tippyOptions: {},
        pluginKey: "bubbleMenu",
        shouldShow: null
      };
    },
    addProseMirrorPlugins() {
      if (!this.options.element) {
        return [];
      }
      return [
        BubbleMenuPlugin({
          pluginKey: this.options.pluginKey,
          editor: this.editor,
          element: this.options.element,
          tippyOptions: this.options.tippyOptions,
          shouldShow: this.options.shouldShow
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-placeholder/dist/tiptap-extension-placeholder.esm.js
  var Placeholder = Extension.create({
    name: "placeholder",
    addOptions() {
      return {
        emptyEditorClass: "is-editor-empty",
        emptyNodeClass: "is-empty",
        placeholder: "Write something \u2026",
        showOnlyWhenEditable: true,
        showOnlyCurrent: true,
        includeChildren: false
      };
    },
    addProseMirrorPlugins() {
      return [
        new Plugin({
          props: {
            decorations: ({ doc: doc2, selection }) => {
              const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
              const { anchor } = selection;
              const decorations = [];
              if (!active) {
                return;
              }
              doc2.descendants((node5, pos) => {
                const hasAnchor = anchor >= pos && anchor <= pos + node5.nodeSize;
                const isEmpty2 = !node5.isLeaf && !node5.childCount;
                if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty2) {
                  const classes = [this.options.emptyNodeClass];
                  if (this.editor.isEmpty) {
                    classes.push(this.options.emptyEditorClass);
                  }
                  const decoration = Decoration.node(pos, pos + node5.nodeSize, {
                    class: classes.join(" "),
                    "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                      editor: this.editor,
                      node: node5,
                      pos,
                      hasAnchor
                    }) : this.options.placeholder
                  });
                  decorations.push(decoration);
                }
                return this.options.includeChildren;
              });
              return DecorationSet.create(doc2, decorations);
            }
          }
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-underline/dist/tiptap-extension-underline.esm.js
  var Underline = Mark3.create({
    name: "underline",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "u"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style2) => style2.includes("underline") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setUnderline: () => ({ commands }) => {
          return commands.setMark(this.name);
        },
        toggleUnderline: () => ({ commands }) => {
          return commands.toggleMark(this.name);
        },
        unsetUnderline: () => ({ commands }) => {
          return commands.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-u": () => this.editor.commands.toggleUnderline(),
        "Mod-U": () => this.editor.commands.toggleUnderline()
      };
    }
  });

  // app/javascript/documentation/controllers/rich_text_editor/with_marks.js
  var marksTargets = ["bold", "italic", "underline", "link"];
  var toolbarMarks = [
    { target: "bold", name: "bold" },
    { target: "italic", name: "italic" },
    { target: "underline", name: "underline" },
    { target: "link", name: "link" }
  ];
  var with_marks_default = (controller, _options = {}) => {
    const MarkExtensions = [Bold, Code, Italic, Strike, Underline];
    const toggleBold = () => {
      controller.runCommand("toggleBold");
    };
    const toggleItalic = () => {
      controller.runCommand("toggleItalic");
    };
    const toggleUnderline = () => {
      controller.runCommand("toggleUnderline");
    };
    const enableSelectedToolbarMarks = () => {
      toolbarMarks.forEach(({ target, name, attributes }) => {
        if (controller.editor.isActive(name, attributes) && controller.hasTarget(target)) {
          controller[`${target}Target`].classList.add("is-active");
        }
      });
    };
    Object.assign(controller, {
      toggleBold,
      toggleItalic,
      toggleUnderline,
      enableSelectedToolbarMarks
    });
    return { MarkExtensions };
  };

  // node_modules/prosemirror-tables/dist/index.es.js
  var readFromCache;
  var addToCache;
  if (typeof WeakMap != "undefined") {
    cache = /* @__PURE__ */ new WeakMap();
    readFromCache = function(key2) {
      return cache.get(key2);
    };
    addToCache = function(key2, value) {
      cache.set(key2, value);
      return value;
    };
  } else {
    cache$1 = [], cacheSize = 10, cachePos = 0;
    readFromCache = function(key2) {
      for (var i = 0; i < cache$1.length; i += 2) {
        if (cache$1[i] == key2) {
          return cache$1[i + 1];
        }
      }
    };
    addToCache = function(key2, value) {
      if (cachePos == cacheSize) {
        cachePos = 0;
      }
      cache$1[cachePos++] = key2;
      return cache$1[cachePos++] = value;
    };
  }
  var cache;
  var cache$1;
  var cacheSize;
  var cachePos;
  var Rect = function Rect2(left2, top2, right2, bottom2) {
    this.left = left2;
    this.top = top2;
    this.right = right2;
    this.bottom = bottom2;
  };
  var TableMap = function TableMap2(width, height, map22, problems) {
    this.width = width;
    this.height = height;
    this.map = map22;
    this.problems = problems;
  };
  TableMap.prototype.findCell = function findCell(pos) {
    for (var i = 0; i < this.map.length; i++) {
      var curPos = this.map[i];
      if (curPos != pos) {
        continue;
      }
      var left2 = i % this.width, top2 = i / this.width | 0;
      var right2 = left2 + 1, bottom2 = top2 + 1;
      for (var j = 1; right2 < this.width && this.map[i + j] == curPos; j++) {
        right2++;
      }
      for (var j$1 = 1; bottom2 < this.height && this.map[i + this.width * j$1] == curPos; j$1++) {
        bottom2++;
      }
      return new Rect(left2, top2, right2, bottom2);
    }
    throw new RangeError("No cell with offset " + pos + " found");
  };
  TableMap.prototype.colCount = function colCount(pos) {
    for (var i = 0; i < this.map.length; i++) {
      if (this.map[i] == pos) {
        return i % this.width;
      }
    }
    throw new RangeError("No cell with offset " + pos + " found");
  };
  TableMap.prototype.nextCell = function nextCell(pos, axis, dir) {
    var ref = this.findCell(pos);
    var left2 = ref.left;
    var right2 = ref.right;
    var top2 = ref.top;
    var bottom2 = ref.bottom;
    if (axis == "horiz") {
      if (dir < 0 ? left2 == 0 : right2 == this.width) {
        return null;
      }
      return this.map[top2 * this.width + (dir < 0 ? left2 - 1 : right2)];
    } else {
      if (dir < 0 ? top2 == 0 : bottom2 == this.height) {
        return null;
      }
      return this.map[left2 + this.width * (dir < 0 ? top2 - 1 : bottom2)];
    }
  };
  TableMap.prototype.rectBetween = function rectBetween(a, b) {
    var ref = this.findCell(a);
    var leftA = ref.left;
    var rightA = ref.right;
    var topA = ref.top;
    var bottomA = ref.bottom;
    var ref$1 = this.findCell(b);
    var leftB = ref$1.left;
    var rightB = ref$1.right;
    var topB = ref$1.top;
    var bottomB = ref$1.bottom;
    return new Rect(Math.min(leftA, leftB), Math.min(topA, topB), Math.max(rightA, rightB), Math.max(bottomA, bottomB));
  };
  TableMap.prototype.cellsInRect = function cellsInRect(rect) {
    var result2 = [], seen = {};
    for (var row = rect.top; row < rect.bottom; row++) {
      for (var col = rect.left; col < rect.right; col++) {
        var index3 = row * this.width + col, pos = this.map[index3];
        if (seen[pos]) {
          continue;
        }
        seen[pos] = true;
        if ((col != rect.left || !col || this.map[index3 - 1] != pos) && (row != rect.top || !row || this.map[index3 - this.width] != pos)) {
          result2.push(pos);
        }
      }
    }
    return result2;
  };
  TableMap.prototype.positionAt = function positionAt(row, col, table) {
    for (var i = 0, rowStart = 0; ; i++) {
      var rowEnd = rowStart + table.child(i).nodeSize;
      if (i == row) {
        var index3 = col + row * this.width, rowEndIndex = (row + 1) * this.width;
        while (index3 < rowEndIndex && this.map[index3] < rowStart) {
          index3++;
        }
        return index3 == rowEndIndex ? rowEnd - 1 : this.map[index3];
      }
      rowStart = rowEnd;
    }
  };
  TableMap.get = function get4(table) {
    return readFromCache(table) || addToCache(table, computeMap(table));
  };
  function computeMap(table) {
    if (table.type.spec.tableRole != "table") {
      throw new RangeError("Not a table node: " + table.type.name);
    }
    var width = findWidth(table), height = table.childCount;
    var map22 = [], mapPos = 0, problems = null, colWidths = [];
    for (var i = 0, e = width * height; i < e; i++) {
      map22[i] = 0;
    }
    for (var row = 0, pos = 0; row < height; row++) {
      var rowNode = table.child(row);
      pos++;
      for (var i$1 = 0; ; i$1++) {
        while (mapPos < map22.length && map22[mapPos] != 0) {
          mapPos++;
        }
        if (i$1 == rowNode.childCount) {
          break;
        }
        var cellNode = rowNode.child(i$1);
        var ref = cellNode.attrs;
        var colspan = ref.colspan;
        var rowspan = ref.rowspan;
        var colwidth = ref.colwidth;
        for (var h = 0; h < rowspan; h++) {
          if (h + row >= height) {
            (problems || (problems = [])).push({ type: "overlong_rowspan", pos, n: rowspan - h });
            break;
          }
          var start6 = mapPos + h * width;
          for (var w = 0; w < colspan; w++) {
            if (map22[start6 + w] == 0) {
              map22[start6 + w] = pos;
            } else {
              (problems || (problems = [])).push({ type: "collision", row, pos, n: colspan - w });
            }
            var colW = colwidth && colwidth[w];
            if (colW) {
              var widthIndex = (start6 + w) % width * 2, prev = colWidths[widthIndex];
              if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
                colWidths[widthIndex] = colW;
                colWidths[widthIndex + 1] = 1;
              } else if (prev == colW) {
                colWidths[widthIndex + 1]++;
              }
            }
          }
        }
        mapPos += colspan;
        pos += cellNode.nodeSize;
      }
      var expectedPos = (row + 1) * width, missing = 0;
      while (mapPos < expectedPos) {
        if (map22[mapPos++] == 0) {
          missing++;
        }
      }
      if (missing) {
        (problems || (problems = [])).push({ type: "missing", row, n: missing });
      }
      pos++;
    }
    var tableMap = new TableMap(width, height, map22, problems), badWidths = false;
    for (var i$2 = 0; !badWidths && i$2 < colWidths.length; i$2 += 2) {
      if (colWidths[i$2] != null && colWidths[i$2 + 1] < height) {
        badWidths = true;
      }
    }
    if (badWidths) {
      findBadColWidths(tableMap, colWidths, table);
    }
    return tableMap;
  }
  function findWidth(table) {
    var width = -1, hasRowSpan = false;
    for (var row = 0; row < table.childCount; row++) {
      var rowNode = table.child(row), rowWidth = 0;
      if (hasRowSpan) {
        for (var j = 0; j < row; j++) {
          var prevRow = table.child(j);
          for (var i = 0; i < prevRow.childCount; i++) {
            var cell = prevRow.child(i);
            if (j + cell.attrs.rowspan > row) {
              rowWidth += cell.attrs.colspan;
            }
          }
        }
      }
      for (var i$1 = 0; i$1 < rowNode.childCount; i$1++) {
        var cell$1 = rowNode.child(i$1);
        rowWidth += cell$1.attrs.colspan;
        if (cell$1.attrs.rowspan > 1) {
          hasRowSpan = true;
        }
      }
      if (width == -1) {
        width = rowWidth;
      } else if (width != rowWidth) {
        width = Math.max(width, rowWidth);
      }
    }
    return width;
  }
  function findBadColWidths(map22, colWidths, table) {
    if (!map22.problems) {
      map22.problems = [];
    }
    for (var i = 0, seen = {}; i < map22.map.length; i++) {
      var pos = map22.map[i];
      if (seen[pos]) {
        continue;
      }
      seen[pos] = true;
      var node5 = table.nodeAt(pos), updated = null;
      for (var j = 0; j < node5.attrs.colspan; j++) {
        var col = (i + j) % map22.width, colWidth = colWidths[col * 2];
        if (colWidth != null && (!node5.attrs.colwidth || node5.attrs.colwidth[j] != colWidth)) {
          (updated || (updated = freshColWidth(node5.attrs)))[j] = colWidth;
        }
      }
      if (updated) {
        map22.problems.unshift({ type: "colwidth mismatch", pos, colwidth: updated });
      }
    }
  }
  function freshColWidth(attrs) {
    if (attrs.colwidth) {
      return attrs.colwidth.slice();
    }
    var result2 = [];
    for (var i = 0; i < attrs.colspan; i++) {
      result2.push(0);
    }
    return result2;
  }
  function tableNodeTypes(schema) {
    var result2 = schema.cached.tableNodeTypes;
    if (!result2) {
      result2 = schema.cached.tableNodeTypes = {};
      for (var name in schema.nodes) {
        var type = schema.nodes[name], role = type.spec.tableRole;
        if (role) {
          result2[role] = type;
        }
      }
    }
    return result2;
  }
  var key = new PluginKey("selectingCells");
  function cellAround($pos) {
    for (var d = $pos.depth - 1; d > 0; d--) {
      if ($pos.node(d).type.spec.tableRole == "row") {
        return $pos.node(0).resolve($pos.before(d + 1));
      }
    }
    return null;
  }
  function cellWrapping($pos) {
    for (var d = $pos.depth; d > 0; d--) {
      var role = $pos.node(d).type.spec.tableRole;
      if (role === "cell" || role === "header_cell") {
        return $pos.node(d);
      }
    }
    return null;
  }
  function isInTable(state) {
    var $head = state.selection.$head;
    for (var d = $head.depth; d > 0; d--) {
      if ($head.node(d).type.spec.tableRole == "row") {
        return true;
      }
    }
    return false;
  }
  function selectionCell(state) {
    var sel = state.selection;
    if (sel.$anchorCell) {
      return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
    } else if (sel.node && sel.node.type.spec.tableRole == "cell") {
      return sel.$anchor;
    }
    return cellAround(sel.$head) || cellNear(sel.$head);
  }
  function cellNear($pos) {
    for (var after3 = $pos.nodeAfter, pos = $pos.pos; after3; after3 = after3.firstChild, pos++) {
      var role = after3.type.spec.tableRole;
      if (role == "cell" || role == "header_cell") {
        return $pos.doc.resolve(pos);
      }
    }
    for (var before3 = $pos.nodeBefore, pos$1 = $pos.pos; before3; before3 = before3.lastChild, pos$1--) {
      var role$1 = before3.type.spec.tableRole;
      if (role$1 == "cell" || role$1 == "header_cell") {
        return $pos.doc.resolve(pos$1 - before3.nodeSize);
      }
    }
  }
  function pointsAtCell($pos) {
    return $pos.parent.type.spec.tableRole == "row" && $pos.nodeAfter;
  }
  function moveCellForward($pos) {
    return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
  }
  function inSameTable($a, $b) {
    return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);
  }
  function nextCell2($pos, axis, dir) {
    var start6 = $pos.start(-1), map22 = TableMap.get($pos.node(-1));
    var moved = map22.nextCell($pos.pos - start6, axis, dir);
    return moved == null ? null : $pos.node(0).resolve(start6 + moved);
  }
  function setAttr(attrs, name, value) {
    var result2 = {};
    for (var prop in attrs) {
      result2[prop] = attrs[prop];
    }
    result2[name] = value;
    return result2;
  }
  function removeColSpan(attrs, pos, n) {
    if (n === void 0)
      n = 1;
    var result2 = setAttr(attrs, "colspan", attrs.colspan - n);
    if (result2.colwidth) {
      result2.colwidth = result2.colwidth.slice();
      result2.colwidth.splice(pos, n);
      if (!result2.colwidth.some(function(w) {
        return w > 0;
      })) {
        result2.colwidth = null;
      }
    }
    return result2;
  }
  function addColSpan(attrs, pos, n) {
    if (n === void 0)
      n = 1;
    var result2 = setAttr(attrs, "colspan", attrs.colspan + n);
    if (result2.colwidth) {
      result2.colwidth = result2.colwidth.slice();
      for (var i = 0; i < n; i++) {
        result2.colwidth.splice(pos, 0, 0);
      }
    }
    return result2;
  }
  function columnIsHeader(map22, table, col) {
    var headerCell = tableNodeTypes(table.type.schema).header_cell;
    for (var row = 0; row < map22.height; row++) {
      if (table.nodeAt(map22.map[col + row * map22.width]).type != headerCell) {
        return false;
      }
    }
    return true;
  }
  var CellSelection = /* @__PURE__ */ function(Selection5) {
    function CellSelection2($anchorCell, $headCell) {
      if ($headCell === void 0)
        $headCell = $anchorCell;
      var table = $anchorCell.node(-1), map22 = TableMap.get(table), start6 = $anchorCell.start(-1);
      var rect = map22.rectBetween($anchorCell.pos - start6, $headCell.pos - start6);
      var doc2 = $anchorCell.node(0);
      var cells = map22.cellsInRect(rect).filter(function(p) {
        return p != $headCell.pos - start6;
      });
      cells.unshift($headCell.pos - start6);
      var ranges = cells.map(function(pos) {
        var cell = table.nodeAt(pos), from5 = pos + start6 + 1;
        return new SelectionRange(doc2.resolve(from5), doc2.resolve(from5 + cell.content.size));
      });
      Selection5.call(this, ranges[0].$from, ranges[0].$to, ranges);
      this.$anchorCell = $anchorCell;
      this.$headCell = $headCell;
    }
    if (Selection5)
      CellSelection2.__proto__ = Selection5;
    CellSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
    CellSelection2.prototype.constructor = CellSelection2;
    CellSelection2.prototype.map = function map22(doc2, mapping) {
      var $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
      var $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
      if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
        var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
        if (tableChanged && this.isRowSelection()) {
          return CellSelection2.rowSelection($anchorCell, $headCell);
        } else if (tableChanged && this.isColSelection()) {
          return CellSelection2.colSelection($anchorCell, $headCell);
        } else {
          return new CellSelection2($anchorCell, $headCell);
        }
      }
      return TextSelection.between($anchorCell, $headCell);
    };
    CellSelection2.prototype.content = function content3() {
      var table = this.$anchorCell.node(-1), map22 = TableMap.get(table), start6 = this.$anchorCell.start(-1);
      var rect = map22.rectBetween(this.$anchorCell.pos - start6, this.$headCell.pos - start6);
      var seen = {}, rows = [];
      for (var row = rect.top; row < rect.bottom; row++) {
        var rowContent = [];
        for (var index3 = row * map22.width + rect.left, col = rect.left; col < rect.right; col++, index3++) {
          var pos = map22.map[index3];
          if (!seen[pos]) {
            seen[pos] = true;
            var cellRect = map22.findCell(pos), cell = table.nodeAt(pos);
            var extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right;
            if (extraLeft > 0 || extraRight > 0) {
              var attrs = cell.attrs;
              if (extraLeft > 0) {
                attrs = removeColSpan(attrs, 0, extraLeft);
              }
              if (extraRight > 0) {
                attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);
              }
              if (cellRect.left < rect.left) {
                cell = cell.type.createAndFill(attrs);
              } else {
                cell = cell.type.create(attrs, cell.content);
              }
            }
            if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
              var attrs$1 = setAttr(cell.attrs, "rowspan", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));
              if (cellRect.top < rect.top) {
                cell = cell.type.createAndFill(attrs$1);
              } else {
                cell = cell.type.create(attrs$1, cell.content);
              }
            }
            rowContent.push(cell);
          }
        }
        rows.push(table.child(row).copy(Fragment.from(rowContent)));
      }
      var fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
      return new Slice(Fragment.from(fragment), 1, 1);
    };
    CellSelection2.prototype.replace = function replace5(tr, content3) {
      if (content3 === void 0)
        content3 = Slice.empty;
      var mapFrom = tr.steps.length, ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var ref = ranges[i];
        var $from = ref.$from;
        var $to = ref.$to;
        var mapping = tr.mapping.slice(mapFrom);
        tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content3);
      }
      var sel = Selection5.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);
      if (sel) {
        tr.setSelection(sel);
      }
    };
    CellSelection2.prototype.replaceWith = function replaceWith3(tr, node5) {
      this.replace(tr, new Slice(Fragment.from(node5), 0, 0));
    };
    CellSelection2.prototype.forEachCell = function forEachCell(f) {
      var table = this.$anchorCell.node(-1), map22 = TableMap.get(table), start6 = this.$anchorCell.start(-1);
      var cells = map22.cellsInRect(map22.rectBetween(this.$anchorCell.pos - start6, this.$headCell.pos - start6));
      for (var i = 0; i < cells.length; i++) {
        f(table.nodeAt(cells[i]), start6 + cells[i]);
      }
    };
    CellSelection2.prototype.isColSelection = function isColSelection() {
      var anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1);
      if (Math.min(anchorTop, headTop) > 0) {
        return false;
      }
      var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan, headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;
      return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;
    };
    CellSelection2.colSelection = function colSelection($anchorCell, $headCell) {
      if ($headCell === void 0)
        $headCell = $anchorCell;
      var map22 = TableMap.get($anchorCell.node(-1)), start6 = $anchorCell.start(-1);
      var anchorRect = map22.findCell($anchorCell.pos - start6), headRect = map22.findCell($headCell.pos - start6);
      var doc2 = $anchorCell.node(0);
      if (anchorRect.top <= headRect.top) {
        if (anchorRect.top > 0) {
          $anchorCell = doc2.resolve(start6 + map22.map[anchorRect.left]);
        }
        if (headRect.bottom < map22.height) {
          $headCell = doc2.resolve(start6 + map22.map[map22.width * (map22.height - 1) + headRect.right - 1]);
        }
      } else {
        if (headRect.top > 0) {
          $headCell = doc2.resolve(start6 + map22.map[headRect.left]);
        }
        if (anchorRect.bottom < map22.height) {
          $anchorCell = doc2.resolve(start6 + map22.map[map22.width * (map22.height - 1) + anchorRect.right - 1]);
        }
      }
      return new CellSelection2($anchorCell, $headCell);
    };
    CellSelection2.prototype.isRowSelection = function isRowSelection() {
      var map22 = TableMap.get(this.$anchorCell.node(-1)), start6 = this.$anchorCell.start(-1);
      var anchorLeft = map22.colCount(this.$anchorCell.pos - start6), headLeft = map22.colCount(this.$headCell.pos - start6);
      if (Math.min(anchorLeft, headLeft) > 0) {
        return false;
      }
      var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan, headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
      return Math.max(anchorRight, headRight) == map22.width;
    };
    CellSelection2.prototype.eq = function eq16(other) {
      return other instanceof CellSelection2 && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
    };
    CellSelection2.rowSelection = function rowSelection($anchorCell, $headCell) {
      if ($headCell === void 0)
        $headCell = $anchorCell;
      var map22 = TableMap.get($anchorCell.node(-1)), start6 = $anchorCell.start(-1);
      var anchorRect = map22.findCell($anchorCell.pos - start6), headRect = map22.findCell($headCell.pos - start6);
      var doc2 = $anchorCell.node(0);
      if (anchorRect.left <= headRect.left) {
        if (anchorRect.left > 0) {
          $anchorCell = doc2.resolve(start6 + map22.map[anchorRect.top * map22.width]);
        }
        if (headRect.right < map22.width) {
          $headCell = doc2.resolve(start6 + map22.map[map22.width * (headRect.top + 1) - 1]);
        }
      } else {
        if (headRect.left > 0) {
          $headCell = doc2.resolve(start6 + map22.map[headRect.top * map22.width]);
        }
        if (anchorRect.right < map22.width) {
          $anchorCell = doc2.resolve(start6 + map22.map[map22.width * (anchorRect.top + 1) - 1]);
        }
      }
      return new CellSelection2($anchorCell, $headCell);
    };
    CellSelection2.prototype.toJSON = function toJSON13() {
      return { type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos };
    };
    CellSelection2.fromJSON = function fromJSON15(doc2, json2) {
      return new CellSelection2(doc2.resolve(json2.anchor), doc2.resolve(json2.head));
    };
    CellSelection2.create = function create9(doc2, anchorCell, headCell) {
      if (headCell === void 0)
        headCell = anchorCell;
      return new CellSelection2(doc2.resolve(anchorCell), doc2.resolve(headCell));
    };
    CellSelection2.prototype.getBookmark = function getBookmark3() {
      return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
    };
    return CellSelection2;
  }(Selection);
  CellSelection.prototype.visible = false;
  Selection.jsonID("cell", CellSelection);
  var CellBookmark = function CellBookmark2(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };
  CellBookmark.prototype.map = function map15(mapping) {
    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  };
  CellBookmark.prototype.resolve = function resolve7(doc2) {
    var $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) {
      return new CellSelection($anchorCell, $headCell);
    } else {
      return Selection.near($headCell, 1);
    }
  };
  function drawCellSelection(state) {
    if (!(state.selection instanceof CellSelection)) {
      return null;
    }
    var cells = [];
    state.selection.forEachCell(function(node5, pos) {
      cells.push(Decoration.node(pos, pos + node5.nodeSize, { class: "selectedCell" }));
    });
    return DecorationSet.create(state.doc, cells);
  }
  function isCellBoundarySelection(ref) {
    var $from = ref.$from;
    var $to = ref.$to;
    if ($from.pos == $to.pos || $from.pos < $from.pos - 6) {
      return false;
    }
    var afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth;
    for (; depth >= 0; depth--, afterFrom++) {
      if ($from.after(depth + 1) < $from.end(depth)) {
        break;
      }
    }
    for (var d = $to.depth; d >= 0; d--, beforeTo--) {
      if ($to.before(d + 1) > $to.start(d)) {
        break;
      }
    }
    return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
  }
  function isTextSelectionAcrossCells(ref) {
    var $from = ref.$from;
    var $to = ref.$to;
    var fromCellBoundaryNode;
    var toCellBoundaryNode;
    for (var i = $from.depth; i > 0; i--) {
      var node5 = $from.node(i);
      if (node5.type.spec.tableRole === "cell" || node5.type.spec.tableRole === "header_cell") {
        fromCellBoundaryNode = node5;
        break;
      }
    }
    for (var i$1 = $to.depth; i$1 > 0; i$1--) {
      var node$1 = $to.node(i$1);
      if (node$1.type.spec.tableRole === "cell" || node$1.type.spec.tableRole === "header_cell") {
        toCellBoundaryNode = node$1;
        break;
      }
    }
    return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
  }
  function normalizeSelection(state, tr, allowTableNodeSelection) {
    var sel = (tr || state).selection, doc2 = (tr || state).doc, normalize2, role;
    if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
      if (role == "cell" || role == "header_cell") {
        normalize2 = CellSelection.create(doc2, sel.from);
      } else if (role == "row") {
        var $cell = doc2.resolve(sel.from + 1);
        normalize2 = CellSelection.rowSelection($cell, $cell);
      } else if (!allowTableNodeSelection) {
        var map22 = TableMap.get(sel.node), start6 = sel.from + 1;
        var lastCell = start6 + map22.map[map22.width * map22.height - 1];
        normalize2 = CellSelection.create(doc2, start6 + 1, lastCell);
      }
    } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
      normalize2 = TextSelection.create(doc2, sel.from);
    } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
      normalize2 = TextSelection.create(doc2, sel.$from.start(), sel.$from.end());
    }
    if (normalize2) {
      (tr || (tr = state.tr)).setSelection(normalize2);
    }
    return tr;
  }
  function pastedCells(slice6) {
    if (!slice6.size) {
      return null;
    }
    var content3 = slice6.content;
    var openStart = slice6.openStart;
    var openEnd = slice6.openEnd;
    while (content3.childCount == 1 && (openStart > 0 && openEnd > 0 || content3.firstChild.type.spec.tableRole == "table")) {
      openStart--;
      openEnd--;
      content3 = content3.firstChild.content;
    }
    var first2 = content3.firstChild, role = first2.type.spec.tableRole;
    var schema = first2.type.schema, rows = [];
    if (role == "row") {
      for (var i = 0; i < content3.childCount; i++) {
        var cells = content3.child(i).content;
        var left2 = i ? 0 : Math.max(0, openStart - 1);
        var right2 = i < content3.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
        if (left2 || right2) {
          cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left2, right2)).content;
        }
        rows.push(cells);
      }
    } else if (role == "cell" || role == "header_cell") {
      rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content3, openStart, openEnd)).content : content3);
    } else {
      return null;
    }
    return ensureRectangular(schema, rows);
  }
  function ensureRectangular(schema, rows) {
    var widths = [];
    for (var i = 0; i < rows.length; i++) {
      var row = rows[i];
      for (var j = row.childCount - 1; j >= 0; j--) {
        var ref = row.child(j).attrs;
        var rowspan = ref.rowspan;
        var colspan = ref.colspan;
        for (var r = i; r < i + rowspan; r++) {
          widths[r] = (widths[r] || 0) + colspan;
        }
      }
    }
    var width = 0;
    for (var r$1 = 0; r$1 < widths.length; r$1++) {
      width = Math.max(width, widths[r$1]);
    }
    for (var r$2 = 0; r$2 < widths.length; r$2++) {
      if (r$2 >= rows.length) {
        rows.push(Fragment.empty);
      }
      if (widths[r$2] < width) {
        var empty2 = tableNodeTypes(schema).cell.createAndFill(), cells = [];
        for (var i$1 = widths[r$2]; i$1 < width; i$1++) {
          cells.push(empty2);
        }
        rows[r$2] = rows[r$2].append(Fragment.from(cells));
      }
    }
    return { height: rows.length, width, rows };
  }
  function fitSlice(nodeType2, slice6) {
    var node5 = nodeType2.createAndFill();
    var tr = new Transform(node5).replace(0, node5.content.size, slice6);
    return tr.doc;
  }
  function clipCells(ref, newWidth, newHeight) {
    var width = ref.width;
    var height = ref.height;
    var rows = ref.rows;
    if (width != newWidth) {
      var added = [], newRows = [];
      for (var row = 0; row < rows.length; row++) {
        var frag = rows[row], cells = [];
        for (var col = added[row] || 0, i = 0; col < newWidth; i++) {
          var cell = frag.child(i % frag.childCount);
          if (col + cell.attrs.colspan > newWidth) {
            cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);
          }
          cells.push(cell);
          col += cell.attrs.colspan;
          for (var j = 1; j < cell.attrs.rowspan; j++) {
            added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
          }
        }
        newRows.push(Fragment.from(cells));
      }
      rows = newRows;
      width = newWidth;
    }
    if (height != newHeight) {
      var newRows$1 = [];
      for (var row$1 = 0, i$1 = 0; row$1 < newHeight; row$1++, i$1++) {
        var cells$1 = [], source2 = rows[i$1 % height];
        for (var j$1 = 0; j$1 < source2.childCount; j$1++) {
          var cell$1 = source2.child(j$1);
          if (row$1 + cell$1.attrs.rowspan > newHeight) {
            cell$1 = cell$1.type.create(setAttr(cell$1.attrs, "rowspan", Math.max(1, newHeight - cell$1.attrs.rowspan)), cell$1.content);
          }
          cells$1.push(cell$1);
        }
        newRows$1.push(Fragment.from(cells$1));
      }
      rows = newRows$1;
      height = newHeight;
    }
    return { width, height, rows };
  }
  function growTable(tr, map22, table, start6, width, height, mapFrom) {
    var schema = tr.doc.type.schema, types = tableNodeTypes(schema), empty2, emptyHead;
    if (width > map22.width) {
      for (var row = 0, rowEnd = 0; row < map22.height; row++) {
        var rowNode = table.child(row);
        rowEnd += rowNode.nodeSize;
        var cells = [], add3 = void 0;
        if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) {
          add3 = empty2 || (empty2 = types.cell.createAndFill());
        } else {
          add3 = emptyHead || (emptyHead = types.header_cell.createAndFill());
        }
        for (var i = map22.width; i < width; i++) {
          cells.push(add3);
        }
        tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start6), cells);
      }
    }
    if (height > map22.height) {
      var cells$1 = [];
      for (var i$1 = 0, start$1 = (map22.height - 1) * map22.width; i$1 < Math.max(map22.width, width); i$1++) {
        var header = i$1 >= map22.width ? false : table.nodeAt(map22.map[start$1 + i$1]).type == types.header_cell;
        cells$1.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill()));
      }
      var emptyRow = types.row.create(null, Fragment.from(cells$1)), rows = [];
      for (var i$2 = map22.height; i$2 < height; i$2++) {
        rows.push(emptyRow);
      }
      tr.insert(tr.mapping.slice(mapFrom).map(start6 + table.nodeSize - 2), rows);
    }
    return !!(empty2 || emptyHead);
  }
  function isolateHorizontal(tr, map22, table, start6, left2, right2, top2, mapFrom) {
    if (top2 == 0 || top2 == map22.height) {
      return false;
    }
    var found3 = false;
    for (var col = left2; col < right2; col++) {
      var index3 = top2 * map22.width + col, pos = map22.map[index3];
      if (map22.map[index3 - map22.width] == pos) {
        found3 = true;
        var cell = table.nodeAt(pos);
        var ref = map22.findCell(pos);
        var cellTop = ref.top;
        var cellLeft = ref.left;
        tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start6), null, setAttr(cell.attrs, "rowspan", top2 - cellTop));
        tr.insert(tr.mapping.slice(mapFrom).map(map22.positionAt(top2, cellLeft, table)), cell.type.createAndFill(setAttr(cell.attrs, "rowspan", cellTop + cell.attrs.rowspan - top2)));
        col += cell.attrs.colspan - 1;
      }
    }
    return found3;
  }
  function isolateVertical(tr, map22, table, start6, top2, bottom2, left2, mapFrom) {
    if (left2 == 0 || left2 == map22.width) {
      return false;
    }
    var found3 = false;
    for (var row = top2; row < bottom2; row++) {
      var index3 = row * map22.width + left2, pos = map22.map[index3];
      if (map22.map[index3 - 1] == pos) {
        found3 = true;
        var cell = table.nodeAt(pos), cellLeft = map22.colCount(pos);
        var updatePos = tr.mapping.slice(mapFrom).map(pos + start6);
        tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left2 - cellLeft, cell.attrs.colspan - (left2 - cellLeft)));
        tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left2 - cellLeft)));
        row += cell.attrs.rowspan - 1;
      }
    }
    return found3;
  }
  function insertCells(state, dispatch3, tableStart, rect, cells) {
    var table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map22 = TableMap.get(table);
    var top2 = rect.top;
    var left2 = rect.left;
    var right2 = left2 + cells.width, bottom2 = top2 + cells.height;
    var tr = state.tr, mapFrom = 0;
    function recomp() {
      table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
      map22 = TableMap.get(table);
      mapFrom = tr.mapping.maps.length;
    }
    if (growTable(tr, map22, table, tableStart, right2, bottom2, mapFrom)) {
      recomp();
    }
    if (isolateHorizontal(tr, map22, table, tableStart, left2, right2, top2, mapFrom)) {
      recomp();
    }
    if (isolateHorizontal(tr, map22, table, tableStart, left2, right2, bottom2, mapFrom)) {
      recomp();
    }
    if (isolateVertical(tr, map22, table, tableStart, top2, bottom2, left2, mapFrom)) {
      recomp();
    }
    if (isolateVertical(tr, map22, table, tableStart, top2, bottom2, right2, mapFrom)) {
      recomp();
    }
    for (var row = top2; row < bottom2; row++) {
      var from5 = map22.positionAt(row, left2, table), to = map22.positionAt(row, right2, table);
      tr.replace(tr.mapping.slice(mapFrom).map(from5 + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice(cells.rows[row - top2], 0, 0));
    }
    recomp();
    tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map22.positionAt(top2, left2, table)), tr.doc.resolve(tableStart + map22.positionAt(bottom2 - 1, right2 - 1, table))));
    dispatch3(tr);
  }
  var handleKeyDown2 = keydownHandler({
    "ArrowLeft": arrow3("horiz", -1),
    "ArrowRight": arrow3("horiz", 1),
    "ArrowUp": arrow3("vert", -1),
    "ArrowDown": arrow3("vert", 1),
    "Shift-ArrowLeft": shiftArrow("horiz", -1),
    "Shift-ArrowRight": shiftArrow("horiz", 1),
    "Shift-ArrowUp": shiftArrow("vert", -1),
    "Shift-ArrowDown": shiftArrow("vert", 1),
    "Backspace": deleteCellSelection,
    "Mod-Backspace": deleteCellSelection,
    "Delete": deleteCellSelection,
    "Mod-Delete": deleteCellSelection
  });
  function maybeSetSelection(state, dispatch3, selection) {
    if (selection.eq(state.selection)) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.setSelection(selection).scrollIntoView());
    }
    return true;
  }
  function arrow3(axis, dir) {
    return function(state, dispatch3, view) {
      var sel = state.selection;
      if (sel instanceof CellSelection) {
        return maybeSetSelection(state, dispatch3, Selection.near(sel.$headCell, dir));
      }
      if (axis != "horiz" && !sel.empty) {
        return false;
      }
      var end4 = atEndOfCell(view, axis, dir);
      if (end4 == null) {
        return false;
      }
      if (axis == "horiz") {
        return maybeSetSelection(state, dispatch3, Selection.near(state.doc.resolve(sel.head + dir), dir));
      } else {
        var $cell = state.doc.resolve(end4), $next = nextCell2($cell, axis, dir), newSel;
        if ($next) {
          newSel = Selection.near($next, 1);
        } else if (dir < 0) {
          newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
        } else {
          newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
        }
        return maybeSetSelection(state, dispatch3, newSel);
      }
    };
  }
  function shiftArrow(axis, dir) {
    return function(state, dispatch3, view) {
      var sel = state.selection;
      if (!(sel instanceof CellSelection)) {
        var end4 = atEndOfCell(view, axis, dir);
        if (end4 == null) {
          return false;
        }
        sel = new CellSelection(state.doc.resolve(end4));
      }
      var $head = nextCell2(sel.$headCell, axis, dir);
      if (!$head) {
        return false;
      }
      return maybeSetSelection(state, dispatch3, new CellSelection(sel.$anchorCell, $head));
    };
  }
  function deleteCellSelection(state, dispatch3) {
    var sel = state.selection;
    if (!(sel instanceof CellSelection)) {
      return false;
    }
    if (dispatch3) {
      var tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
      sel.forEachCell(function(cell, pos) {
        if (!cell.content.eq(baseContent)) {
          tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice(baseContent, 0, 0));
        }
      });
      if (tr.docChanged) {
        dispatch3(tr);
      }
    }
    return true;
  }
  function handleTripleClick2(view, pos) {
    var doc2 = view.state.doc, $cell = cellAround(doc2.resolve(pos));
    if (!$cell) {
      return false;
    }
    view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
    return true;
  }
  function handlePaste(view, _, slice6) {
    if (!isInTable(view.state)) {
      return false;
    }
    var cells = pastedCells(slice6), sel = view.state.selection;
    if (sel instanceof CellSelection) {
      if (!cells) {
        cells = { width: 1, height: 1, rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice6))] };
      }
      var table = sel.$anchorCell.node(-1), start6 = sel.$anchorCell.start(-1);
      var rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start6, sel.$headCell.pos - start6);
      cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
      insertCells(view.state, view.dispatch, start6, rect, cells);
      return true;
    } else if (cells) {
      var $cell = selectionCell(view.state), start$1 = $cell.start(-1);
      insertCells(view.state, view.dispatch, start$1, TableMap.get($cell.node(-1)).findCell($cell.pos - start$1), cells);
      return true;
    } else {
      return false;
    }
  }
  function handleMouseDown(view, startEvent) {
    if (startEvent.ctrlKey || startEvent.metaKey) {
      return;
    }
    var startDOMCell = domInCell(view, startEvent.target), $anchor;
    if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
      setCellSelection(view.state.selection.$anchorCell, startEvent);
      startEvent.preventDefault();
    } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && cellUnderMouse(view, startEvent).pos != $anchor.pos) {
      setCellSelection($anchor, startEvent);
      startEvent.preventDefault();
    } else if (!startDOMCell) {
      return;
    }
    function setCellSelection($anchor2, event) {
      var $head = cellUnderMouse(view, event);
      var starting = key.getState(view.state) == null;
      if (!$head || !inSameTable($anchor2, $head)) {
        if (starting) {
          $head = $anchor2;
        } else {
          return;
        }
      }
      var selection = new CellSelection($anchor2, $head);
      if (starting || !view.state.selection.eq(selection)) {
        var tr = view.state.tr.setSelection(selection);
        if (starting) {
          tr.setMeta(key, $anchor2.pos);
        }
        view.dispatch(tr);
      }
    }
    function stop2() {
      view.root.removeEventListener("mouseup", stop2);
      view.root.removeEventListener("dragstart", stop2);
      view.root.removeEventListener("mousemove", move2);
      if (key.getState(view.state) != null) {
        view.dispatch(view.state.tr.setMeta(key, -1));
      }
    }
    function move2(event) {
      var anchor = key.getState(view.state), $anchor2;
      if (anchor != null) {
        $anchor2 = view.state.doc.resolve(anchor);
      } else if (domInCell(view, event.target) != startDOMCell) {
        $anchor2 = cellUnderMouse(view, startEvent);
        if (!$anchor2) {
          return stop2();
        }
      }
      if ($anchor2) {
        setCellSelection($anchor2, event);
      }
    }
    view.root.addEventListener("mouseup", stop2);
    view.root.addEventListener("dragstart", stop2);
    view.root.addEventListener("mousemove", move2);
  }
  function atEndOfCell(view, axis, dir) {
    if (!(view.state.selection instanceof TextSelection)) {
      return null;
    }
    var ref = view.state.selection;
    var $head = ref.$head;
    for (var d = $head.depth - 1; d >= 0; d--) {
      var parent = $head.node(d), index3 = dir < 0 ? $head.index(d) : $head.indexAfter(d);
      if (index3 != (dir < 0 ? 0 : parent.childCount)) {
        return null;
      }
      if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
        var cellPos = $head.before(d);
        var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
        return view.endOfTextblock(dirStr) ? cellPos : null;
      }
    }
    return null;
  }
  function domInCell(view, dom) {
    for (; dom && dom != view.dom; dom = dom.parentNode) {
      if (dom.nodeName == "TD" || dom.nodeName == "TH") {
        return dom;
      }
    }
  }
  function cellUnderMouse(view, event) {
    var mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (!mousePos) {
      return null;
    }
    return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
  }
  var fixTablesKey = new PluginKey("fix-tables");
  function changedDescendants(old, cur, offset4, f) {
    var oldSize = old.childCount, curSize = cur.childCount;
    outer:
      for (var i = 0, j = 0; i < curSize; i++) {
        var child5 = cur.child(i);
        for (var scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
          if (old.child(scan) == child5) {
            j = scan + 1;
            offset4 += child5.nodeSize;
            continue outer;
          }
        }
        f(child5, offset4);
        if (j < oldSize && old.child(j).sameMarkup(child5)) {
          changedDescendants(old.child(j), child5, offset4 + 1, f);
        } else {
          child5.nodesBetween(0, child5.content.size, f, offset4 + 1);
        }
        offset4 += child5.nodeSize;
      }
  }
  function fixTables(state, oldState) {
    var tr, check4 = function(node5, pos) {
      if (node5.type.spec.tableRole == "table") {
        tr = fixTable(state, node5, pos, tr);
      }
    };
    if (!oldState) {
      state.doc.descendants(check4);
    } else if (oldState.doc != state.doc) {
      changedDescendants(oldState.doc, state.doc, 0, check4);
    }
    return tr;
  }
  function fixTable(state, table, tablePos, tr) {
    var map22 = TableMap.get(table);
    if (!map22.problems) {
      return tr;
    }
    if (!tr) {
      tr = state.tr;
    }
    var mustAdd = [];
    for (var i = 0; i < map22.height; i++) {
      mustAdd.push(0);
    }
    for (var i$1 = 0; i$1 < map22.problems.length; i$1++) {
      var prob = map22.problems[i$1];
      if (prob.type == "collision") {
        var cell = table.nodeAt(prob.pos);
        for (var j = 0; j < cell.attrs.rowspan; j++) {
          mustAdd[prob.row + j] += prob.n;
        }
        tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));
      } else if (prob.type == "missing") {
        mustAdd[prob.row] += prob.n;
      } else if (prob.type == "overlong_rowspan") {
        var cell$1 = table.nodeAt(prob.pos);
        tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$1.attrs, "rowspan", cell$1.attrs.rowspan - prob.n));
      } else if (prob.type == "colwidth mismatch") {
        var cell$2 = table.nodeAt(prob.pos);
        tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$2.attrs, "colwidth", prob.colwidth));
      }
    }
    var first2, last;
    for (var i$2 = 0; i$2 < mustAdd.length; i$2++) {
      if (mustAdd[i$2]) {
        if (first2 == null) {
          first2 = i$2;
        }
        last = i$2;
      }
    }
    for (var i$3 = 0, pos = tablePos + 1; i$3 < map22.height; i$3++) {
      var row = table.child(i$3);
      var end4 = pos + row.nodeSize;
      var add3 = mustAdd[i$3];
      if (add3 > 0) {
        var tableNodeType = "cell";
        if (row.firstChild) {
          tableNodeType = row.firstChild.type.spec.tableRole;
        }
        var nodes = [];
        for (var j$1 = 0; j$1 < add3; j$1++) {
          nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());
        }
        var side = (i$3 == 0 || first2 == i$3 - 1) && last == i$3 ? pos + 1 : end4 - 1;
        tr.insert(tr.mapping.map(side), nodes);
      }
      pos = end4;
    }
    return tr.setMeta(fixTablesKey, { fixTables: true });
  }
  function selectedRect(state) {
    var sel = state.selection, $pos = selectionCell(state);
    var table = $pos.node(-1), tableStart = $pos.start(-1), map22 = TableMap.get(table);
    var rect;
    if (sel instanceof CellSelection) {
      rect = map22.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart);
    } else {
      rect = map22.findCell($pos.pos - tableStart);
    }
    rect.tableStart = tableStart;
    rect.map = map22;
    rect.table = table;
    return rect;
  }
  function addColumn(tr, ref, col) {
    var map22 = ref.map;
    var tableStart = ref.tableStart;
    var table = ref.table;
    var refColumn = col > 0 ? -1 : 0;
    if (columnIsHeader(map22, table, col + refColumn)) {
      refColumn = col == 0 || col == map22.width ? null : 0;
    }
    for (var row = 0; row < map22.height; row++) {
      var index3 = row * map22.width + col;
      if (col > 0 && col < map22.width && map22.map[index3 - 1] == map22.map[index3]) {
        var pos = map22.map[index3], cell = table.nodeAt(pos);
        tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map22.colCount(pos)));
        row += cell.attrs.rowspan - 1;
      } else {
        var type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map22.map[index3 + refColumn]).type;
        var pos$1 = map22.positionAt(row, col, table);
        tr.insert(tr.mapping.map(tableStart + pos$1), type.createAndFill());
      }
    }
    return tr;
  }
  function addColumnBefore(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch3) {
      var rect = selectedRect(state);
      dispatch3(addColumn(state.tr, rect, rect.left));
    }
    return true;
  }
  function addColumnAfter(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch3) {
      var rect = selectedRect(state);
      dispatch3(addColumn(state.tr, rect, rect.right));
    }
    return true;
  }
  function removeColumn(tr, ref, col) {
    var map22 = ref.map;
    var table = ref.table;
    var tableStart = ref.tableStart;
    var mapStart = tr.mapping.maps.length;
    for (var row = 0; row < map22.height; ) {
      var index3 = row * map22.width + col, pos = map22.map[index3], cell = table.nodeAt(pos);
      if (col > 0 && map22.map[index3 - 1] == pos || col < map22.width - 1 && map22.map[index3 + 1] == pos) {
        tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(cell.attrs, col - map22.colCount(pos)));
      } else {
        var start6 = tr.mapping.slice(mapStart).map(tableStart + pos);
        tr.delete(start6, start6 + cell.nodeSize);
      }
      row += cell.attrs.rowspan;
    }
  }
  function deleteColumn(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch3) {
      var rect = selectedRect(state), tr = state.tr;
      if (rect.left == 0 && rect.right == rect.map.width) {
        return false;
      }
      for (var i = rect.right - 1; ; i--) {
        removeColumn(tr, rect, i);
        if (i == rect.left) {
          break;
        }
        rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
        rect.map = TableMap.get(rect.table);
      }
      dispatch3(tr);
    }
    return true;
  }
  function rowIsHeader(map22, table, row) {
    var headerCell = tableNodeTypes(table.type.schema).header_cell;
    for (var col = 0; col < map22.width; col++) {
      if (table.nodeAt(map22.map[col + row * map22.width]).type != headerCell) {
        return false;
      }
    }
    return true;
  }
  function addRow(tr, ref, row) {
    var map22 = ref.map;
    var tableStart = ref.tableStart;
    var table = ref.table;
    var rowPos = tableStart;
    for (var i = 0; i < row; i++) {
      rowPos += table.child(i).nodeSize;
    }
    var cells = [], refRow = row > 0 ? -1 : 0;
    if (rowIsHeader(map22, table, row + refRow)) {
      refRow = row == 0 || row == map22.height ? null : 0;
    }
    for (var col = 0, index3 = map22.width * row; col < map22.width; col++, index3++) {
      if (row > 0 && row < map22.height && map22.map[index3] == map22.map[index3 - map22.width]) {
        var pos = map22.map[index3], attrs = table.nodeAt(pos).attrs;
        tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, "rowspan", attrs.rowspan + 1));
        col += attrs.colspan - 1;
      } else {
        var type = refRow == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map22.map[index3 + refRow * map22.width]).type;
        cells.push(type.createAndFill());
      }
    }
    tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
    return tr;
  }
  function addRowBefore(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch3) {
      var rect = selectedRect(state);
      dispatch3(addRow(state.tr, rect, rect.top));
    }
    return true;
  }
  function addRowAfter(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch3) {
      var rect = selectedRect(state);
      dispatch3(addRow(state.tr, rect, rect.bottom));
    }
    return true;
  }
  function removeRow(tr, ref, row) {
    var map22 = ref.map;
    var table = ref.table;
    var tableStart = ref.tableStart;
    var rowPos = 0;
    for (var i = 0; i < row; i++) {
      rowPos += table.child(i).nodeSize;
    }
    var nextRow = rowPos + table.child(row).nodeSize;
    var mapFrom = tr.mapping.maps.length;
    tr.delete(rowPos + tableStart, nextRow + tableStart);
    for (var col = 0, index3 = row * map22.width; col < map22.width; col++, index3++) {
      var pos = map22.map[index3];
      if (row > 0 && pos == map22.map[index3 - map22.width]) {
        var attrs = table.nodeAt(pos).attrs;
        tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, "rowspan", attrs.rowspan - 1));
        col += attrs.colspan - 1;
      } else if (row < map22.width && pos == map22.map[index3 + map22.width]) {
        var cell = table.nodeAt(pos);
        var copy7 = cell.type.create(setAttr(cell.attrs, "rowspan", cell.attrs.rowspan - 1), cell.content);
        var newPos = map22.positionAt(row + 1, col, table);
        tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy7);
        col += cell.attrs.colspan - 1;
      }
    }
  }
  function deleteRow(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch3) {
      var rect = selectedRect(state), tr = state.tr;
      if (rect.top == 0 && rect.bottom == rect.map.height) {
        return false;
      }
      for (var i = rect.bottom - 1; ; i--) {
        removeRow(tr, rect, i);
        if (i == rect.top) {
          break;
        }
        rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
        rect.map = TableMap.get(rect.table);
      }
      dispatch3(tr);
    }
    return true;
  }
  function isEmpty(cell) {
    var c = cell.content;
    return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0;
  }
  function cellsOverlapRectangle(ref, rect) {
    var width = ref.width;
    var height = ref.height;
    var map22 = ref.map;
    var indexTop = rect.top * width + rect.left, indexLeft = indexTop;
    var indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
    for (var i = rect.top; i < rect.bottom; i++) {
      if (rect.left > 0 && map22[indexLeft] == map22[indexLeft - 1] || rect.right < width && map22[indexRight] == map22[indexRight + 1]) {
        return true;
      }
      indexLeft += width;
      indexRight += width;
    }
    for (var i$1 = rect.left; i$1 < rect.right; i$1++) {
      if (rect.top > 0 && map22[indexTop] == map22[indexTop - width] || rect.bottom < height && map22[indexBottom] == map22[indexBottom + width]) {
        return true;
      }
      indexTop++;
      indexBottom++;
    }
    return false;
  }
  function mergeCells(state, dispatch3) {
    var sel = state.selection;
    if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) {
      return false;
    }
    var rect = selectedRect(state);
    var map22 = rect.map;
    if (cellsOverlapRectangle(map22, rect)) {
      return false;
    }
    if (dispatch3) {
      var tr = state.tr, seen = {}, content3 = Fragment.empty, mergedPos, mergedCell;
      for (var row = rect.top; row < rect.bottom; row++) {
        for (var col = rect.left; col < rect.right; col++) {
          var cellPos = map22.map[row * map22.width + col], cell = rect.table.nodeAt(cellPos);
          if (seen[cellPos]) {
            continue;
          }
          seen[cellPos] = true;
          if (mergedPos == null) {
            mergedPos = cellPos;
            mergedCell = cell;
          } else {
            if (!isEmpty(cell)) {
              content3 = content3.append(cell.content);
            }
            var mapped = tr.mapping.map(cellPos + rect.tableStart);
            tr.delete(mapped, mapped + cell.nodeSize);
          }
        }
      }
      tr.setNodeMarkup(mergedPos + rect.tableStart, null, setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan), "rowspan", rect.bottom - rect.top));
      if (content3.size) {
        var end4 = mergedPos + 1 + mergedCell.content.size;
        var start6 = isEmpty(mergedCell) ? mergedPos + 1 : end4;
        tr.replaceWith(start6 + rect.tableStart, end4 + rect.tableStart, content3);
      }
      tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));
      dispatch3(tr);
    }
    return true;
  }
  function splitCell(state, dispatch3) {
    var nodeTypes = tableNodeTypes(state.schema);
    return splitCellWithType(function(ref) {
      var node5 = ref.node;
      return nodeTypes[node5.type.spec.tableRole];
    })(state, dispatch3);
  }
  function splitCellWithType(getCellType) {
    return function(state, dispatch3) {
      var sel = state.selection;
      var cellNode, cellPos;
      if (!(sel instanceof CellSelection)) {
        cellNode = cellWrapping(sel.$from);
        if (!cellNode) {
          return false;
        }
        cellPos = cellAround(sel.$from).pos;
      } else {
        if (sel.$anchorCell.pos != sel.$headCell.pos) {
          return false;
        }
        cellNode = sel.$anchorCell.nodeAfter;
        cellPos = sel.$anchorCell.pos;
      }
      if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
        return false;
      }
      if (dispatch3) {
        var baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth;
        if (baseAttrs.rowspan > 1) {
          baseAttrs = setAttr(baseAttrs, "rowspan", 1);
        }
        if (baseAttrs.colspan > 1) {
          baseAttrs = setAttr(baseAttrs, "colspan", 1);
        }
        var rect = selectedRect(state), tr = state.tr;
        for (var i = 0; i < rect.right - rect.left; i++) {
          attrs.push(colwidth ? setAttr(baseAttrs, "colwidth", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs);
        }
        var lastCell;
        for (var row = rect.top; row < rect.bottom; row++) {
          var pos = rect.map.positionAt(row, rect.left, rect.table);
          if (row == rect.top) {
            pos += cellNode.nodeSize;
          }
          for (var col = rect.left, i$1 = 0; col < rect.right; col++, i$1++) {
            if (col == rect.left && row == rect.top) {
              continue;
            }
            tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({ node: cellNode, row, col }).createAndFill(attrs[i$1]));
          }
        }
        tr.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left }), attrs[0]);
        if (sel instanceof CellSelection) {
          tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell && tr.doc.resolve(lastCell)));
        }
        dispatch3(tr);
      }
      return true;
    };
  }
  function setCellAttr(name, value) {
    return function(state, dispatch3) {
      if (!isInTable(state)) {
        return false;
      }
      var $cell = selectionCell(state);
      if ($cell.nodeAfter.attrs[name] === value) {
        return false;
      }
      if (dispatch3) {
        var tr = state.tr;
        if (state.selection instanceof CellSelection) {
          state.selection.forEachCell(function(node5, pos) {
            if (node5.attrs[name] !== value) {
              tr.setNodeMarkup(pos, null, setAttr(node5.attrs, name, value));
            }
          });
        } else {
          tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value));
        }
        dispatch3(tr);
      }
      return true;
    };
  }
  function deprecated_toggleHeader(type) {
    return function(state, dispatch3) {
      if (!isInTable(state)) {
        return false;
      }
      if (dispatch3) {
        var types = tableNodeTypes(state.schema);
        var rect = selectedRect(state), tr = state.tr;
        var cells = rect.map.cellsInRect(type == "column" ? new Rect(rect.left, 0, rect.right, rect.map.height) : type == "row" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);
        var nodes = cells.map(function(pos) {
          return rect.table.nodeAt(pos);
        });
        for (var i = 0; i < cells.length; i++) {
          if (nodes[i].type == types.header_cell) {
            tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);
          }
        }
        if (tr.steps.length == 0) {
          for (var i$1 = 0; i$1 < cells.length; i$1++) {
            tr.setNodeMarkup(rect.tableStart + cells[i$1], types.header_cell, nodes[i$1].attrs);
          }
        }
        dispatch3(tr);
      }
      return true;
    };
  }
  function isHeaderEnabledByType(type, rect, types) {
    var cellPositions = rect.map.cellsInRect({
      left: 0,
      top: 0,
      right: type == "row" ? rect.map.width : 1,
      bottom: type == "column" ? rect.map.height : 1
    });
    for (var i = 0; i < cellPositions.length; i++) {
      var cell = rect.table.nodeAt(cellPositions[i]);
      if (cell && cell.type !== types.header_cell) {
        return false;
      }
    }
    return true;
  }
  function toggleHeader(type, options) {
    options = options || { useDeprecatedLogic: false };
    if (options.useDeprecatedLogic) {
      return deprecated_toggleHeader(type);
    }
    return function(state, dispatch3) {
      if (!isInTable(state)) {
        return false;
      }
      if (dispatch3) {
        var types = tableNodeTypes(state.schema);
        var rect = selectedRect(state), tr = state.tr;
        var isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
        var isHeaderColumnEnabled = isHeaderEnabledByType("column", rect, types);
        var isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
        var selectionStartsAt = isHeaderEnabled ? 1 : 0;
        var cellsRect = type == "column" ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type == "row" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;
        var newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
        rect.map.cellsInRect(cellsRect).forEach(function(relativeCellPos) {
          var cellPos = relativeCellPos + rect.tableStart;
          var cell = tr.doc.nodeAt(cellPos);
          if (cell) {
            tr.setNodeMarkup(cellPos, newType, cell.attrs);
          }
        });
        dispatch3(tr);
      }
      return true;
    };
  }
  var toggleHeaderRow = toggleHeader("row", { useDeprecatedLogic: true });
  var toggleHeaderColumn = toggleHeader("column", { useDeprecatedLogic: true });
  var toggleHeaderCell = toggleHeader("cell", { useDeprecatedLogic: true });
  function findNextCell($cell, dir) {
    if (dir < 0) {
      var before3 = $cell.nodeBefore;
      if (before3) {
        return $cell.pos - before3.nodeSize;
      }
      for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
        var rowNode = $cell.node(-1).child(row);
        if (rowNode.childCount) {
          return rowEnd - 1 - rowNode.lastChild.nodeSize;
        }
        rowEnd -= rowNode.nodeSize;
      }
    } else {
      if ($cell.index() < $cell.parent.childCount - 1) {
        return $cell.pos + $cell.nodeAfter.nodeSize;
      }
      var table = $cell.node(-1);
      for (var row$1 = $cell.indexAfter(-1), rowStart = $cell.after(); row$1 < table.childCount; row$1++) {
        var rowNode$1 = table.child(row$1);
        if (rowNode$1.childCount) {
          return rowStart + 1;
        }
        rowStart += rowNode$1.nodeSize;
      }
    }
  }
  function goToNextCell(direction) {
    return function(state, dispatch3) {
      if (!isInTable(state)) {
        return false;
      }
      var cell = findNextCell(selectionCell(state), direction);
      if (cell == null) {
        return;
      }
      if (dispatch3) {
        var $cell = state.doc.resolve(cell);
        dispatch3(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());
      }
      return true;
    };
  }
  function deleteTable(state, dispatch3) {
    var $pos = state.selection.$anchor;
    for (var d = $pos.depth; d > 0; d--) {
      var node5 = $pos.node(d);
      if (node5.type.spec.tableRole == "table") {
        if (dispatch3) {
          dispatch3(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  var TableView = function TableView2(node5, cellMinWidth) {
    this.node = node5;
    this.cellMinWidth = cellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumns(node5, this.colgroup, this.table, cellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  };
  TableView.prototype.update = function update3(node5) {
    if (node5.type != this.node.type) {
      return false;
    }
    this.node = node5;
    updateColumns(node5, this.colgroup, this.table, this.cellMinWidth);
    return true;
  };
  TableView.prototype.ignoreMutation = function ignoreMutation2(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  };
  function updateColumns(node5, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
    var totalWidth = 0, fixedWidth = true;
    var nextDOM = colgroup.firstChild, row = node5.firstChild;
    for (var i = 0, col = 0; i < row.childCount; i++) {
      var ref = row.child(i).attrs;
      var colspan = ref.colspan;
      var colwidth = ref.colwidth;
      for (var j = 0; j < colspan; j++, col++) {
        var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
        var cssWidth = hasWidth ? hasWidth + "px" : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) {
          fixedWidth = false;
        }
        if (!nextDOM) {
          colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
        } else {
          if (nextDOM.style.width != cssWidth) {
            nextDOM.style.width = cssWidth;
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
    while (nextDOM) {
      var after3 = nextDOM.nextSibling;
      nextDOM.parentNode.removeChild(nextDOM);
      nextDOM = after3;
    }
    if (fixedWidth) {
      table.style.width = totalWidth + "px";
      table.style.minWidth = "";
    } else {
      table.style.width = "";
      table.style.minWidth = totalWidth + "px";
    }
  }
  var key$1 = new PluginKey("tableColumnResizing");
  function columnResizing(ref) {
    if (ref === void 0)
      ref = {};
    var handleWidth = ref.handleWidth;
    if (handleWidth === void 0)
      handleWidth = 5;
    var cellMinWidth = ref.cellMinWidth;
    if (cellMinWidth === void 0)
      cellMinWidth = 25;
    var View2 = ref.View;
    if (View2 === void 0)
      View2 = TableView;
    var lastColumnResizable = ref.lastColumnResizable;
    if (lastColumnResizable === void 0)
      lastColumnResizable = true;
    var plugin = new Plugin({
      key: key$1,
      state: {
        init: function init10(_, state) {
          this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = function(node5, view) {
            return new View2(node5, cellMinWidth, view);
          };
          return new ResizeState(-1, false);
        },
        apply: function apply15(tr, prev) {
          return prev.apply(tr);
        }
      },
      props: {
        attributes: function attributes(state) {
          var pluginState = key$1.getState(state);
          return pluginState.activeHandle > -1 ? { class: "resize-cursor" } : null;
        },
        handleDOMEvents: {
          mousemove: function mousemove(view, event) {
            handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);
          },
          mouseleave: function mouseleave(view) {
            handleMouseLeave(view);
          },
          mousedown: function mousedown(view, event) {
            handleMouseDown$1(view, event, cellMinWidth);
          }
        },
        decorations: function decorations(state) {
          var pluginState = key$1.getState(state);
          if (pluginState.activeHandle > -1) {
            return handleDecorations(state, pluginState.activeHandle);
          }
        },
        nodeViews: {}
      }
    });
    return plugin;
  }
  var ResizeState = function ResizeState2(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  };
  ResizeState.prototype.apply = function apply8(tr) {
    var state = this, action = tr.getMeta(key$1);
    if (action && action.setHandle != null) {
      return new ResizeState(action.setHandle, null);
    }
    if (action && action.setDragging !== void 0) {
      return new ResizeState(state.activeHandle, action.setDragging);
    }
    if (state.activeHandle > -1 && tr.docChanged) {
      var handle = tr.mapping.map(state.activeHandle, -1);
      if (!pointsAtCell(tr.doc.resolve(handle))) {
        handle = null;
      }
      state = new ResizeState(handle, state.dragging);
    }
    return state;
  };
  function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
    var pluginState = key$1.getState(view.state);
    if (!pluginState.dragging) {
      var target = domCellAround(event.target), cell = -1;
      if (target) {
        var ref = target.getBoundingClientRect();
        var left2 = ref.left;
        var right2 = ref.right;
        if (event.clientX - left2 <= handleWidth) {
          cell = edgeCell(view, event, "left");
        } else if (right2 - event.clientX <= handleWidth) {
          cell = edgeCell(view, event, "right");
        }
      }
      if (cell != pluginState.activeHandle) {
        if (!lastColumnResizable && cell !== -1) {
          var $cell = view.state.doc.resolve(cell);
          var table = $cell.node(-1), map22 = TableMap.get(table), start6 = $cell.start(-1);
          var col = map22.colCount($cell.pos - start6) + $cell.nodeAfter.attrs.colspan - 1;
          if (col == map22.width - 1) {
            return;
          }
        }
        updateHandle(view, cell);
      }
    }
  }
  function handleMouseLeave(view) {
    var pluginState = key$1.getState(view.state);
    if (pluginState.activeHandle > -1 && !pluginState.dragging) {
      updateHandle(view, -1);
    }
  }
  function handleMouseDown$1(view, event, cellMinWidth) {
    var pluginState = key$1.getState(view.state);
    if (pluginState.activeHandle == -1 || pluginState.dragging) {
      return false;
    }
    var cell = view.state.doc.nodeAt(pluginState.activeHandle);
    var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
    view.dispatch(view.state.tr.setMeta(key$1, { setDragging: { startX: event.clientX, startWidth: width } }));
    function finish5(event2) {
      window.removeEventListener("mouseup", finish5);
      window.removeEventListener("mousemove", move2);
      var pluginState2 = key$1.getState(view.state);
      if (pluginState2.dragging) {
        updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));
        view.dispatch(view.state.tr.setMeta(key$1, { setDragging: null }));
      }
    }
    function move2(event2) {
      if (!event2.which) {
        return finish5(event2);
      }
      var pluginState2 = key$1.getState(view.state);
      var dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);
    }
    window.addEventListener("mouseup", finish5);
    window.addEventListener("mousemove", move2);
    event.preventDefault();
    return true;
  }
  function currentColWidth(view, cellPos, ref) {
    var colspan = ref.colspan;
    var colwidth = ref.colwidth;
    var width = colwidth && colwidth[colwidth.length - 1];
    if (width) {
      return width;
    }
    var dom = view.domAtPos(cellPos);
    var node5 = dom.node.childNodes[dom.offset];
    var domWidth = node5.offsetWidth, parts = colspan;
    if (colwidth) {
      for (var i = 0; i < colspan; i++) {
        if (colwidth[i]) {
          domWidth -= colwidth[i];
          parts--;
        }
      }
    }
    return domWidth / parts;
  }
  function domCellAround(target) {
    while (target && target.nodeName != "TD" && target.nodeName != "TH") {
      target = target.classList.contains("ProseMirror") ? null : target.parentNode;
    }
    return target;
  }
  function edgeCell(view, event, side) {
    var found3 = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (!found3) {
      return -1;
    }
    var pos = found3.pos;
    var $cell = cellAround(view.state.doc.resolve(pos));
    if (!$cell) {
      return -1;
    }
    if (side == "right") {
      return $cell.pos;
    }
    var map22 = TableMap.get($cell.node(-1)), start6 = $cell.start(-1);
    var index3 = map22.map.indexOf($cell.pos - start6);
    return index3 % map22.width == 0 ? -1 : start6 + map22.map[index3 - 1];
  }
  function draggedWidth(dragging, event, cellMinWidth) {
    var offset4 = event.clientX - dragging.startX;
    return Math.max(cellMinWidth, dragging.startWidth + offset4);
  }
  function updateHandle(view, value) {
    view.dispatch(view.state.tr.setMeta(key$1, { setHandle: value }));
  }
  function updateColumnWidth(view, cell, width) {
    var $cell = view.state.doc.resolve(cell);
    var table = $cell.node(-1), map22 = TableMap.get(table), start6 = $cell.start(-1);
    var col = map22.colCount($cell.pos - start6) + $cell.nodeAfter.attrs.colspan - 1;
    var tr = view.state.tr;
    for (var row = 0; row < map22.height; row++) {
      var mapIndex = row * map22.width + col;
      if (row && map22.map[mapIndex] == map22.map[mapIndex - map22.width]) {
        continue;
      }
      var pos = map22.map[mapIndex];
      var ref = table.nodeAt(pos);
      var attrs = ref.attrs;
      var index3 = attrs.colspan == 1 ? 0 : col - map22.colCount(pos);
      if (attrs.colwidth && attrs.colwidth[index3] == width) {
        continue;
      }
      var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
      colwidth[index3] = width;
      tr.setNodeMarkup(start6 + pos, null, setAttr(attrs, "colwidth", colwidth));
    }
    if (tr.docChanged) {
      view.dispatch(tr);
    }
  }
  function displayColumnWidth(view, cell, width, cellMinWidth) {
    var $cell = view.state.doc.resolve(cell);
    var table = $cell.node(-1), start6 = $cell.start(-1);
    var col = TableMap.get(table).colCount($cell.pos - start6) + $cell.nodeAfter.attrs.colspan - 1;
    var dom = view.domAtPos($cell.start(-1)).node;
    while (dom.nodeName != "TABLE") {
      dom = dom.parentNode;
    }
    updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);
  }
  function zeroes(n) {
    var result2 = [];
    for (var i = 0; i < n; i++) {
      result2.push(0);
    }
    return result2;
  }
  function handleDecorations(state, cell) {
    var decorations = [];
    var $cell = state.doc.resolve(cell);
    var table = $cell.node(-1), map22 = TableMap.get(table), start6 = $cell.start(-1);
    var col = map22.colCount($cell.pos - start6) + $cell.nodeAfter.attrs.colspan;
    for (var row = 0; row < map22.height; row++) {
      var index3 = col + row * map22.width - 1;
      if ((col == map22.width || map22.map[index3] != map22.map[index3 + 1]) && (row == 0 || map22.map[index3 - 1] != map22.map[index3 - 1 - map22.width])) {
        var cellPos = map22.map[index3];
        var pos = start6 + cellPos + table.nodeAt(cellPos).nodeSize - 1;
        var dom = document.createElement("div");
        dom.className = "column-resize-handle";
        decorations.push(Decoration.widget(pos, dom));
      }
    }
    return DecorationSet.create(state.doc, decorations);
  }
  function tableEditing(ref) {
    if (ref === void 0)
      ref = {};
    var allowTableNodeSelection = ref.allowTableNodeSelection;
    if (allowTableNodeSelection === void 0)
      allowTableNodeSelection = false;
    return new Plugin({
      key,
      state: {
        init: function init10() {
          return null;
        },
        apply: function apply15(tr, cur) {
          var set2 = tr.getMeta(key);
          if (set2 != null) {
            return set2 == -1 ? null : set2;
          }
          if (cur == null || !tr.docChanged) {
            return cur;
          }
          var ref2 = tr.mapping.mapResult(cur);
          var deleted = ref2.deleted;
          var pos = ref2.pos;
          return deleted ? null : pos;
        }
      },
      props: {
        decorations: drawCellSelection,
        handleDOMEvents: {
          mousedown: handleMouseDown
        },
        createSelectionBetween: function createSelectionBetween(view) {
          if (key.getState(view.state) != null) {
            return view.state.selection;
          }
        },
        handleTripleClick: handleTripleClick2,
        handleKeyDown: handleKeyDown2,
        handlePaste
      },
      appendTransaction: function appendTransaction(_, oldState, state) {
        return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);
      }
    });
  }

  // node_modules/@tiptap/extension-table/dist/tiptap-extension-table.esm.js
  function findDiffStart2(a, b, pos) {
    for (var i = 0; ; i++) {
      if (i == a.childCount || i == b.childCount) {
        return a.childCount == b.childCount ? null : pos;
      }
      var childA = a.child(i), childB = b.child(i);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB)) {
        return pos;
      }
      if (childA.isText && childA.text != childB.text) {
        for (var j = 0; childA.text[j] == childB.text[j]; j++) {
          pos++;
        }
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        var inner = findDiffStart2(childA.content, childB.content, pos + 1);
        if (inner != null) {
          return inner;
        }
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd2(a, b, posA, posB) {
    for (var iA = a.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0) {
        return iA == iB ? null : { a: posA, b: posB };
      }
      var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB)) {
        return { a: posA, b: posB };
      }
      if (childA.isText && childA.text != childB.text) {
        var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        var inner = findDiffEnd2(childA.content, childB.content, posA - 1, posB - 1);
        if (inner) {
          return inner;
        }
      }
      posA -= size;
      posB -= size;
    }
  }
  var Fragment3 = function Fragment4(content3, size) {
    this.content = content3;
    this.size = size || 0;
    if (size == null) {
      for (var i = 0; i < content3.length; i++) {
        this.size += content3[i].nodeSize;
      }
    }
  };
  var prototypeAccessors$32 = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
  Fragment3.prototype.nodesBetween = function nodesBetween3(from5, to, f, nodeStart, parent) {
    if (nodeStart === void 0)
      nodeStart = 0;
    for (var i = 0, pos = 0; pos < to; i++) {
      var child5 = this.content[i], end4 = pos + child5.nodeSize;
      if (end4 > from5 && f(child5, nodeStart + pos, parent, i) !== false && child5.content.size) {
        var start6 = pos + 1;
        child5.nodesBetween(Math.max(0, from5 - start6), Math.min(child5.content.size, to - start6), f, nodeStart + start6);
      }
      pos = end4;
    }
  };
  Fragment3.prototype.descendants = function descendants3(f) {
    this.nodesBetween(0, this.size, f);
  };
  Fragment3.prototype.textBetween = function textBetween3(from5, to, blockSeparator, leafText) {
    var text4 = "", separated = true;
    this.nodesBetween(from5, to, function(node5, pos) {
      if (node5.isText) {
        text4 += node5.text.slice(Math.max(from5, pos) - pos, to - pos);
        separated = !blockSeparator;
      } else if (node5.isLeaf && leafText) {
        text4 += typeof leafText === "function" ? leafText(node5) : leafText;
        separated = !blockSeparator;
      } else if (!separated && node5.isBlock) {
        text4 += blockSeparator;
        separated = true;
      }
    }, 0);
    return text4;
  };
  Fragment3.prototype.append = function append3(other) {
    if (!other.size) {
      return this;
    }
    if (!this.size) {
      return other;
    }
    var last = this.lastChild, first2 = other.firstChild, content3 = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content3[content3.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++) {
      content3.push(other.content[i]);
    }
    return new Fragment3(content3, this.size + other.size);
  };
  Fragment3.prototype.cut = function cut3(from5, to) {
    if (to == null) {
      to = this.size;
    }
    if (from5 == 0 && to == this.size) {
      return this;
    }
    var result2 = [], size = 0;
    if (to > from5) {
      for (var i = 0, pos = 0; pos < to; i++) {
        var child5 = this.content[i], end4 = pos + child5.nodeSize;
        if (end4 > from5) {
          if (pos < from5 || end4 > to) {
            if (child5.isText) {
              child5 = child5.cut(Math.max(0, from5 - pos), Math.min(child5.text.length, to - pos));
            } else {
              child5 = child5.cut(Math.max(0, from5 - pos - 1), Math.min(child5.content.size, to - pos - 1));
            }
          }
          result2.push(child5);
          size += child5.nodeSize;
        }
        pos = end4;
      }
    }
    return new Fragment3(result2, size);
  };
  Fragment3.prototype.cutByIndex = function cutByIndex2(from5, to) {
    if (from5 == to) {
      return Fragment3.empty;
    }
    if (from5 == 0 && to == this.content.length) {
      return this;
    }
    return new Fragment3(this.content.slice(from5, to));
  };
  Fragment3.prototype.replaceChild = function replaceChild2(index3, node5) {
    var current = this.content[index3];
    if (current == node5) {
      return this;
    }
    var copy7 = this.content.slice();
    var size = this.size + node5.nodeSize - current.nodeSize;
    copy7[index3] = node5;
    return new Fragment3(copy7, size);
  };
  Fragment3.prototype.addToStart = function addToStart2(node5) {
    return new Fragment3([node5].concat(this.content), this.size + node5.nodeSize);
  };
  Fragment3.prototype.addToEnd = function addToEnd2(node5) {
    return new Fragment3(this.content.concat(node5), this.size + node5.nodeSize);
  };
  Fragment3.prototype.eq = function eq12(other) {
    if (this.content.length != other.content.length) {
      return false;
    }
    for (var i = 0; i < this.content.length; i++) {
      if (!this.content[i].eq(other.content[i])) {
        return false;
      }
    }
    return true;
  };
  prototypeAccessors$32.firstChild.get = function() {
    return this.content.length ? this.content[0] : null;
  };
  prototypeAccessors$32.lastChild.get = function() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  };
  prototypeAccessors$32.childCount.get = function() {
    return this.content.length;
  };
  Fragment3.prototype.child = function child3(index3) {
    var found3 = this.content[index3];
    if (!found3) {
      throw new RangeError("Index " + index3 + " out of range for " + this);
    }
    return found3;
  };
  Fragment3.prototype.maybeChild = function maybeChild3(index3) {
    return this.content[index3];
  };
  Fragment3.prototype.forEach = function forEach6(f) {
    for (var i = 0, p = 0; i < this.content.length; i++) {
      var child5 = this.content[i];
      f(child5, p, i);
      p += child5.nodeSize;
    }
  };
  Fragment3.prototype.findDiffStart = function findDiffStart$12(other, pos) {
    if (pos === void 0)
      pos = 0;
    return findDiffStart2(this, other, pos);
  };
  Fragment3.prototype.findDiffEnd = function findDiffEnd$12(other, pos, otherPos) {
    if (pos === void 0)
      pos = this.size;
    if (otherPos === void 0)
      otherPos = other.size;
    return findDiffEnd2(this, other, pos, otherPos);
  };
  Fragment3.prototype.findIndex = function findIndex2(pos, round2) {
    if (round2 === void 0)
      round2 = -1;
    if (pos == 0) {
      return retIndex2(0, pos);
    }
    if (pos == this.size) {
      return retIndex2(this.content.length, pos);
    }
    if (pos > this.size || pos < 0) {
      throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
    }
    for (var i = 0, curPos = 0; ; i++) {
      var cur = this.child(i), end4 = curPos + cur.nodeSize;
      if (end4 >= pos) {
        if (end4 == pos || round2 > 0) {
          return retIndex2(i + 1, end4);
        }
        return retIndex2(i, curPos);
      }
      curPos = end4;
    }
  };
  Fragment3.prototype.toString = function toString7() {
    return "<" + this.toStringInner() + ">";
  };
  Fragment3.prototype.toStringInner = function toStringInner2() {
    return this.content.join(", ");
  };
  Fragment3.prototype.toJSON = function toJSON7() {
    return this.content.length ? this.content.map(function(n) {
      return n.toJSON();
    }) : null;
  };
  Fragment3.fromJSON = function fromJSON8(schema, value) {
    if (!value) {
      return Fragment3.empty;
    }
    if (!Array.isArray(value)) {
      throw new RangeError("Invalid input for Fragment.fromJSON");
    }
    return new Fragment3(value.map(schema.nodeFromJSON));
  };
  Fragment3.fromArray = function fromArray2(array) {
    if (!array.length) {
      return Fragment3.empty;
    }
    var joined, size = 0;
    for (var i = 0; i < array.length; i++) {
      var node5 = array[i];
      size += node5.nodeSize;
      if (i && node5.isText && array[i - 1].sameMarkup(node5)) {
        if (!joined) {
          joined = array.slice(0, i);
        }
        joined[joined.length - 1] = node5.withText(joined[joined.length - 1].text + node5.text);
      } else if (joined) {
        joined.push(node5);
      }
    }
    return new Fragment3(joined || array, size);
  };
  Fragment3.from = function from4(nodes) {
    if (!nodes) {
      return Fragment3.empty;
    }
    if (nodes instanceof Fragment3) {
      return nodes;
    }
    if (Array.isArray(nodes)) {
      return this.fromArray(nodes);
    }
    if (nodes.attrs) {
      return new Fragment3([nodes], nodes.nodeSize);
    }
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  };
  Object.defineProperties(Fragment3.prototype, prototypeAccessors$32);
  var found2 = { index: 0, offset: 0 };
  function retIndex2(index3, offset4) {
    found2.index = index3;
    found2.offset = offset4;
    return found2;
  }
  Fragment3.empty = new Fragment3([], 0);
  function compareDeep2(a, b) {
    if (a === b) {
      return true;
    }
    if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
      return false;
    }
    var array = Array.isArray(a);
    if (Array.isArray(b) != array) {
      return false;
    }
    if (array) {
      if (a.length != b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!compareDeep2(a[i], b[i])) {
          return false;
        }
      }
    } else {
      for (var p in a) {
        if (!(p in b) || !compareDeep2(a[p], b[p])) {
          return false;
        }
      }
      for (var p$1 in b) {
        if (!(p$1 in a)) {
          return false;
        }
      }
    }
    return true;
  }
  var Mark4 = function Mark5(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  };
  Mark4.prototype.addToSet = function addToSet2(set2) {
    var copy7, placed = false;
    for (var i = 0; i < set2.length; i++) {
      var other = set2[i];
      if (this.eq(other)) {
        return set2;
      }
      if (this.type.excludes(other.type)) {
        if (!copy7) {
          copy7 = set2.slice(0, i);
        }
      } else if (other.type.excludes(this.type)) {
        return set2;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy7) {
            copy7 = set2.slice(0, i);
          }
          copy7.push(this);
          placed = true;
        }
        if (copy7) {
          copy7.push(other);
        }
      }
    }
    if (!copy7) {
      copy7 = set2.slice();
    }
    if (!placed) {
      copy7.push(this);
    }
    return copy7;
  };
  Mark4.prototype.removeFromSet = function removeFromSet3(set2) {
    for (var i = 0; i < set2.length; i++) {
      if (this.eq(set2[i])) {
        return set2.slice(0, i).concat(set2.slice(i + 1));
      }
    }
    return set2;
  };
  Mark4.prototype.isInSet = function isInSet3(set2) {
    for (var i = 0; i < set2.length; i++) {
      if (this.eq(set2[i])) {
        return true;
      }
    }
    return false;
  };
  Mark4.prototype.eq = function eq13(other) {
    return this == other || this.type == other.type && compareDeep2(this.attrs, other.attrs);
  };
  Mark4.prototype.toJSON = function toJSON8() {
    var obj = { type: this.type.name };
    for (var _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  };
  Mark4.fromJSON = function fromJSON9(schema, json2) {
    if (!json2) {
      throw new RangeError("Invalid input for Mark.fromJSON");
    }
    var type = schema.marks[json2.type];
    if (!type) {
      throw new RangeError("There is no mark type " + json2.type + " in this schema");
    }
    return type.create(json2.attrs);
  };
  Mark4.sameSet = function sameSet2(a, b) {
    if (a == b) {
      return true;
    }
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!a[i].eq(b[i])) {
        return false;
      }
    }
    return true;
  };
  Mark4.setFrom = function setFrom2(marks3) {
    if (!marks3 || marks3.length == 0) {
      return Mark4.none;
    }
    if (marks3 instanceof Mark4) {
      return [marks3];
    }
    var copy7 = marks3.slice();
    copy7.sort(function(a, b) {
      return a.type.rank - b.type.rank;
    });
    return copy7;
  };
  Mark4.none = [];
  function ReplaceError2(message) {
    var err3 = Error.call(this, message);
    err3.__proto__ = ReplaceError2.prototype;
    return err3;
  }
  ReplaceError2.prototype = Object.create(Error.prototype);
  ReplaceError2.prototype.constructor = ReplaceError2;
  ReplaceError2.prototype.name = "ReplaceError";
  var Slice3 = function Slice4(content3, openStart, openEnd) {
    this.content = content3;
    this.openStart = openStart;
    this.openEnd = openEnd;
  };
  var prototypeAccessors$1$22 = { size: { configurable: true } };
  prototypeAccessors$1$22.size.get = function() {
    return this.content.size - this.openStart - this.openEnd;
  };
  Slice3.prototype.insertAt = function insertAt2(pos, fragment) {
    var content3 = insertInto2(this.content, pos + this.openStart, fragment, null);
    return content3 && new Slice3(content3, this.openStart, this.openEnd);
  };
  Slice3.prototype.removeBetween = function removeBetween2(from5, to) {
    return new Slice3(removeRange2(this.content, from5 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  };
  Slice3.prototype.eq = function eq14(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  };
  Slice3.prototype.toString = function toString8() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  };
  Slice3.prototype.toJSON = function toJSON9() {
    if (!this.content.size) {
      return null;
    }
    var json2 = { content: this.content.toJSON() };
    if (this.openStart > 0) {
      json2.openStart = this.openStart;
    }
    if (this.openEnd > 0) {
      json2.openEnd = this.openEnd;
    }
    return json2;
  };
  Slice3.fromJSON = function fromJSON10(schema, json2) {
    if (!json2) {
      return Slice3.empty;
    }
    var openStart = json2.openStart || 0, openEnd = json2.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number") {
      throw new RangeError("Invalid input for Slice.fromJSON");
    }
    return new Slice3(Fragment3.fromJSON(schema, json2.content), openStart, openEnd);
  };
  Slice3.maxOpen = function maxOpen2(fragment, openIsolating) {
    if (openIsolating === void 0)
      openIsolating = true;
    var openStart = 0, openEnd = 0;
    for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
      openStart++;
    }
    for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
      openEnd++;
    }
    return new Slice3(fragment, openStart, openEnd);
  };
  Object.defineProperties(Slice3.prototype, prototypeAccessors$1$22);
  function removeRange2(content3, from5, to) {
    var ref = content3.findIndex(from5);
    var index3 = ref.index;
    var offset4 = ref.offset;
    var child5 = content3.maybeChild(index3);
    var ref$1 = content3.findIndex(to);
    var indexTo = ref$1.index;
    var offsetTo = ref$1.offset;
    if (offset4 == from5 || child5.isText) {
      if (offsetTo != to && !content3.child(indexTo).isText) {
        throw new RangeError("Removing non-flat range");
      }
      return content3.cut(0, from5).append(content3.cut(to));
    }
    if (index3 != indexTo) {
      throw new RangeError("Removing non-flat range");
    }
    return content3.replaceChild(index3, child5.copy(removeRange2(child5.content, from5 - offset4 - 1, to - offset4 - 1)));
  }
  function insertInto2(content3, dist, insert, parent) {
    var ref = content3.findIndex(dist);
    var index3 = ref.index;
    var offset4 = ref.offset;
    var child5 = content3.maybeChild(index3);
    if (offset4 == dist || child5.isText) {
      if (parent && !parent.canReplace(index3, index3, insert)) {
        return null;
      }
      return content3.cut(0, dist).append(insert).append(content3.cut(dist));
    }
    var inner = insertInto2(child5.content, dist - offset4 - 1, insert);
    return inner && content3.replaceChild(index3, child5.copy(inner));
  }
  Slice3.empty = new Slice3(Fragment3.empty, 0, 0);
  function replace3($from, $to, slice6) {
    if (slice6.openStart > $from.depth) {
      throw new ReplaceError2("Inserted content deeper than insertion position");
    }
    if ($from.depth - slice6.openStart != $to.depth - slice6.openEnd) {
      throw new ReplaceError2("Inconsistent open depths");
    }
    return replaceOuter2($from, $to, slice6, 0);
  }
  function replaceOuter2($from, $to, slice6, depth) {
    var index3 = $from.index(depth), node5 = $from.node(depth);
    if (index3 == $to.index(depth) && depth < $from.depth - slice6.openStart) {
      var inner = replaceOuter2($from, $to, slice6, depth + 1);
      return node5.copy(node5.content.replaceChild(index3, inner));
    } else if (!slice6.content.size) {
      return close3(node5, replaceTwoWay2($from, $to, depth));
    } else if (!slice6.openStart && !slice6.openEnd && $from.depth == depth && $to.depth == depth) {
      var parent = $from.parent, content3 = parent.content;
      return close3(parent, content3.cut(0, $from.parentOffset).append(slice6.content).append(content3.cut($to.parentOffset)));
    } else {
      var ref = prepareSliceForReplace2(slice6, $from);
      var start6 = ref.start;
      var end4 = ref.end;
      return close3(node5, replaceThreeWay2($from, start6, end4, $to, depth));
    }
  }
  function checkJoin2(main2, sub) {
    if (!sub.type.compatibleContent(main2.type)) {
      throw new ReplaceError2("Cannot join " + sub.type.name + " onto " + main2.type.name);
    }
  }
  function joinable3($before, $after, depth) {
    var node5 = $before.node(depth);
    checkJoin2(node5, $after.node(depth));
    return node5;
  }
  function addNode3(child5, target) {
    var last = target.length - 1;
    if (last >= 0 && child5.isText && child5.sameMarkup(target[last])) {
      target[last] = child5.withText(target[last].text + child5.text);
    } else {
      target.push(child5);
    }
  }
  function addRange2($start, $end, depth, target) {
    var node5 = ($end || $start).node(depth);
    var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node5.childCount;
    if ($start) {
      startIndex2 = $start.index(depth);
      if ($start.depth > depth) {
        startIndex2++;
      } else if ($start.textOffset) {
        addNode3($start.nodeAfter, target);
        startIndex2++;
      }
    }
    for (var i = startIndex2; i < endIndex2; i++) {
      addNode3(node5.child(i), target);
    }
    if ($end && $end.depth == depth && $end.textOffset) {
      addNode3($end.nodeBefore, target);
    }
  }
  function close3(node5, content3) {
    if (!node5.type.validContent(content3)) {
      throw new ReplaceError2("Invalid content for node " + node5.type.name);
    }
    return node5.copy(content3);
  }
  function replaceThreeWay2($from, $start, $end, $to, depth) {
    var openStart = $from.depth > depth && joinable3($from, $start, depth + 1);
    var openEnd = $to.depth > depth && joinable3($end, $to, depth + 1);
    var content3 = [];
    addRange2(null, $from, depth, content3);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin2(openStart, openEnd);
      addNode3(close3(openStart, replaceThreeWay2($from, $start, $end, $to, depth + 1)), content3);
    } else {
      if (openStart) {
        addNode3(close3(openStart, replaceTwoWay2($from, $start, depth + 1)), content3);
      }
      addRange2($start, $end, depth, content3);
      if (openEnd) {
        addNode3(close3(openEnd, replaceTwoWay2($end, $to, depth + 1)), content3);
      }
    }
    addRange2($to, null, depth, content3);
    return new Fragment3(content3);
  }
  function replaceTwoWay2($from, $to, depth) {
    var content3 = [];
    addRange2(null, $from, depth, content3);
    if ($from.depth > depth) {
      var type = joinable3($from, $to, depth + 1);
      addNode3(close3(type, replaceTwoWay2($from, $to, depth + 1)), content3);
    }
    addRange2($to, null, depth, content3);
    return new Fragment3(content3);
  }
  function prepareSliceForReplace2(slice6, $along) {
    var extra = $along.depth - slice6.openStart, parent = $along.node(extra);
    var node5 = parent.copy(slice6.content);
    for (var i = extra - 1; i >= 0; i--) {
      node5 = $along.node(i).copy(Fragment3.from(node5));
    }
    return {
      start: node5.resolveNoCache(slice6.openStart + extra),
      end: node5.resolveNoCache(node5.content.size - slice6.openEnd - extra)
    };
  }
  var ResolvedPos3 = function ResolvedPos4(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.depth = path.length / 3 - 1;
    this.parentOffset = parentOffset;
  };
  var prototypeAccessors$2$1 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
  ResolvedPos3.prototype.resolveDepth = function resolveDepth2(val) {
    if (val == null) {
      return this.depth;
    }
    if (val < 0) {
      return this.depth + val;
    }
    return val;
  };
  prototypeAccessors$2$1.parent.get = function() {
    return this.node(this.depth);
  };
  prototypeAccessors$2$1.doc.get = function() {
    return this.node(0);
  };
  ResolvedPos3.prototype.node = function node4(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  };
  ResolvedPos3.prototype.index = function index2(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  };
  ResolvedPos3.prototype.indexAfter = function indexAfter2(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  };
  ResolvedPos3.prototype.start = function start5(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  };
  ResolvedPos3.prototype.end = function end3(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  };
  ResolvedPos3.prototype.before = function before2(depth) {
    depth = this.resolveDepth(depth);
    if (!depth) {
      throw new RangeError("There is no position before the top-level node");
    }
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  };
  ResolvedPos3.prototype.after = function after2(depth) {
    depth = this.resolveDepth(depth);
    if (!depth) {
      throw new RangeError("There is no position after the top-level node");
    }
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  };
  prototypeAccessors$2$1.textOffset.get = function() {
    return this.pos - this.path[this.path.length - 1];
  };
  prototypeAccessors$2$1.nodeAfter.get = function() {
    var parent = this.parent, index3 = this.index(this.depth);
    if (index3 == parent.childCount) {
      return null;
    }
    var dOff = this.pos - this.path[this.path.length - 1], child5 = parent.child(index3);
    return dOff ? parent.child(index3).cut(dOff) : child5;
  };
  prototypeAccessors$2$1.nodeBefore.get = function() {
    var index3 = this.index(this.depth);
    var dOff = this.pos - this.path[this.path.length - 1];
    if (dOff) {
      return this.parent.child(index3).cut(0, dOff);
    }
    return index3 == 0 ? null : this.parent.child(index3 - 1);
  };
  ResolvedPos3.prototype.posAtIndex = function posAtIndex2(index3, depth) {
    depth = this.resolveDepth(depth);
    var node5 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (var i = 0; i < index3; i++) {
      pos += node5.child(i).nodeSize;
    }
    return pos;
  };
  ResolvedPos3.prototype.marks = function marks2() {
    var parent = this.parent, index3 = this.index();
    if (parent.content.size == 0) {
      return Mark4.none;
    }
    if (this.textOffset) {
      return parent.child(index3).marks;
    }
    var main2 = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
    if (!main2) {
      var tmp = main2;
      main2 = other;
      other = tmp;
    }
    var marks3 = main2.marks;
    for (var i = 0; i < marks3.length; i++) {
      if (marks3[i].type.spec.inclusive === false && (!other || !marks3[i].isInSet(other.marks))) {
        marks3 = marks3[i--].removeFromSet(marks3);
      }
    }
    return marks3;
  };
  ResolvedPos3.prototype.marksAcross = function marksAcross2($end) {
    var after3 = this.parent.maybeChild(this.index());
    if (!after3 || !after3.isInline) {
      return null;
    }
    var marks3 = after3.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks3.length; i++) {
      if (marks3[i].type.spec.inclusive === false && (!next || !marks3[i].isInSet(next.marks))) {
        marks3 = marks3[i--].removeFromSet(marks3);
      }
    }
    return marks3;
  };
  ResolvedPos3.prototype.sharedDepth = function sharedDepth2(pos) {
    for (var depth = this.depth; depth > 0; depth--) {
      if (this.start(depth) <= pos && this.end(depth) >= pos) {
        return depth;
      }
    }
    return 0;
  };
  ResolvedPos3.prototype.blockRange = function blockRange2(other, pred) {
    if (other === void 0)
      other = this;
    if (other.pos < this.pos) {
      return other.blockRange(this);
    }
    for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
        return new NodeRange3(this, other, d);
      }
    }
  };
  ResolvedPos3.prototype.sameParent = function sameParent2(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  };
  ResolvedPos3.prototype.max = function max3(other) {
    return other.pos > this.pos ? other : this;
  };
  ResolvedPos3.prototype.min = function min3(other) {
    return other.pos < this.pos ? other : this;
  };
  ResolvedPos3.prototype.toString = function toString9() {
    var str = "";
    for (var i = 1; i <= this.depth; i++) {
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    }
    return str + ":" + this.parentOffset;
  };
  ResolvedPos3.resolve = function resolve8(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size)) {
      throw new RangeError("Position " + pos + " out of range");
    }
    var path = [];
    var start6 = 0, parentOffset = pos;
    for (var node5 = doc2; ; ) {
      var ref = node5.content.findIndex(parentOffset);
      var index3 = ref.index;
      var offset4 = ref.offset;
      var rem = parentOffset - offset4;
      path.push(node5, index3, start6 + offset4);
      if (!rem) {
        break;
      }
      node5 = node5.child(index3);
      if (node5.isText) {
        break;
      }
      parentOffset = rem - 1;
      start6 += offset4 + 1;
    }
    return new ResolvedPos3(pos, path, parentOffset);
  };
  ResolvedPos3.resolveCached = function resolveCached2(doc2, pos) {
    for (var i = 0; i < resolveCache2.length; i++) {
      var cached = resolveCache2[i];
      if (cached.pos == pos && cached.doc == doc2) {
        return cached;
      }
    }
    var result2 = resolveCache2[resolveCachePos2] = ResolvedPos3.resolve(doc2, pos);
    resolveCachePos2 = (resolveCachePos2 + 1) % resolveCacheSize2;
    return result2;
  };
  Object.defineProperties(ResolvedPos3.prototype, prototypeAccessors$2$1);
  var resolveCache2 = [];
  var resolveCachePos2 = 0;
  var resolveCacheSize2 = 12;
  var NodeRange3 = function NodeRange4($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  };
  var prototypeAccessors$1$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
  prototypeAccessors$1$1$1.start.get = function() {
    return this.$from.before(this.depth + 1);
  };
  prototypeAccessors$1$1$1.end.get = function() {
    return this.$to.after(this.depth + 1);
  };
  prototypeAccessors$1$1$1.parent.get = function() {
    return this.$from.node(this.depth);
  };
  prototypeAccessors$1$1$1.startIndex.get = function() {
    return this.$from.index(this.depth);
  };
  prototypeAccessors$1$1$1.endIndex.get = function() {
    return this.$to.indexAfter(this.depth);
  };
  Object.defineProperties(NodeRange3.prototype, prototypeAccessors$1$1$1);
  var emptyAttrs2 = /* @__PURE__ */ Object.create(null);
  var Node5 = function Node6(type, attrs, content3, marks3) {
    this.type = type;
    this.attrs = attrs;
    this.content = content3 || Fragment3.empty;
    this.marks = marks3 || Mark4.none;
  };
  var prototypeAccessors$3$1 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
  prototypeAccessors$3$1.nodeSize.get = function() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  };
  prototypeAccessors$3$1.childCount.get = function() {
    return this.content.childCount;
  };
  Node5.prototype.child = function child4(index3) {
    return this.content.child(index3);
  };
  Node5.prototype.maybeChild = function maybeChild4(index3) {
    return this.content.maybeChild(index3);
  };
  Node5.prototype.forEach = function forEach7(f) {
    this.content.forEach(f);
  };
  Node5.prototype.nodesBetween = function nodesBetween4(from5, to, f, startPos) {
    if (startPos === void 0)
      startPos = 0;
    this.content.nodesBetween(from5, to, f, startPos, this);
  };
  Node5.prototype.descendants = function descendants4(f) {
    this.nodesBetween(0, this.content.size, f);
  };
  prototypeAccessors$3$1.textContent.get = function() {
    return this.textBetween(0, this.content.size, "");
  };
  Node5.prototype.textBetween = function textBetween4(from5, to, blockSeparator, leafText) {
    return this.content.textBetween(from5, to, blockSeparator, leafText);
  };
  prototypeAccessors$3$1.firstChild.get = function() {
    return this.content.firstChild;
  };
  prototypeAccessors$3$1.lastChild.get = function() {
    return this.content.lastChild;
  };
  Node5.prototype.eq = function eq15(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  };
  Node5.prototype.sameMarkup = function sameMarkup2(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  };
  Node5.prototype.hasMarkup = function hasMarkup2(type, attrs, marks3) {
    return this.type == type && compareDeep2(this.attrs, attrs || type.defaultAttrs || emptyAttrs2) && Mark4.sameSet(this.marks, marks3 || Mark4.none);
  };
  Node5.prototype.copy = function copy5(content3) {
    if (content3 === void 0)
      content3 = null;
    if (content3 == this.content) {
      return this;
    }
    return new this.constructor(this.type, this.attrs, content3, this.marks);
  };
  Node5.prototype.mark = function mark3(marks3) {
    return marks3 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks3);
  };
  Node5.prototype.cut = function cut4(from5, to) {
    if (from5 == 0 && to == this.content.size) {
      return this;
    }
    return this.copy(this.content.cut(from5, to));
  };
  Node5.prototype.slice = function slice4(from5, to, includeParents) {
    if (to === void 0)
      to = this.content.size;
    if (includeParents === void 0)
      includeParents = false;
    if (from5 == to) {
      return Slice3.empty;
    }
    var $from = this.resolve(from5), $to = this.resolve(to);
    var depth = includeParents ? 0 : $from.sharedDepth(to);
    var start6 = $from.start(depth), node5 = $from.node(depth);
    var content3 = node5.content.cut($from.pos - start6, $to.pos - start6);
    return new Slice3(content3, $from.depth - depth, $to.depth - depth);
  };
  Node5.prototype.replace = function replace$12(from5, to, slice6) {
    return replace3(this.resolve(from5), this.resolve(to), slice6);
  };
  Node5.prototype.nodeAt = function nodeAt2(pos) {
    for (var node5 = this; ; ) {
      var ref = node5.content.findIndex(pos);
      var index3 = ref.index;
      var offset4 = ref.offset;
      node5 = node5.maybeChild(index3);
      if (!node5) {
        return null;
      }
      if (offset4 == pos || node5.isText) {
        return node5;
      }
      pos -= offset4 + 1;
    }
  };
  Node5.prototype.childAfter = function childAfter2(pos) {
    var ref = this.content.findIndex(pos);
    var index3 = ref.index;
    var offset4 = ref.offset;
    return { node: this.content.maybeChild(index3), index: index3, offset: offset4 };
  };
  Node5.prototype.childBefore = function childBefore2(pos) {
    if (pos == 0) {
      return { node: null, index: 0, offset: 0 };
    }
    var ref = this.content.findIndex(pos);
    var index3 = ref.index;
    var offset4 = ref.offset;
    if (offset4 < pos) {
      return { node: this.content.child(index3), index: index3, offset: offset4 };
    }
    var node5 = this.content.child(index3 - 1);
    return { node: node5, index: index3 - 1, offset: offset4 - node5.nodeSize };
  };
  Node5.prototype.resolve = function resolve9(pos) {
    return ResolvedPos3.resolveCached(this, pos);
  };
  Node5.prototype.resolveNoCache = function resolveNoCache2(pos) {
    return ResolvedPos3.resolve(this, pos);
  };
  Node5.prototype.rangeHasMark = function rangeHasMark2(from5, to, type) {
    var found3 = false;
    if (to > from5) {
      this.nodesBetween(from5, to, function(node5) {
        if (type.isInSet(node5.marks)) {
          found3 = true;
        }
        return !found3;
      });
    }
    return found3;
  };
  prototypeAccessors$3$1.isBlock.get = function() {
    return this.type.isBlock;
  };
  prototypeAccessors$3$1.isTextblock.get = function() {
    return this.type.isTextblock;
  };
  prototypeAccessors$3$1.inlineContent.get = function() {
    return this.type.inlineContent;
  };
  prototypeAccessors$3$1.isInline.get = function() {
    return this.type.isInline;
  };
  prototypeAccessors$3$1.isText.get = function() {
    return this.type.isText;
  };
  prototypeAccessors$3$1.isLeaf.get = function() {
    return this.type.isLeaf;
  };
  prototypeAccessors$3$1.isAtom.get = function() {
    return this.type.isAtom;
  };
  Node5.prototype.toString = function toString10() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    var name = this.type.name;
    if (this.content.size) {
      name += "(" + this.content.toStringInner() + ")";
    }
    return wrapMarks2(this.marks, name);
  };
  Node5.prototype.contentMatchAt = function contentMatchAt2(index3) {
    var match = this.type.contentMatch.matchFragment(this.content, 0, index3);
    if (!match) {
      throw new Error("Called contentMatchAt on a node with invalid content");
    }
    return match;
  };
  Node5.prototype.canReplace = function canReplace2(from5, to, replacement, start6, end4) {
    if (replacement === void 0)
      replacement = Fragment3.empty;
    if (start6 === void 0)
      start6 = 0;
    if (end4 === void 0)
      end4 = replacement.childCount;
    var one = this.contentMatchAt(from5).matchFragment(replacement, start6, end4);
    var two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd) {
      return false;
    }
    for (var i = start6; i < end4; i++) {
      if (!this.type.allowsMarks(replacement.child(i).marks)) {
        return false;
      }
    }
    return true;
  };
  Node5.prototype.canReplaceWith = function canReplaceWith2(from5, to, type, marks3) {
    if (marks3 && !this.type.allowsMarks(marks3)) {
      return false;
    }
    var start6 = this.contentMatchAt(from5).matchType(type);
    var end4 = start6 && start6.matchFragment(this.content, to);
    return end4 ? end4.validEnd : false;
  };
  Node5.prototype.canAppend = function canAppend2(other) {
    if (other.content.size) {
      return this.canReplace(this.childCount, this.childCount, other.content);
    } else {
      return this.type.compatibleContent(other.type);
    }
  };
  Node5.prototype.check = function check2() {
    if (!this.type.validContent(this.content)) {
      throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
    }
    var copy7 = Mark4.none;
    for (var i = 0; i < this.marks.length; i++) {
      copy7 = this.marks[i].addToSet(copy7);
    }
    if (!Mark4.sameSet(copy7, this.marks)) {
      throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
        return m.type.name;
      }));
    }
    this.content.forEach(function(node5) {
      return node5.check();
    });
  };
  Node5.prototype.toJSON = function toJSON10() {
    var obj = { type: this.type.name };
    for (var _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size) {
      obj.content = this.content.toJSON();
    }
    if (this.marks.length) {
      obj.marks = this.marks.map(function(n) {
        return n.toJSON();
      });
    }
    return obj;
  };
  Node5.fromJSON = function fromJSON11(schema, json2) {
    if (!json2) {
      throw new RangeError("Invalid input for Node.fromJSON");
    }
    var marks3 = null;
    if (json2.marks) {
      if (!Array.isArray(json2.marks)) {
        throw new RangeError("Invalid mark data for Node.fromJSON");
      }
      marks3 = json2.marks.map(schema.markFromJSON);
    }
    if (json2.type == "text") {
      if (typeof json2.text != "string") {
        throw new RangeError("Invalid text node in JSON");
      }
      return schema.text(json2.text, marks3);
    }
    var content3 = Fragment3.fromJSON(schema, json2.content);
    return schema.nodeType(json2.type).create(json2.attrs, content3, marks3);
  };
  Object.defineProperties(Node5.prototype, prototypeAccessors$3$1);
  function wrapMarks2(marks3, str) {
    for (var i = marks3.length - 1; i >= 0; i--) {
      str = marks3[i].type.name + "(" + str + ")";
    }
    return str;
  }
  var ContentMatch3 = function ContentMatch4(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  };
  var prototypeAccessors$42 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
  ContentMatch3.parse = function parse3(string, nodeTypes) {
    var stream = new TokenStream3(string, nodeTypes);
    if (stream.next == null) {
      return ContentMatch3.empty;
    }
    var expr = parseExpr2(stream);
    if (stream.next) {
      stream.err("Unexpected trailing text");
    }
    var match = dfa2(nfa2(expr));
    checkForDeadEnds2(match, stream);
    return match;
  };
  ContentMatch3.prototype.matchType = function matchType2(type) {
    for (var i = 0; i < this.next.length; i += 2) {
      if (this.next[i] == type) {
        return this.next[i + 1];
      }
    }
    return null;
  };
  ContentMatch3.prototype.matchFragment = function matchFragment2(frag, start6, end4) {
    if (start6 === void 0)
      start6 = 0;
    if (end4 === void 0)
      end4 = frag.childCount;
    var cur = this;
    for (var i = start6; cur && i < end4; i++) {
      cur = cur.matchType(frag.child(i).type);
    }
    return cur;
  };
  prototypeAccessors$42.inlineContent.get = function() {
    var first2 = this.next[0];
    return first2 ? first2.isInline : false;
  };
  prototypeAccessors$42.defaultType.get = function() {
    for (var i = 0; i < this.next.length; i += 2) {
      var type = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs())) {
        return type;
      }
    }
  };
  ContentMatch3.prototype.compatible = function compatible2(other) {
    for (var i = 0; i < this.next.length; i += 2) {
      for (var j = 0; j < other.next.length; j += 2) {
        if (this.next[i] == other.next[j]) {
          return true;
        }
      }
    }
    return false;
  };
  ContentMatch3.prototype.fillBefore = function fillBefore2(after3, toEnd, startIndex2) {
    if (toEnd === void 0)
      toEnd = false;
    if (startIndex2 === void 0)
      startIndex2 = 0;
    var seen = [this];
    function search(match, types) {
      var finished = match.matchFragment(after3, startIndex2);
      if (finished && (!toEnd || finished.validEnd)) {
        return Fragment3.from(types.map(function(tp) {
          return tp.createAndFill();
        }));
      }
      for (var i = 0; i < match.next.length; i += 2) {
        var type = match.next[i], next = match.next[i + 1];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          var found3 = search(next, types.concat(type));
          if (found3) {
            return found3;
          }
        }
      }
    }
    return search(this, []);
  };
  ContentMatch3.prototype.findWrapping = function findWrapping4(target) {
    for (var i = 0; i < this.wrapCache.length; i += 2) {
      if (this.wrapCache[i] == target) {
        return this.wrapCache[i + 1];
      }
    }
    var computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  };
  ContentMatch3.prototype.computeWrapping = function computeWrapping2(target) {
    var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      var current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        var result2 = [];
        for (var obj = current; obj.type; obj = obj.via) {
          result2.push(obj.type);
        }
        return result2.reverse();
      }
      for (var i = 0; i < match.next.length; i += 2) {
        var type = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
  };
  prototypeAccessors$42.edgeCount.get = function() {
    return this.next.length >> 1;
  };
  ContentMatch3.prototype.edge = function edge2(n) {
    var i = n << 1;
    if (i >= this.next.length) {
      throw new RangeError("There's no " + n + "th edge in this content match");
    }
    return { type: this.next[i], next: this.next[i + 1] };
  };
  ContentMatch3.prototype.toString = function toString11() {
    var seen = [];
    function scan(m) {
      seen.push(m);
      for (var i = 1; i < m.next.length; i += 2) {
        if (seen.indexOf(m.next[i]) == -1) {
          scan(m.next[i]);
        }
      }
    }
    scan(this);
    return seen.map(function(m, i) {
      var out = i + (m.validEnd ? "*" : " ") + " ";
      for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
        out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
      }
      return out;
    }).join("\n");
  };
  Object.defineProperties(ContentMatch3.prototype, prototypeAccessors$42);
  ContentMatch3.empty = new ContentMatch3(true);
  var TokenStream3 = function TokenStream4(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "") {
      this.tokens.pop();
    }
    if (this.tokens[0] == "") {
      this.tokens.shift();
    }
  };
  var prototypeAccessors$1$2$1 = { next: { configurable: true } };
  prototypeAccessors$1$2$1.next.get = function() {
    return this.tokens[this.pos];
  };
  TokenStream3.prototype.eat = function eat2(tok) {
    return this.next == tok && (this.pos++ || true);
  };
  TokenStream3.prototype.err = function err2(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  };
  Object.defineProperties(TokenStream3.prototype, prototypeAccessors$1$2$1);
  function parseExpr2(stream) {
    var exprs = [];
    do {
      exprs.push(parseExprSeq2(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq2(stream) {
    var exprs = [];
    do {
      exprs.push(parseExprSubscript2(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript2(stream) {
    var expr = parseExprAtom2(stream);
    for (; ; ) {
      if (stream.eat("+")) {
        expr = { type: "plus", expr };
      } else if (stream.eat("*")) {
        expr = { type: "star", expr };
      } else if (stream.eat("?")) {
        expr = { type: "opt", expr };
      } else if (stream.eat("{")) {
        expr = parseExprRange2(stream, expr);
      } else {
        break;
      }
    }
    return expr;
  }
  function parseNum2(stream) {
    if (/\D/.test(stream.next)) {
      stream.err("Expected number, got '" + stream.next + "'");
    }
    var result2 = Number(stream.next);
    stream.pos++;
    return result2;
  }
  function parseExprRange2(stream, expr) {
    var min4 = parseNum2(stream), max4 = min4;
    if (stream.eat(",")) {
      if (stream.next != "}") {
        max4 = parseNum2(stream);
      } else {
        max4 = -1;
      }
    }
    if (!stream.eat("}")) {
      stream.err("Unclosed braced range");
    }
    return { type: "range", min: min4, max: max4, expr };
  }
  function resolveName2(stream, name) {
    var types = stream.nodeTypes, type = types[name];
    if (type) {
      return [type];
    }
    var result2 = [];
    for (var typeName in types) {
      var type$1 = types[typeName];
      if (type$1.groups.indexOf(name) > -1) {
        result2.push(type$1);
      }
    }
    if (result2.length == 0) {
      stream.err("No node type or group '" + name + "' found");
    }
    return result2;
  }
  function parseExprAtom2(stream) {
    if (stream.eat("(")) {
      var expr = parseExpr2(stream);
      if (!stream.eat(")")) {
        stream.err("Missing closing paren");
      }
      return expr;
    } else if (!/\W/.test(stream.next)) {
      var exprs = resolveName2(stream, stream.next).map(function(type) {
        if (stream.inline == null) {
          stream.inline = type.isInline;
        } else if (stream.inline != type.isInline) {
          stream.err("Mixing inline and block content");
        }
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa2(expr) {
    var nfa3 = [[]];
    connect(compile5(expr, 0), node5());
    return nfa3;
    function node5() {
      return nfa3.push([]) - 1;
    }
    function edge3(from5, to, term) {
      var edge4 = { term, to };
      nfa3[from5].push(edge4);
      return edge4;
    }
    function connect(edges, to) {
      edges.forEach(function(edge4) {
        return edge4.to = to;
      });
    }
    function compile5(expr2, from5) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce(function(out, expr3) {
          return out.concat(compile5(expr3, from5));
        }, []);
      } else if (expr2.type == "seq") {
        for (var i = 0; ; i++) {
          var next = compile5(expr2.exprs[i], from5);
          if (i == expr2.exprs.length - 1) {
            return next;
          }
          connect(next, from5 = node5());
        }
      } else if (expr2.type == "star") {
        var loop = node5();
        edge3(from5, loop);
        connect(compile5(expr2.expr, loop), loop);
        return [edge3(loop)];
      } else if (expr2.type == "plus") {
        var loop$1 = node5();
        connect(compile5(expr2.expr, from5), loop$1);
        connect(compile5(expr2.expr, loop$1), loop$1);
        return [edge3(loop$1)];
      } else if (expr2.type == "opt") {
        return [edge3(from5)].concat(compile5(expr2.expr, from5));
      } else if (expr2.type == "range") {
        var cur = from5;
        for (var i$1 = 0; i$1 < expr2.min; i$1++) {
          var next$1 = node5();
          connect(compile5(expr2.expr, cur), next$1);
          cur = next$1;
        }
        if (expr2.max == -1) {
          connect(compile5(expr2.expr, cur), cur);
        } else {
          for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
            var next$2 = node5();
            edge3(cur, next$2);
            connect(compile5(expr2.expr, cur), next$2);
            cur = next$2;
          }
        }
        return [edge3(cur)];
      } else if (expr2.type == "name") {
        return [edge3(from5, null, expr2.value)];
      }
    }
  }
  function cmp2(a, b) {
    return b - a;
  }
  function nullFrom2(nfa3, node5) {
    var result2 = [];
    scan(node5);
    return result2.sort(cmp2);
    function scan(node6) {
      var edges = nfa3[node6];
      if (edges.length == 1 && !edges[0].term) {
        return scan(edges[0].to);
      }
      result2.push(node6);
      for (var i = 0; i < edges.length; i++) {
        var ref = edges[i];
        var term = ref.term;
        var to = ref.to;
        if (!term && result2.indexOf(to) == -1) {
          scan(to);
        }
      }
    }
  }
  function dfa2(nfa3) {
    var labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom2(nfa3, 0));
    function explore(states) {
      var out = [];
      states.forEach(function(node5) {
        nfa3[node5].forEach(function(ref) {
          var term = ref.term;
          var to = ref.to;
          if (!term) {
            return;
          }
          var known = out.indexOf(term), set2 = known > -1 && out[known + 1];
          nullFrom2(nfa3, to).forEach(function(node6) {
            if (!set2) {
              out.push(term, set2 = []);
            }
            if (set2.indexOf(node6) == -1) {
              set2.push(node6);
            }
          });
        });
      });
      var state = labeled[states.join(",")] = new ContentMatch3(states.indexOf(nfa3.length - 1) > -1);
      for (var i = 0; i < out.length; i += 2) {
        var states$1 = out[i + 1].sort(cmp2);
        state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
      }
      return state;
    }
  }
  function checkForDeadEnds2(match, stream) {
    for (var i = 0, work = [match]; i < work.length; i++) {
      var state = work[i], dead = !state.validEnd, nodes = [];
      for (var j = 0; j < state.next.length; j += 2) {
        var node5 = state.next[j], next = state.next[j + 1];
        nodes.push(node5.name);
        if (dead && !(node5.isText || node5.hasRequiredAttrs())) {
          dead = false;
        }
        if (work.indexOf(next) == -1) {
          work.push(next);
        }
      }
      if (dead) {
        stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
  }
  function defaultAttrs2(attrs) {
    var defaults2 = /* @__PURE__ */ Object.create(null);
    for (var attrName in attrs) {
      var attr = attrs[attrName];
      if (!attr.hasDefault) {
        return null;
      }
      defaults2[attrName] = attr.default;
    }
    return defaults2;
  }
  function computeAttrs2(attrs, value) {
    var built = /* @__PURE__ */ Object.create(null);
    for (var name in attrs) {
      var given = value && value[name];
      if (given === void 0) {
        var attr = attrs[name];
        if (attr.hasDefault) {
          given = attr.default;
        } else {
          throw new RangeError("No value supplied for attribute " + name);
        }
      }
      built[name] = given;
    }
    return built;
  }
  function initAttrs2(attrs) {
    var result2 = /* @__PURE__ */ Object.create(null);
    if (attrs) {
      for (var name in attrs) {
        result2[name] = new Attribute3(attrs[name]);
      }
    }
    return result2;
  }
  var NodeType5 = function NodeType6(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs2(spec.attrs);
    this.defaultAttrs = defaultAttrs2(this.attrs);
    this.contentMatch = null;
    this.markSet = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  };
  var prototypeAccessors$52 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
  prototypeAccessors$52.isInline.get = function() {
    return !this.isBlock;
  };
  prototypeAccessors$52.isTextblock.get = function() {
    return this.isBlock && this.inlineContent;
  };
  prototypeAccessors$52.isLeaf.get = function() {
    return this.contentMatch == ContentMatch3.empty;
  };
  prototypeAccessors$52.isAtom.get = function() {
    return this.isLeaf || this.spec.atom;
  };
  prototypeAccessors$52.whitespace.get = function() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  };
  NodeType5.prototype.hasRequiredAttrs = function hasRequiredAttrs2() {
    for (var n in this.attrs) {
      if (this.attrs[n].isRequired) {
        return true;
      }
    }
    return false;
  };
  NodeType5.prototype.compatibleContent = function compatibleContent2(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  };
  NodeType5.prototype.computeAttrs = function computeAttrs$12(attrs) {
    if (!attrs && this.defaultAttrs) {
      return this.defaultAttrs;
    } else {
      return computeAttrs2(this.attrs, attrs);
    }
  };
  NodeType5.prototype.create = function create5(attrs, content3, marks3) {
    if (this.isText) {
      throw new Error("NodeType.create can't construct text nodes");
    }
    return new Node5(this, this.computeAttrs(attrs), Fragment3.from(content3), Mark4.setFrom(marks3));
  };
  NodeType5.prototype.createChecked = function createChecked2(attrs, content3, marks3) {
    content3 = Fragment3.from(content3);
    if (!this.validContent(content3)) {
      throw new RangeError("Invalid content for node " + this.name);
    }
    return new Node5(this, this.computeAttrs(attrs), content3, Mark4.setFrom(marks3));
  };
  NodeType5.prototype.createAndFill = function createAndFill2(attrs, content3, marks3) {
    attrs = this.computeAttrs(attrs);
    content3 = Fragment3.from(content3);
    if (content3.size) {
      var before3 = this.contentMatch.fillBefore(content3);
      if (!before3) {
        return null;
      }
      content3 = before3.append(content3);
    }
    var after3 = this.contentMatch.matchFragment(content3).fillBefore(Fragment3.empty, true);
    if (!after3) {
      return null;
    }
    return new Node5(this, attrs, content3.append(after3), Mark4.setFrom(marks3));
  };
  NodeType5.prototype.validContent = function validContent2(content3) {
    var result2 = this.contentMatch.matchFragment(content3);
    if (!result2 || !result2.validEnd) {
      return false;
    }
    for (var i = 0; i < content3.childCount; i++) {
      if (!this.allowsMarks(content3.child(i).marks)) {
        return false;
      }
    }
    return true;
  };
  NodeType5.prototype.allowsMarkType = function allowsMarkType2(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  };
  NodeType5.prototype.allowsMarks = function allowsMarks2(marks3) {
    if (this.markSet == null) {
      return true;
    }
    for (var i = 0; i < marks3.length; i++) {
      if (!this.allowsMarkType(marks3[i].type)) {
        return false;
      }
    }
    return true;
  };
  NodeType5.prototype.allowedMarks = function allowedMarks2(marks3) {
    if (this.markSet == null) {
      return marks3;
    }
    var copy7;
    for (var i = 0; i < marks3.length; i++) {
      if (!this.allowsMarkType(marks3[i].type)) {
        if (!copy7) {
          copy7 = marks3.slice(0, i);
        }
      } else if (copy7) {
        copy7.push(marks3[i]);
      }
    }
    return !copy7 ? marks3 : copy7.length ? copy7 : Mark4.empty;
  };
  NodeType5.compile = function compile3(nodes, schema) {
    var result2 = /* @__PURE__ */ Object.create(null);
    nodes.forEach(function(name, spec) {
      return result2[name] = new NodeType5(name, schema, spec);
    });
    var topType = schema.spec.topNode || "doc";
    if (!result2[topType]) {
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    }
    if (!result2.text) {
      throw new RangeError("Every schema needs a 'text' type");
    }
    for (var _ in result2.text.attrs) {
      throw new RangeError("The text node type should not have attributes");
    }
    return result2;
  };
  Object.defineProperties(NodeType5.prototype, prototypeAccessors$52);
  var Attribute3 = function Attribute4(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  };
  var prototypeAccessors$1$32 = { isRequired: { configurable: true } };
  prototypeAccessors$1$32.isRequired.get = function() {
    return !this.hasDefault;
  };
  Object.defineProperties(Attribute3.prototype, prototypeAccessors$1$32);
  var MarkType3 = function MarkType4(name, rank, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs2(spec.attrs);
    this.rank = rank;
    this.excluded = null;
    var defaults2 = defaultAttrs2(this.attrs);
    this.instance = defaults2 && new Mark4(this, defaults2);
  };
  MarkType3.prototype.create = function create6(attrs) {
    if (!attrs && this.instance) {
      return this.instance;
    }
    return new Mark4(this, computeAttrs2(this.attrs, attrs));
  };
  MarkType3.compile = function compile4(marks3, schema) {
    var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
    marks3.forEach(function(name, spec) {
      return result2[name] = new MarkType3(name, rank++, schema, spec);
    });
    return result2;
  };
  MarkType3.prototype.removeFromSet = function removeFromSet4(set2) {
    for (var i = 0; i < set2.length; i++) {
      if (set2[i].type == this) {
        set2 = set2.slice(0, i).concat(set2.slice(i + 1));
        i--;
      }
    }
    return set2;
  };
  MarkType3.prototype.isInSet = function isInSet4(set2) {
    for (var i = 0; i < set2.length; i++) {
      if (set2[i].type == this) {
        return set2[i];
      }
    }
  };
  MarkType3.prototype.excludes = function excludes2(other) {
    return this.excluded.indexOf(other) > -1;
  };
  var blockTags2 = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  var ignoreTags2 = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  var listTags2 = { ol: true, ul: true };
  var OPT_PRESERVE_WS2 = 1;
  var OPT_PRESERVE_WS_FULL2 = 2;
  var OPT_OPEN_LEFT2 = 4;
  function wsOptionsFor2(type, preserveWhitespace, base2) {
    if (preserveWhitespace != null) {
      return (preserveWhitespace ? OPT_PRESERVE_WS2 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL2 : 0);
    }
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS2 | OPT_PRESERVE_WS_FULL2 : base2 & ~OPT_OPEN_LEFT2;
  }
  var NodeContext3 = function NodeContext4(type, attrs, marks3, pendingMarks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.solid = solid;
    this.match = match || (options & OPT_OPEN_LEFT2 ? null : type.contentMatch);
    this.options = options;
    this.content = [];
    this.marks = marks3;
    this.activeMarks = Mark4.none;
    this.pendingMarks = pendingMarks;
    this.stashMarks = [];
  };
  NodeContext3.prototype.findWrapping = function findWrapping5(node5) {
    if (!this.match) {
      if (!this.type) {
        return [];
      }
      var fill = this.type.contentMatch.fillBefore(Fragment3.from(node5));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        var start6 = this.type.contentMatch, wrap;
        if (wrap = start6.findWrapping(node5.type)) {
          this.match = start6;
          return wrap;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node5.type);
  };
  NodeContext3.prototype.finish = function finish3(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS2)) {
      var last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        if (last.text.length == m[0].length) {
          this.content.pop();
        } else {
          this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
        }
      }
    }
    var content3 = Fragment3.from(this.content);
    if (!openEnd && this.match) {
      content3 = content3.append(this.match.fillBefore(Fragment3.empty, true));
    }
    return this.type ? this.type.create(this.attrs, content3, this.marks) : content3;
  };
  NodeContext3.prototype.popFromStashMark = function popFromStashMark2(mark4) {
    for (var i = this.stashMarks.length - 1; i >= 0; i--) {
      if (mark4.eq(this.stashMarks[i])) {
        return this.stashMarks.splice(i, 1)[0];
      }
    }
  };
  NodeContext3.prototype.applyPending = function applyPending2(nextType) {
    for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
      var mark4 = pending[i];
      if ((this.type ? this.type.allowsMarkType(mark4.type) : markMayApply2(mark4.type, nextType)) && !mark4.isInSet(this.activeMarks)) {
        this.activeMarks = mark4.addToSet(this.activeMarks);
        this.pendingMarks = mark4.removeFromSet(this.pendingMarks);
      }
    }
  };
  NodeContext3.prototype.inlineContext = function inlineContext2(node5) {
    if (this.type) {
      return this.type.inlineContent;
    }
    if (this.content.length) {
      return this.content[0].isInline;
    }
    return node5.parentNode && !blockTags2.hasOwnProperty(node5.parentNode.nodeName.toLowerCase());
  };
  var ParseContext3 = function ParseContext4(parser, options, open2) {
    this.parser = parser;
    this.options = options;
    this.isOpen = open2;
    var topNode = options.topNode, topContext;
    var topOptions = wsOptionsFor2(null, options.preserveWhitespace, 0) | (open2 ? OPT_OPEN_LEFT2 : 0);
    if (topNode) {
      topContext = new NodeContext3(topNode.type, topNode.attrs, Mark4.none, Mark4.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    } else if (open2) {
      topContext = new NodeContext3(null, null, Mark4.none, Mark4.none, true, null, topOptions);
    } else {
      topContext = new NodeContext3(parser.schema.topNodeType, null, Mark4.none, Mark4.none, true, null, topOptions);
    }
    this.nodes = [topContext];
    this.open = 0;
    this.find = options.findPositions;
    this.needsBlock = false;
  };
  var prototypeAccessors$62 = { top: { configurable: true }, currentPos: { configurable: true } };
  prototypeAccessors$62.top.get = function() {
    return this.nodes[this.open];
  };
  ParseContext3.prototype.addDOM = function addDOM2(dom) {
    if (dom.nodeType == 3) {
      this.addTextNode(dom);
    } else if (dom.nodeType == 1) {
      var style2 = dom.getAttribute("style");
      var marks3 = style2 ? this.readStyles(parseStyles2(style2)) : null, top2 = this.top;
      if (marks3 != null) {
        for (var i = 0; i < marks3.length; i++) {
          this.addPendingMark(marks3[i]);
        }
      }
      this.addElement(dom);
      if (marks3 != null) {
        for (var i$1 = 0; i$1 < marks3.length; i$1++) {
          this.removePendingMark(marks3[i$1], top2);
        }
      }
    }
  };
  ParseContext3.prototype.addTextNode = function addTextNode2(dom) {
    var value = dom.nodeValue;
    var top2 = this.top;
    if (top2.options & OPT_PRESERVE_WS_FULL2 || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top2.options & OPT_PRESERVE_WS2)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          var nodeBefore = top2.content[top2.content.length - 1];
          var domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
            value = value.slice(1);
          }
        }
      } else if (!(top2.options & OPT_PRESERVE_WS_FULL2)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value) {
        this.insertNode(this.parser.schema.text(value));
      }
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  };
  ParseContext3.prototype.addElement = function addElement2(dom, matchAfter) {
    var name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags2.hasOwnProperty(name) && this.parser.normalizeLists) {
      normalizeList2(dom);
    }
    var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags2.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent) {
        this.open = Math.max(0, this.open - 1);
      } else if (rule && rule.skip.nodeType) {
        dom = rule.skip;
      }
      var sync3, top2 = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags2.hasOwnProperty(name)) {
        sync3 = true;
        if (!top2.type) {
          this.needsBlock = true;
        }
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      this.addAll(dom);
      if (sync3) {
        this.sync(top2);
      }
      this.needsBlock = oldNeedsBlock;
    } else {
      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
    }
  };
  ParseContext3.prototype.leafFallback = function leafFallback2(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
  };
  ParseContext3.prototype.ignoreFallback = function ignoreFallback2(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
      this.findPlace(this.parser.schema.text("-"));
    }
  };
  ParseContext3.prototype.readStyles = function readStyles2(styles) {
    var marks3 = Mark4.none;
    style:
      for (var i = 0; i < styles.length; i += 2) {
        for (var after3 = null; ; ) {
          var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after3);
          if (!rule) {
            continue style;
          }
          if (rule.ignore) {
            return null;
          }
          marks3 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks3);
          if (rule.consuming === false) {
            after3 = rule;
          } else {
            break;
          }
        }
      }
    return marks3;
  };
  ParseContext3.prototype.addElementByRule = function addElementByRule2(dom, rule, continueAfter) {
    var this$1$1 = this;
    var sync3, nodeType2, markType, mark4;
    if (rule.node) {
      nodeType2 = this.parser.schema.nodes[rule.node];
      if (!nodeType2.isLeaf) {
        sync3 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      markType = this.parser.schema.marks[rule.mark];
      mark4 = markType.create(rule.attrs);
      this.addPendingMark(mark4);
    }
    var startIn = this.top;
    if (nodeType2 && nodeType2.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach(function(node5) {
        return this$1$1.insertNode(node5);
      });
    } else {
      var contentDOM = rule.contentElement;
      if (typeof contentDOM == "string") {
        contentDOM = dom.querySelector(contentDOM);
      } else if (typeof contentDOM == "function") {
        contentDOM = contentDOM(dom);
      }
      if (!contentDOM) {
        contentDOM = dom;
      }
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, sync3);
    }
    if (sync3) {
      this.sync(startIn);
      this.open--;
    }
    if (mark4) {
      this.removePendingMark(mark4, startIn);
    }
  };
  ParseContext3.prototype.addAll = function addAll2(parent, sync3, startIndex2, endIndex2) {
    var index3 = startIndex2 || 0;
    for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end4 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end4; dom = dom.nextSibling, ++index3) {
      this.findAtPoint(parent, index3);
      this.addDOM(dom);
      if (sync3 && blockTags2.hasOwnProperty(dom.nodeName.toLowerCase())) {
        this.sync(sync3);
      }
    }
    this.findAtPoint(parent, index3);
  };
  ParseContext3.prototype.findPlace = function findPlace2(node5) {
    var route, sync3;
    for (var depth = this.open; depth >= 0; depth--) {
      var cx = this.nodes[depth];
      var found3 = cx.findWrapping(node5);
      if (found3 && (!route || route.length > found3.length)) {
        route = found3;
        sync3 = cx;
        if (!found3.length) {
          break;
        }
      }
      if (cx.solid) {
        break;
      }
    }
    if (!route) {
      return false;
    }
    this.sync(sync3);
    for (var i = 0; i < route.length; i++) {
      this.enterInner(route[i], null, false);
    }
    return true;
  };
  ParseContext3.prototype.insertNode = function insertNode2(node5) {
    if (node5.isInline && this.needsBlock && !this.top.type) {
      var block = this.textblockFromContext();
      if (block) {
        this.enterInner(block);
      }
    }
    if (this.findPlace(node5)) {
      this.closeExtra();
      var top2 = this.top;
      top2.applyPending(node5.type);
      if (top2.match) {
        top2.match = top2.match.matchType(node5.type);
      }
      var marks3 = top2.activeMarks;
      for (var i = 0; i < node5.marks.length; i++) {
        if (!top2.type || top2.type.allowsMarkType(node5.marks[i].type)) {
          marks3 = node5.marks[i].addToSet(marks3);
        }
      }
      top2.content.push(node5.mark(marks3));
      return true;
    }
    return false;
  };
  ParseContext3.prototype.enter = function enter3(type, attrs, preserveWS) {
    var ok3 = this.findPlace(type.create(attrs));
    if (ok3) {
      this.enterInner(type, attrs, true, preserveWS);
    }
    return ok3;
  };
  ParseContext3.prototype.enterInner = function enterInner2(type, attrs, solid, preserveWS) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(type);
    top2.match = top2.match && top2.match.matchType(type, attrs);
    var options = wsOptionsFor2(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT2 && top2.content.length == 0) {
      options |= OPT_OPEN_LEFT2;
    }
    this.nodes.push(new NodeContext3(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
    this.open++;
  };
  ParseContext3.prototype.closeExtra = function closeExtra2(openEnd) {
    var i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--) {
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      }
      this.nodes.length = this.open + 1;
    }
  };
  ParseContext3.prototype.finish = function finish4() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  };
  ParseContext3.prototype.sync = function sync2(to) {
    for (var i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return;
      }
    }
  };
  prototypeAccessors$62.currentPos.get = function() {
    this.closeExtra();
    var pos = 0;
    for (var i = this.open; i >= 0; i--) {
      var content3 = this.nodes[i].content;
      for (var j = content3.length - 1; j >= 0; j--) {
        pos += content3[j].nodeSize;
      }
      if (i) {
        pos++;
      }
    }
    return pos;
  };
  ParseContext3.prototype.findAtPoint = function findAtPoint2(parent, offset4) {
    if (this.find) {
      for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset4) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  };
  ParseContext3.prototype.findInside = function findInside2(parent) {
    if (this.find) {
      for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  };
  ParseContext3.prototype.findAround = function findAround2(parent, content3, before3) {
    if (parent != content3 && this.find) {
      for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          var pos = content3.compareDocumentPosition(this.find[i].node);
          if (pos & (before3 ? 2 : 4)) {
            this.find[i].pos = this.currentPos;
          }
        }
      }
    }
  };
  ParseContext3.prototype.findInText = function findInText2(textNode) {
    if (this.find) {
      for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode) {
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
        }
      }
    }
  };
  ParseContext3.prototype.matchesContext = function matchesContext2(context) {
    var this$1$1 = this;
    if (context.indexOf("|") > -1) {
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    }
    var parts = context.split("/");
    var option = this.options.context;
    var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    var match = function(i, depth) {
      for (; i >= 0; i--) {
        var part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0) {
            continue;
          }
          for (; depth >= minDepth; depth--) {
            if (match(i - 1, depth)) {
              return true;
            }
          }
          return false;
        } else {
          var next = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && next.groups.indexOf(part) == -1) {
            return false;
          }
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  };
  ParseContext3.prototype.textblockFromContext = function textblockFromContext2() {
    var $context = this.options.context;
    if ($context) {
      for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
          return deflt;
        }
      }
    }
    for (var name in this.parser.schema.nodes) {
      var type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs) {
        return type;
      }
    }
  };
  ParseContext3.prototype.addPendingMark = function addPendingMark2(mark4) {
    var found3 = findSameMarkInSet2(mark4, this.top.pendingMarks);
    if (found3) {
      this.top.stashMarks.push(found3);
    }
    this.top.pendingMarks = mark4.addToSet(this.top.pendingMarks);
  };
  ParseContext3.prototype.removePendingMark = function removePendingMark2(mark4, upto) {
    for (var depth = this.open; depth >= 0; depth--) {
      var level = this.nodes[depth];
      var found3 = level.pendingMarks.lastIndexOf(mark4);
      if (found3 > -1) {
        level.pendingMarks = mark4.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark4.removeFromSet(level.activeMarks);
        var stashMark = level.popFromStashMark(mark4);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
          level.activeMarks = stashMark.addToSet(level.activeMarks);
        }
      }
      if (level == upto) {
        break;
      }
    }
  };
  Object.defineProperties(ParseContext3.prototype, prototypeAccessors$62);
  function normalizeList2(dom) {
    for (var child5 = dom.firstChild, prevItem = null; child5; child5 = child5.nextSibling) {
      var name = child5.nodeType == 1 ? child5.nodeName.toLowerCase() : null;
      if (name && listTags2.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child5);
        child5 = prevItem;
      } else if (name == "li") {
        prevItem = child5;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function parseStyles2(style2) {
    var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result2 = [];
    while (m = re.exec(style2)) {
      result2.push(m[1], m[2].trim());
    }
    return result2;
  }
  function markMayApply2(markType, nodeType2) {
    var nodes = nodeType2.schema.nodes;
    var loop = function(name2) {
      var parent = nodes[name2];
      if (!parent.allowsMarkType(markType)) {
        return;
      }
      var seen = [], scan = function(match) {
        seen.push(match);
        for (var i = 0; i < match.edgeCount; i++) {
          var ref = match.edge(i);
          var type = ref.type;
          var next = ref.next;
          if (type == nodeType2) {
            return true;
          }
          if (seen.indexOf(next) < 0 && scan(next)) {
            return true;
          }
        }
      };
      if (scan(parent.contentMatch)) {
        return { v: true };
      }
    };
    for (var name in nodes) {
      var returned = loop(name);
      if (returned)
        return returned.v;
    }
  }
  function findSameMarkInSet2(mark4, set2) {
    for (var i = 0; i < set2.length; i++) {
      if (mark4.eq(set2[i])) {
        return set2[i];
      }
    }
  }
  var lower162 = 65535;
  var factor162 = Math.pow(2, 16);
  function makeRecover2(index3, offset4) {
    return index3 + offset4 * factor162;
  }
  function recoverIndex2(value) {
    return value & lower162;
  }
  function recoverOffset2(value) {
    return (value - (value & lower162)) / factor162;
  }
  var MapResult3 = function MapResult4(pos, deleted, recover3) {
    if (deleted === void 0)
      deleted = false;
    if (recover3 === void 0)
      recover3 = null;
    this.pos = pos;
    this.deleted = deleted;
    this.recover = recover3;
  };
  var StepMap3 = function StepMap4(ranges, inverted) {
    if (inverted === void 0)
      inverted = false;
    this.ranges = ranges;
    this.inverted = inverted;
  };
  StepMap3.prototype.recover = function recover2(value) {
    var diff = 0, index3 = recoverIndex2(value);
    if (!this.inverted) {
      for (var i = 0; i < index3; i++) {
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      }
    }
    return this.ranges[index3 * 3] + diff + recoverOffset2(value);
  };
  StepMap3.prototype.mapResult = function mapResult3(pos, assoc) {
    if (assoc === void 0)
      assoc = 1;
    return this._map(pos, assoc, false);
  };
  StepMap3.prototype.map = function map16(pos, assoc) {
    if (assoc === void 0)
      assoc = 1;
    return this._map(pos, assoc, true);
  };
  StepMap3.prototype._map = function _map3(pos, assoc, simple) {
    var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var i = 0; i < this.ranges.length; i += 3) {
      var start6 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start6 > pos) {
        break;
      }
      var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end4 = start6 + oldSize;
      if (pos <= end4) {
        var side = !oldSize ? assoc : pos == start6 ? -1 : pos == end4 ? 1 : assoc;
        var result2 = start6 + diff + (side < 0 ? 0 : newSize);
        if (simple) {
          return result2;
        }
        var recover3 = pos == (assoc < 0 ? start6 : end4) ? null : makeRecover2(i / 3, pos - start6);
        return new MapResult3(result2, assoc < 0 ? pos != start6 : pos != end4, recover3);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult3(pos + diff);
  };
  StepMap3.prototype.touches = function touches2(pos, recover3) {
    var diff = 0, index3 = recoverIndex2(recover3);
    var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var i = 0; i < this.ranges.length; i += 3) {
      var start6 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start6 > pos) {
        break;
      }
      var oldSize = this.ranges[i + oldIndex], end4 = start6 + oldSize;
      if (pos <= end4 && i == index3 * 3) {
        return true;
      }
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  };
  StepMap3.prototype.forEach = function forEach8(f) {
    var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
      var start6 = this.ranges[i], oldStart = start6 - (this.inverted ? diff : 0), newStart = start6 + (this.inverted ? 0 : diff);
      var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  };
  StepMap3.prototype.invert = function invert4() {
    return new StepMap3(this.ranges, !this.inverted);
  };
  StepMap3.prototype.toString = function toString12() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  };
  StepMap3.offset = function offset3(n) {
    return n == 0 ? StepMap3.empty : new StepMap3(n < 0 ? [0, -n, 0] : [0, 0, n]);
  };
  StepMap3.empty = new StepMap3([]);
  var Mapping3 = function Mapping4(maps, mirror, from5, to) {
    this.maps = maps || [];
    this.from = from5 || 0;
    this.to = to == null ? this.maps.length : to;
    this.mirror = mirror;
  };
  Mapping3.prototype.slice = function slice5(from5, to) {
    if (from5 === void 0)
      from5 = 0;
    if (to === void 0)
      to = this.maps.length;
    return new Mapping3(this.maps, this.mirror, from5, to);
  };
  Mapping3.prototype.copy = function copy6() {
    return new Mapping3(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  };
  Mapping3.prototype.appendMap = function appendMap2(map22, mirrors) {
    this.to = this.maps.push(map22);
    if (mirrors != null) {
      this.setMirror(this.maps.length - 1, mirrors);
    }
  };
  Mapping3.prototype.appendMapping = function appendMapping2(mapping) {
    for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      var mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
    }
  };
  Mapping3.prototype.getMirror = function getMirror2(n) {
    if (this.mirror) {
      for (var i = 0; i < this.mirror.length; i++) {
        if (this.mirror[i] == n) {
          return this.mirror[i + (i % 2 ? -1 : 1)];
        }
      }
    }
  };
  Mapping3.prototype.setMirror = function setMirror2(n, m) {
    if (!this.mirror) {
      this.mirror = [];
    }
    this.mirror.push(n, m);
  };
  Mapping3.prototype.appendMappingInverted = function appendMappingInverted2(mapping) {
    for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      var mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
    }
  };
  Mapping3.prototype.invert = function invert5() {
    var inverse = new Mapping3();
    inverse.appendMappingInverted(this);
    return inverse;
  };
  Mapping3.prototype.map = function map17(pos, assoc) {
    if (assoc === void 0)
      assoc = 1;
    if (this.mirror) {
      return this._map(pos, assoc, true);
    }
    for (var i = this.from; i < this.to; i++) {
      pos = this.maps[i].map(pos, assoc);
    }
    return pos;
  };
  Mapping3.prototype.mapResult = function mapResult4(pos, assoc) {
    if (assoc === void 0)
      assoc = 1;
    return this._map(pos, assoc, false);
  };
  Mapping3.prototype._map = function _map4(pos, assoc, simple) {
    var deleted = false;
    for (var i = this.from; i < this.to; i++) {
      var map22 = this.maps[i], result2 = map22.mapResult(pos, assoc);
      if (result2.recover != null) {
        var corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result2.recover);
          continue;
        }
      }
      if (result2.deleted) {
        deleted = true;
      }
      pos = result2.pos;
    }
    return simple ? pos : new MapResult3(pos, deleted);
  };
  function TransformError2(message) {
    var err3 = Error.call(this, message);
    err3.__proto__ = TransformError2.prototype;
    return err3;
  }
  TransformError2.prototype = Object.create(Error.prototype);
  TransformError2.prototype.constructor = TransformError2;
  TransformError2.prototype.name = "TransformError";
  var Transform3 = function Transform4(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping3();
  };
  var prototypeAccessors$23 = { before: { configurable: true }, docChanged: { configurable: true } };
  prototypeAccessors$23.before.get = function() {
    return this.docs.length ? this.docs[0] : this.doc;
  };
  Transform3.prototype.step = function step2(object) {
    var result2 = this.maybeStep(object);
    if (result2.failed) {
      throw new TransformError2(result2.failed);
    }
    return this;
  };
  Transform3.prototype.maybeStep = function maybeStep2(step3) {
    var result2 = step3.apply(this.doc);
    if (!result2.failed) {
      this.addStep(step3, result2.doc);
    }
    return result2;
  };
  prototypeAccessors$23.docChanged.get = function() {
    return this.steps.length > 0;
  };
  Transform3.prototype.addStep = function addStep2(step3, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step3);
    this.mapping.appendMap(step3.getMap());
    this.doc = doc2;
  };
  Object.defineProperties(Transform3.prototype, prototypeAccessors$23);
  function mustOverride2() {
    throw new Error("Override me");
  }
  var stepsByID2 = /* @__PURE__ */ Object.create(null);
  var Step3 = function Step4() {
  };
  Step3.prototype.apply = function apply9(_doc) {
    return mustOverride2();
  };
  Step3.prototype.getMap = function getMap2() {
    return StepMap3.empty;
  };
  Step3.prototype.invert = function invert6(_doc) {
    return mustOverride2();
  };
  Step3.prototype.map = function map18(_mapping) {
    return mustOverride2();
  };
  Step3.prototype.merge = function merge3(_other) {
    return null;
  };
  Step3.prototype.toJSON = function toJSON11() {
    return mustOverride2();
  };
  Step3.fromJSON = function fromJSON12(schema, json2) {
    if (!json2 || !json2.stepType) {
      throw new RangeError("Invalid input for Step.fromJSON");
    }
    var type = stepsByID2[json2.stepType];
    if (!type) {
      throw new RangeError("No step type " + json2.stepType + " defined");
    }
    return type.fromJSON(schema, json2);
  };
  Step3.jsonID = function jsonID3(id, stepClass) {
    if (id in stepsByID2) {
      throw new RangeError("Duplicate use of step JSON ID " + id);
    }
    stepsByID2[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  };
  var StepResult3 = function StepResult4(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  };
  StepResult3.ok = function ok2(doc2) {
    return new StepResult3(doc2, null);
  };
  StepResult3.fail = function fail2(message) {
    return new StepResult3(null, message);
  };
  StepResult3.fromReplace = function fromReplace2(doc2, from5, to, slice6) {
    try {
      return StepResult3.ok(doc2.replace(from5, to, slice6));
    } catch (e) {
      if (e instanceof ReplaceError2) {
        return StepResult3.fail(e.message);
      }
      throw e;
    }
  };
  var ReplaceStep2 = /* @__PURE__ */ function(Step5) {
    function ReplaceStep3(from5, to, slice6, structure) {
      Step5.call(this);
      this.from = from5;
      this.to = to;
      this.slice = slice6;
      this.structure = !!structure;
    }
    if (Step5)
      ReplaceStep3.__proto__ = Step5;
    ReplaceStep3.prototype = Object.create(Step5 && Step5.prototype);
    ReplaceStep3.prototype.constructor = ReplaceStep3;
    ReplaceStep3.prototype.apply = function apply15(doc2) {
      if (this.structure && contentBetween2(doc2, this.from, this.to)) {
        return StepResult3.fail("Structure replace would overwrite content");
      }
      return StepResult3.fromReplace(doc2, this.from, this.to, this.slice);
    };
    ReplaceStep3.prototype.getMap = function getMap3() {
      return new StepMap3([this.from, this.to - this.from, this.slice.size]);
    };
    ReplaceStep3.prototype.invert = function invert7(doc2) {
      return new ReplaceStep3(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
    };
    ReplaceStep3.prototype.map = function map22(mapping) {
      var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from5.deleted && to.deleted) {
        return null;
      }
      return new ReplaceStep3(from5.pos, Math.max(from5.pos, to.pos), this.slice);
    };
    ReplaceStep3.prototype.merge = function merge4(other) {
      if (!(other instanceof ReplaceStep3) || other.structure || this.structure) {
        return null;
      }
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        var slice6 = this.slice.size + other.slice.size == 0 ? Slice3.empty : new Slice3(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep3(this.from, this.to + (other.to - other.from), slice6, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        var slice$1 = this.slice.size + other.slice.size == 0 ? Slice3.empty : new Slice3(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new ReplaceStep3(other.from, this.to, slice$1, this.structure);
      } else {
        return null;
      }
    };
    ReplaceStep3.prototype.toJSON = function toJSON13() {
      var json2 = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size) {
        json2.slice = this.slice.toJSON();
      }
      if (this.structure) {
        json2.structure = true;
      }
      return json2;
    };
    ReplaceStep3.fromJSON = function fromJSON15(schema, json2) {
      if (typeof json2.from != "number" || typeof json2.to != "number") {
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      }
      return new ReplaceStep3(json2.from, json2.to, Slice3.fromJSON(schema, json2.slice), !!json2.structure);
    };
    return ReplaceStep3;
  }(Step3);
  Step3.jsonID("replace", ReplaceStep2);
  var ReplaceAroundStep2 = /* @__PURE__ */ function(Step5) {
    function ReplaceAroundStep3(from5, to, gapFrom, gapTo, slice6, insert, structure) {
      Step5.call(this);
      this.from = from5;
      this.to = to;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice6;
      this.insert = insert;
      this.structure = !!structure;
    }
    if (Step5)
      ReplaceAroundStep3.__proto__ = Step5;
    ReplaceAroundStep3.prototype = Object.create(Step5 && Step5.prototype);
    ReplaceAroundStep3.prototype.constructor = ReplaceAroundStep3;
    ReplaceAroundStep3.prototype.apply = function apply15(doc2) {
      if (this.structure && (contentBetween2(doc2, this.from, this.gapFrom) || contentBetween2(doc2, this.gapTo, this.to))) {
        return StepResult3.fail("Structure gap-replace would overwrite content");
      }
      var gap = doc2.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd) {
        return StepResult3.fail("Gap is not a flat range");
      }
      var inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted) {
        return StepResult3.fail("Content does not fit in gap");
      }
      return StepResult3.fromReplace(doc2, this.from, this.to, inserted);
    };
    ReplaceAroundStep3.prototype.getMap = function getMap3() {
      return new StepMap3([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    };
    ReplaceAroundStep3.prototype.invert = function invert7(doc2) {
      var gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep3(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    };
    ReplaceAroundStep3.prototype.map = function map22(mapping) {
      var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
      if (from5.deleted && to.deleted || gapFrom < from5.pos || gapTo > to.pos) {
        return null;
      }
      return new ReplaceAroundStep3(from5.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    };
    ReplaceAroundStep3.prototype.toJSON = function toJSON13() {
      var json2 = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size) {
        json2.slice = this.slice.toJSON();
      }
      if (this.structure) {
        json2.structure = true;
      }
      return json2;
    };
    ReplaceAroundStep3.fromJSON = function fromJSON15(schema, json2) {
      if (typeof json2.from != "number" || typeof json2.to != "number" || typeof json2.gapFrom != "number" || typeof json2.gapTo != "number" || typeof json2.insert != "number") {
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      }
      return new ReplaceAroundStep3(json2.from, json2.to, json2.gapFrom, json2.gapTo, Slice3.fromJSON(schema, json2.slice), json2.insert, !!json2.structure);
    };
    return ReplaceAroundStep3;
  }(Step3);
  Step3.jsonID("replaceAround", ReplaceAroundStep2);
  function contentBetween2(doc2, from5, to) {
    var $from = doc2.resolve(from5), dist = to - from5, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      var next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf) {
          return true;
        }
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  Transform3.prototype.lift = function(range, target) {
    var $from = range.$from;
    var $to = range.$to;
    var depth = range.depth;
    var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    var start6 = gapStart, end4 = gapEnd;
    var before3 = Fragment3.empty, openStart = 0;
    for (var d = depth, splitting = false; d > target; d--) {
      if (splitting || $from.index(d) > 0) {
        splitting = true;
        before3 = Fragment3.from($from.node(d).copy(before3));
        openStart++;
      } else {
        start6--;
      }
    }
    var after3 = Fragment3.empty, openEnd = 0;
    for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
      if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
        splitting$1 = true;
        after3 = Fragment3.from($to.node(d$1).copy(after3));
        openEnd++;
      } else {
        end4++;
      }
    }
    return this.step(new ReplaceAroundStep2(start6, end4, gapStart, gapEnd, new Slice3(before3.append(after3), openStart, openEnd), before3.size - openStart, true));
  };
  Transform3.prototype.wrap = function(range, wrappers) {
    var content3 = Fragment3.empty;
    for (var i = wrappers.length - 1; i >= 0; i--) {
      content3 = Fragment3.from(wrappers[i].type.create(wrappers[i].attrs, content3));
    }
    var start6 = range.start, end4 = range.end;
    return this.step(new ReplaceAroundStep2(start6, end4, start6, end4, new Slice3(content3, 0, 0), wrappers.length, true));
  };
  Transform3.prototype.setBlockType = function(from5, to, type, attrs) {
    var this$1$1 = this;
    if (to === void 0)
      to = from5;
    if (!type.isTextblock) {
      throw new RangeError("Type given to setBlockType should be a textblock");
    }
    var mapFrom = this.steps.length;
    this.doc.nodesBetween(from5, to, function(node5, pos) {
      if (node5.isTextblock && !node5.hasMarkup(type, attrs) && canChangeType2(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type)) {
        this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type);
        var mapping = this$1$1.mapping.slice(mapFrom);
        var startM = mapping.map(pos, 1), endM = mapping.map(pos + node5.nodeSize, 1);
        this$1$1.step(new ReplaceAroundStep2(startM, endM, startM + 1, endM - 1, new Slice3(Fragment3.from(type.create(attrs, null, node5.marks)), 0, 0), 1, true));
        return false;
      }
    });
    return this;
  };
  function canChangeType2(doc2, pos, type) {
    var $pos = doc2.resolve(pos), index3 = $pos.index();
    return $pos.parent.canReplaceWith(index3, index3 + 1, type);
  }
  Transform3.prototype.setNodeMarkup = function(pos, type, attrs, marks3) {
    var node5 = this.doc.nodeAt(pos);
    if (!node5) {
      throw new RangeError("No node at given position");
    }
    if (!type) {
      type = node5.type;
    }
    var newNode = type.create(attrs, null, marks3 || node5.marks);
    if (node5.isLeaf) {
      return this.replaceWith(pos, pos + node5.nodeSize, newNode);
    }
    if (!type.validContent(node5.content)) {
      throw new RangeError("Invalid content for node type " + type.name);
    }
    return this.step(new ReplaceAroundStep2(pos, pos + node5.nodeSize, pos + 1, pos + node5.nodeSize - 1, new Slice3(Fragment3.from(newNode), 0, 0), 1, true));
  };
  Transform3.prototype.split = function(pos, depth, typesAfter) {
    if (depth === void 0)
      depth = 1;
    var $pos = this.doc.resolve(pos), before3 = Fragment3.empty, after3 = Fragment3.empty;
    for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
      before3 = Fragment3.from($pos.node(d).copy(before3));
      var typeAfter = typesAfter && typesAfter[i];
      after3 = Fragment3.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after3) : $pos.node(d).copy(after3));
    }
    return this.step(new ReplaceStep2(pos, pos, new Slice3(before3.append(after3), depth, depth), true));
  };
  Transform3.prototype.join = function(pos, depth) {
    if (depth === void 0)
      depth = 1;
    var step3 = new ReplaceStep2(pos - depth, pos + depth, Slice3.empty, true);
    return this.step(step3);
  };
  function insertPoint2(doc2, pos, nodeType2) {
    var $pos = doc2.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
      return pos;
    }
    if ($pos.parentOffset == 0) {
      for (var d = $pos.depth - 1; d >= 0; d--) {
        var index3 = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index3, index3, nodeType2)) {
          return $pos.before(d + 1);
        }
        if (index3 > 0) {
          return null;
        }
      }
    }
    if ($pos.parentOffset == $pos.parent.content.size) {
      for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
        var index$1 = $pos.indexAfter(d$1);
        if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
          return $pos.after(d$1 + 1);
        }
        if (index$1 < $pos.node(d$1).childCount) {
          return null;
        }
      }
    }
  }
  function mapFragment2(fragment, f, parent) {
    var mapped = [];
    for (var i = 0; i < fragment.childCount; i++) {
      var child5 = fragment.child(i);
      if (child5.content.size) {
        child5 = child5.copy(mapFragment2(child5.content, f, child5));
      }
      if (child5.isInline) {
        child5 = f(child5, parent, i);
      }
      mapped.push(child5);
    }
    return Fragment3.fromArray(mapped);
  }
  var AddMarkStep2 = /* @__PURE__ */ function(Step5) {
    function AddMarkStep3(from5, to, mark4) {
      Step5.call(this);
      this.from = from5;
      this.to = to;
      this.mark = mark4;
    }
    if (Step5)
      AddMarkStep3.__proto__ = Step5;
    AddMarkStep3.prototype = Object.create(Step5 && Step5.prototype);
    AddMarkStep3.prototype.constructor = AddMarkStep3;
    AddMarkStep3.prototype.apply = function apply15(doc2) {
      var this$1$1 = this;
      var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
      var parent = $from.node($from.sharedDepth(this.to));
      var slice6 = new Slice3(mapFragment2(oldSlice.content, function(node5, parent2) {
        if (!node5.isAtom || !parent2.type.allowsMarkType(this$1$1.mark.type)) {
          return node5;
        }
        return node5.mark(this$1$1.mark.addToSet(node5.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult3.fromReplace(doc2, this.from, this.to, slice6);
    };
    AddMarkStep3.prototype.invert = function invert7() {
      return new RemoveMarkStep2(this.from, this.to, this.mark);
    };
    AddMarkStep3.prototype.map = function map22(mapping) {
      var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from5.deleted && to.deleted || from5.pos >= to.pos) {
        return null;
      }
      return new AddMarkStep3(from5.pos, to.pos, this.mark);
    };
    AddMarkStep3.prototype.merge = function merge4(other) {
      if (other instanceof AddMarkStep3 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
        return new AddMarkStep3(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      }
    };
    AddMarkStep3.prototype.toJSON = function toJSON13() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    };
    AddMarkStep3.fromJSON = function fromJSON15(schema, json2) {
      if (typeof json2.from != "number" || typeof json2.to != "number") {
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      }
      return new AddMarkStep3(json2.from, json2.to, schema.markFromJSON(json2.mark));
    };
    return AddMarkStep3;
  }(Step3);
  Step3.jsonID("addMark", AddMarkStep2);
  var RemoveMarkStep2 = /* @__PURE__ */ function(Step5) {
    function RemoveMarkStep3(from5, to, mark4) {
      Step5.call(this);
      this.from = from5;
      this.to = to;
      this.mark = mark4;
    }
    if (Step5)
      RemoveMarkStep3.__proto__ = Step5;
    RemoveMarkStep3.prototype = Object.create(Step5 && Step5.prototype);
    RemoveMarkStep3.prototype.constructor = RemoveMarkStep3;
    RemoveMarkStep3.prototype.apply = function apply15(doc2) {
      var this$1$1 = this;
      var oldSlice = doc2.slice(this.from, this.to);
      var slice6 = new Slice3(mapFragment2(oldSlice.content, function(node5) {
        return node5.mark(this$1$1.mark.removeFromSet(node5.marks));
      }), oldSlice.openStart, oldSlice.openEnd);
      return StepResult3.fromReplace(doc2, this.from, this.to, slice6);
    };
    RemoveMarkStep3.prototype.invert = function invert7() {
      return new AddMarkStep2(this.from, this.to, this.mark);
    };
    RemoveMarkStep3.prototype.map = function map22(mapping) {
      var from5 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from5.deleted && to.deleted || from5.pos >= to.pos) {
        return null;
      }
      return new RemoveMarkStep3(from5.pos, to.pos, this.mark);
    };
    RemoveMarkStep3.prototype.merge = function merge4(other) {
      if (other instanceof RemoveMarkStep3 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
        return new RemoveMarkStep3(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      }
    };
    RemoveMarkStep3.prototype.toJSON = function toJSON13() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    };
    RemoveMarkStep3.fromJSON = function fromJSON15(schema, json2) {
      if (typeof json2.from != "number" || typeof json2.to != "number") {
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      }
      return new RemoveMarkStep3(json2.from, json2.to, schema.markFromJSON(json2.mark));
    };
    return RemoveMarkStep3;
  }(Step3);
  Step3.jsonID("removeMark", RemoveMarkStep2);
  Transform3.prototype.addMark = function(from5, to, mark4) {
    var this$1$1 = this;
    var removed = [], added = [], removing = null, adding = null;
    this.doc.nodesBetween(from5, to, function(node5, pos, parent) {
      if (!node5.isInline) {
        return;
      }
      var marks3 = node5.marks;
      if (!mark4.isInSet(marks3) && parent.type.allowsMarkType(mark4.type)) {
        var start6 = Math.max(pos, from5), end4 = Math.min(pos + node5.nodeSize, to);
        var newSet = mark4.addToSet(marks3);
        for (var i = 0; i < marks3.length; i++) {
          if (!marks3[i].isInSet(newSet)) {
            if (removing && removing.to == start6 && removing.mark.eq(marks3[i])) {
              removing.to = end4;
            } else {
              removed.push(removing = new RemoveMarkStep2(start6, end4, marks3[i]));
            }
          }
        }
        if (adding && adding.to == start6) {
          adding.to = end4;
        } else {
          added.push(adding = new AddMarkStep2(start6, end4, mark4));
        }
      }
    });
    removed.forEach(function(s) {
      return this$1$1.step(s);
    });
    added.forEach(function(s) {
      return this$1$1.step(s);
    });
    return this;
  };
  Transform3.prototype.removeMark = function(from5, to, mark4) {
    var this$1$1 = this;
    if (mark4 === void 0)
      mark4 = null;
    var matched = [], step3 = 0;
    this.doc.nodesBetween(from5, to, function(node5, pos) {
      if (!node5.isInline) {
        return;
      }
      step3++;
      var toRemove = null;
      if (mark4 instanceof MarkType3) {
        var set2 = node5.marks, found3;
        while (found3 = mark4.isInSet(set2)) {
          (toRemove || (toRemove = [])).push(found3);
          set2 = found3.removeFromSet(set2);
        }
      } else if (mark4) {
        if (mark4.isInSet(node5.marks)) {
          toRemove = [mark4];
        }
      } else {
        toRemove = node5.marks;
      }
      if (toRemove && toRemove.length) {
        var end4 = Math.min(pos + node5.nodeSize, to);
        for (var i = 0; i < toRemove.length; i++) {
          var style2 = toRemove[i], found$1 = void 0;
          for (var j = 0; j < matched.length; j++) {
            var m = matched[j];
            if (m.step == step3 - 1 && style2.eq(matched[j].style)) {
              found$1 = m;
            }
          }
          if (found$1) {
            found$1.to = end4;
            found$1.step = step3;
          } else {
            matched.push({ style: style2, from: Math.max(pos, from5), to: end4, step: step3 });
          }
        }
      }
    });
    matched.forEach(function(m) {
      return this$1$1.step(new RemoveMarkStep2(m.from, m.to, m.style));
    });
    return this;
  };
  Transform3.prototype.clearIncompatible = function(pos, parentType, match) {
    if (match === void 0)
      match = parentType.contentMatch;
    var node5 = this.doc.nodeAt(pos);
    var delSteps = [], cur = pos + 1;
    for (var i = 0; i < node5.childCount; i++) {
      var child5 = node5.child(i), end4 = cur + child5.nodeSize;
      var allowed = match.matchType(child5.type, child5.attrs);
      if (!allowed) {
        delSteps.push(new ReplaceStep2(cur, end4, Slice3.empty));
      } else {
        match = allowed;
        for (var j = 0; j < child5.marks.length; j++) {
          if (!parentType.allowsMarkType(child5.marks[j].type)) {
            this.step(new RemoveMarkStep2(cur, end4, child5.marks[j]));
          }
        }
      }
      cur = end4;
    }
    if (!match.validEnd) {
      var fill = match.fillBefore(Fragment3.empty, true);
      this.replace(cur, cur, new Slice3(fill, 0, 0));
    }
    for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
      this.step(delSteps[i$1]);
    }
    return this;
  };
  function replaceStep2(doc2, from5, to, slice6) {
    if (to === void 0)
      to = from5;
    if (slice6 === void 0)
      slice6 = Slice3.empty;
    if (from5 == to && !slice6.size) {
      return null;
    }
    var $from = doc2.resolve(from5), $to = doc2.resolve(to);
    if (fitsTrivially2($from, $to, slice6)) {
      return new ReplaceStep2(from5, to, slice6);
    }
    return new Fitter3($from, $to, slice6).fit();
  }
  Transform3.prototype.replace = function(from5, to, slice6) {
    if (to === void 0)
      to = from5;
    if (slice6 === void 0)
      slice6 = Slice3.empty;
    var step3 = replaceStep2(this.doc, from5, to, slice6);
    if (step3) {
      this.step(step3);
    }
    return this;
  };
  Transform3.prototype.replaceWith = function(from5, to, content3) {
    return this.replace(from5, to, new Slice3(Fragment3.from(content3), 0, 0));
  };
  Transform3.prototype.delete = function(from5, to) {
    return this.replace(from5, to, Slice3.empty);
  };
  Transform3.prototype.insert = function(pos, content3) {
    return this.replaceWith(pos, pos, content3);
  };
  function fitsTrivially2($from, $to, slice6) {
    return !slice6.openStart && !slice6.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice6.content);
  }
  var Fitter3 = function Fitter4($from, $to, slice6) {
    this.$to = $to;
    this.$from = $from;
    this.unplaced = slice6;
    this.frontier = [];
    for (var i = 0; i <= $from.depth; i++) {
      var node5 = $from.node(i);
      this.frontier.push({
        type: node5.type,
        match: node5.contentMatchAt($from.indexAfter(i))
      });
    }
    this.placed = Fragment3.empty;
    for (var i$1 = $from.depth; i$1 > 0; i$1--) {
      this.placed = Fragment3.from($from.node(i$1).copy(this.placed));
    }
  };
  var prototypeAccessors$1$12 = { depth: { configurable: true } };
  prototypeAccessors$1$12.depth.get = function() {
    return this.frontier.length - 1;
  };
  Fitter3.prototype.fit = function fit2() {
    while (this.unplaced.size) {
      var fit3 = this.findFittable();
      if (fit3) {
        this.placeNodes(fit3);
      } else {
        this.openMore() || this.dropNode();
      }
    }
    var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to) {
      return null;
    }
    var content3 = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content3.childCount == 1) {
      content3 = content3.firstChild.content;
      openStart--;
      openEnd--;
    }
    var slice6 = new Slice3(content3, openStart, openEnd);
    if (moveInline > -1) {
      return new ReplaceAroundStep2($from.pos, moveInline, this.$to.pos, this.$to.end(), slice6, placedSize);
    }
    if (slice6.size || $from.pos != this.$to.pos) {
      return new ReplaceStep2($from.pos, $to.pos, slice6);
    }
  };
  Fitter3.prototype.findFittable = function findFittable2() {
    for (var pass = 1; pass <= 2; pass++) {
      for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        var fragment = void 0, parent = void 0;
        if (sliceDepth) {
          parent = contentAt2(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        var first2 = fragment.firstChild;
        for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          var ref = this.frontier[frontierDepth];
          var type = ref.type;
          var match = ref.match;
          var wrap = void 0, inject = void 0;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment3.from(first2), false)) : type.compatibleContent(parent.type))) {
            return { sliceDepth, frontierDepth, parent, inject };
          } else if (pass == 2 && first2 && (wrap = match.findWrapping(first2.type))) {
            return { sliceDepth, frontierDepth, parent, wrap };
          }
          if (parent && match.matchType(parent.type)) {
            break;
          }
        }
      }
    }
  };
  Fitter3.prototype.openMore = function openMore2() {
    var ref = this.unplaced;
    var content3 = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
    var inner = contentAt2(content3, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf) {
      return false;
    }
    this.unplaced = new Slice3(content3, openStart + 1, Math.max(openEnd, inner.size + openStart >= content3.size - openEnd ? openStart + 1 : 0));
    return true;
  };
  Fitter3.prototype.dropNode = function dropNode2() {
    var ref = this.unplaced;
    var content3 = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
    var inner = contentAt2(content3, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      var openAtEnd = content3.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice3(dropFromFragment2(content3, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice3(dropFromFragment2(content3, openStart, 1), openStart, openEnd);
    }
  };
  Fitter3.prototype.placeNodes = function placeNodes2(ref) {
    var sliceDepth = ref.sliceDepth;
    var frontierDepth = ref.frontierDepth;
    var parent = ref.parent;
    var inject = ref.inject;
    var wrap = ref.wrap;
    while (this.depth > frontierDepth) {
      this.closeFrontierNode();
    }
    if (wrap) {
      for (var i = 0; i < wrap.length; i++) {
        this.openFrontierNode(wrap[i]);
      }
    }
    var slice6 = this.unplaced, fragment = parent ? parent.content : slice6.content;
    var openStart = slice6.openStart - sliceDepth;
    var taken = 0, add3 = [];
    var ref$1 = this.frontier[frontierDepth];
    var match = ref$1.match;
    var type = ref$1.type;
    if (inject) {
      for (var i$1 = 0; i$1 < inject.childCount; i$1++) {
        add3.push(inject.child(i$1));
      }
      match = match.matchFragment(inject);
    }
    var openEndCount = fragment.size + sliceDepth - (slice6.content.size - slice6.openEnd);
    while (taken < fragment.childCount) {
      var next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2) {
        break;
      }
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add3.push(closeNodeStart2(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    var toEnd = taken == fragment.childCount;
    if (!toEnd) {
      openEndCount = -1;
    }
    this.placed = addToFragment2(this.placed, frontierDepth, Fragment3.from(add3));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
      this.closeFrontierNode();
    }
    for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
      var node5 = cur.lastChild;
      this.frontier.push({ type: node5.type, match: node5.contentMatchAt(node5.childCount) });
      cur = node5.content;
    }
    this.unplaced = !toEnd ? new Slice3(dropFromFragment2(slice6.content, sliceDepth, taken), slice6.openStart, slice6.openEnd) : sliceDepth == 0 ? Slice3.empty : new Slice3(dropFromFragment2(slice6.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice6.openEnd : sliceDepth - 1);
  };
  Fitter3.prototype.mustMoveInline = function mustMoveInline2() {
    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
      return -1;
    }
    var top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits2(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
      return -1;
    }
    var ref = this.$to;
    var depth = ref.depth;
    var after3 = this.$to.after(depth);
    while (depth > 1 && after3 == this.$to.end(--depth)) {
      ++after3;
    }
    return after3;
  };
  Fitter3.prototype.findCloseLevel = function findCloseLevel2($to) {
    scan:
      for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        var ref = this.frontier[i];
        var match = ref.match;
        var type = ref.type;
        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        var fit3 = contentAfterFits2($to, i, type, match, dropInner);
        if (!fit3) {
          continue;
        }
        for (var d = i - 1; d >= 0; d--) {
          var ref$1 = this.frontier[d];
          var match$1 = ref$1.match;
          var type$1 = ref$1.type;
          var matches2 = contentAfterFits2($to, d, type$1, match$1, true);
          if (!matches2 || matches2.childCount) {
            continue scan;
          }
        }
        return { depth: i, fit: fit3, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  };
  Fitter3.prototype.close = function close4($to) {
    var close6 = this.findCloseLevel($to);
    if (!close6) {
      return null;
    }
    while (this.depth > close6.depth) {
      this.closeFrontierNode();
    }
    if (close6.fit.childCount) {
      this.placed = addToFragment2(this.placed, close6.depth, close6.fit);
    }
    $to = close6.move;
    for (var d = close6.depth + 1; d <= $to.depth; d++) {
      var node5 = $to.node(d), add3 = node5.type.contentMatch.fillBefore(node5.content, true, $to.index(d));
      this.openFrontierNode(node5.type, node5.attrs, add3);
    }
    return $to;
  };
  Fitter3.prototype.openFrontierNode = function openFrontierNode2(type, attrs, content3) {
    var top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment2(this.placed, this.depth, Fragment3.from(type.create(attrs, content3)));
    this.frontier.push({ type, match: type.contentMatch });
  };
  Fitter3.prototype.closeFrontierNode = function closeFrontierNode2() {
    var open2 = this.frontier.pop();
    var add3 = open2.match.fillBefore(Fragment3.empty, true);
    if (add3.childCount) {
      this.placed = addToFragment2(this.placed, this.frontier.length, add3);
    }
  };
  Object.defineProperties(Fitter3.prototype, prototypeAccessors$1$12);
  function dropFromFragment2(fragment, depth, count) {
    if (depth == 0) {
      return fragment.cutByIndex(count);
    }
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment2(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment2(fragment, depth, content3) {
    if (depth == 0) {
      return fragment.append(content3);
    }
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment2(fragment.lastChild.content, depth - 1, content3)));
  }
  function contentAt2(fragment, depth) {
    for (var i = 0; i < depth; i++) {
      fragment = fragment.firstChild.content;
    }
    return fragment;
  }
  function closeNodeStart2(node5, openStart, openEnd) {
    if (openStart <= 0) {
      return node5;
    }
    var frag = node5.content;
    if (openStart > 1) {
      frag = frag.replaceChild(0, closeNodeStart2(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    }
    if (openStart > 0) {
      frag = node5.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0) {
        frag = frag.append(node5.type.contentMatch.matchFragment(frag).fillBefore(Fragment3.empty, true));
      }
    }
    return node5.copy(frag);
  }
  function contentAfterFits2($to, depth, type, match, open2) {
    var node5 = $to.node(depth), index3 = open2 ? $to.indexAfter(depth) : $to.index(depth);
    if (index3 == node5.childCount && !type.compatibleContent(node5.type)) {
      return null;
    }
    var fit3 = match.fillBefore(node5.content, true, index3);
    return fit3 && !invalidMarks2(type, node5.content, index3) ? fit3 : null;
  }
  function invalidMarks2(type, fragment, start6) {
    for (var i = start6; i < fragment.childCount; i++) {
      if (!type.allowsMarks(fragment.child(i).marks)) {
        return true;
      }
    }
    return false;
  }
  Transform3.prototype.replaceRange = function(from5, to, slice6) {
    if (!slice6.size) {
      return this.deleteRange(from5, to);
    }
    var $from = this.doc.resolve(from5), $to = this.doc.resolve(to);
    if (fitsTrivially2($from, $to, slice6)) {
      return this.step(new ReplaceStep2(from5, to, slice6));
    }
    var targetDepths = coveredDepths2($from, this.doc.resolve(to));
    if (targetDepths[targetDepths.length - 1] == 0) {
      targetDepths.pop();
    }
    var preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      var spec = $from.node(d).type.spec;
      if (spec.defining || spec.isolating) {
        break;
      }
      if (targetDepths.indexOf(d) > -1) {
        preferredTarget = d;
      } else if ($from.before(d) == pos) {
        targetDepths.splice(1, 0, -d);
      }
    }
    var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    var leftNodes = [], preferredDepth = slice6.openStart;
    for (var content3 = slice6.content, i = 0; ; i++) {
      var node5 = content3.firstChild;
      leftNodes.push(node5);
      if (i == slice6.openStart) {
        break;
      }
      content3 = node5.content;
    }
    if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
      preferredDepth -= 1;
    } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
      preferredDepth -= 2;
    }
    for (var j = slice6.openStart; j >= 0; j--) {
      var openDepth = (j + preferredDepth + 1) % (slice6.openStart + 1);
      var insert = leftNodes[openDepth];
      if (!insert) {
        continue;
      }
      for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
        var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        var parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index3, index3, insert.type, insert.marks)) {
          return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice3(closeFragment2(slice6.content, 0, slice6.openStart, openDepth), openDepth, slice6.openEnd));
        }
      }
    }
    var startSteps = this.steps.length;
    for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
      this.replace(from5, to, slice6);
      if (this.steps.length > startSteps) {
        break;
      }
      var depth = targetDepths[i$2];
      if (depth < 0) {
        continue;
      }
      from5 = $from.before(depth);
      to = $to.after(depth);
    }
    return this;
  };
  function closeFragment2(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      var first2 = fragment.firstChild;
      fragment = fragment.replaceChild(0, first2.copy(closeFragment2(first2.content, depth + 1, oldOpen, newOpen, first2)));
    }
    if (depth > newOpen) {
      var match = parent.contentMatchAt(0);
      var start6 = match.fillBefore(fragment).append(fragment);
      fragment = start6.append(match.matchFragment(start6).fillBefore(Fragment3.empty, true));
    }
    return fragment;
  }
  Transform3.prototype.replaceRangeWith = function(from5, to, node5) {
    if (!node5.isInline && from5 == to && this.doc.resolve(from5).parent.content.size) {
      var point = insertPoint2(this.doc, from5, node5.type);
      if (point != null) {
        from5 = to = point;
      }
    }
    return this.replaceRange(from5, to, new Slice3(Fragment3.from(node5), 0, 0));
  };
  Transform3.prototype.deleteRange = function(from5, to) {
    var $from = this.doc.resolve(from5), $to = this.doc.resolve(to);
    var covered = coveredDepths2($from, $to);
    for (var i = 0; i < covered.length; i++) {
      var depth = covered[i], last = i == covered.length - 1;
      if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
        return this.delete($from.start(depth), $to.end(depth));
      }
      if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
        return this.delete($from.before(depth), $to.after(depth));
      }
    }
    for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from5 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {
        return this.delete($from.before(d), to);
      }
    }
    return this.delete(from5, to);
  };
  function coveredDepths2($from, $to) {
    var result2 = [], minDepth = Math.min($from.depth, $to.depth);
    for (var d = minDepth; d >= 0; d--) {
      var start6 = $from.start(d);
      if (start6 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
        break;
      }
      if (start6 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start6 - 1) {
        result2.push(d);
      }
    }
    return result2;
  }
  var classesById2 = /* @__PURE__ */ Object.create(null);
  var Selection3 = function Selection4($anchor, $head, ranges) {
    this.ranges = ranges || [new SelectionRange3($anchor.min($head), $anchor.max($head))];
    this.$anchor = $anchor;
    this.$head = $head;
  };
  var prototypeAccessors5 = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
  prototypeAccessors5.anchor.get = function() {
    return this.$anchor.pos;
  };
  prototypeAccessors5.head.get = function() {
    return this.$head.pos;
  };
  prototypeAccessors5.from.get = function() {
    return this.$from.pos;
  };
  prototypeAccessors5.to.get = function() {
    return this.$to.pos;
  };
  prototypeAccessors5.$from.get = function() {
    return this.ranges[0].$from;
  };
  prototypeAccessors5.$to.get = function() {
    return this.ranges[0].$to;
  };
  prototypeAccessors5.empty.get = function() {
    var ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      if (ranges[i].$from.pos != ranges[i].$to.pos) {
        return false;
      }
    }
    return true;
  };
  Selection3.prototype.content = function content2() {
    return this.$from.node(0).slice(this.from, this.to, true);
  };
  Selection3.prototype.replace = function replace4(tr, content3) {
    if (content3 === void 0)
      content3 = Slice3.empty;
    var lastNode = content3.content.lastChild, lastParent = null;
    for (var i = 0; i < content3.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    var mapFrom = tr.steps.length, ranges = this.ranges;
    for (var i$1 = 0; i$1 < ranges.length; i$1++) {
      var ref = ranges[i$1];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice3.empty : content3);
      if (i$1 == 0) {
        selectionToInsertionEnd3(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
  };
  Selection3.prototype.replaceWith = function replaceWith2(tr, node5) {
    var mapFrom = tr.steps.length, ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      var ref = ranges[i];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
      var from5 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from5, to);
      } else {
        tr.replaceRangeWith(from5, to, node5);
        selectionToInsertionEnd3(tr, mapFrom, node5.isInline ? -1 : 1);
      }
    }
  };
  Selection3.findFrom = function findFrom2($pos, dir, textOnly) {
    var inner = $pos.parent.inlineContent ? new TextSelection2($pos) : findSelectionIn2($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner) {
      return inner;
    }
    for (var depth = $pos.depth - 1; depth >= 0; depth--) {
      var found3 = dir < 0 ? findSelectionIn2($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn2($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found3) {
        return found3;
      }
    }
  };
  Selection3.near = function near2($pos, bias) {
    if (bias === void 0)
      bias = 1;
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection2($pos.node(0));
  };
  Selection3.atStart = function atStart2(doc2) {
    return findSelectionIn2(doc2, doc2, 0, 0, 1) || new AllSelection2(doc2);
  };
  Selection3.atEnd = function atEnd2(doc2) {
    return findSelectionIn2(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection2(doc2);
  };
  Selection3.fromJSON = function fromJSON13(doc2, json2) {
    if (!json2 || !json2.type) {
      throw new RangeError("Invalid input for Selection.fromJSON");
    }
    var cls = classesById2[json2.type];
    if (!cls) {
      throw new RangeError("No selection type " + json2.type + " defined");
    }
    return cls.fromJSON(doc2, json2);
  };
  Selection3.jsonID = function jsonID4(id, selectionClass) {
    if (id in classesById2) {
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    }
    classesById2[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  };
  Selection3.prototype.getBookmark = function getBookmark2() {
    return TextSelection2.between(this.$anchor, this.$head).getBookmark();
  };
  Object.defineProperties(Selection3.prototype, prototypeAccessors5);
  Selection3.prototype.visible = true;
  var SelectionRange3 = function SelectionRange4($from, $to) {
    this.$from = $from;
    this.$to = $to;
  };
  var TextSelection2 = /* @__PURE__ */ function(Selection5) {
    function TextSelection3($anchor, $head) {
      if ($head === void 0)
        $head = $anchor;
      Selection5.call(this, $anchor, $head);
    }
    if (Selection5)
      TextSelection3.__proto__ = Selection5;
    TextSelection3.prototype = Object.create(Selection5 && Selection5.prototype);
    TextSelection3.prototype.constructor = TextSelection3;
    var prototypeAccessors$16 = { $cursor: { configurable: true } };
    prototypeAccessors$16.$cursor.get = function() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    };
    TextSelection3.prototype.map = function map22(doc2, mapping) {
      var $head = doc2.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent) {
        return Selection5.near($head);
      }
      var $anchor = doc2.resolve(mapping.map(this.anchor));
      return new TextSelection3($anchor.parent.inlineContent ? $anchor : $head, $head);
    };
    TextSelection3.prototype.replace = function replace5(tr, content3) {
      if (content3 === void 0)
        content3 = Slice3.empty;
      Selection5.prototype.replace.call(this, tr, content3);
      if (content3 == Slice3.empty) {
        var marks3 = this.$from.marksAcross(this.$to);
        if (marks3) {
          tr.ensureMarks(marks3);
        }
      }
    };
    TextSelection3.prototype.eq = function eq16(other) {
      return other instanceof TextSelection3 && other.anchor == this.anchor && other.head == this.head;
    };
    TextSelection3.prototype.getBookmark = function getBookmark3() {
      return new TextBookmark3(this.anchor, this.head);
    };
    TextSelection3.prototype.toJSON = function toJSON13() {
      return { type: "text", anchor: this.anchor, head: this.head };
    };
    TextSelection3.fromJSON = function fromJSON15(doc2, json2) {
      if (typeof json2.anchor != "number" || typeof json2.head != "number") {
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      }
      return new TextSelection3(doc2.resolve(json2.anchor), doc2.resolve(json2.head));
    };
    TextSelection3.create = function create9(doc2, anchor, head) {
      if (head === void 0)
        head = anchor;
      var $anchor = doc2.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
    };
    TextSelection3.between = function between($anchor, $head, bias) {
      var dPos = $anchor.pos - $head.pos;
      if (!bias || dPos) {
        bias = dPos >= 0 ? 1 : -1;
      }
      if (!$head.parent.inlineContent) {
        var found3 = Selection5.findFrom($head, bias, true) || Selection5.findFrom($head, -bias, true);
        if (found3) {
          $head = found3.$head;
        } else {
          return Selection5.near($head, bias);
        }
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection5.findFrom($anchor, -bias, true) || Selection5.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0) {
            $anchor = $head;
          }
        }
      }
      return new TextSelection3($anchor, $head);
    };
    Object.defineProperties(TextSelection3.prototype, prototypeAccessors$16);
    return TextSelection3;
  }(Selection3);
  Selection3.jsonID("text", TextSelection2);
  var TextBookmark3 = function TextBookmark4(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };
  TextBookmark3.prototype.map = function map19(mapping) {
    return new TextBookmark3(mapping.map(this.anchor), mapping.map(this.head));
  };
  TextBookmark3.prototype.resolve = function resolve10(doc2) {
    return TextSelection2.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  };
  var NodeSelection2 = /* @__PURE__ */ function(Selection5) {
    function NodeSelection3($pos) {
      var node5 = $pos.nodeAfter;
      var $end = $pos.node(0).resolve($pos.pos + node5.nodeSize);
      Selection5.call(this, $pos, $end);
      this.node = node5;
    }
    if (Selection5)
      NodeSelection3.__proto__ = Selection5;
    NodeSelection3.prototype = Object.create(Selection5 && Selection5.prototype);
    NodeSelection3.prototype.constructor = NodeSelection3;
    NodeSelection3.prototype.map = function map22(doc2, mapping) {
      var ref = mapping.mapResult(this.anchor);
      var deleted = ref.deleted;
      var pos = ref.pos;
      var $pos = doc2.resolve(pos);
      if (deleted) {
        return Selection5.near($pos);
      }
      return new NodeSelection3($pos);
    };
    NodeSelection3.prototype.content = function content3() {
      return new Slice3(Fragment3.from(this.node), 0, 0);
    };
    NodeSelection3.prototype.eq = function eq16(other) {
      return other instanceof NodeSelection3 && other.anchor == this.anchor;
    };
    NodeSelection3.prototype.toJSON = function toJSON13() {
      return { type: "node", anchor: this.anchor };
    };
    NodeSelection3.prototype.getBookmark = function getBookmark3() {
      return new NodeBookmark3(this.anchor);
    };
    NodeSelection3.fromJSON = function fromJSON15(doc2, json2) {
      if (typeof json2.anchor != "number") {
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      }
      return new NodeSelection3(doc2.resolve(json2.anchor));
    };
    NodeSelection3.create = function create9(doc2, from5) {
      return new this(doc2.resolve(from5));
    };
    NodeSelection3.isSelectable = function isSelectable(node5) {
      return !node5.isText && node5.type.spec.selectable !== false;
    };
    return NodeSelection3;
  }(Selection3);
  NodeSelection2.prototype.visible = false;
  Selection3.jsonID("node", NodeSelection2);
  var NodeBookmark3 = function NodeBookmark4(anchor) {
    this.anchor = anchor;
  };
  NodeBookmark3.prototype.map = function map20(mapping) {
    var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
    return deleted ? new TextBookmark3(pos, pos) : new NodeBookmark3(pos);
  };
  NodeBookmark3.prototype.resolve = function resolve11(doc2) {
    var $pos = doc2.resolve(this.anchor), node5 = $pos.nodeAfter;
    if (node5 && NodeSelection2.isSelectable(node5)) {
      return new NodeSelection2($pos);
    }
    return Selection3.near($pos);
  };
  var AllSelection2 = /* @__PURE__ */ function(Selection5) {
    function AllSelection3(doc2) {
      Selection5.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
    }
    if (Selection5)
      AllSelection3.__proto__ = Selection5;
    AllSelection3.prototype = Object.create(Selection5 && Selection5.prototype);
    AllSelection3.prototype.constructor = AllSelection3;
    AllSelection3.prototype.replace = function replace5(tr, content3) {
      if (content3 === void 0)
        content3 = Slice3.empty;
      if (content3 == Slice3.empty) {
        tr.delete(0, tr.doc.content.size);
        var sel = Selection5.atStart(tr.doc);
        if (!sel.eq(tr.selection)) {
          tr.setSelection(sel);
        }
      } else {
        Selection5.prototype.replace.call(this, tr, content3);
      }
    };
    AllSelection3.prototype.toJSON = function toJSON13() {
      return { type: "all" };
    };
    AllSelection3.fromJSON = function fromJSON15(doc2) {
      return new AllSelection3(doc2);
    };
    AllSelection3.prototype.map = function map22(doc2) {
      return new AllSelection3(doc2);
    };
    AllSelection3.prototype.eq = function eq16(other) {
      return other instanceof AllSelection3;
    };
    AllSelection3.prototype.getBookmark = function getBookmark3() {
      return AllBookmark2;
    };
    return AllSelection3;
  }(Selection3);
  Selection3.jsonID("all", AllSelection2);
  var AllBookmark2 = {
    map: function map21() {
      return this;
    },
    resolve: function resolve12(doc2) {
      return new AllSelection2(doc2);
    }
  };
  function findSelectionIn2(doc2, node5, pos, index3, dir, text4) {
    if (node5.inlineContent) {
      return TextSelection2.create(doc2, pos);
    }
    for (var i = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i < node5.childCount : i >= 0; i += dir) {
      var child5 = node5.child(i);
      if (!child5.isAtom) {
        var inner = findSelectionIn2(doc2, child5, pos + dir, dir < 0 ? child5.childCount : 0, dir, text4);
        if (inner) {
          return inner;
        }
      } else if (!text4 && NodeSelection2.isSelectable(child5)) {
        return NodeSelection2.create(doc2, pos - (dir < 0 ? child5.nodeSize : 0));
      }
      pos += child5.nodeSize * dir;
    }
  }
  function selectionToInsertionEnd3(tr, startLen, bias) {
    var last = tr.steps.length - 1;
    if (last < startLen) {
      return;
    }
    var step3 = tr.steps[last];
    if (!(step3 instanceof ReplaceStep2 || step3 instanceof ReplaceAroundStep2)) {
      return;
    }
    var map22 = tr.mapping.maps[last], end4;
    map22.forEach(function(_from, _to, _newFrom, newTo) {
      if (end4 == null) {
        end4 = newTo;
      }
    });
    tr.setSelection(Selection3.near(tr.doc.resolve(end4), bias));
  }
  var UPDATED_SEL2 = 1;
  var UPDATED_MARKS2 = 2;
  var UPDATED_SCROLL2 = 4;
  var Transaction2 = /* @__PURE__ */ function(Transform5) {
    function Transaction3(state) {
      Transform5.call(this, state.doc);
      this.time = Date.now();
      this.curSelection = state.selection;
      this.curSelectionFor = 0;
      this.storedMarks = state.storedMarks;
      this.updated = 0;
      this.meta = /* @__PURE__ */ Object.create(null);
    }
    if (Transform5)
      Transaction3.__proto__ = Transform5;
    Transaction3.prototype = Object.create(Transform5 && Transform5.prototype);
    Transaction3.prototype.constructor = Transaction3;
    var prototypeAccessors6 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
    prototypeAccessors6.selection.get = function() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }
      return this.curSelection;
    };
    Transaction3.prototype.setSelection = function setSelection2(selection) {
      if (selection.$from.doc != this.doc) {
        throw new RangeError("Selection passed to setSelection must point at the current document");
      }
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL2) & ~UPDATED_MARKS2;
      this.storedMarks = null;
      return this;
    };
    prototypeAccessors6.selectionSet.get = function() {
      return (this.updated & UPDATED_SEL2) > 0;
    };
    Transaction3.prototype.setStoredMarks = function setStoredMarks(marks3) {
      this.storedMarks = marks3;
      this.updated |= UPDATED_MARKS2;
      return this;
    };
    Transaction3.prototype.ensureMarks = function ensureMarks2(marks3) {
      if (!Mark4.sameSet(this.storedMarks || this.selection.$from.marks(), marks3)) {
        this.setStoredMarks(marks3);
      }
      return this;
    };
    Transaction3.prototype.addStoredMark = function addStoredMark(mark4) {
      return this.ensureMarks(mark4.addToSet(this.storedMarks || this.selection.$head.marks()));
    };
    Transaction3.prototype.removeStoredMark = function removeStoredMark(mark4) {
      return this.ensureMarks(mark4.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    };
    prototypeAccessors6.storedMarksSet.get = function() {
      return (this.updated & UPDATED_MARKS2) > 0;
    };
    Transaction3.prototype.addStep = function addStep3(step3, doc2) {
      Transform5.prototype.addStep.call(this, step3, doc2);
      this.updated = this.updated & ~UPDATED_MARKS2;
      this.storedMarks = null;
    };
    Transaction3.prototype.setTime = function setTime(time) {
      this.time = time;
      return this;
    };
    Transaction3.prototype.replaceSelection = function replaceSelection(slice6) {
      this.selection.replace(this, slice6);
      return this;
    };
    Transaction3.prototype.replaceSelectionWith = function replaceSelectionWith(node5, inheritMarks) {
      var selection = this.selection;
      if (inheritMarks !== false) {
        node5 = node5.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark4.none));
      }
      selection.replaceWith(this, node5);
      return this;
    };
    Transaction3.prototype.deleteSelection = function deleteSelection3() {
      this.selection.replace(this);
      return this;
    };
    Transaction3.prototype.insertText = function insertText(text4, from5, to) {
      if (to === void 0)
        to = from5;
      var schema = this.doc.type.schema;
      if (from5 == null) {
        if (!text4) {
          return this.deleteSelection();
        }
        return this.replaceSelectionWith(schema.text(text4), true);
      } else {
        if (!text4) {
          return this.deleteRange(from5, to);
        }
        var marks3 = this.storedMarks;
        if (!marks3) {
          var $from = this.doc.resolve(from5);
          marks3 = to == from5 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }
        this.replaceRangeWith(from5, to, schema.text(text4, marks3));
        if (!this.selection.empty) {
          this.setSelection(Selection3.near(this.selection.$to));
        }
        return this;
      }
    };
    Transaction3.prototype.setMeta = function setMeta2(key2, value) {
      this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
      return this;
    };
    Transaction3.prototype.getMeta = function getMeta(key2) {
      return this.meta[typeof key2 == "string" ? key2 : key2.key];
    };
    prototypeAccessors6.isGeneric.get = function() {
      for (var _ in this.meta) {
        return false;
      }
      return true;
    };
    Transaction3.prototype.scrollIntoView = function scrollIntoView2() {
      this.updated |= UPDATED_SCROLL2;
      return this;
    };
    prototypeAccessors6.scrolledIntoView.get = function() {
      return (this.updated & UPDATED_SCROLL2) > 0;
    };
    Object.defineProperties(Transaction3.prototype, prototypeAccessors6);
    return Transaction3;
  }(Transform3);
  function bind2(f, self2) {
    return !self2 || !f ? f : f.bind(self2);
  }
  var FieldDesc3 = function FieldDesc4(name, desc, self2) {
    this.name = name;
    this.init = bind2(desc.init, self2);
    this.apply = bind2(desc.apply, self2);
  };
  var baseFields2 = [
    new FieldDesc3("doc", {
      init: function init5(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply: function apply10(tr) {
        return tr.doc;
      }
    }),
    new FieldDesc3("selection", {
      init: function init6(config, instance) {
        return config.selection || Selection3.atStart(instance.doc);
      },
      apply: function apply11(tr) {
        return tr.selection;
      }
    }),
    new FieldDesc3("storedMarks", {
      init: function init7(config) {
        return config.storedMarks || null;
      },
      apply: function apply12(tr, _marks, _old, state) {
        return state.selection.$cursor ? tr.storedMarks : null;
      }
    }),
    new FieldDesc3("scrollToSelection", {
      init: function init8() {
        return 0;
      },
      apply: function apply13(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      }
    })
  ];
  var Configuration3 = function Configuration4(schema, plugins) {
    var this$1$1 = this;
    this.schema = schema;
    this.fields = baseFields2.concat();
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    if (plugins) {
      plugins.forEach(function(plugin) {
        if (this$1$1.pluginsByKey[plugin.key]) {
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        }
        this$1$1.plugins.push(plugin);
        this$1$1.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state) {
          this$1$1.fields.push(new FieldDesc3(plugin.key, plugin.spec.state, plugin));
        }
      });
    }
  };
  var EditorState3 = function EditorState4(config) {
    this.config = config;
  };
  var prototypeAccessors$15 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
  prototypeAccessors$15.schema.get = function() {
    return this.config.schema;
  };
  prototypeAccessors$15.plugins.get = function() {
    return this.config.plugins;
  };
  EditorState3.prototype.apply = function apply14(tr) {
    return this.applyTransaction(tr).state;
  };
  EditorState3.prototype.filterTransaction = function filterTransaction2(tr, ignore) {
    if (ignore === void 0)
      ignore = -1;
    for (var i = 0; i < this.config.plugins.length; i++) {
      if (i != ignore) {
        var plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
          return false;
        }
      }
    }
    return true;
  };
  EditorState3.prototype.applyTransaction = function applyTransaction3(rootTr) {
    if (!this.filterTransaction(rootTr)) {
      return { state: this, transactions: [] };
    }
    var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      var haveNew = false;
      for (var i = 0; i < this.config.plugins.length; i++) {
        var plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (var j = 0; j < this.config.plugins.length; j++) {
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
              }
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen) {
            seen[i] = { state: newState, n: trs.length };
          }
        }
      }
      if (!haveNew) {
        return { state: newState, transactions: trs };
      }
    }
  };
  EditorState3.prototype.applyInner = function applyInner2(tr) {
    if (!tr.before.eq(this.doc)) {
      throw new RangeError("Applying a mismatched transaction");
    }
    var newInstance = new EditorState3(this.config), fields = this.config.fields;
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    for (var i$1 = 0; i$1 < applyListeners2.length; i$1++) {
      applyListeners2[i$1](this, tr, newInstance);
    }
    return newInstance;
  };
  prototypeAccessors$15.tr.get = function() {
    return new Transaction2(this);
  };
  EditorState3.create = function create7(config) {
    var $config = new Configuration3(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    var instance = new EditorState3($config);
    for (var i = 0; i < $config.fields.length; i++) {
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    }
    return instance;
  };
  EditorState3.prototype.reconfigure = function reconfigure2(config) {
    var $config = new Configuration3(this.schema, config.plugins);
    var fields = $config.fields, instance = new EditorState3($config);
    for (var i = 0; i < fields.length; i++) {
      var name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  };
  EditorState3.prototype.toJSON = function toJSON12(pluginFields) {
    var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks) {
      result2.storedMarks = this.storedMarks.map(function(m) {
        return m.toJSON();
      });
    }
    if (pluginFields && typeof pluginFields == "object") {
      for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection") {
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        }
        var plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON) {
          result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
        }
      }
    }
    return result2;
  };
  EditorState3.fromJSON = function fromJSON14(config, json2, pluginFields) {
    if (!json2) {
      throw new RangeError("Invalid input for EditorState.fromJSON");
    }
    if (!config.schema) {
      throw new RangeError("Required config field 'schema' missing");
    }
    var $config = new Configuration3(config.schema, config.plugins);
    var instance = new EditorState3($config);
    $config.fields.forEach(function(field) {
      if (field.name == "doc") {
        instance.doc = Node5.fromJSON(config.schema, json2.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection3.fromJSON(instance.doc, json2.selection);
      } else if (field.name == "storedMarks") {
        if (json2.storedMarks) {
          instance.storedMarks = json2.storedMarks.map(config.schema.markFromJSON);
        }
      } else {
        if (pluginFields) {
          for (var prop in pluginFields) {
            var plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json2, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json2[prop], instance);
              return;
            }
          }
        }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  };
  EditorState3.addApplyListener = function addApplyListener2(f) {
    applyListeners2.push(f);
  };
  EditorState3.removeApplyListener = function removeApplyListener2(f) {
    var found3 = applyListeners2.indexOf(f);
    if (found3 > -1) {
      applyListeners2.splice(found3, 1);
    }
  };
  Object.defineProperties(EditorState3.prototype, prototypeAccessors$15);
  var applyListeners2 = [];
  function createCell(cellType, cellContent) {
    if (cellContent) {
      return cellType.createChecked(null, cellContent);
    }
    return cellType.createAndFill();
  }
  function getTableNodeTypes(schema) {
    if (schema.cached.tableNodeTypes) {
      return schema.cached.tableNodeTypes;
    }
    const roles = {};
    Object.keys(schema.nodes).forEach((type) => {
      const nodeType2 = schema.nodes[type];
      if (nodeType2.spec.tableRole) {
        roles[nodeType2.spec.tableRole] = nodeType2;
      }
    });
    schema.cached.tableNodeTypes = roles;
    return roles;
  }
  function createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {
    const types = getTableNodeTypes(schema);
    const headerCells = [];
    const cells = [];
    for (let index3 = 0; index3 < colsCount; index3 += 1) {
      const cell = createCell(types.cell, cellContent);
      if (cell) {
        cells.push(cell);
      }
      if (withHeaderRow) {
        const headerCell = createCell(types.header_cell, cellContent);
        if (headerCell) {
          headerCells.push(headerCell);
        }
      }
    }
    const rows = [];
    for (let index3 = 0; index3 < rowsCount; index3 += 1) {
      rows.push(types.row.createChecked(null, withHeaderRow && index3 === 0 ? headerCells : cells));
    }
    return types.table.createChecked(null, rows);
  }
  function isCellSelection(value) {
    return value instanceof CellSelection;
  }
  var deleteTableWhenAllCellsSelected = ({ editor }) => {
    const { selection } = editor.state;
    if (!isCellSelection(selection)) {
      return false;
    }
    let cellCount = 0;
    const table = findParentNodeClosestToPos(selection.ranges[0].$from, (node5) => {
      return node5.type.name === "table";
    });
    table === null || table === void 0 ? void 0 : table.node.descendants((node5) => {
      if (node5.type.name === "table") {
        return false;
      }
      if (["tableCell", "tableHeader"].includes(node5.type.name)) {
        cellCount += 1;
      }
    });
    const allCellsSelected = cellCount === selection.ranges.length;
    if (!allCellsSelected) {
      return false;
    }
    editor.commands.deleteTable();
    return true;
  };
  function updateColumns2(node5, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
    let totalWidth = 0;
    let fixedWidth = true;
    let nextDOM = colgroup.firstChild;
    const row = node5.firstChild;
    for (let i = 0, col = 0; i < row.childCount; i += 1) {
      const { colspan, colwidth } = row.child(i).attrs;
      for (let j = 0; j < colspan; j += 1, col += 1) {
        const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? `${hasWidth}px` : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) {
          fixedWidth = false;
        }
        if (!nextDOM) {
          colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
        } else {
          if (nextDOM.style.width !== cssWidth) {
            nextDOM.style.width = cssWidth;
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
    while (nextDOM) {
      const after3 = nextDOM.nextSibling;
      nextDOM.parentNode.removeChild(nextDOM);
      nextDOM = after3;
    }
    if (fixedWidth) {
      table.style.width = `${totalWidth}px`;
      table.style.minWidth = "";
    } else {
      table.style.width = "";
      table.style.minWidth = `${totalWidth}px`;
    }
  }
  var TableView3 = class {
    constructor(node5, cellMinWidth) {
      this.node = node5;
      this.cellMinWidth = cellMinWidth;
      this.dom = document.createElement("div");
      this.dom.className = "tableWrapper";
      this.table = this.dom.appendChild(document.createElement("table"));
      this.colgroup = this.table.appendChild(document.createElement("colgroup"));
      updateColumns2(node5, this.colgroup, this.table, cellMinWidth);
      this.contentDOM = this.table.appendChild(document.createElement("tbody"));
    }
    update(node5) {
      if (node5.type !== this.node.type) {
        return false;
      }
      this.node = node5;
      updateColumns2(node5, this.colgroup, this.table, this.cellMinWidth);
      return true;
    }
    ignoreMutation(mutation) {
      return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
    }
  };
  var Table = Node4.create({
    name: "table",
    addOptions() {
      return {
        HTMLAttributes: {},
        resizable: false,
        handleWidth: 5,
        cellMinWidth: 25,
        View: TableView3,
        lastColumnResizable: true,
        allowTableNodeSelection: false
      };
    },
    content: "tableRow+",
    tableRole: "table",
    isolating: true,
    group: "block",
    parseHTML() {
      return [
        { tag: "table" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["table", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ["tbody", 0]];
    },
    addCommands() {
      return {
        insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch: dispatch3, editor }) => {
          const node5 = createTable(editor.schema, rows, cols, withHeaderRow);
          if (dispatch3) {
            const offset4 = tr.selection.anchor + 1;
            tr.replaceSelectionWith(node5).scrollIntoView().setSelection(TextSelection2.near(tr.doc.resolve(offset4)));
          }
          return true;
        },
        addColumnBefore: () => ({ state, dispatch: dispatch3 }) => {
          return addColumnBefore(state, dispatch3);
        },
        addColumnAfter: () => ({ state, dispatch: dispatch3 }) => {
          return addColumnAfter(state, dispatch3);
        },
        deleteColumn: () => ({ state, dispatch: dispatch3 }) => {
          return deleteColumn(state, dispatch3);
        },
        addRowBefore: () => ({ state, dispatch: dispatch3 }) => {
          return addRowBefore(state, dispatch3);
        },
        addRowAfter: () => ({ state, dispatch: dispatch3 }) => {
          return addRowAfter(state, dispatch3);
        },
        deleteRow: () => ({ state, dispatch: dispatch3 }) => {
          return deleteRow(state, dispatch3);
        },
        deleteTable: () => ({ state, dispatch: dispatch3 }) => {
          return deleteTable(state, dispatch3);
        },
        mergeCells: () => ({ state, dispatch: dispatch3 }) => {
          return mergeCells(state, dispatch3);
        },
        splitCell: () => ({ state, dispatch: dispatch3 }) => {
          return splitCell(state, dispatch3);
        },
        toggleHeaderColumn: () => ({ state, dispatch: dispatch3 }) => {
          return toggleHeader("column")(state, dispatch3);
        },
        toggleHeaderRow: () => ({ state, dispatch: dispatch3 }) => {
          return toggleHeader("row")(state, dispatch3);
        },
        toggleHeaderCell: () => ({ state, dispatch: dispatch3 }) => {
          return toggleHeaderCell(state, dispatch3);
        },
        mergeOrSplit: () => ({ state, dispatch: dispatch3 }) => {
          if (mergeCells(state, dispatch3)) {
            return true;
          }
          return splitCell(state, dispatch3);
        },
        setCellAttribute: (name, value) => ({ state, dispatch: dispatch3 }) => {
          return setCellAttr(name, value)(state, dispatch3);
        },
        goToNextCell: () => ({ state, dispatch: dispatch3 }) => {
          return goToNextCell(1)(state, dispatch3);
        },
        goToPreviousCell: () => ({ state, dispatch: dispatch3 }) => {
          return goToNextCell(-1)(state, dispatch3);
        },
        fixTables: () => ({ state, dispatch: dispatch3 }) => {
          if (dispatch3) {
            fixTables(state);
          }
          return true;
        },
        setCellSelection: (position) => ({ tr, dispatch: dispatch3 }) => {
          if (dispatch3) {
            const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);
            tr.setSelection(selection);
          }
          return true;
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        Tab: () => {
          if (this.editor.commands.goToNextCell()) {
            return true;
          }
          if (!this.editor.can().addRowAfter()) {
            return false;
          }
          return this.editor.chain().addRowAfter().goToNextCell().run();
        },
        "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
        Backspace: deleteTableWhenAllCellsSelected,
        "Mod-Backspace": deleteTableWhenAllCellsSelected,
        Delete: deleteTableWhenAllCellsSelected,
        "Mod-Delete": deleteTableWhenAllCellsSelected
      };
    },
    addProseMirrorPlugins() {
      const isResizable = this.options.resizable && this.editor.isEditable;
      return [
        ...isResizable ? [columnResizing({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })] : [],
        tableEditing({
          allowTableNodeSelection: this.options.allowTableNodeSelection
        })
      ];
    },
    extendNodeSchema(extension) {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      return {
        tableRole: callOrReturn(getExtensionField(extension, "tableRole", context))
      };
    }
  });

  // node_modules/@tiptap/extension-table-row/dist/tiptap-extension-table-row.esm.js
  var TableRow = Node4.create({
    name: "tableRow",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "(tableCell | tableHeader)*",
    tableRole: "row",
    parseHTML() {
      return [
        { tag: "tr" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["tr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    }
  });

  // node_modules/@tiptap/extension-table-cell/dist/tiptap-extension-table-cell.esm.js
  var TableCell = Node4.create({
    name: "tableCell",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    addAttributes() {
      return {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: null,
          parseHTML: (element) => {
            const colwidth = element.getAttribute("colwidth");
            const value = colwidth ? [parseInt(colwidth, 10)] : null;
            return value;
          }
        }
      };
    },
    tableRole: "cell",
    isolating: true,
    parseHTML() {
      return [
        { tag: "td" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    }
  });

  // node_modules/@tiptap/extension-table-header/dist/tiptap-extension-table-header.esm.js
  var TableHeader = Node4.create({
    name: "tableHeader",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    addAttributes() {
      return {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: null,
          parseHTML: (element) => {
            const colwidth = element.getAttribute("colwidth");
            const value = colwidth ? [parseInt(colwidth, 10)] : null;
            return value;
          }
        }
      };
    },
    tableRole: "header_cell",
    isolating: true,
    parseHTML() {
      return [
        { tag: "th" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    }
  });

  // app/javascript/documentation/controllers/rich_text_editor/with_table.js
  var defaultOptions2 = {
    resizable: false
  };
  var tableTargets = ["tablePanel"];
  var with_table_default = (controller, options = {}) => {
    const { resizable } = Object.assign({}, defaultOptions2, options);
    const TableExtensions = [
      Table.configure({
        resizable
      }),
      TableRow,
      TableCell,
      TableHeader
    ];
    const runTableCommand = (event, name) => {
      if (!controller.editor.isActive("table")) {
        return event.stopPropagation();
      }
      controller.runCommand(name);
    };
    const tableModifierTargets = () => {
      if (!controller.hasTablePanelTarget)
        return [];
      return Array.from(controller.tablePanelTarget.querySelectorAll(".modifier"));
    };
    const insertTable = () => {
      controller.runCommand("insertTable", {
        rows: 3,
        cols: 3,
        withHeaderRow: true
      });
    };
    const addColumnBefore2 = (e) => runTableCommand(e, "addColumnBefore");
    const addColumnAfter2 = (e) => runTableCommand(e, "addColumnAfter");
    const addRowBefore2 = (e) => runTableCommand(e, "addRowBefore");
    const addRowAfter2 = (e) => runTableCommand(e, "addRowAfter");
    const deleteColumn2 = (e) => runTableCommand(e, "deleteColumn");
    const deleteRow2 = (e) => runTableCommand(e, "deleteRow");
    const updateTableModifiers = () => {
      const tableIsActive = controller.editor.isActive("table");
      tableModifierTargets().forEach((modifier) => {
        tableIsActive ? modifier.classList.remove("disabled") : modifier.classList.add("disabled");
      });
    };
    const openTablePanel = () => {
      controller.closeNodeSelect();
      controller.closeLinkPanel();
    };
    const closeTablePanel = () => {
      if (!controller.hasTablePanelTarget)
        return;
      controller.tablePanelTarget.classList.remove("is-active");
    };
    Object.assign(controller, {
      insertTable,
      addColumnBefore: addColumnBefore2,
      addColumnAfter: addColumnAfter2,
      addRowBefore: addRowBefore2,
      addRowAfter: addRowAfter2,
      deleteColumn: deleteColumn2,
      deleteRow: deleteRow2,
      updateTableModifiers,
      openTablePanel,
      closeTablePanel
    });
    return { TableExtensions };
  };

  // node_modules/linkifyjs/dist/linkify.module.js
  function State(token) {
    this.j = {};
    this.jr = [];
    this.jd = null;
    this.t = token;
  }
  State.prototype = {
    accepts: function accepts() {
      return !!this.t;
    },
    tt: function tt(input, tokenOrState) {
      if (tokenOrState && tokenOrState.j) {
        this.j[input] = tokenOrState;
        return tokenOrState;
      }
      var token = tokenOrState;
      var nextState = this.j[input];
      if (nextState) {
        if (token) {
          nextState.t = token;
        }
        return nextState;
      }
      nextState = makeState();
      var templateState = takeT(this, input);
      if (templateState) {
        Object.assign(nextState.j, templateState.j);
        nextState.jr.append(templateState.jr);
        nextState.jr = templateState.jd;
        nextState.t = token || templateState.t;
      } else {
        nextState.t = token;
      }
      this.j[input] = nextState;
      return nextState;
    }
  };
  var makeState = function makeState2() {
    return new State();
  };
  var makeAcceptingState = function makeAcceptingState2(token) {
    return new State(token);
  };
  var makeT = function makeT2(startState, input, nextState) {
    if (!startState.j[input]) {
      startState.j[input] = nextState;
    }
  };
  var makeRegexT = function makeRegexT2(startState, regex, nextState) {
    startState.jr.push([regex, nextState]);
  };
  var takeT = function takeT2(state, input) {
    var nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (var i = 0; i < state.jr.length; i++) {
      var regex = state.jr[i][0];
      var _nextState = state.jr[i][1];
      if (regex.test(input)) {
        return _nextState;
      }
    }
    return state.jd;
  };
  var makeMultiT = function makeMultiT2(startState, chars, nextState) {
    for (var i = 0; i < chars.length; i++) {
      makeT(startState, chars[i], nextState);
    }
  };
  var makeBatchT = function makeBatchT2(startState, transitions) {
    for (var i = 0; i < transitions.length; i++) {
      var input = transitions[i][0];
      var nextState = transitions[i][1];
      makeT(startState, input, nextState);
    }
  };
  var makeChainT = function makeChainT2(state, str, endState, defaultStateFactory) {
    var i = 0, len = str.length, nextState;
    while (i < len && (nextState = state.j[str[i]])) {
      state = nextState;
      i++;
    }
    if (i >= len) {
      return [];
    }
    while (i < len - 1) {
      nextState = defaultStateFactory();
      makeT(state, str[i], nextState);
      state = nextState;
      i++;
    }
    makeT(state, str[len - 1], endState);
  };
  var DOMAIN = "DOMAIN";
  var LOCALHOST = "LOCALHOST";
  var TLD = "TLD";
  var NUM = "NUM";
  var PROTOCOL = "PROTOCOL";
  var MAILTO = "MAILTO";
  var WS = "WS";
  var NL = "NL";
  var OPENBRACE = "OPENBRACE";
  var OPENBRACKET = "OPENBRACKET";
  var OPENANGLEBRACKET = "OPENANGLEBRACKET";
  var OPENPAREN = "OPENPAREN";
  var CLOSEBRACE = "CLOSEBRACE";
  var CLOSEBRACKET = "CLOSEBRACKET";
  var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
  var CLOSEPAREN = "CLOSEPAREN";
  var AMPERSAND = "AMPERSAND";
  var APOSTROPHE = "APOSTROPHE";
  var ASTERISK = "ASTERISK";
  var AT = "AT";
  var BACKSLASH = "BACKSLASH";
  var BACKTICK = "BACKTICK";
  var CARET = "CARET";
  var COLON = "COLON";
  var COMMA = "COMMA";
  var DOLLAR = "DOLLAR";
  var DOT = "DOT";
  var EQUALS = "EQUALS";
  var EXCLAMATION = "EXCLAMATION";
  var HYPHEN = "HYPHEN";
  var PERCENT = "PERCENT";
  var PIPE = "PIPE";
  var PLUS = "PLUS";
  var POUND = "POUND";
  var QUERY = "QUERY";
  var QUOTE = "QUOTE";
  var SEMI = "SEMI";
  var SLASH = "SLASH";
  var TILDE = "TILDE";
  var UNDERSCORE = "UNDERSCORE";
  var SYM = "SYM";
  var text2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    DOMAIN,
    LOCALHOST,
    TLD,
    NUM,
    PROTOCOL,
    MAILTO,
    WS,
    NL,
    OPENBRACE,
    OPENBRACKET,
    OPENANGLEBRACKET,
    OPENPAREN,
    CLOSEBRACE,
    CLOSEBRACKET,
    CLOSEANGLEBRACKET,
    CLOSEPAREN,
    AMPERSAND,
    APOSTROPHE,
    ASTERISK,
    AT,
    BACKSLASH,
    BACKTICK,
    CARET,
    COLON,
    COMMA,
    DOLLAR,
    DOT,
    EQUALS,
    EXCLAMATION,
    HYPHEN,
    PERCENT,
    PIPE,
    PLUS,
    POUND,
    QUERY,
    QUOTE,
    SEMI,
    SLASH,
    TILDE,
    UNDERSCORE,
    SYM
  });
  var tlds = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw verm\xF6gensberater-ctb verm\xF6gensberatung-pwb \u03B5\u03BB \u03B5\u03C5 \u0431\u0433 \u0431\u0435\u043B \u0434\u0435\u0442\u0438 \u0435\u044E \u043A\u0430\u0442\u043E\u043B\u0438\u043A \u043A\u043E\u043C \u049B\u0430\u0437 \u043C\u043A\u0434 \u043C\u043E\u043D \u043C\u043E\u0441\u043A\u0432\u0430 \u043E\u043D\u043B\u0430\u0439\u043D \u043E\u0440\u0433 \u0440\u0443\u0441 \u0440\u0444 \u0441\u0430\u0439\u0442 \u0441\u0440\u0431 \u0443\u043A\u0440 \u10D2\u10D4 \u0570\u0561\u0575 \u05D9\u05E9\u05E8\u05D0\u05DC \u05E7\u05D5\u05DD \u0627\u0628\u0648\u0638\u0628\u064A \u0627\u062A\u0635\u0627\u0644\u0627\u062A \u0627\u0631\u0627\u0645\u0643\u0648 \u0627\u0644\u0627\u0631\u062F\u0646 \u0627\u0644\u0628\u062D\u0631\u064A\u0646 \u0627\u0644\u062C\u0632\u0627\u0626\u0631 \u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629 \u0627\u0644\u0639\u0644\u064A\u0627\u0646 \u0627\u0644\u0645\u063A\u0631\u0628 \u0627\u0645\u0627\u0631\u0627\u062A \u0627\u06CC\u0631\u0627\u0646 \u0628\u0627\u0631\u062A \u0628\u0627\u0632\u0627\u0631 \u0628\u06BE\u0627\u0631\u062A \u0628\u064A\u062A\u0643 \u067E\u0627\u06A9\u0633\u062A\u0627\u0646 \u0680\u0627\u0631\u062A \u062A\u0648\u0646\u0633 \u0633\u0648\u062F\u0627\u0646 \u0633\u0648\u0631\u064A\u0629 \u0634\u0628\u0643\u0629 \u0639\u0631\u0627\u0642 \u0639\u0631\u0628 \u0639\u0645\u0627\u0646 \u0641\u0644\u0633\u0637\u064A\u0646 \u0642\u0637\u0631 \u0643\u0627\u062B\u0648\u0644\u064A\u0643 \u0643\u0648\u0645 \u0645\u0635\u0631 \u0645\u0644\u064A\u0633\u064A\u0627 \u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627 \u0645\u0648\u0642\u0639 \u0647\u0645\u0631\u0627\u0647 \u0915\u0949\u092E \u0928\u0947\u091F \u092D\u093E\u0930\u0924 \u092D\u093E\u0930\u0924\u092E\u094D \u092D\u093E\u0930\u094B\u0924 \u0938\u0902\u0917\u0920\u0928 \u09AC\u09BE\u0982\u09B2\u09BE \u09AD\u09BE\u09B0\u09A4 \u09AD\u09BE\u09F0\u09A4 \u0A2D\u0A3E\u0A30\u0A24 \u0AAD\u0ABE\u0AB0\u0AA4 \u0B2D\u0B3E\u0B30\u0B24 \u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE \u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8 \u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD \u0C2D\u0C3E\u0C30\u0C24\u0C4D \u0CAD\u0CBE\u0CB0\u0CA4 \u0D2D\u0D3E\u0D30\u0D24\u0D02 \u0DBD\u0D82\u0D9A\u0DCF \u0E04\u0E2D\u0E21 \u0E44\u0E17\u0E22 \u0EA5\u0EB2\u0EA7 \uB2F7\uB137 \uB2F7\uCEF4 \uC0BC\uC131 \uD55C\uAD6D \u30A2\u30DE\u30BE\u30F3 \u30B0\u30FC\u30B0\u30EB \u30AF\u30E9\u30A6\u30C9 \u30B3\u30E0 \u30B9\u30C8\u30A2 \u30BB\u30FC\u30EB \u30D5\u30A1\u30C3\u30B7\u30E7\u30F3 \u30DD\u30A4\u30F3\u30C8 \u307F\u3093\u306A \u4E16\u754C \u4E2D\u4FE1 \u4E2D\u56FD \u4E2D\u570B \u4E2D\u6587\u7F51 \u4E9A\u9A6C\u900A \u4F01\u4E1A \u4F5B\u5C71 \u4FE1\u606F \u5065\u5EB7 \u516B\u5366 \u516C\u53F8 \u516C\u76CA \u53F0\u6E7E \u53F0\u7063 \u5546\u57CE \u5546\u5E97 \u5546\u6807 \u5609\u91CC \u5609\u91CC\u5927\u9152\u5E97 \u5728\u7EBF \u5927\u4F17\u6C7D\u8F66 \u5927\u62FF \u5929\u4E3B\u6559 \u5A31\u4E50 \u5BB6\u96FB \u5E7F\u4E1C \u5FAE\u535A \u6148\u5584 \u6211\u7231\u4F60 \u624B\u673A \u62DB\u8058 \u653F\u52A1 \u653F\u5E9C \u65B0\u52A0\u5761 \u65B0\u95FB \u65F6\u5C1A \u66F8\u7C4D \u673A\u6784 \u6DE1\u9A6C\u9521 \u6E38\u620F \u6FB3\u9580 \u70B9\u770B \u79FB\u52A8 \u7EC4\u7EC7\u673A\u6784 \u7F51\u5740 \u7F51\u5E97 \u7F51\u7AD9 \u7F51\u7EDC \u8054\u901A \u8BFA\u57FA\u4E9A \u8C37\u6B4C \u8D2D\u7269 \u901A\u8CA9 \u96C6\u56E2 \u96FB\u8A0A\u76C8\u79D1 \u98DE\u5229\u6D66 \u98DF\u54C1 \u9910\u5385 \u9999\u683C\u91CC\u62C9 \u9999\u6E2F".split(" ");
  var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/;
  var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/;
  var EMOJI_VARIATION = /\uFE0F/;
  var DIGIT = /\d/;
  var SPACE = /\s/;
  function init$2() {
    var customProtocols = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var S_START = makeState();
    var S_NUM = makeAcceptingState(NUM);
    var S_DOMAIN = makeAcceptingState(DOMAIN);
    var S_DOMAIN_HYPHEN = makeState();
    var S_WS = makeAcceptingState(WS);
    var DOMAIN_REGEX_TRANSITIONS = [[DIGIT, S_DOMAIN], [LETTER, S_DOMAIN], [EMOJI, S_DOMAIN], [EMOJI_VARIATION, S_DOMAIN]];
    var makeDomainState = function makeDomainState2() {
      var state = makeAcceptingState(DOMAIN);
      state.j = {
        "-": S_DOMAIN_HYPHEN
      };
      state.jr = [].concat(DOMAIN_REGEX_TRANSITIONS);
      return state;
    };
    var makeNearDomainState = function makeNearDomainState2(token) {
      var state = makeDomainState();
      state.t = token;
      return state;
    };
    makeBatchT(S_START, [["'", makeAcceptingState(APOSTROPHE)], ["{", makeAcceptingState(OPENBRACE)], ["[", makeAcceptingState(OPENBRACKET)], ["<", makeAcceptingState(OPENANGLEBRACKET)], ["(", makeAcceptingState(OPENPAREN)], ["}", makeAcceptingState(CLOSEBRACE)], ["]", makeAcceptingState(CLOSEBRACKET)], [">", makeAcceptingState(CLOSEANGLEBRACKET)], [")", makeAcceptingState(CLOSEPAREN)], ["&", makeAcceptingState(AMPERSAND)], ["*", makeAcceptingState(ASTERISK)], ["@", makeAcceptingState(AT)], ["`", makeAcceptingState(BACKTICK)], ["^", makeAcceptingState(CARET)], [":", makeAcceptingState(COLON)], [",", makeAcceptingState(COMMA)], ["$", makeAcceptingState(DOLLAR)], [".", makeAcceptingState(DOT)], ["=", makeAcceptingState(EQUALS)], ["!", makeAcceptingState(EXCLAMATION)], ["-", makeAcceptingState(HYPHEN)], ["%", makeAcceptingState(PERCENT)], ["|", makeAcceptingState(PIPE)], ["+", makeAcceptingState(PLUS)], ["#", makeAcceptingState(POUND)], ["?", makeAcceptingState(QUERY)], ['"', makeAcceptingState(QUOTE)], ["/", makeAcceptingState(SLASH)], [";", makeAcceptingState(SEMI)], ["~", makeAcceptingState(TILDE)], ["_", makeAcceptingState(UNDERSCORE)], ["\\", makeAcceptingState(BACKSLASH)]]);
    makeT(S_START, "\n", makeAcceptingState(NL));
    makeRegexT(S_START, SPACE, S_WS);
    makeT(S_WS, "\n", makeState());
    makeRegexT(S_WS, SPACE, S_WS);
    for (var i = 0; i < tlds.length; i++) {
      makeChainT(S_START, tlds[i], makeNearDomainState(TLD), makeDomainState);
    }
    var S_PROTOCOL_FILE = makeDomainState();
    var S_PROTOCOL_FTP = makeDomainState();
    var S_PROTOCOL_HTTP = makeDomainState();
    var S_MAILTO = makeDomainState();
    makeChainT(S_START, "file", S_PROTOCOL_FILE, makeDomainState);
    makeChainT(S_START, "ftp", S_PROTOCOL_FTP, makeDomainState);
    makeChainT(S_START, "http", S_PROTOCOL_HTTP, makeDomainState);
    makeChainT(S_START, "mailto", S_MAILTO, makeDomainState);
    var S_PROTOCOL_SECURE = makeDomainState();
    var S_FULL_PROTOCOL = makeAcceptingState(PROTOCOL);
    var S_FULL_MAILTO = makeAcceptingState(MAILTO);
    makeT(S_PROTOCOL_FTP, "s", S_PROTOCOL_SECURE);
    makeT(S_PROTOCOL_FTP, ":", S_FULL_PROTOCOL);
    makeT(S_PROTOCOL_HTTP, "s", S_PROTOCOL_SECURE);
    makeT(S_PROTOCOL_HTTP, ":", S_FULL_PROTOCOL);
    makeT(S_PROTOCOL_FILE, ":", S_FULL_PROTOCOL);
    makeT(S_PROTOCOL_SECURE, ":", S_FULL_PROTOCOL);
    makeT(S_MAILTO, ":", S_FULL_MAILTO);
    var S_CUSTOM_PROTOCOL = makeDomainState();
    for (var _i = 0; _i < customProtocols.length; _i++) {
      makeChainT(S_START, customProtocols[_i], S_CUSTOM_PROTOCOL, makeDomainState);
    }
    makeT(S_CUSTOM_PROTOCOL, ":", S_FULL_PROTOCOL);
    makeChainT(S_START, "localhost", makeNearDomainState(LOCALHOST), makeDomainState);
    makeRegexT(S_START, DIGIT, S_NUM);
    makeRegexT(S_START, LETTER, S_DOMAIN);
    makeRegexT(S_START, EMOJI, S_DOMAIN);
    makeRegexT(S_START, EMOJI_VARIATION, S_DOMAIN);
    makeRegexT(S_NUM, DIGIT, S_NUM);
    makeRegexT(S_NUM, LETTER, S_DOMAIN);
    makeRegexT(S_NUM, EMOJI, S_DOMAIN);
    makeRegexT(S_NUM, EMOJI_VARIATION, S_DOMAIN);
    makeT(S_NUM, "-", S_DOMAIN_HYPHEN);
    makeT(S_DOMAIN, "-", S_DOMAIN_HYPHEN);
    makeT(S_DOMAIN_HYPHEN, "-", S_DOMAIN_HYPHEN);
    makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
    makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
    makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
    makeRegexT(S_DOMAIN, EMOJI_VARIATION, S_DOMAIN);
    makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
    makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
    makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);
    makeRegexT(S_DOMAIN_HYPHEN, EMOJI_VARIATION, S_DOMAIN);
    S_START.jd = makeAcceptingState(SYM);
    return S_START;
  }
  function run$12(start6, str) {
    var iterable = stringToArray(str.replace(/[A-Z]/g, function(c) {
      return c.toLowerCase();
    }));
    var charCount = iterable.length;
    var tokens = [];
    var cursor = 0;
    var charCursor = 0;
    while (charCursor < charCount) {
      var state = start6;
      var nextState = null;
      var tokenLength = 0;
      var latestAccepting = null;
      var sinceAccepts = -1;
      var charsSinceAccepts = -1;
      while (charCursor < charCount && (nextState = takeT(state, iterable[charCursor]))) {
        state = nextState;
        if (state.accepts()) {
          sinceAccepts = 0;
          charsSinceAccepts = 0;
          latestAccepting = state;
        } else if (sinceAccepts >= 0) {
          sinceAccepts += iterable[charCursor].length;
          charsSinceAccepts++;
        }
        tokenLength += iterable[charCursor].length;
        cursor += iterable[charCursor].length;
        charCursor++;
      }
      cursor -= sinceAccepts;
      charCursor -= charsSinceAccepts;
      tokenLength -= sinceAccepts;
      tokens.push({
        t: latestAccepting.t,
        v: str.substr(cursor - tokenLength, tokenLength),
        s: cursor - tokenLength,
        e: cursor
      });
    }
    return tokens;
  }
  function stringToArray(str) {
    var result2 = [];
    var len = str.length;
    var index3 = 0;
    while (index3 < len) {
      var first2 = str.charCodeAt(index3);
      var second = void 0;
      var char = first2 < 55296 || first2 > 56319 || index3 + 1 === len || (second = str.charCodeAt(index3 + 1)) < 56320 || second > 57343 ? str[index3] : str.slice(index3, index3 + 2);
      result2.push(char);
      index3 += char.length;
    }
    return result2;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  var defaults = {
    defaultProtocol: "http",
    events: null,
    format: noop,
    formatHref: noop,
    nl2br: false,
    tagName: "a",
    target: null,
    rel: null,
    validate: true,
    truncate: 0,
    className: null,
    attributes: null,
    ignoreTags: []
  };
  function Options(opts) {
    opts = opts || {};
    this.defaultProtocol = "defaultProtocol" in opts ? opts.defaultProtocol : defaults.defaultProtocol;
    this.events = "events" in opts ? opts.events : defaults.events;
    this.format = "format" in opts ? opts.format : defaults.format;
    this.formatHref = "formatHref" in opts ? opts.formatHref : defaults.formatHref;
    this.nl2br = "nl2br" in opts ? opts.nl2br : defaults.nl2br;
    this.tagName = "tagName" in opts ? opts.tagName : defaults.tagName;
    this.target = "target" in opts ? opts.target : defaults.target;
    this.rel = "rel" in opts ? opts.rel : defaults.rel;
    this.validate = "validate" in opts ? opts.validate : defaults.validate;
    this.truncate = "truncate" in opts ? opts.truncate : defaults.truncate;
    this.className = "className" in opts ? opts.className : defaults.className;
    this.attributes = opts.attributes || defaults.attributes;
    this.ignoreTags = [];
    var ignoredTags = "ignoreTags" in opts ? opts.ignoreTags : defaults.ignoreTags;
    for (var i = 0; i < ignoredTags.length; i++) {
      this.ignoreTags.push(ignoredTags[i].toUpperCase());
    }
  }
  Options.prototype = {
    resolve: function resolve13(token) {
      var href = token.toHref(this.defaultProtocol);
      return {
        formatted: this.get("format", token.toString(), token),
        formattedHref: this.get("formatHref", href, token),
        tagName: this.get("tagName", href, token),
        className: this.get("className", href, token),
        target: this.get("target", href, token),
        rel: this.get("rel", href, token),
        events: this.getObject("events", href, token),
        attributes: this.getObject("attributes", href, token),
        truncate: this.get("truncate", href, token)
      };
    },
    check: function check3(token) {
      return this.get("validate", token.toString(), token);
    },
    get: function get5(key2, operator, token) {
      var option = this[key2];
      if (!option) {
        return option;
      }
      var optionValue;
      switch (_typeof(option)) {
        case "function":
          return option(operator, token.t);
        case "object":
          optionValue = token.t in option ? option[token.t] : defaults[key2];
          return typeof optionValue === "function" ? optionValue(operator, token.t) : optionValue;
      }
      return option;
    },
    getObject: function getObject(key2, operator, token) {
      var option = this[key2];
      return typeof option === "function" ? option(operator, token.t) : option;
    }
  };
  function noop(val) {
    return val;
  }
  function inherits(parent, child5) {
    var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var extended = Object.create(parent.prototype);
    for (var p in props) {
      extended[p] = props[p];
    }
    extended.constructor = child5;
    child5.prototype = extended;
    return child5;
  }
  function MultiToken() {
  }
  MultiToken.prototype = {
    t: "token",
    isLink: false,
    toString: function toString13() {
      return this.v;
    },
    toHref: function toHref() {
      return this.toString();
    },
    startIndex: function startIndex() {
      return this.tk[0].s;
    },
    endIndex: function endIndex() {
      return this.tk[this.tk.length - 1].e;
    },
    toObject: function toObject() {
      var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults.defaultProtocol;
      return {
        type: this.t,
        value: this.v,
        isLink: this.isLink,
        href: this.toHref(protocol),
        start: this.startIndex(),
        end: this.endIndex()
      };
    }
  };
  function createTokenClass(type, props) {
    function Token(value, tokens) {
      this.t = type;
      this.v = value;
      this.tk = tokens;
    }
    inherits(MultiToken, Token, props);
    return Token;
  }
  var MailtoEmail = createTokenClass("email", {
    isLink: true
  });
  var Email = createTokenClass("email", {
    isLink: true,
    toHref: function toHref2() {
      return "mailto:" + this.toString();
    }
  });
  var Text2 = createTokenClass("text");
  var Nl = createTokenClass("nl");
  var Url = createTokenClass("url", {
    isLink: true,
    toHref: function toHref3() {
      var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults.defaultProtocol;
      var tokens = this.tk;
      var hasProtocol2 = false;
      var hasSlashSlash = false;
      var result2 = [];
      var i = 0;
      while (tokens[i].t === PROTOCOL) {
        hasProtocol2 = true;
        result2.push(tokens[i].v);
        i++;
      }
      while (tokens[i].t === SLASH) {
        hasSlashSlash = true;
        result2.push(tokens[i].v);
        i++;
      }
      for (; i < tokens.length; i++) {
        result2.push(tokens[i].v);
      }
      result2 = result2.join("");
      if (!(hasProtocol2 || hasSlashSlash)) {
        result2 = "".concat(protocol, "://").concat(result2);
      }
      return result2;
    },
    hasProtocol: function hasProtocol() {
      return this.tk[0].t === PROTOCOL;
    }
  });
  var multi = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MultiToken,
    Base: MultiToken,
    createTokenClass,
    MailtoEmail,
    Email,
    Text: Text2,
    Nl,
    Url
  });
  function init$1() {
    var S_START = makeState();
    var S_PROTOCOL = makeState();
    var S_MAILTO = makeState();
    var S_PROTOCOL_SLASH = makeState();
    var S_PROTOCOL_SLASH_SLASH = makeState();
    var S_DOMAIN = makeState();
    var S_DOMAIN_DOT = makeState();
    var S_TLD = makeAcceptingState(Url);
    var S_TLD_COLON = makeState();
    var S_TLD_PORT = makeAcceptingState(Url);
    var S_URL = makeAcceptingState(Url);
    var S_URL_NON_ACCEPTING = makeState();
    var S_URL_OPENBRACE = makeState();
    var S_URL_OPENBRACKET = makeState();
    var S_URL_OPENANGLEBRACKET = makeState();
    var S_URL_OPENPAREN = makeState();
    var S_URL_OPENBRACE_Q = makeAcceptingState(Url);
    var S_URL_OPENBRACKET_Q = makeAcceptingState(Url);
    var S_URL_OPENANGLEBRACKET_Q = makeAcceptingState(Url);
    var S_URL_OPENPAREN_Q = makeAcceptingState(Url);
    var S_URL_OPENBRACE_SYMS = makeState();
    var S_URL_OPENBRACKET_SYMS = makeState();
    var S_URL_OPENANGLEBRACKET_SYMS = makeState();
    var S_URL_OPENPAREN_SYMS = makeState();
    var S_EMAIL_DOMAIN = makeState();
    var S_EMAIL_DOMAIN_DOT = makeState();
    var S_EMAIL = makeAcceptingState(Email);
    var S_EMAIL_COLON = makeState();
    var S_EMAIL_PORT = makeAcceptingState(Email);
    var S_MAILTO_EMAIL = makeAcceptingState(MailtoEmail);
    var S_MAILTO_EMAIL_NON_ACCEPTING = makeState();
    var S_LOCALPART = makeState();
    var S_LOCALPART_AT = makeState();
    var S_LOCALPART_DOT = makeState();
    var S_NL = makeAcceptingState(Nl);
    makeT(S_START, NL, S_NL);
    makeT(S_START, PROTOCOL, S_PROTOCOL);
    makeT(S_START, MAILTO, S_MAILTO);
    makeT(S_PROTOCOL, SLASH, S_PROTOCOL_SLASH);
    makeT(S_PROTOCOL_SLASH, SLASH, S_PROTOCOL_SLASH_SLASH);
    makeT(S_START, TLD, S_DOMAIN);
    makeT(S_START, DOMAIN, S_DOMAIN);
    makeT(S_START, LOCALHOST, S_TLD);
    makeT(S_START, NUM, S_DOMAIN);
    makeT(S_PROTOCOL_SLASH_SLASH, TLD, S_URL);
    makeT(S_PROTOCOL_SLASH_SLASH, DOMAIN, S_URL);
    makeT(S_PROTOCOL_SLASH_SLASH, NUM, S_URL);
    makeT(S_PROTOCOL_SLASH_SLASH, LOCALHOST, S_URL);
    makeT(S_DOMAIN, DOT, S_DOMAIN_DOT);
    makeT(S_EMAIL_DOMAIN, DOT, S_EMAIL_DOMAIN_DOT);
    makeT(S_DOMAIN_DOT, TLD, S_TLD);
    makeT(S_DOMAIN_DOT, DOMAIN, S_DOMAIN);
    makeT(S_DOMAIN_DOT, NUM, S_DOMAIN);
    makeT(S_DOMAIN_DOT, LOCALHOST, S_DOMAIN);
    makeT(S_EMAIL_DOMAIN_DOT, TLD, S_EMAIL);
    makeT(S_EMAIL_DOMAIN_DOT, DOMAIN, S_EMAIL_DOMAIN);
    makeT(S_EMAIL_DOMAIN_DOT, NUM, S_EMAIL_DOMAIN);
    makeT(S_EMAIL_DOMAIN_DOT, LOCALHOST, S_EMAIL_DOMAIN);
    makeT(S_TLD, DOT, S_DOMAIN_DOT);
    makeT(S_EMAIL, DOT, S_EMAIL_DOMAIN_DOT);
    makeT(S_TLD, COLON, S_TLD_COLON);
    makeT(S_TLD, SLASH, S_URL);
    makeT(S_TLD_COLON, NUM, S_TLD_PORT);
    makeT(S_TLD_PORT, SLASH, S_URL);
    makeT(S_EMAIL, COLON, S_EMAIL_COLON);
    makeT(S_EMAIL_COLON, NUM, S_EMAIL_PORT);
    var qsAccepting = [AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, DOMAIN, EQUALS, HYPHEN, LOCALHOST, NUM, PERCENT, PIPE, PLUS, POUND, PROTOCOL, SLASH, SYM, TILDE, TLD, UNDERSCORE];
    var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
    makeT(S_URL, OPENBRACE, S_URL_OPENBRACE);
    makeT(S_URL, OPENBRACKET, S_URL_OPENBRACKET);
    makeT(S_URL, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
    makeT(S_URL, OPENPAREN, S_URL_OPENPAREN);
    makeT(S_URL_NON_ACCEPTING, OPENBRACE, S_URL_OPENBRACE);
    makeT(S_URL_NON_ACCEPTING, OPENBRACKET, S_URL_OPENBRACKET);
    makeT(S_URL_NON_ACCEPTING, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
    makeT(S_URL_NON_ACCEPTING, OPENPAREN, S_URL_OPENPAREN);
    makeT(S_URL_OPENBRACE, CLOSEBRACE, S_URL);
    makeT(S_URL_OPENBRACKET, CLOSEBRACKET, S_URL);
    makeT(S_URL_OPENANGLEBRACKET, CLOSEANGLEBRACKET, S_URL);
    makeT(S_URL_OPENPAREN, CLOSEPAREN, S_URL);
    makeT(S_URL_OPENBRACE_Q, CLOSEBRACE, S_URL);
    makeT(S_URL_OPENBRACKET_Q, CLOSEBRACKET, S_URL);
    makeT(S_URL_OPENANGLEBRACKET_Q, CLOSEANGLEBRACKET, S_URL);
    makeT(S_URL_OPENPAREN_Q, CLOSEPAREN, S_URL);
    makeT(S_URL_OPENBRACE_SYMS, CLOSEBRACE, S_URL);
    makeT(S_URL_OPENBRACKET_SYMS, CLOSEBRACKET, S_URL);
    makeT(S_URL_OPENANGLEBRACKET_SYMS, CLOSEANGLEBRACKET, S_URL);
    makeT(S_URL_OPENPAREN_SYMS, CLOSEPAREN, S_URL);
    makeMultiT(S_URL_OPENBRACE, qsAccepting, S_URL_OPENBRACE_Q);
    makeMultiT(S_URL_OPENBRACKET, qsAccepting, S_URL_OPENBRACKET_Q);
    makeMultiT(S_URL_OPENANGLEBRACKET, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    makeMultiT(S_URL_OPENPAREN, qsAccepting, S_URL_OPENPAREN_Q);
    makeMultiT(S_URL_OPENBRACE, qsNonAccepting, S_URL_OPENBRACE_SYMS);
    makeMultiT(S_URL_OPENBRACKET, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
    makeMultiT(S_URL_OPENANGLEBRACKET, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
    makeMultiT(S_URL_OPENPAREN, qsNonAccepting, S_URL_OPENPAREN_SYMS);
    makeMultiT(S_URL_OPENBRACE_Q, qsAccepting, S_URL_OPENBRACE_Q);
    makeMultiT(S_URL_OPENBRACKET_Q, qsAccepting, S_URL_OPENBRACKET_Q);
    makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    makeMultiT(S_URL_OPENPAREN_Q, qsAccepting, S_URL_OPENPAREN_Q);
    makeMultiT(S_URL_OPENBRACE_Q, qsNonAccepting, S_URL_OPENBRACE_Q);
    makeMultiT(S_URL_OPENBRACKET_Q, qsNonAccepting, S_URL_OPENBRACKET_Q);
    makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
    makeMultiT(S_URL_OPENPAREN_Q, qsNonAccepting, S_URL_OPENPAREN_Q);
    makeMultiT(S_URL_OPENBRACE_SYMS, qsAccepting, S_URL_OPENBRACE_Q);
    makeMultiT(S_URL_OPENBRACKET_SYMS, qsAccepting, S_URL_OPENBRACKET_Q);
    makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    makeMultiT(S_URL_OPENPAREN_SYMS, qsAccepting, S_URL_OPENPAREN_Q);
    makeMultiT(S_URL_OPENBRACE_SYMS, qsNonAccepting, S_URL_OPENBRACE_SYMS);
    makeMultiT(S_URL_OPENBRACKET_SYMS, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
    makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
    makeMultiT(S_URL_OPENPAREN_SYMS, qsNonAccepting, S_URL_OPENPAREN_SYMS);
    makeMultiT(S_URL, qsAccepting, S_URL);
    makeMultiT(S_URL_NON_ACCEPTING, qsAccepting, S_URL);
    makeMultiT(S_URL, qsNonAccepting, S_URL_NON_ACCEPTING);
    makeMultiT(S_URL_NON_ACCEPTING, qsNonAccepting, S_URL_NON_ACCEPTING);
    makeT(S_MAILTO, TLD, S_MAILTO_EMAIL);
    makeT(S_MAILTO, DOMAIN, S_MAILTO_EMAIL);
    makeT(S_MAILTO, NUM, S_MAILTO_EMAIL);
    makeT(S_MAILTO, LOCALHOST, S_MAILTO_EMAIL);
    makeMultiT(S_MAILTO_EMAIL, qsAccepting, S_MAILTO_EMAIL);
    makeMultiT(S_MAILTO_EMAIL, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
    makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsAccepting, S_MAILTO_EMAIL);
    makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
    var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, DOMAIN, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, TLD, UNDERSCORE];
    makeMultiT(S_DOMAIN, localpartAccepting, S_LOCALPART);
    makeT(S_DOMAIN, AT, S_LOCALPART_AT);
    makeMultiT(S_TLD, localpartAccepting, S_LOCALPART);
    makeT(S_TLD, AT, S_LOCALPART_AT);
    makeMultiT(S_DOMAIN_DOT, localpartAccepting, S_LOCALPART);
    makeMultiT(S_LOCALPART, localpartAccepting, S_LOCALPART);
    makeT(S_LOCALPART, AT, S_LOCALPART_AT);
    makeT(S_LOCALPART, DOT, S_LOCALPART_DOT);
    makeMultiT(S_LOCALPART_DOT, localpartAccepting, S_LOCALPART);
    makeT(S_LOCALPART_AT, TLD, S_EMAIL_DOMAIN);
    makeT(S_LOCALPART_AT, DOMAIN, S_EMAIL_DOMAIN);
    makeT(S_LOCALPART_AT, NUM, S_EMAIL_DOMAIN);
    makeT(S_LOCALPART_AT, LOCALHOST, S_EMAIL);
    return S_START;
  }
  function run2(start6, input, tokens) {
    var len = tokens.length;
    var cursor = 0;
    var multis = [];
    var textTokens = [];
    while (cursor < len) {
      var state = start6;
      var secondState = null;
      var nextState = null;
      var multiLength = 0;
      var latestAccepting = null;
      var sinceAccepts = -1;
      while (cursor < len && !(secondState = takeT(state, tokens[cursor].t))) {
        textTokens.push(tokens[cursor++]);
      }
      while (cursor < len && (nextState = secondState || takeT(state, tokens[cursor].t))) {
        secondState = null;
        state = nextState;
        if (state.accepts()) {
          sinceAccepts = 0;
          latestAccepting = state;
        } else if (sinceAccepts >= 0) {
          sinceAccepts++;
        }
        cursor++;
        multiLength++;
      }
      if (sinceAccepts < 0) {
        for (var i = cursor - multiLength; i < cursor; i++) {
          textTokens.push(tokens[i]);
        }
      } else {
        if (textTokens.length > 0) {
          multis.push(parserCreateMultiToken(Text2, input, textTokens));
          textTokens = [];
        }
        cursor -= sinceAccepts;
        multiLength -= sinceAccepts;
        var Multi = latestAccepting.t;
        var subtokens = tokens.slice(cursor - multiLength, cursor);
        multis.push(parserCreateMultiToken(Multi, input, subtokens));
      }
    }
    if (textTokens.length > 0) {
      multis.push(parserCreateMultiToken(Text2, input, textTokens));
    }
    return multis;
  }
  function parserCreateMultiToken(Multi, input, tokens) {
    var startIdx = tokens[0].s;
    var endIdx = tokens[tokens.length - 1].e;
    var value = input.substr(startIdx, endIdx - startIdx);
    return new Multi(value, tokens);
  }
  var INIT = {
    scanner: null,
    parser: null,
    pluginQueue: [],
    customProtocols: [],
    initialized: false
  };
  function init9() {
    INIT.scanner = {
      start: init$2(INIT.customProtocols),
      tokens: text2
    };
    INIT.parser = {
      start: init$1(),
      tokens: multi
    };
    var utils = {
      createTokenClass
    };
    for (var i = 0; i < INIT.pluginQueue.length; i++) {
      INIT.pluginQueue[i][1]({
        scanner: INIT.scanner,
        parser: INIT.parser,
        utils
      });
    }
    INIT.initialized = true;
  }
  function tokenize2(str) {
    if (!INIT.initialized) {
      init9();
    }
    return run2(INIT.parser.start, str, run$12(INIT.scanner.start, str));
  }
  function find2(str) {
    var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var tokens = tokenize2(str);
    var filtered = [];
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (token.isLink && (!type || token.t === type)) {
        filtered.push(token.toObject());
      }
    }
    return filtered;
  }
  function test(str) {
    var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var tokens = tokenize2(str);
    return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);
  }

  // node_modules/@tiptap/extension-link/dist/tiptap-extension-link.esm.js
  function autolink(options) {
    return new Plugin({
      key: new PluginKey("autolink"),
      appendTransaction: (transactions, oldState, newState) => {
        const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
        const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
        if (!docChanges || preventAutolink) {
          return;
        }
        const { tr } = newState;
        const transform = combineTransactionSteps(oldState.doc, transactions);
        const { mapping } = transform;
        const changes = getChangedRanges(transform);
        changes.forEach(({ oldRange, newRange }) => {
          getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter((item) => item.mark.type === options.type).forEach((oldMark) => {
            const newFrom = mapping.map(oldMark.from);
            const newTo = mapping.map(oldMark.to);
            const newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter((item) => item.mark.type === options.type);
            if (!newMarks.length) {
              return;
            }
            const newMark = newMarks[0];
            const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, void 0, " ");
            const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, void 0, " ");
            const wasLink = test(oldLinkText);
            const isLink = test(newLinkText);
            if (wasLink && !isLink) {
              tr.removeMark(newMark.from, newMark.to, options.type);
            }
          });
          findChildrenInRange(newState.doc, newRange, (node5) => node5.isTextblock).forEach((textBlock) => {
            const text4 = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
            find2(text4).filter((link) => link.isLink).map((link) => ({
              ...link,
              from: textBlock.pos + link.start + 1,
              to: textBlock.pos + link.end + 1
            })).filter((link) => {
              const fromIsInRange = newRange.from >= link.from && newRange.from <= link.to;
              const toIsInRange = newRange.to >= link.from && newRange.to <= link.to;
              return fromIsInRange || toIsInRange;
            }).forEach((link) => {
              tr.addMark(link.from, link.to, options.type.create({
                href: link.href
              }));
            });
          });
        });
        if (!tr.steps.length) {
          return;
        }
        return tr;
      }
    });
  }
  function clickHandler(options) {
    return new Plugin({
      key: new PluginKey("handleClickLink"),
      props: {
        handleClick: (view, pos, event) => {
          var _a;
          const attrs = getAttributes(view.state, options.type.name);
          const link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest("a");
          if (link && attrs.href) {
            window.open(attrs.href, attrs.target);
            return true;
          }
          return false;
        }
      }
    });
  }
  function pasteHandler(options) {
    return new Plugin({
      key: new PluginKey("handlePasteLink"),
      props: {
        handlePaste: (view, event, slice6) => {
          const { state } = view;
          const { selection } = state;
          const { empty: empty2 } = selection;
          if (empty2) {
            return false;
          }
          let textContent = "";
          slice6.content.forEach((node5) => {
            textContent += node5.textContent;
          });
          const link = find2(textContent).find((item) => item.isLink && item.value === textContent);
          if (!textContent || !link) {
            return false;
          }
          options.editor.commands.setMark(options.type, {
            href: link.href
          });
          return true;
        }
      }
    });
  }
  var Link = Mark3.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: false,
    inclusive() {
      return this.options.autolink;
    },
    addOptions() {
      return {
        openOnClick: true,
        linkOnPaste: true,
        autolink: true,
        HTMLAttributes: {
          target: "_blank",
          rel: "noopener noreferrer nofollow"
        }
      };
    },
    addAttributes() {
      return {
        href: {
          default: null
        },
        target: {
          default: this.options.HTMLAttributes.target
        }
      };
    },
    parseHTML() {
      return [
        { tag: "a[href]" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return [
        "a",
        mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
        0
      ];
    },
    addCommands() {
      return {
        setLink: (attributes) => ({ chain }) => {
          return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
        },
        toggleLink: (attributes) => ({ chain }) => {
          return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
        },
        unsetLink: () => ({ chain }) => {
          return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
        }
      };
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: (text4) => find2(text4).filter((link) => link.isLink).map((link) => ({
            text: link.value,
            index: link.start,
            data: link
          })),
          type: this.type,
          getAttributes: (match) => {
            var _a;
            return {
              href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href
            };
          }
        })
      ];
    },
    addProseMirrorPlugins() {
      const plugins = [];
      if (this.options.autolink) {
        plugins.push(autolink({
          type: this.type
        }));
      }
      if (this.options.openOnClick) {
        plugins.push(clickHandler({
          type: this.type
        }));
      }
      if (this.options.linkOnPaste) {
        plugins.push(pasteHandler({
          editor: this.editor,
          type: this.type
        }));
      }
      return plugins;
    }
  });

  // app/javascript/documentation/controllers/rich_text_editor/with_link.js
  var defaultOptions3 = {
    openOnClick: false
  };
  var linkTargets = ["linkPanel", "linkInput"];
  var with_link_default = (controller, options = {}) => {
    const { openOnClick } = Object.assign({}, defaultOptions3, options);
    const LinkExtensions = [
      Link.configure({
        openOnClick
      })
    ];
    const closeLinkPanel = () => {
      if (!controller.hasLinkPanelTarget)
        return;
      controller.linkPanelTarget.classList.remove("is-active");
    };
    const openLinkPanel = () => {
      controller.closeNodeSelect();
      controller.closeTablePanel();
      const link = controller.editor.getAttributes("link");
      controller.linkInputTarget.innerHTML = link.href || "";
      controller.linkInputTarget.focus();
    };
    const saveLinkUrl = (event) => {
      if (event.key !== "Enter")
        return;
      const url = event.target.innerHTML;
      if (url == "") {
        controller.editor.chain().focus().extendMarkRange("link").unsetLink().run();
      } else {
        controller.editor.chain().focus().extendMarkRange("link").setLink({ href: event.target.innerHTML, target: "_blank" }).run();
      }
      controller.linkInputTarget.innerHTML = "";
    };
    const savePageLink = (event) => {
      const { url } = event.target.dataset;
      controller.editor.chain().focus().extendMarkRange("link").setLink({ href: url, target: "_blank" }).run();
    };
    Object.assign(controller, {
      closeLinkPanel,
      openLinkPanel,
      saveLinkUrl,
      savePageLink
    });
    return { LinkExtensions };
  };

  // node_modules/@tiptap/suggestion/dist/tiptap-suggestion.esm.js
  function findSuggestionMatch(config) {
    const { char, allowSpaces, prefixSpace, startOfLine, $position } = config;
    const escapedChar = escapeForRegEx(char);
    const suffix = new RegExp(`\\s${escapedChar}$`);
    const prefix = startOfLine ? "^" : "";
    const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${escapedChar}|$)`, "gm") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${escapedChar}]*`, "gm");
    const isTopLevelNode = $position.depth <= 0;
    const textFrom = isTopLevelNode ? 0 : $position.before();
    const textTo = $position.pos;
    const text4 = $position.doc.textBetween(textFrom, textTo, "\0", "\0");
    const match = Array.from(text4.matchAll(regexp)).pop();
    if (!match || match.input === void 0 || match.index === void 0) {
      return null;
    }
    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
    const matchPrefixIsSpace = /^[\s\0]?$/.test(matchPrefix);
    if (prefixSpace && !matchPrefixIsSpace) {
      return null;
    }
    const from5 = match.index + $position.start();
    let to = from5 + match[0].length;
    if (allowSpaces && suffix.test(text4.slice(to - 1, to + 1))) {
      match[0] += " ";
      to += 1;
    }
    if (from5 < $position.pos && to >= $position.pos) {
      return {
        range: {
          from: from5,
          to
        },
        query: match[0].slice(char.length),
        text: match[0]
      };
    }
    return null;
  }
  var SuggestionPluginKey = new PluginKey("suggestion");
  function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, prefixSpace = true, startOfLine = false, decorationTag = "span", decorationClass = "suggestion", command: command2 = () => null, items = () => [], render: render2 = () => ({}), allow = () => true }) {
    let props;
    const renderer = render2 === null || render2 === void 0 ? void 0 : render2();
    return new Plugin({
      key: pluginKey,
      view() {
        return {
          update: async (view, prevState) => {
            var _a, _b, _c, _d, _e;
            const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
            const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
            const moved = prev.active && next.active && prev.range.from !== next.range.from;
            const started = !prev.active && next.active;
            const stopped = prev.active && !next.active;
            const changed = !started && !stopped && prev.query !== next.query;
            const handleStart = started || moved;
            const handleChange = changed && !moved;
            const handleExit = stopped || moved;
            if (!handleStart && !handleChange && !handleExit) {
              return;
            }
            const state = handleExit && !handleStart ? prev : next;
            const decorationNode = document.querySelector(`[data-decoration-id="${state.decorationId}"]`);
            props = {
              editor,
              range: state.range,
              query: state.query,
              text: state.text,
              items: handleChange || handleStart ? await items({
                editor,
                query: state.query
              }) : [],
              command: (commandProps) => {
                command2({
                  editor,
                  range: state.range,
                  props: commandProps
                });
              },
              decorationNode,
              clientRect: decorationNode ? () => {
                var _a2;
                const { decorationId } = (_a2 = this.key) === null || _a2 === void 0 ? void 0 : _a2.getState(editor.state);
                const currentDecorationNode = document.querySelector(`[data-decoration-id="${decorationId}"]`);
                return currentDecorationNode.getBoundingClientRect();
              } : null
            };
            if (handleExit) {
              (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
            }
            if (handleChange) {
              (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
            }
            if (handleStart) {
              (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
            }
          },
          destroy: () => {
            var _a;
            if (!props) {
              return;
            }
            (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);
          }
        };
      },
      state: {
        init() {
          return {
            active: false,
            range: {},
            query: null,
            text: null,
            composing: false
          };
        },
        apply(transaction, prev, oldState, state) {
          const { composing } = editor.view;
          const { selection } = transaction;
          const { empty: empty2, from: from5 } = selection;
          const next = { ...prev };
          next.composing = composing;
          if (empty2 || editor.view.composing) {
            if ((from5 < prev.range.from || from5 > prev.range.to) && !composing && !prev.composing) {
              next.active = false;
            }
            const match = findSuggestionMatch({
              char,
              allowSpaces,
              prefixSpace,
              startOfLine,
              $position: selection.$from
            });
            const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
            if (match && allow({ editor, state, range: match.range })) {
              next.active = true;
              next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
              next.range = match.range;
              next.query = match.query;
              next.text = match.text;
            } else {
              next.active = false;
            }
          } else {
            next.active = false;
          }
          if (!next.active) {
            next.decorationId = null;
            next.range = {};
            next.query = null;
            next.text = null;
          }
          return next;
        }
      },
      props: {
        handleKeyDown(view, event) {
          var _a;
          const { active, range } = this.getState(view.state);
          if (!active) {
            return false;
          }
          return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;
        },
        decorations(state) {
          const { active, range, decorationId } = this.getState(state);
          if (!active) {
            return null;
          }
          return DecorationSet.create(state.doc, [
            Decoration.inline(range.from, range.to, {
              nodeName: decorationTag,
              class: decorationClass,
              "data-decoration-id": decorationId
            })
          ]);
        }
      }
    });
  }

  // node_modules/@tiptap/extension-mention/dist/tiptap-extension-mention.esm.js
  var MentionPluginKey = new PluginKey("mention");
  var Mention = Node4.create({
    name: "mention",
    addOptions() {
      return {
        HTMLAttributes: {},
        renderLabel({ options, node: node5 }) {
          var _a;
          return `${options.suggestion.char}${(_a = node5.attrs.label) !== null && _a !== void 0 ? _a : node5.attrs.id}`;
        },
        suggestion: {
          char: "@",
          pluginKey: MentionPluginKey,
          command: ({ editor, range, props }) => {
            var _a;
            const nodeAfter = editor.view.state.selection.$to.nodeAfter;
            const overrideSpace = (_a = nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.text) === null || _a === void 0 ? void 0 : _a.startsWith(" ");
            if (overrideSpace) {
              range.to += 1;
            }
            editor.chain().focus().insertContentAt(range, [
              {
                type: this.name,
                attrs: props
              },
              {
                type: "text",
                text: " "
              }
            ]).run();
          },
          allow: ({ state, range }) => {
            const $from = state.doc.resolve(range.from);
            const type = state.schema.nodes[this.name];
            const allow = !!$from.parent.type.contentMatch.matchType(type);
            return allow;
          }
        }
      };
    },
    group: "inline",
    inline: true,
    selectable: false,
    atom: true,
    addAttributes() {
      return {
        id: {
          default: null,
          parseHTML: (element) => element.getAttribute("data-id"),
          renderHTML: (attributes) => {
            if (!attributes.id) {
              return {};
            }
            return {
              "data-id": attributes.id
            };
          }
        },
        label: {
          default: null,
          parseHTML: (element) => element.getAttribute("data-label"),
          renderHTML: (attributes) => {
            if (!attributes.label) {
              return {};
            }
            return {
              "data-label": attributes.label
            };
          }
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: `span[data-type="${this.name}"]`
        }
      ];
    },
    renderHTML({ node: node5, HTMLAttributes }) {
      return [
        "span",
        mergeAttributes({ "data-type": this.name }, this.options.HTMLAttributes, HTMLAttributes),
        this.options.renderLabel({
          options: this.options,
          node: node5
        })
      ];
    },
    renderText({ node: node5 }) {
      return this.options.renderLabel({
        options: this.options,
        node: node5
      });
    },
    addKeyboardShortcuts() {
      return {
        Backspace: () => this.editor.commands.command(({ tr, state }) => {
          let isMention = false;
          const { selection } = state;
          const { empty: empty2, anchor } = selection;
          if (!empty2) {
            return false;
          }
          state.doc.nodesBetween(anchor - 1, anchor, (node5, pos) => {
            if (node5.type.name === this.name) {
              isMention = true;
              tr.insertText(this.options.suggestion.char || "", pos, pos + node5.nodeSize);
              return false;
            }
          });
          return isMention;
        })
      };
    },
    addProseMirrorPlugins() {
      return [
        Suggestion({
          editor: this.editor,
          ...this.options.suggestion
        })
      ];
    }
  });

  // app/javascript/documentation/controllers/rich_text_editor/popup_list_component.js
  var createRoot = () => {
    const div2 = document.createElement("div");
    div2.classList.add("dropdown-content");
    return div2;
  };
  var createItem = (item, classNames = "") => {
    const div2 = document.createElement("div");
    div2.classList.add("dropdown-item", classNames);
    div2.innerHTML = item.title;
    return div2;
  };
  var PopUpListComponent = class {
    constructor(items = [], command2 = () => {
    }) {
      this.selectedIndex = 0;
      this.items = items;
      this.element = createRoot();
      this.command = command2;
    }
    render() {
      this.element.innerHTML = "";
      this.items.forEach((item, index3) => {
        const classNames = index3 === this.selectedIndex ? "is-active" : "inactive";
        this.element.appendChild(createItem(item, classNames));
      });
      return this.element;
    }
    updateProps({ items, command: command2 }) {
      this.items = items;
      this.command = command2;
    }
    selectActiveItem() {
      const { id, url, title } = this.items[this.selectedIndex];
      this.command({ id: url, url, label: title });
    }
    updateActiveItem(index3) {
      this.selectedIndex = index3;
      this.render();
    }
    goUp() {
      const newSelectedIndex = (this.selectedIndex + this.items.length - 1) % this.items.length;
      this.updateActiveItem(newSelectedIndex);
    }
    goDown() {
      const newSelectedIndex = (this.selectedIndex + 1) % this.items.length;
      this.updateActiveItem(newSelectedIndex);
    }
    destroy() {
      this.element.remove();
    }
  };

  // app/javascript/documentation/controllers/rich_text_editor/suggestion.js
  var suggestion_default = {
    items: async ({ query }) => {
      const response = await get("/documentation/pages", {
        query: { title: query },
        responseKind: "json"
      });
      if (!response.ok)
        return [];
      return await response.json;
    },
    render: () => {
      let component = new PopUpListComponent();
      let popup;
      return {
        onStart: ({ clientRect: clientRect2 }) => {
          popup = tippy_esm_default("body", {
            getReferenceClientRect: clientRect2,
            appendTo: () => document.body,
            allowHTML: true,
            content: component.render(),
            showOnCreate: true,
            interactive: true,
            trigger: "manual",
            placement: "bottom-start",
            arrow: false
          });
        },
        onUpdate({ items, command: command2, clientRect: clientRect2 }) {
          component.updateProps({ items, command: command2 });
          component.render();
          popup[0].setProps({ getReferenceClientRect: clientRect2 });
        },
        onKeyDown({ event }) {
          if (event.key === "Escape") {
            popup[0].hide();
            return true;
          } else if (event.key === "Enter") {
            component.selectActiveItem();
            return true;
          } else if (event.key === "ArrowUp") {
            component.goUp();
            return true;
          } else if (event.key === "ArrowDown") {
            component.goDown();
            return true;
          }
        },
        onExit() {
          popup[0].destroy();
          component.destroy();
        }
      };
    }
  };

  // app/javascript/documentation/controllers/rich_text_editor/with_mention.js
  var with_mention_default = (_controller, _options = {}) => {
    const MentionExtensions = [
      Mention.configure({
        HTMLAttributes: {
          class: "suggestion"
        },
        renderLabel({ options, node: node5 }) {
          return `${options.suggestion.char}${node5.attrs.label}`;
        },
        suggestion: suggestion_default
      })
    ];
    return { MentionExtensions };
  };

  // node_modules/@tiptap/extension-code-block-lowlight/dist/tiptap-extension-code-block-lowlight.esm.js
  var core$1 = {};
  function deepFreeze(obj) {
    if (obj instanceof Map) {
      obj.clear = obj.delete = obj.set = function() {
        throw new Error("map is read-only");
      };
    } else if (obj instanceof Set) {
      obj.add = obj.clear = obj.delete = function() {
        throw new Error("set is read-only");
      };
    }
    Object.freeze(obj);
    Object.getOwnPropertyNames(obj).forEach(function(name) {
      var prop = obj[name];
      if (typeof prop == "object" && !Object.isFrozen(prop)) {
        deepFreeze(prop);
      }
    });
    return obj;
  }
  var deepFreezeEs6 = deepFreeze;
  var _default = deepFreeze;
  deepFreezeEs6.default = _default;
  var Response = class {
    constructor(mode) {
      if (mode.data === void 0)
        mode.data = {};
      this.data = mode.data;
      this.isMatchIgnored = false;
    }
    ignoreMatch() {
      this.isMatchIgnored = true;
    }
  };
  function escapeHTML(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function inherit(original, ...objects) {
    const result2 = /* @__PURE__ */ Object.create(null);
    for (const key2 in original) {
      result2[key2] = original[key2];
    }
    objects.forEach(function(obj) {
      for (const key2 in obj) {
        result2[key2] = obj[key2];
      }
    });
    return result2;
  }
  var SPAN_CLOSE = "</span>";
  var emitsWrappingTags = (node5) => {
    return !!node5.kind;
  };
  var HTMLRenderer = class {
    constructor(parseTree, options) {
      this.buffer = "";
      this.classPrefix = options.classPrefix;
      parseTree.walk(this);
    }
    addText(text4) {
      this.buffer += escapeHTML(text4);
    }
    openNode(node5) {
      if (!emitsWrappingTags(node5))
        return;
      let className = node5.kind;
      if (!node5.sublanguage) {
        className = `${this.classPrefix}${className}`;
      }
      this.span(className);
    }
    closeNode(node5) {
      if (!emitsWrappingTags(node5))
        return;
      this.buffer += SPAN_CLOSE;
    }
    value() {
      return this.buffer;
    }
    span(className) {
      this.buffer += `<span class="${className}">`;
    }
  };
  var TokenTree = class {
    constructor() {
      this.rootNode = { children: [] };
      this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    add(node5) {
      this.top.children.push(node5);
    }
    openNode(kind) {
      const node5 = { kind, children: [] };
      this.add(node5);
      this.stack.push(node5);
    }
    closeNode() {
      if (this.stack.length > 1) {
        return this.stack.pop();
      }
      return void 0;
    }
    closeAllNodes() {
      while (this.closeNode())
        ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    walk(builder) {
      return this.constructor._walk(builder, this.rootNode);
    }
    static _walk(builder, node5) {
      if (typeof node5 === "string") {
        builder.addText(node5);
      } else if (node5.children) {
        builder.openNode(node5);
        node5.children.forEach((child5) => this._walk(builder, child5));
        builder.closeNode(node5);
      }
      return builder;
    }
    static _collapse(node5) {
      if (typeof node5 === "string")
        return;
      if (!node5.children)
        return;
      if (node5.children.every((el) => typeof el === "string")) {
        node5.children = [node5.children.join("")];
      } else {
        node5.children.forEach((child5) => {
          TokenTree._collapse(child5);
        });
      }
    }
  };
  var TokenTreeEmitter = class extends TokenTree {
    constructor(options) {
      super();
      this.options = options;
    }
    addKeyword(text4, kind) {
      if (text4 === "") {
        return;
      }
      this.openNode(kind);
      this.addText(text4);
      this.closeNode();
    }
    addText(text4) {
      if (text4 === "") {
        return;
      }
      this.add(text4);
    }
    addSublanguage(emitter, name) {
      const node5 = emitter.root;
      node5.kind = name;
      node5.sublanguage = true;
      this.add(node5);
    }
    toHTML() {
      const renderer = new HTMLRenderer(this, this.options);
      return renderer.value();
    }
    finalize() {
      return true;
    }
  };
  function escape(value) {
    return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "m");
  }
  function source(re) {
    if (!re)
      return null;
    if (typeof re === "string")
      return re;
    return re.source;
  }
  function concat(...args) {
    const joined = args.map((x) => source(x)).join("");
    return joined;
  }
  function either(...args) {
    const joined = "(" + args.map((x) => source(x)).join("|") + ")";
    return joined;
  }
  function countMatchGroups(re) {
    return new RegExp(re.toString() + "|").exec("").length - 1;
  }
  function startsWith(re, lexeme) {
    const match = re && re.exec(lexeme);
    return match && match.index === 0;
  }
  var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function join(regexps, separator = "|") {
    let numCaptures = 0;
    return regexps.map((regex) => {
      numCaptures += 1;
      const offset4 = numCaptures;
      let re = source(regex);
      let out = "";
      while (re.length > 0) {
        const match = BACKREF_RE.exec(re);
        if (!match) {
          out += re;
          break;
        }
        out += re.substring(0, match.index);
        re = re.substring(match.index + match[0].length);
        if (match[0][0] === "\\" && match[1]) {
          out += "\\" + String(Number(match[1]) + offset4);
        } else {
          out += match[0];
          if (match[0] === "(") {
            numCaptures++;
          }
        }
      }
      return out;
    }).map((re) => `(${re})`).join(separator);
  }
  var MATCH_NOTHING_RE = /\b\B/;
  var IDENT_RE = "[a-zA-Z]\\w*";
  var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
  var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
  var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
  var BINARY_NUMBER_RE = "\\b(0b[01]+)";
  var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
  var SHEBANG = (opts = {}) => {
    const beginShebang = /^#![ ]*\//;
    if (opts.binary) {
      opts.begin = concat(beginShebang, /.*\b/, opts.binary, /\b.*/);
    }
    return inherit({
      className: "meta",
      begin: beginShebang,
      end: /$/,
      relevance: 0,
      "on:begin": (m, resp) => {
        if (m.index !== 0)
          resp.ignoreMatch();
      }
    }, opts);
  };
  var BACKSLASH_ESCAPE = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  };
  var APOS_STRING_MODE = {
    className: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  var QUOTE_STRING_MODE = {
    className: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  var PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  var COMMENT = function(begin, end4, modeOptions = {}) {
    const mode = inherit({
      className: "comment",
      begin,
      end: end4,
      contains: []
    }, modeOptions);
    mode.contains.push(PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: "doctag",
      begin: "(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",
      relevance: 0
    });
    return mode;
  };
  var C_LINE_COMMENT_MODE = COMMENT("//", "$");
  var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
  var HASH_COMMENT_MODE = COMMENT("#", "$");
  var NUMBER_MODE = {
    className: "number",
    begin: NUMBER_RE,
    relevance: 0
  };
  var C_NUMBER_MODE = {
    className: "number",
    begin: C_NUMBER_RE,
    relevance: 0
  };
  var BINARY_NUMBER_MODE = {
    className: "number",
    begin: BINARY_NUMBER_RE,
    relevance: 0
  };
  var CSS_NUMBER_MODE = {
    className: "number",
    begin: NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  };
  var REGEXP_MODE = {
    begin: /(?=\/[^/\n]*\/)/,
    contains: [{
      className: "regexp",
      begin: /\//,
      end: /\/[gimuy]*/,
      illegal: /\n/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    }]
  };
  var TITLE_MODE = {
    className: "title",
    begin: IDENT_RE,
    relevance: 0
  };
  var UNDERSCORE_TITLE_MODE = {
    className: "title",
    begin: UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  var METHOD_GUARD = {
    begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  var END_SAME_AS_BEGIN = function(mode) {
    return Object.assign(mode, {
      "on:begin": (m, resp) => {
        resp.data._beginMatch = m[1];
      },
      "on:end": (m, resp) => {
        if (resp.data._beginMatch !== m[1])
          resp.ignoreMatch();
      }
    });
  };
  var MODES = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE,
    IDENT_RE,
    UNDERSCORE_IDENT_RE,
    NUMBER_RE,
    C_NUMBER_RE,
    BINARY_NUMBER_RE,
    RE_STARTERS_RE,
    SHEBANG,
    BACKSLASH_ESCAPE,
    APOS_STRING_MODE,
    QUOTE_STRING_MODE,
    PHRASAL_WORDS_MODE,
    COMMENT,
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    HASH_COMMENT_MODE,
    NUMBER_MODE,
    C_NUMBER_MODE,
    BINARY_NUMBER_MODE,
    CSS_NUMBER_MODE,
    REGEXP_MODE,
    TITLE_MODE,
    UNDERSCORE_TITLE_MODE,
    METHOD_GUARD,
    END_SAME_AS_BEGIN
  });
  function skipIfhasPrecedingDot(match, response) {
    const before3 = match.input[match.index - 1];
    if (before3 === ".") {
      response.ignoreMatch();
    }
  }
  function beginKeywords(mode, parent) {
    if (!parent)
      return;
    if (!mode.beginKeywords)
      return;
    mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
    mode.__beforeBegin = skipIfhasPrecedingDot;
    mode.keywords = mode.keywords || mode.beginKeywords;
    delete mode.beginKeywords;
    if (mode.relevance === void 0)
      mode.relevance = 0;
  }
  function compileIllegal(mode, _parent) {
    if (!Array.isArray(mode.illegal))
      return;
    mode.illegal = either(...mode.illegal);
  }
  function compileMatch(mode, _parent) {
    if (!mode.match)
      return;
    if (mode.begin || mode.end)
      throw new Error("begin & end are not supported with match");
    mode.begin = mode.match;
    delete mode.match;
  }
  function compileRelevance(mode, _parent) {
    if (mode.relevance === void 0)
      mode.relevance = 1;
  }
  var COMMON_KEYWORDS = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    "list",
    "value"
  ];
  var DEFAULT_KEYWORD_CLASSNAME = "keyword";
  function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
    const compiledKeywords = {};
    if (typeof rawKeywords === "string") {
      compileList(className, rawKeywords.split(" "));
    } else if (Array.isArray(rawKeywords)) {
      compileList(className, rawKeywords);
    } else {
      Object.keys(rawKeywords).forEach(function(className2) {
        Object.assign(compiledKeywords, compileKeywords(rawKeywords[className2], caseInsensitive, className2));
      });
    }
    return compiledKeywords;
    function compileList(className2, keywordList) {
      if (caseInsensitive) {
        keywordList = keywordList.map((x) => x.toLowerCase());
      }
      keywordList.forEach(function(keyword) {
        const pair = keyword.split("|");
        compiledKeywords[pair[0]] = [className2, scoreForKeyword(pair[0], pair[1])];
      });
    }
  }
  function scoreForKeyword(keyword, providedScore) {
    if (providedScore) {
      return Number(providedScore);
    }
    return commonKeyword(keyword) ? 0 : 1;
  }
  function commonKeyword(keyword) {
    return COMMON_KEYWORDS.includes(keyword.toLowerCase());
  }
  function compileLanguage(language, { plugins }) {
    function langRe(value, global2) {
      return new RegExp(source(value), "m" + (language.case_insensitive ? "i" : "") + (global2 ? "g" : ""));
    }
    class MultiRegex {
      constructor() {
        this.matchIndexes = {};
        this.regexes = [];
        this.matchAt = 1;
        this.position = 0;
      }
      addRule(re, opts) {
        opts.position = this.position++;
        this.matchIndexes[this.matchAt] = opts;
        this.regexes.push([opts, re]);
        this.matchAt += countMatchGroups(re) + 1;
      }
      compile() {
        if (this.regexes.length === 0) {
          this.exec = () => null;
        }
        const terminators = this.regexes.map((el) => el[1]);
        this.matcherRe = langRe(join(terminators), true);
        this.lastIndex = 0;
      }
      exec(s) {
        this.matcherRe.lastIndex = this.lastIndex;
        const match = this.matcherRe.exec(s);
        if (!match) {
          return null;
        }
        const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
        const matchData = this.matchIndexes[i];
        match.splice(0, i);
        return Object.assign(match, matchData);
      }
    }
    class ResumableMultiRegex {
      constructor() {
        this.rules = [];
        this.multiRegexes = [];
        this.count = 0;
        this.lastIndex = 0;
        this.regexIndex = 0;
      }
      getMatcher(index3) {
        if (this.multiRegexes[index3])
          return this.multiRegexes[index3];
        const matcher = new MultiRegex();
        this.rules.slice(index3).forEach(([re, opts]) => matcher.addRule(re, opts));
        matcher.compile();
        this.multiRegexes[index3] = matcher;
        return matcher;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      addRule(re, opts) {
        this.rules.push([re, opts]);
        if (opts.type === "begin")
          this.count++;
      }
      exec(s) {
        const m = this.getMatcher(this.regexIndex);
        m.lastIndex = this.lastIndex;
        let result2 = m.exec(s);
        if (this.resumingScanAtSamePosition()) {
          if (result2 && result2.index === this.lastIndex)
            ;
          else {
            const m2 = this.getMatcher(0);
            m2.lastIndex = this.lastIndex + 1;
            result2 = m2.exec(s);
          }
        }
        if (result2) {
          this.regexIndex += result2.position + 1;
          if (this.regexIndex === this.count) {
            this.considerAll();
          }
        }
        return result2;
      }
    }
    function buildModeRegex(mode) {
      const mm = new ResumableMultiRegex();
      mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
      if (mode.terminatorEnd) {
        mm.addRule(mode.terminatorEnd, { type: "end" });
      }
      if (mode.illegal) {
        mm.addRule(mode.illegal, { type: "illegal" });
      }
      return mm;
    }
    function compileMode(mode, parent) {
      const cmode = mode;
      if (mode.isCompiled)
        return cmode;
      [
        compileMatch
      ].forEach((ext) => ext(mode, parent));
      language.compilerExtensions.forEach((ext) => ext(mode, parent));
      mode.__beforeBegin = null;
      [
        beginKeywords,
        compileIllegal,
        compileRelevance
      ].forEach((ext) => ext(mode, parent));
      mode.isCompiled = true;
      let keywordPattern = null;
      if (typeof mode.keywords === "object") {
        keywordPattern = mode.keywords.$pattern;
        delete mode.keywords.$pattern;
      }
      if (mode.keywords) {
        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
      }
      if (mode.lexemes && keywordPattern) {
        throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
      }
      keywordPattern = keywordPattern || mode.lexemes || /\w+/;
      cmode.keywordPatternRe = langRe(keywordPattern, true);
      if (parent) {
        if (!mode.begin)
          mode.begin = /\B|\b/;
        cmode.beginRe = langRe(mode.begin);
        if (mode.endSameAsBegin)
          mode.end = mode.begin;
        if (!mode.end && !mode.endsWithParent)
          mode.end = /\B|\b/;
        if (mode.end)
          cmode.endRe = langRe(mode.end);
        cmode.terminatorEnd = source(mode.end) || "";
        if (mode.endsWithParent && parent.terminatorEnd) {
          cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
        }
      }
      if (mode.illegal)
        cmode.illegalRe = langRe(mode.illegal);
      if (!mode.contains)
        mode.contains = [];
      mode.contains = [].concat(...mode.contains.map(function(c) {
        return expandOrCloneMode(c === "self" ? mode : c);
      }));
      mode.contains.forEach(function(c) {
        compileMode(c, cmode);
      });
      if (mode.starts) {
        compileMode(mode.starts, parent);
      }
      cmode.matcher = buildModeRegex(cmode);
      return cmode;
    }
    if (!language.compilerExtensions)
      language.compilerExtensions = [];
    if (language.contains && language.contains.includes("self")) {
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    }
    language.classNameAliases = inherit(language.classNameAliases || {});
    return compileMode(language);
  }
  function dependencyOnParent(mode) {
    if (!mode)
      return false;
    return mode.endsWithParent || dependencyOnParent(mode.starts);
  }
  function expandOrCloneMode(mode) {
    if (mode.variants && !mode.cachedVariants) {
      mode.cachedVariants = mode.variants.map(function(variant) {
        return inherit(mode, { variants: null }, variant);
      });
    }
    if (mode.cachedVariants) {
      return mode.cachedVariants;
    }
    if (dependencyOnParent(mode)) {
      return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });
    }
    if (Object.isFrozen(mode)) {
      return inherit(mode);
    }
    return mode;
  }
  var version = "10.7.3";
  function hasValueOrEmptyAttribute(value) {
    return Boolean(value || value === "");
  }
  function BuildVuePlugin(hljs) {
    const Component = {
      props: ["language", "code", "autodetect"],
      data: function() {
        return {
          detectedLanguage: "",
          unknownLanguage: false
        };
      },
      computed: {
        className() {
          if (this.unknownLanguage)
            return "";
          return "hljs " + this.detectedLanguage;
        },
        highlighted() {
          if (!this.autoDetect && !hljs.getLanguage(this.language)) {
            console.warn(`The language "${this.language}" you specified could not be found.`);
            this.unknownLanguage = true;
            return escapeHTML(this.code);
          }
          let result2 = {};
          if (this.autoDetect) {
            result2 = hljs.highlightAuto(this.code);
            this.detectedLanguage = result2.language;
          } else {
            result2 = hljs.highlight(this.language, this.code, this.ignoreIllegals);
            this.detectedLanguage = this.language;
          }
          return result2.value;
        },
        autoDetect() {
          return !this.language || hasValueOrEmptyAttribute(this.autodetect);
        },
        ignoreIllegals() {
          return true;
        }
      },
      render(createElement) {
        return createElement("pre", {}, [
          createElement("code", {
            class: this.className,
            domProps: { innerHTML: this.highlighted }
          })
        ]);
      }
    };
    const VuePlugin = {
      install(Vue) {
        Vue.component("highlightjs", Component);
      }
    };
    return { Component, VuePlugin };
  }
  var mergeHTMLPlugin = {
    "after:highlightElement": ({ el, result: result2, text: text4 }) => {
      const originalStream = nodeStream(el);
      if (!originalStream.length)
        return;
      const resultNode = document.createElement("div");
      resultNode.innerHTML = result2.value;
      result2.value = mergeStreams(originalStream, nodeStream(resultNode), text4);
    }
  };
  function tag(node5) {
    return node5.nodeName.toLowerCase();
  }
  function nodeStream(node5) {
    const result2 = [];
    (function _nodeStream(node6, offset4) {
      for (let child5 = node6.firstChild; child5; child5 = child5.nextSibling) {
        if (child5.nodeType === 3) {
          offset4 += child5.nodeValue.length;
        } else if (child5.nodeType === 1) {
          result2.push({
            event: "start",
            offset: offset4,
            node: child5
          });
          offset4 = _nodeStream(child5, offset4);
          if (!tag(child5).match(/br|hr|img|input/)) {
            result2.push({
              event: "stop",
              offset: offset4,
              node: child5
            });
          }
        }
      }
      return offset4;
    })(node5, 0);
    return result2;
  }
  function mergeStreams(original, highlighted, value) {
    let processed = 0;
    let result2 = "";
    const nodeStack = [];
    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return original[0].offset < highlighted[0].offset ? original : highlighted;
      }
      return highlighted[0].event === "start" ? original : highlighted;
    }
    function open2(node5) {
      function attributeString(attr) {
        return " " + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
      }
      result2 += "<" + tag(node5) + [].map.call(node5.attributes, attributeString).join("") + ">";
    }
    function close6(node5) {
      result2 += "</" + tag(node5) + ">";
    }
    function render2(event) {
      (event.event === "start" ? open2 : close6)(event.node);
    }
    while (original.length || highlighted.length) {
      let stream = selectStream();
      result2 += escapeHTML(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        nodeStack.reverse().forEach(close6);
        do {
          render2(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open2);
      } else {
        if (stream[0].event === "start") {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render2(stream.splice(0, 1)[0]);
      }
    }
    return result2 + escapeHTML(value.substr(processed));
  }
  var seenDeprecations = {};
  var error2 = (message) => {
    console.error(message);
  };
  var warn = (message, ...args) => {
    console.log(`WARN: ${message}`, ...args);
  };
  var deprecated = (version2, message) => {
    if (seenDeprecations[`${version2}/${message}`])
      return;
    console.log(`Deprecated as of ${version2}. ${message}`);
    seenDeprecations[`${version2}/${message}`] = true;
  };
  var escape$1 = escapeHTML;
  var inherit$1 = inherit;
  var NO_MATCH = Symbol("nomatch");
  var HLJS = function(hljs) {
    const languages = /* @__PURE__ */ Object.create(null);
    const aliases = /* @__PURE__ */ Object.create(null);
    const plugins = [];
    let SAFE_MODE = true;
    const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
    const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
    const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
    let options = {
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      tabReplace: null,
      useBR: false,
      languages: null,
      __emitter: TokenTreeEmitter
    };
    function shouldNotHighlight(languageName) {
      return options.noHighlightRe.test(languageName);
    }
    function blockLanguage(block) {
      let classes = block.className + " ";
      classes += block.parentNode ? block.parentNode.className : "";
      const match = options.languageDetectRe.exec(classes);
      if (match) {
        const language = getLanguage(match[1]);
        if (!language) {
          warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
          warn("Falling back to no-highlight mode for this block.", block);
        }
        return language ? match[1] : "no-highlight";
      }
      return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
    }
    function highlight2(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
      let code = "";
      let languageName = "";
      if (typeof optionsOrCode === "object") {
        code = codeOrlanguageName;
        ignoreIllegals = optionsOrCode.ignoreIllegals;
        languageName = optionsOrCode.language;
        continuation = void 0;
      } else {
        deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
        deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
        languageName = codeOrlanguageName;
        code = optionsOrCode;
      }
      const context = {
        code,
        language: languageName
      };
      fire("before:highlight", context);
      const result2 = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals, continuation);
      result2.code = context.code;
      fire("after:highlight", result2);
      return result2;
    }
    function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
      function keywordData(mode, match) {
        const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
        return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
      }
      function processKeywords() {
        if (!top2.keywords) {
          emitter.addText(modeBuffer);
          return;
        }
        let lastIndex = 0;
        top2.keywordPatternRe.lastIndex = 0;
        let match = top2.keywordPatternRe.exec(modeBuffer);
        let buf = "";
        while (match) {
          buf += modeBuffer.substring(lastIndex, match.index);
          const data = keywordData(top2, match);
          if (data) {
            const [kind, keywordRelevance] = data;
            emitter.addText(buf);
            buf = "";
            relevance += keywordRelevance;
            if (kind.startsWith("_")) {
              buf += match[0];
            } else {
              const cssClass = language.classNameAliases[kind] || kind;
              emitter.addKeyword(match[0], cssClass);
            }
          } else {
            buf += match[0];
          }
          lastIndex = top2.keywordPatternRe.lastIndex;
          match = top2.keywordPatternRe.exec(modeBuffer);
        }
        buf += modeBuffer.substr(lastIndex);
        emitter.addText(buf);
      }
      function processSubLanguage() {
        if (modeBuffer === "")
          return;
        let result3 = null;
        if (typeof top2.subLanguage === "string") {
          if (!languages[top2.subLanguage]) {
            emitter.addText(modeBuffer);
            return;
          }
          result3 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
          continuations[top2.subLanguage] = result3.top;
        } else {
          result3 = highlightAuto2(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
        }
        if (top2.relevance > 0) {
          relevance += result3.relevance;
        }
        emitter.addSublanguage(result3.emitter, result3.language);
      }
      function processBuffer() {
        if (top2.subLanguage != null) {
          processSubLanguage();
        } else {
          processKeywords();
        }
        modeBuffer = "";
      }
      function startNewMode(mode) {
        if (mode.className) {
          emitter.openNode(language.classNameAliases[mode.className] || mode.className);
        }
        top2 = Object.create(mode, { parent: { value: top2 } });
        return top2;
      }
      function endOfMode(mode, match, matchPlusRemainder) {
        let matched = startsWith(mode.endRe, matchPlusRemainder);
        if (matched) {
          if (mode["on:end"]) {
            const resp = new Response(mode);
            mode["on:end"](match, resp);
            if (resp.isMatchIgnored)
              matched = false;
          }
          if (matched) {
            while (mode.endsParent && mode.parent) {
              mode = mode.parent;
            }
            return mode;
          }
        }
        if (mode.endsWithParent) {
          return endOfMode(mode.parent, match, matchPlusRemainder);
        }
      }
      function doIgnore(lexeme) {
        if (top2.matcher.regexIndex === 0) {
          modeBuffer += lexeme[0];
          return 1;
        } else {
          resumeScanAtSamePosition = true;
          return 0;
        }
      }
      function doBeginMatch(match) {
        const lexeme = match[0];
        const newMode = match.rule;
        const resp = new Response(newMode);
        const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
        for (const cb of beforeCallbacks) {
          if (!cb)
            continue;
          cb(match, resp);
          if (resp.isMatchIgnored)
            return doIgnore(lexeme);
        }
        if (newMode && newMode.endSameAsBegin) {
          newMode.endRe = escape(lexeme);
        }
        if (newMode.skip) {
          modeBuffer += lexeme;
        } else {
          if (newMode.excludeBegin) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (!newMode.returnBegin && !newMode.excludeBegin) {
            modeBuffer = lexeme;
          }
        }
        startNewMode(newMode);
        return newMode.returnBegin ? 0 : lexeme.length;
      }
      function doEndMatch(match) {
        const lexeme = match[0];
        const matchPlusRemainder = codeToHighlight.substr(match.index);
        const endMode = endOfMode(top2, match, matchPlusRemainder);
        if (!endMode) {
          return NO_MATCH;
        }
        const origin = top2;
        if (origin.skip) {
          modeBuffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            modeBuffer = lexeme;
          }
        }
        do {
          if (top2.className) {
            emitter.closeNode();
          }
          if (!top2.skip && !top2.subLanguage) {
            relevance += top2.relevance;
          }
          top2 = top2.parent;
        } while (top2 !== endMode.parent);
        if (endMode.starts) {
          if (endMode.endSameAsBegin) {
            endMode.starts.endRe = endMode.endRe;
          }
          startNewMode(endMode.starts);
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }
      function processContinuations() {
        const list = [];
        for (let current = top2; current !== language; current = current.parent) {
          if (current.className) {
            list.unshift(current.className);
          }
        }
        list.forEach((item) => emitter.openNode(item));
      }
      let lastMatch = {};
      function processLexeme(textBeforeMatch, match) {
        const lexeme = match && match[0];
        modeBuffer += textBeforeMatch;
        if (lexeme == null) {
          processBuffer();
          return 0;
        }
        if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
          modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
          if (!SAFE_MODE) {
            const err3 = new Error("0 width match regex");
            err3.languageName = languageName;
            err3.badRule = lastMatch.rule;
            throw err3;
          }
          return 1;
        }
        lastMatch = match;
        if (match.type === "begin") {
          return doBeginMatch(match);
        } else if (match.type === "illegal" && !ignoreIllegals) {
          const err3 = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.className || "<unnamed>") + '"');
          err3.mode = top2;
          throw err3;
        } else if (match.type === "end") {
          const processed = doEndMatch(match);
          if (processed !== NO_MATCH) {
            return processed;
          }
        }
        if (match.type === "illegal" && lexeme === "") {
          return 1;
        }
        if (iterations > 1e5 && iterations > match.index * 3) {
          const err3 = new Error("potential infinite loop, way more iterations than matches");
          throw err3;
        }
        modeBuffer += lexeme;
        return lexeme.length;
      }
      const language = getLanguage(languageName);
      if (!language) {
        error2(LANGUAGE_NOT_FOUND.replace("{}", languageName));
        throw new Error('Unknown language: "' + languageName + '"');
      }
      const md = compileLanguage(language, { plugins });
      let result2 = "";
      let top2 = continuation || md;
      const continuations = {};
      const emitter = new options.__emitter(options);
      processContinuations();
      let modeBuffer = "";
      let relevance = 0;
      let index3 = 0;
      let iterations = 0;
      let resumeScanAtSamePosition = false;
      try {
        top2.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top2.matcher.considerAll();
          }
          top2.matcher.lastIndex = index3;
          const match = top2.matcher.exec(codeToHighlight);
          if (!match)
            break;
          const beforeMatch = codeToHighlight.substring(index3, match.index);
          const processedCount = processLexeme(beforeMatch, match);
          index3 = match.index + processedCount;
        }
        processLexeme(codeToHighlight.substr(index3));
        emitter.closeAllNodes();
        emitter.finalize();
        result2 = emitter.toHTML();
        return {
          relevance: Math.floor(relevance),
          value: result2,
          language: languageName,
          illegal: false,
          emitter,
          top: top2
        };
      } catch (err3) {
        if (err3.message && err3.message.includes("Illegal")) {
          return {
            illegal: true,
            illegalBy: {
              msg: err3.message,
              context: codeToHighlight.slice(index3 - 100, index3 + 100),
              mode: err3.mode
            },
            sofar: result2,
            relevance: 0,
            value: escape$1(codeToHighlight),
            emitter
          };
        } else if (SAFE_MODE) {
          return {
            illegal: false,
            relevance: 0,
            value: escape$1(codeToHighlight),
            emitter,
            language: languageName,
            top: top2,
            errorRaised: err3
          };
        } else {
          throw err3;
        }
      }
    }
    function justTextHighlightResult(code) {
      const result2 = {
        relevance: 0,
        emitter: new options.__emitter(options),
        value: escape$1(code),
        illegal: false,
        top: PLAINTEXT_LANGUAGE
      };
      result2.emitter.addText(code);
      return result2;
    }
    function highlightAuto2(code, languageSubset) {
      languageSubset = languageSubset || options.languages || Object.keys(languages);
      const plaintext = justTextHighlightResult(code);
      const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name) => _highlight(name, code, false));
      results.unshift(plaintext);
      const sorted = results.sort((a, b) => {
        if (a.relevance !== b.relevance)
          return b.relevance - a.relevance;
        if (a.language && b.language) {
          if (getLanguage(a.language).supersetOf === b.language) {
            return 1;
          } else if (getLanguage(b.language).supersetOf === a.language) {
            return -1;
          }
        }
        return 0;
      });
      const [best, secondBest] = sorted;
      const result2 = best;
      result2.second_best = secondBest;
      return result2;
    }
    function fixMarkup(html) {
      if (!(options.tabReplace || options.useBR)) {
        return html;
      }
      return html.replace(fixMarkupRe, (match) => {
        if (match === "\n") {
          return options.useBR ? "<br>" : match;
        } else if (options.tabReplace) {
          return match.replace(/\t/g, options.tabReplace);
        }
        return match;
      });
    }
    function updateClassName(element, currentLang, resultLang) {
      const language = currentLang ? aliases[currentLang] : resultLang;
      element.classList.add("hljs");
      if (language)
        element.classList.add(language);
    }
    const brPlugin = {
      "before:highlightElement": ({ el }) => {
        if (options.useBR) {
          el.innerHTML = el.innerHTML.replace(/\n/g, "").replace(/<br[ /]*>/g, "\n");
        }
      },
      "after:highlightElement": ({ result: result2 }) => {
        if (options.useBR) {
          result2.value = result2.value.replace(/\n/g, "<br>");
        }
      }
    };
    const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
    const tabReplacePlugin = {
      "after:highlightElement": ({ result: result2 }) => {
        if (options.tabReplace) {
          result2.value = result2.value.replace(TAB_REPLACE_RE, (m) => m.replace(/\t/g, options.tabReplace));
        }
      }
    };
    function highlightElement(element) {
      let node5 = null;
      const language = blockLanguage(element);
      if (shouldNotHighlight(language))
        return;
      fire("before:highlightElement", { el: element, language });
      node5 = element;
      const text4 = node5.textContent;
      const result2 = language ? highlight2(text4, { language, ignoreIllegals: true }) : highlightAuto2(text4);
      fire("after:highlightElement", { el: element, result: result2, text: text4 });
      element.innerHTML = result2.value;
      updateClassName(element, language, result2.language);
      element.result = {
        language: result2.language,
        re: result2.relevance,
        relavance: result2.relevance
      };
      if (result2.second_best) {
        element.second_best = {
          language: result2.second_best.language,
          re: result2.second_best.relevance,
          relavance: result2.second_best.relevance
        };
      }
    }
    function configure(userOptions) {
      if (userOptions.useBR) {
        deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
        deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
      }
      options = inherit$1(options, userOptions);
    }
    const initHighlighting = () => {
      if (initHighlighting.called)
        return;
      initHighlighting.called = true;
      deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");
      const blocks = document.querySelectorAll("pre code");
      blocks.forEach(highlightElement);
    };
    function initHighlightingOnLoad() {
      deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
      wantsHighlight = true;
    }
    let wantsHighlight = false;
    function highlightAll() {
      if (document.readyState === "loading") {
        wantsHighlight = true;
        return;
      }
      const blocks = document.querySelectorAll("pre code");
      blocks.forEach(highlightElement);
    }
    function boot() {
      if (wantsHighlight)
        highlightAll();
    }
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("DOMContentLoaded", boot, false);
    }
    function registerLanguage2(languageName, languageDefinition) {
      let lang = null;
      try {
        lang = languageDefinition(hljs);
      } catch (error$1) {
        error2("Language definition for '{}' could not be registered.".replace("{}", languageName));
        if (!SAFE_MODE) {
          throw error$1;
        } else {
          error2(error$1);
        }
        lang = PLAINTEXT_LANGUAGE;
      }
      if (!lang.name)
        lang.name = languageName;
      languages[languageName] = lang;
      lang.rawDefinition = languageDefinition.bind(null, hljs);
      if (lang.aliases) {
        registerAliases(lang.aliases, { languageName });
      }
    }
    function unregisterLanguage(languageName) {
      delete languages[languageName];
      for (const alias of Object.keys(aliases)) {
        if (aliases[alias] === languageName) {
          delete aliases[alias];
        }
      }
    }
    function listLanguages2() {
      return Object.keys(languages);
    }
    function requireLanguage(name) {
      deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
      deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");
      const lang = getLanguage(name);
      if (lang) {
        return lang;
      }
      const err3 = new Error("The '{}' language is required, but not loaded.".replace("{}", name));
      throw err3;
    }
    function getLanguage(name) {
      name = (name || "").toLowerCase();
      return languages[name] || languages[aliases[name]];
    }
    function registerAliases(aliasList, { languageName }) {
      if (typeof aliasList === "string") {
        aliasList = [aliasList];
      }
      aliasList.forEach((alias) => {
        aliases[alias.toLowerCase()] = languageName;
      });
    }
    function autoDetection(name) {
      const lang = getLanguage(name);
      return lang && !lang.disableAutodetect;
    }
    function upgradePluginAPI(plugin) {
      if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
        plugin["before:highlightElement"] = (data) => {
          plugin["before:highlightBlock"](Object.assign({ block: data.el }, data));
        };
      }
      if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
        plugin["after:highlightElement"] = (data) => {
          plugin["after:highlightBlock"](Object.assign({ block: data.el }, data));
        };
      }
    }
    function addPlugin(plugin) {
      upgradePluginAPI(plugin);
      plugins.push(plugin);
    }
    function fire(event, args) {
      const cb = event;
      plugins.forEach(function(plugin) {
        if (plugin[cb]) {
          plugin[cb](args);
        }
      });
    }
    function deprecateFixMarkup(arg) {
      deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
      deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");
      return fixMarkup(arg);
    }
    function deprecateHighlightBlock(el) {
      deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
      deprecated("10.7.0", "Please use highlightElement now.");
      return highlightElement(el);
    }
    Object.assign(hljs, {
      highlight: highlight2,
      highlightAuto: highlightAuto2,
      highlightAll,
      fixMarkup: deprecateFixMarkup,
      highlightElement,
      highlightBlock: deprecateHighlightBlock,
      configure,
      initHighlighting,
      initHighlightingOnLoad,
      registerLanguage: registerLanguage2,
      unregisterLanguage,
      listLanguages: listLanguages2,
      getLanguage,
      registerAliases,
      requireLanguage,
      autoDetection,
      inherit: inherit$1,
      addPlugin,
      vuePlugin: BuildVuePlugin(hljs).VuePlugin
    });
    hljs.debugMode = function() {
      SAFE_MODE = false;
    };
    hljs.safeMode = function() {
      SAFE_MODE = true;
    };
    hljs.versionString = version;
    for (const key2 in MODES) {
      if (typeof MODES[key2] === "object") {
        deepFreezeEs6(MODES[key2]);
      }
    }
    Object.assign(hljs, MODES);
    hljs.addPlugin(brPlugin);
    hljs.addPlugin(mergeHTMLPlugin);
    hljs.addPlugin(tabReplacePlugin);
    return hljs;
  };
  var highlight$1 = HLJS({});
  var core = highlight$1;
  var format2 = { exports: {} };
  (function(module2) {
    (function() {
      var namespace;
      {
        namespace = module2.exports = format3;
      }
      namespace.format = format3;
      namespace.vsprintf = vsprintf;
      if (typeof console !== "undefined" && typeof console.log === "function") {
        namespace.printf = printf;
      }
      function printf() {
        console.log(format3.apply(null, arguments));
      }
      function vsprintf(fmt, replacements) {
        return format3.apply(null, [fmt].concat(replacements));
      }
      function format3(fmt) {
        var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result2 = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
          return args[argIndex++];
        }, slurpNumber = function() {
          var digits = "";
          while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        };
        for (; i < n; ++i) {
          c = fmt[i];
          if (escaped) {
            escaped = false;
            if (c == ".") {
              leadingZero = false;
              c = fmt[++i];
            } else if (c == "0" && fmt[i + 1] == ".") {
              leadingZero = true;
              i += 2;
              c = fmt[i];
            } else {
              leadingZero = true;
            }
            precision = slurpNumber();
            switch (c) {
              case "b":
                result2 += parseInt(nextArg(), 10).toString(2);
                break;
              case "c":
                arg = nextArg();
                if (typeof arg === "string" || arg instanceof String)
                  result2 += arg;
                else
                  result2 += String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
                result2 += parseInt(nextArg(), 10);
                break;
              case "f":
                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                result2 += leadingZero ? tmp : tmp.replace(/^0/, "");
                break;
              case "j":
                result2 += JSON.stringify(nextArg());
                break;
              case "o":
                result2 += "0" + parseInt(nextArg(), 10).toString(8);
                break;
              case "s":
                result2 += nextArg();
                break;
              case "x":
                result2 += "0x" + parseInt(nextArg(), 10).toString(16);
                break;
              case "X":
                result2 += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                break;
              default:
                result2 += c;
                break;
            }
          } else if (c === "%") {
            escaped = true;
          } else {
            result2 += c;
          }
        }
        return result2;
      }
    })();
  })(format2);
  var formatter = format2.exports;
  var fault$1 = create8(Error);
  var fault_1 = fault$1;
  fault$1.eval = create8(EvalError);
  fault$1.range = create8(RangeError);
  fault$1.reference = create8(ReferenceError);
  fault$1.syntax = create8(SyntaxError);
  fault$1.type = create8(TypeError);
  fault$1.uri = create8(URIError);
  fault$1.create = create8;
  function create8(EConstructor) {
    FormattedError.displayName = EConstructor.displayName || EConstructor.name;
    return FormattedError;
    function FormattedError(format3) {
      if (format3) {
        format3 = formatter.apply(null, arguments);
      }
      return new EConstructor(format3);
    }
  }
  var high = core;
  var fault = fault_1;
  core$1.highlight = highlight;
  core$1.highlightAuto = highlightAuto;
  core$1.registerLanguage = registerLanguage;
  core$1.listLanguages = listLanguages;
  core$1.registerAlias = registerAlias;
  Emitter.prototype.addText = text3;
  Emitter.prototype.addKeyword = addKeyword;
  Emitter.prototype.addSublanguage = addSublanguage;
  Emitter.prototype.openNode = open;
  Emitter.prototype.closeNode = close5;
  Emitter.prototype.closeAllNodes = noop2;
  Emitter.prototype.finalize = noop2;
  Emitter.prototype.toHTML = toHtmlNoop;
  var defaultPrefix = "hljs-";
  function highlight(name, value, options) {
    var before3 = high.configure({});
    var settings = options || {};
    var prefix = settings.prefix;
    var result2;
    if (typeof name !== "string") {
      throw fault("Expected `string` for name, got `%s`", name);
    }
    if (!high.getLanguage(name)) {
      throw fault("Unknown language: `%s` is not registered", name);
    }
    if (typeof value !== "string") {
      throw fault("Expected `string` for value, got `%s`", value);
    }
    if (prefix === null || prefix === void 0) {
      prefix = defaultPrefix;
    }
    high.configure({ __emitter: Emitter, classPrefix: prefix });
    result2 = high.highlight(value, { language: name, ignoreIllegals: true });
    high.configure(before3 || {});
    if (result2.errorRaised) {
      throw result2.errorRaised;
    }
    return {
      relevance: result2.relevance,
      language: result2.language,
      value: result2.emitter.rootNode.children
    };
  }
  function highlightAuto(value, options) {
    var settings = options || {};
    var subset = settings.subset || high.listLanguages();
    settings.prefix;
    var length = subset.length;
    var index3 = -1;
    var result2;
    var secondBest;
    var current;
    var name;
    if (typeof value !== "string") {
      throw fault("Expected `string` for value, got `%s`", value);
    }
    secondBest = { relevance: 0, language: null, value: [] };
    result2 = { relevance: 0, language: null, value: [] };
    while (++index3 < length) {
      name = subset[index3];
      if (!high.getLanguage(name)) {
        continue;
      }
      current = highlight(name, value, options);
      current.language = name;
      if (current.relevance > secondBest.relevance) {
        secondBest = current;
      }
      if (current.relevance > result2.relevance) {
        secondBest = result2;
        result2 = current;
      }
    }
    if (secondBest.language) {
      result2.secondBest = secondBest;
    }
    return result2;
  }
  function registerLanguage(name, syntax) {
    high.registerLanguage(name, syntax);
  }
  function listLanguages() {
    return high.listLanguages();
  }
  function registerAlias(name, alias) {
    var map22 = name;
    var key2;
    if (alias) {
      map22 = {};
      map22[name] = alias;
    }
    for (key2 in map22) {
      high.registerAliases(map22[key2], { languageName: key2 });
    }
  }
  function Emitter(options) {
    this.options = options;
    this.rootNode = { children: [] };
    this.stack = [this.rootNode];
  }
  function addKeyword(value, name) {
    this.openNode(name);
    this.addText(value);
    this.closeNode();
  }
  function addSublanguage(other, name) {
    var stack = this.stack;
    var current = stack[stack.length - 1];
    var results = other.rootNode.children;
    var node5 = name ? {
      type: "element",
      tagName: "span",
      properties: { className: [name] },
      children: results
    } : results;
    current.children = current.children.concat(node5);
  }
  function text3(value) {
    var stack = this.stack;
    var current;
    var tail;
    if (value === "")
      return;
    current = stack[stack.length - 1];
    tail = current.children[current.children.length - 1];
    if (tail && tail.type === "text") {
      tail.value += value;
    } else {
      current.children.push({ type: "text", value });
    }
  }
  function open(name) {
    var stack = this.stack;
    var className = this.options.classPrefix + name;
    var current = stack[stack.length - 1];
    var child5 = {
      type: "element",
      tagName: "span",
      properties: { className: [className] },
      children: []
    };
    current.children.push(child5);
    stack.push(child5);
  }
  function close5() {
    this.stack.pop();
  }
  function toHtmlNoop() {
    return "";
  }
  function noop2() {
  }
  function parseNodes(nodes, className = []) {
    return nodes.map((node5) => {
      const classes = [
        ...className,
        ...node5.properties ? node5.properties.className : []
      ];
      if (node5.children) {
        return parseNodes(node5.children, classes);
      }
      return {
        text: node5.value,
        classes
      };
    }).flat();
  }
  function getHighlightNodes(result2) {
    return result2.value || result2.children || [];
  }
  function getDecorations({ doc: doc2, name, lowlight: lowlight2, defaultLanguage }) {
    const decorations = [];
    findChildren(doc2, (node5) => node5.type.name === name).forEach((block) => {
      let from5 = block.pos + 1;
      const language = block.node.attrs.language || defaultLanguage;
      const languages = lowlight2.listLanguages();
      const nodes = language && languages.includes(language) ? getHighlightNodes(lowlight2.highlight(language, block.node.textContent)) : getHighlightNodes(lowlight2.highlightAuto(block.node.textContent));
      parseNodes(nodes).forEach((node5) => {
        const to = from5 + node5.text.length;
        if (node5.classes.length) {
          const decoration = Decoration.inline(from5, to, {
            class: node5.classes.join(" ")
          });
          decorations.push(decoration);
        }
        from5 = to;
      });
    });
    return DecorationSet.create(doc2, decorations);
  }
  function LowlightPlugin({ name, lowlight: lowlight2, defaultLanguage }) {
    return new Plugin({
      key: new PluginKey("lowlight"),
      state: {
        init: (_, { doc: doc2 }) => getDecorations({
          doc: doc2,
          name,
          lowlight: lowlight2,
          defaultLanguage
        }),
        apply: (transaction, decorationSet, oldState, newState) => {
          const oldNodeName = oldState.selection.$head.parent.type.name;
          const newNodeName = newState.selection.$head.parent.type.name;
          const oldNodes = findChildren(oldState.doc, (node5) => node5.type.name === name);
          const newNodes = findChildren(newState.doc, (node5) => node5.type.name === name);
          if (transaction.docChanged && ([oldNodeName, newNodeName].includes(name) || newNodes.length !== oldNodes.length || transaction.steps.some((step3) => {
            return step3.from !== void 0 && step3.to !== void 0 && oldNodes.some((node5) => {
              return node5.pos >= step3.from && node5.pos + node5.node.nodeSize <= step3.to;
            });
          }))) {
            return getDecorations({
              doc: transaction.doc,
              name,
              lowlight: lowlight2,
              defaultLanguage
            });
          }
          return decorationSet.map(transaction.mapping, transaction.doc);
        }
      },
      props: {
        decorations(state) {
          return this.getState(state);
        }
      }
    });
  }
  var CodeBlockLowlight = CodeBlock.extend({
    addOptions() {
      var _a;
      return {
        ...(_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this),
        lowlight: core$1,
        defaultLanguage: null
      };
    },
    addProseMirrorPlugins() {
      var _a;
      return [
        ...((_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this)) || [],
        LowlightPlugin({
          name: this.name,
          lowlight: this.options.lowlight,
          defaultLanguage: this.options.defaultLanguage
        })
      ];
    }
  });

  // app/javascript/documentation/controllers/rich_text_editor/lowlight.js
  var import_core32 = __toESM(require_core2());
  var import_css = __toESM(require_css());
  var import_javascript = __toESM(require_javascript());
  var import_json = __toESM(require_json());
  var import_ruby = __toESM(require_ruby());
  var import_scss = __toESM(require_scss());
  var import_sql = __toESM(require_sql());
  var import_xml = __toESM(require_xml());
  var import_yaml = __toESM(require_yaml());
  import_core32.default.registerLanguage("css", import_css.default);
  import_core32.default.registerLanguage("javascript", import_javascript.default);
  import_core32.default.registerLanguage("json", import_json.default);
  import_core32.default.registerLanguage("ruby", import_ruby.default);
  import_core32.default.registerLanguage("scss", import_scss.default);
  import_core32.default.registerLanguage("sql", import_sql.default);
  import_core32.default.registerLanguage("xml", import_xml.default);
  import_core32.default.registerLanguage("yaml", import_yaml.default);
  var lowlight_default = import_core32.default;

  // app/javascript/documentation/controllers/rich_text_editor/with_code_block.js
  var with_code_block_default = (controller, _options = {}) => {
    const CodeBlockExtenstions = [
      CodeBlockLowlight.configure({
        lowlight: lowlight_default
      })
    ];
    const toggleCodeBlock = () => {
      controller.runCommand("toggleCodeBlock");
    };
    Object.assign(controller, {
      toggleCodeBlock
    });
    return { CodeBlockExtenstions };
  };

  // app/javascript/documentation/controllers/rich_text_editor_controller.js
  var import_lodash = __toESM(require_lodash());
  var RichTextEditorController = class extends Controller {
    toolbarTypes = [
      {
        target: "h1",
        name: "heading",
        attributes: { level: 1 },
        text: "Heading 1"
      },
      {
        target: "h2",
        name: "heading",
        attributes: { level: 2 },
        text: "Heading 2"
      },
      {
        target: "h3",
        name: "heading",
        attributes: { level: 3 },
        text: "Heading 3"
      },
      {
        name: "bulletList",
        target: "ul",
        text: "Bulleted List"
      },
      {
        name: "orderedList",
        target: "ol",
        text: "Ordered List"
      },
      {
        name: "blockquote",
        target: "blockquote",
        text: "Quote"
      },
      {
        name: "codeBlock",
        target: "codeBlock",
        text: "Code"
      },
      {
        name: "paragraph",
        target: "text",
        text: "Text"
      }
    ];
    allMenuButtons = toolbarMarks.concat(this.toolbarTypes);
    connect() {
      const { MarkExtensions } = with_marks_default(this);
      const { TableExtensions } = with_table_default(this);
      const { LinkExtensions } = with_link_default(this);
      const { MentionExtensions } = with_mention_default(this);
      const { CodeBlockExtenstions } = with_code_block_default(this);
      const extensions2 = [
        StarterKit.configure({
          blockquote: true,
          bold: false,
          bulletList: true,
          code: false,
          codeBlock: true,
          document: true,
          dropcursor: true,
          gapcursor: true,
          hardBreak: true,
          heading: true,
          history: true,
          horizontalRule: true,
          italic: false,
          listItem: true,
          orderedList: true,
          paragraph: true,
          strike: false,
          text: true
        }),
        Placeholder.configure({
          placeholder: this.placeholderValue
        }),
        ...MarkExtensions,
        ...CodeBlockExtenstions,
        ...LinkExtensions,
        ...TableExtensions,
        ...MentionExtensions
      ];
      if (this.editableValue && this.hasBubbleMenuTarget) {
        extensions2.push(BubbleMenu.configure({
          element: this.bubbleMenuTarget,
          tippyOptions: { appendTo: this.element, duration: 100 }
        }));
      }
      this.editor = new Editor({
        element: this.element,
        extensions: extensions2,
        autofocus: true,
        content: this.contentValue,
        onUpdate: this.throttledUpdate,
        editable: this.editableValue
      });
      this.editor.on("transaction", () => {
        this.resetMenuButtons();
        this.enableSelectedToolbarMarks();
        this.enableSelectedToolbarType();
        this.setCurrentToolbarType();
        this.updateTableModifiers();
      });
    }
    disconnect() {
      this.editor.destroy();
    }
    onUpdate = ({ editor }) => {
      if (!this.hasOutputTarget)
        return;
      this.outputTarget.value = editor.getHTML();
    };
    throttledUpdate = (0, import_lodash.default)(this.onUpdate, 1e3);
    openNodeSelect() {
      this.closeLinkPanel();
      this.closeTablePanel();
    }
    toggleH1() {
      this.runCommand("toggleHeading", { level: 1 });
    }
    toggleH2() {
      this.runCommand("toggleHeading", { level: 2 });
    }
    toggleH3() {
      this.runCommand("toggleHeading", { level: 3 });
    }
    setParagraph() {
      this.runCommand("setParagraph");
    }
    toggleBulletList() {
      this.runCommand("toggleBulletList");
    }
    toggleOrderedList() {
      this.runCommand("toggleOrderedList");
    }
    toggleBlockquote() {
      this.runCommand("toggleBlockquote");
    }
    runCommand(name, attributes) {
      this.editor.chain().focus()[name](attributes).run();
    }
    resetMenuButtons() {
      this.closeNodeSelect();
      this.closeLinkPanel();
      this.allMenuButtons.forEach(({ target }) => {
        if (this.hasTarget(target)) {
          this[`${target}Target`].classList.remove("is-active");
        }
      });
    }
    enableSelectedToolbarType() {
      this.toolbarTypes.some(({ target, name, attributes }) => {
        if (this.editor.isActive(name, attributes) && this.hasTarget(target)) {
          this[`${target}Target`].classList.add("is-active");
          return true;
        }
      });
    }
    setCurrentToolbarType() {
      if (!this.hasNodeSelectTriggerTarget)
        return;
      const selectedType = this.selectedToolbarType();
      if (selectedType) {
        this.nodeSelectTriggerTarget.innerHTML = selectedType.text;
      }
    }
    selectedToolbarType() {
      return this.toolbarTypes.find(({ name, attributes }) => {
        return this.editor.isActive(name, attributes);
      });
    }
    hasTarget(name) {
      const capitalizedName = name[0].toUpperCase() + name.slice(1).toLowerCase();
      return this[`has${capitalizedName}Target`];
    }
    closeNodeSelect() {
      if (!this.hasNodeSelectTarget)
        return;
      this.nodeSelectTarget.classList.remove("is-active");
    }
  };
  __publicField(RichTextEditorController, "targets", [
    "bubbleMenu",
    "nodeSelect",
    "nodeSelectTrigger",
    "text",
    "h1",
    "h2",
    "h3",
    "ul",
    "ol",
    "blockquote",
    "codeBlock",
    "output",
    ...marksTargets,
    ...linkTargets,
    ...tableTargets
  ]);
  __publicField(RichTextEditorController, "values", {
    content: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    editable: { type: Boolean, default: true }
  });

  // app/javascript/documentation/application.js
  var application = Application.start();
  application.register("dropdown", DropdownController);
  application.register("notification", NotificationController);
  application.register("rich-text-editor", RichTextEditorController);
  application.register("slim-select", SlimSelectController);
  application.register("tabs", TabsController);
})();
//# sourceMappingURL=application.js.map
